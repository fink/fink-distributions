Index: src/bin/mksh/Build.sh
diff -u src/bin/mksh/Build.sh:1.443 src/bin/mksh/Build.sh:1.462
--- src/bin/mksh/Build.sh:1.443	Tue Feb 23 22:02:35 2010
+++ src/bin/mksh/Build.sh	Fri Oct  1 19:04:35 2010
@@ -1,5 +1,5 @@
 #!/bin/sh
-srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.443 2010/02/23 22:02:35 tg Exp $'
+srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.462 2010/10/01 19:04:35 tg Exp $'
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 #	Thorsten Glaser <tg@mirbsd.org>
@@ -28,7 +28,9 @@
 # CPPFLAGS recognised:	MKSH_ASSUME_UTF8 MKSH_BINSHREDUCED MKSH_CLS_STRING
 #			MKSH_CONSERVATIVE_FDS MKSH_MIDNIGHTBSD01ASH_COMPAT
 #			MKSH_NOPWNAM MKSH_NO_LIMITS MKSH_SMALL MKSH_S_NOVI
-#			MKSH_UNEMPLOYED
+#			MKSH_UNEMPLOYED MKSH_DEFAULT_EXECSHELL MKSHRC_PATH
+#			MKSH_DEFAULT_TMPDIR MKSH_CLRTOEOL_STRING MKSH_A4PB
+#			MKSH_NO_DEPRECATED_WARNING MKSH_DONT_EMIT_IDSTRING
 
 LC_ALL=C
 export LC_ALL
@@ -176,9 +178,9 @@
 		test $ct = gcc && vscan='unrecogni[sz]ed'
 		test $ct = hpcc && vscan='unsupported'
 		test $ct = pcc && vscan='unsupported'
-		test $ct = sunpro && vscan='ignored'
+		test $ct = sunpro && vscan='-e ignored -e turned.off'
 	fi
-	test -n "$vscan" && grep "$vscan" vv.out >/dev/null 2>&1 && fv=$fr
+	test -n "$vscan" && grep $vscan vv.out >/dev/null 2>&1 && fv=$fr
 	rmf conftest.c conftest.o ${tcfn}* vv.out
 	ac_testdone
 }
@@ -282,54 +284,95 @@
 	echo "$me: Error: ./mksh is a directory!" >&2
 	exit 1
 fi
-rmf a.exe* a.out* conftest.c *core lft mksh* no *.o \
-    signames.inc stdint.h test.sh x vv.out
+rmf a.exe* a.out* conftest.c *core lft mksh* no *.bc *.ll *.o \
+    Rebuild.sh signames.inc test.sh x vv.out
 
 curdir=`pwd` srcdir=`dirname "$0"` check_categories=
+test -n "$dirname" || dirname=.
+dstversion=`sed -n '/define MKSH_VERSION/s/^.*"\(.*\)".*$/\1/p' $srcdir/sh.h`
 
 e=echo
 r=0
 eq=0
 pm=0
 cm=normal
-llvm=
+optflags=-std-compile-opts
+last=
 
 for i
 do
-	case $i in
-	-j)
-		pm=1
+	case $last:$i in
+	c:combine|c:dragonegg|c:llvm)
+		cm=$i
+		last=
+		;;
+	c:*)
+		echo "$me: Unknown option -c '$i'!" >&2
+		exit 1
+		;;
+	o:*)
+		optflags=$i
+		last=
+		;;
+	:-c)
+		last=c
 		;;
-	-combine)
+	:-combine)
 		cm=combine
+		echo "$me: Warning: '$i' is deprecated, use '-c combine' instead!" >&2
+		;;
+	:-g)
+		# checker, debug, valgrind build
+		CPPFLAGS="$CPPFLAGS -DDEBUG"
+		CFLAGS="$CFLAGS -g3 -fno-builtin"
+		;;
+	:-j)
+		pm=1
 		;;
-	-llvm)
+	:-llvm)
 		cm=llvm
-		llvm=-std-compile-opts
+		optflags=-std-compile-opts
+		echo "$me: Warning: '$i' is deprecated, use '-c llvm -O' instead!" >&2
 		;;
-	-llvm=*)
+	:-llvm=*)
 		cm=llvm
-		llvm=`echo "x$i" | sed 's/^x-llvm=//'`
+		optflags=`echo "x$i" | sed 's/^x-llvm=//'`
+		echo "$me: Warning: '$i' is deprecated, use '-c llvm -o $llvm' instead!" >&2
 		;;
-	-M)
+	:-M)
 		cm=makefile
 		;;
-	-Q)
+	:-O)
+		optflags=-std-compile-opts
+		;;
+	:-o)
+		last=o
+		;;
+	:-Q)
 		eq=1
 		;;
-	-r)
+	:-r)
 		r=1
 		;;
-	-valgrind)
-		CPPFLAGS="$CPPFLAGS -DDEBUG"
-		CFLAGS="$CFLAGS -g3 -fno-builtin"
+	:-v)
+		echo "Build.sh $srcversion"
+		echo "for mksh $dstversion"
+		exit 0
 		;;
-	*)
+	:*)
 		echo "$me: Unknown option '$i'!" >&2
 		exit 1
 		;;
+	*)
+		echo "$me: Unknown option -'$last' '$i'!" >&2
+		exit 1
+		;;
 	esac
 done
+if test -n "$last"; then
+	echo "$me: Option -'$last' not followed by argument!" >&2
+	exit 1
+fi
 
 SRCS="lalloc.c edit.c eval.c exec.c expr.c funcs.c histrap.c"
 SRCS="$SRCS jobs.c lex.c main.c misc.c shf.c syn.c tree.c var.c"
@@ -360,7 +403,7 @@
 	CPPFLAGS="$CPPFLAGS -D_ALL_SOURCE"
 	: ${HAVE_SETLOCALE_CTYPE=0}
 	;;
-BeOS|Haiku)
+BeOS)
 	oswarn=' and will currently not work'
 	;;
 BSD/OS)
@@ -382,6 +425,9 @@
 GNU/kFreeBSD)
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	;;
+Haiku)
+	CPPFLAGS="$CPPFLAGS -DMKSH_ASSUME_UTF8"
+	;;
 HP-UX)
 	;;
 Interix)
@@ -395,7 +441,7 @@
 	: ${HAVE_SETLOCALE_CTYPE=0}
 	;;
 Linux)
-	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE -DSETUID_CAN_FAIL_WITH_EAGAIN"
 	: ${HAVE_REVOKE=0}
 	;;
 MidnightBSD)
@@ -469,7 +515,6 @@
     NROFF="$NROFF -c"
 
 # this aids me in tracing FTBFSen without access to the buildd
-dstversion=`sed -n '/define MKSH_VERSION/s/^.*"\(.*\)".*$/\1/p' $srcdir/sh.h`
 $e "Hi from$ao $bi$srcversion$ao on:"
 case $TARGET_OS in
 Darwin)
@@ -698,7 +743,11 @@
 	ct=unknown
 	;;
 esac
-test $cm = llvm && vv '|' "llc -version"
+case $cm in
+dragonegg|llvm)
+	vv '|' "llc -version"
+	;;
+esac
 $e "$bi==> which compiler seems to be used...$ao $ui$ct$ao"
 rmf conftest.c conftest.o conftest a.out* a.exe* vv.out
 
@@ -996,6 +1045,7 @@
 	esac
 
 	: ${HAVE_MKNOD=0}
+	: ${HAVE_NICE=0}
 	: ${HAVE_REVOKE=0}
 	: ${HAVE_PERSISTENT_HISTORY=0}
 	check_categories=$check_categories,smksh
@@ -1020,33 +1070,16 @@
 ac_header sys/mkdev.h sys/types.h
 ac_header sys/mman.h sys/types.h
 ac_header sys/sysmacros.h
+ac_header grp.h sys/types.h
 ac_header libgen.h
 ac_header libutil.h sys/types.h
 ac_header paths.h
 ac_header stdbool.h
+ac_header stdint.h stdarg.h
 ac_header strings.h sys/types.h
-ac_header grp.h sys/types.h
 ac_header ulimit.h sys/types.h
 ac_header values.h
 
-ac_header '!' stdint.h stdarg.h
-ac_testn can_inttypes '!' stdint_h 1 "for standard 32-bit integer types" <<-'EOF'
-	#include <sys/types.h>
-	int main(int ac, char **av) { return ((uint32_t)*av + (int32_t)ac); }
-EOF
-ac_testn can_ucbints '!' can_inttypes 1 "for UCB 32-bit integer types" <<-'EOF'
-	#include <sys/types.h>
-	int main(int ac, char **av) { return ((u_int32_t)*av + (int32_t)ac); }
-EOF
-case $HAVE_CAN_INTTYPES$HAVE_CAN_UCBINTS in
-01)	HAVE_U_INT32_T=1
-	echo 'typedef u_int32_t uint32_t;' >>stdint.h ;;
-00)	echo 'typedef signed int int32_t;' >>stdint.h
-	echo 'typedef unsigned int uint32_t;' >>stdint.h ;;
-esac
-test -f stdint.h && HAVE_STDINT_H=1
-ac_cppflags STDINT_H
-
 #
 # Environment: definitions
 #
@@ -1070,6 +1103,27 @@
 #
 # Environment: types
 #
+ac_test can_inttypes '!' stdint_h 1 "for standard 32-bit integer types" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((uint32_t)(ptrdiff_t)*av + (int32_t)ac); }
+EOF
+ac_test can_ucbints '!' can_inttypes 1 "for UCB 32-bit integer types" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((u_int32_t)(ptrdiff_t)*av + (int32_t)ac); }
+EOF
+ac_test can_int8type '!' stdint_h 1 "for standard 8-bit integer type" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((uint8_t)(ptrdiff_t)av[ac]); }
+EOF
+ac_test can_ucbint8 '!' can_int8type 1 "for UCB 8-bit integer type" <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	int main(int ac, char **av) { return ((u_int8_t)(ptrdiff_t)av[ac]); }
+EOF
+
 ac_test rlim_t <<-'EOF'
 	#include <sys/types.h>
 	#include <sys/time.h>
@@ -1083,14 +1137,14 @@
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(sig_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(sig_t)(ptrdiff_t)kill(0,0)); }
 EOF
 
 ac_testn sighandler_t '!' sig_t 0 <<-'EOF'
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(sighandler_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(sighandler_t)(ptrdiff_t)kill(0,0)); }
 EOF
 if test 1 = $HAVE_SIGHANDLER_T; then
 	CPPFLAGS="$CPPFLAGS -Dsig_t=sighandler_t"
@@ -1101,7 +1155,7 @@
 	#include <sys/types.h>
 	#include <signal.h>
 	#include <stddef.h>
-	int main(void) { return ((int)(ptrdiff_t)(__sighandler_t)kill(0,0)); }
+	int main(void) { return ((int)(ptrdiff_t)(__sighandler_t)(ptrdiff_t)kill(0,0)); }
 EOF
 if test 1 = $HAVE___SIGHANDLER_T; then
 	CPPFLAGS="$CPPFLAGS -Dsig_t=__sighandler_t"
@@ -1111,15 +1165,6 @@
 test 1 = $HAVE_SIG_T || CPPFLAGS="$CPPFLAGS -Dsig_t=nosig_t"
 ac_cppflags SIG_T
 
-ac_testn u_int32_t <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	int main(void) { return ((int)(u_int32_t)0); }
-EOF
-test 1 = $HAVE_U_INT32_T || CPPFLAGS="$CPPFLAGS -Du_int32_t=uint32_t"
-
 #
 # Environment: signals
 #
@@ -1151,51 +1196,6 @@
 #
 # Environment: library functions
 #
-ac_testn arc4random <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	extern u_int32_t arc4random(void);
-	int main(void) { return ((int)(arc4random() & 0xFF)); }
-EOF
-
-save_LIBS=$LIBS
-if test 0 = $HAVE_ARC4RANDOM; then
-	test -f arc4random.c || if test -f "$srcdir/arc4random.c"; then
-		# ensure isolation of source directory from build directory
-		cp "$srcdir/arc4random.c" .
-	fi
-	if test -f arc4random.c; then
-		ac_testn can_uint8t '' "for uint8_t" <<-'EOF'
-			#include <sys/types.h>
-			#if HAVE_STDINT_H
-			#include <stdint.h>
-			#endif
-			int main(void) { return (1 - (uint8_t)1); }
-		EOF
-		test $HAVE_CAN_UINT8T = 1 || \
-		    CPPFLAGS="$CPPFLAGS -D\"uint8_t=unsigned char\""
-
-		ac_header sys/sysctl.h
-		addsrcs '!' HAVE_ARC4RANDOM arc4random.c
-		HAVE_ARC4RANDOM=1
-		LIBS="$LIBS arc4random.c"
-	fi
-fi
-ac_cppflags ARC4RANDOM
-
-ac_test arc4random_pushb arc4random 0 <<-'EOF'
-	#include <sys/types.h>
-	#if HAVE_STDINT_H
-	#include <stdint.h>
-	#endif
-	extern uint32_t arc4random_pushb(void *, size_t);
-	int main(int ac, char *av[]) { return ((int)(arc4random_pushb(*av,
-	    (size_t)ac)) & 0xFF); }
-EOF
-LIBS=$save_LIBS
-
 ac_testn flock_ex '' 'flock and mmap' <<-'EOF'
 	#include <sys/types.h>
 	#include <sys/file.h>
@@ -1317,18 +1317,6 @@
 #
 save_CC=$CC; save_LDFLAGS=$LDFLAGS; save_LIBS=$LIBS
 CC="$CC -c -o $tcfn"; LDFLAGS=; LIBS=
-ac_test '!' arc4random_decl arc4random 1 'if arc4random() does not need to be declared' <<-'EOF'
-	#define MKSH_INCLUDES_ONLY
-	#include "sh.h"
-	long arc4random(void);		/* this clashes if defined before */
-	int main(void) { return ((int)arc4random()); }
-EOF
-ac_test '!' arc4random_pushb_decl arc4random_pushb 1 'if arc4random_pushb() does not need to be declared' <<-'EOF'
-	#define MKSH_INCLUDES_ONLY
-	#include "sh.h"
-	int arc4random_pushb(char, int); /* this clashes if defined before */
-	int main(int ac, char *av[]) { return ((int)arc4random_pushb(**av, ac)); }
-EOF
 ac_test '!' flock_decl flock_ex 1 'if flock() does not need to be declared' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
@@ -1363,7 +1351,7 @@
 test 0 = $HAVE_SYS_SIGNAME && if ac_testinit cpp_dd '' \
     'checking if the C Preprocessor supports -dD'; then
 	echo '#define foo bar' >conftest.c
-	vv ']' "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -dD conftest.c $LIBS >x"
+	vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c >x"
 	grep '#define foo bar' x >/dev/null 2>&1 && fv=1
 	rmf conftest.c x vv.out
 	ac_testdone
@@ -1397,7 +1385,7 @@
 #endif
 #endif
 mksh_cfg: NSIG' >conftest.c
-	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS" | \
+	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
 	    grep mksh_cfg: | sed 's/^mksh_cfg:[	 ]*\([0-9x ()+-]*\).*$/\1/'`
 	case $NSIG in
 	*[\ \(\)+-]*) NSIG=`awk "BEGIN { print $NSIG }"` ;;
@@ -1410,14 +1398,14 @@
 	sigs="$sigs KILL LOST PIPE PROF PWR QUIT RESV SAK SEGV STOP SYS TERM"
 	sigs="$sigs TRAP TSTP TTIN TTOU URG USR1 USR2 VTALRM WINCH XCPU XFSZ"
 	test 1 = $HAVE_CPP_DD && test $NSIG -gt 1 && sigs="$sigs "`vq \
-	    "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -dD conftest.c $LIBS" | \
+	    "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c" | \
 	    grep '[	 ]SIG[A-Z0-9]*[	 ]' | \
 	    sed 's/^\(.*[	 ]SIG\)\([A-Z0-9]*\)\([	 ].*\)$/\2/' | sort`
 	test $NSIG -gt 1 || sigs=
 	for name in $sigs; do
 		echo '#include <signal.h>' >conftest.c
 		echo mksh_cfg: SIG$name >>conftest.c
-		vq "$CPP $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS" | \
+		vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
 		    grep mksh_cfg: | \
 		    sed 's/^mksh_cfg:[	 ]*\([0-9x]*\).*$/\1:'$name/
 	done | grep -v '^:' | while IFS=: read nr name; do
@@ -1439,11 +1427,11 @@
 addsrcs '!' HAVE_STRLCPY strlcpy.c
 addsrcs USE_PRINTF_BUILTIN printf.c
 test 1 = "$USE_PRINTF_BUILTIN" && CPPFLAGS="$CPPFLAGS -DMKSH_PRINTF_BUILTIN"
-test 0 = "$HAVE_SETMODE" && CPPFLAGS="$CPPFLAGS -DHAVE_CONFIG_H -DCONFIG_H_FILENAME=\\\"sh.h\\\""
 test 1 = "$HAVE_CAN_VERB" && CFLAGS="$CFLAGS -verbose"
 
 $e $bi$me: Finished configuration testing, now producing output.$ao
 
+CPPFLAGS="$CPPFLAGS -DIN_MKSH"
 files=
 objs=
 sp=
@@ -1474,25 +1462,36 @@
 test $HAVE_CAN_COMBINE$cm = 0combine && cm=normal
 if test $cm = llvm; then
 	emitbc="-emit-llvm -c"
+elif test $cm = dragonegg; then
+	emitbc="-S -flto"
 else
 	emitbc=-c
 fi
 echo set -x >Rebuild.sh
 for file in $SRCS; do
-	of=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1.o/'`
-	objs="$objs$sp$of"
+	op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 	test -f $file || file=$srcdir/$file
 	files="$files$sp$file"
 	sp=' '
 	echo "$CC $CFLAGS $CPPFLAGS $emitbc $file || exit 1" >>Rebuild.sh
+	if test $cm = dragonegg; then
+		echo "mv ${op}s ${op}ll" >>Rebuild.sh
+		echo "llvm-as ${op}ll || exit 1" >>Rebuild.sh
+		objs="$objs$sp${op}bc"
+	else
+		objs="$objs$sp${op}o"
+	fi
 done
-if test $cm = llvm; then
+case $cm in
+dragonegg|llvm)
 	echo "rm -f mksh.s" >>Rebuild.sh
-	echo "llvm-link -o - $objs | opt $llvm | llc -o mksh.s" >>Rebuild.sh
+	echo "llvm-link -o - $objs | opt $optflags | llc -o mksh.s" >>Rebuild.sh
 	lobjs=mksh.s
-else
+	;;
+*)
 	lobjs=$objs
-fi
+	;;
+esac
 case $tcfn in
 a.exe)	mkshexe=mksh.exe ;;
 *)	mkshexe=mksh ;;
@@ -1558,14 +1557,22 @@
 	wait
 else
 	for file in $SRCS; do
+		test $cm = dragonegg && \
+		    op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 		test -f $file || file=$srcdir/$file
 		v "$CC $CFLAGS $CPPFLAGS $emitbc $file" || exit 1
+		if test $cm = dragonegg; then
+			v "mv ${op}s ${op}ll"
+			v "llvm-as ${op}ll" || exit 1
+		fi
 	done
 fi
-if test $cm = llvm; then
+case $cm in
+dragonegg|llvm)
 	rmf mksh.s
-	v "llvm-link -o - $objs | opt $llvm | llc -o mksh.s"
-fi
+	v "llvm-link -o - $objs | opt $optflags | llc -o mksh.s"
+	;;
+esac
 tcfn=$mkshexe
 test $cm = combine || v "$CC $CFLAGS $LDFLAGS -o $tcfn $lobjs $LIBS $ccpr"
 test -f $tcfn || exit 1
Index: src/bin/mksh/Makefile
diff -u /dev/null src/bin/mksh/Makefile:1.82
--- /dev/null	Fri Oct  1 19:17:43 2010
+++ src/bin/mksh/Makefile	Tue Sep 14 21:26:05 2010
@@ -0,0 +1,86 @@
+# $MirOS: src/bin/mksh/Makefile,v 1.82 2010/09/14 21:26:05 tg Exp $
+#-
+# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+#	Thorsten Glaser <tg@mirbsd.org>
+#
+# Provided that these terms and disclaimer and all copyright notices
+# are retained or reproduced in an accompanying document, permission
+# is granted to deal in this work without restriction, including un-
+# limited rights to use, publicly perform, distribute, sell, modify,
+# merge, give away, or sublicence.
+#
+# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
+# the utmost extent permitted by applicable law, neither express nor
+# implied; without malicious intent or gross negligence. In no event
+# may a licensor, author or contributor be held liable for indirect,
+# direct, other damage, loss, or other issues arising in any way out
+# of dealing in the work, even if advised of the possibility of such
+# damage or existence of a defect, except proven that it results out
+# of said person's immediate fault when using the work as intended.
+#-
+# use CPPFLAGS=-DDEBUG __CRAZY=Yes to check for certain more stuff
+
+.include <bsd.own.mk>
+
+PROG=		mksh
+SRCS=		edit.c eval.c exec.c expr.c funcs.c histrap.c jobs.c \
+		lalloc.c lex.c main.c misc.c shf.c syn.c tree.c var.c
+.if !make(test-build)
+CPPFLAGS+=	-DMKSH_ASSUME_UTF8 \
+		-DHAVE_ATTRIBUTE_BOUNDED=1 -DHAVE_ATTRIBUTE_FORMAT=1 \
+		-DHAVE_ATTRIBUTE_NONNULL=1 -DHAVE_ATTRIBUTE_NORETURN=1 \
+		-DHAVE_ATTRIBUTE_UNUSED=1 -DHAVE_ATTRIBUTE_USED=1 \
+		-DHAVE_SYS_PARAM_H=1 -DHAVE_SYS_MKDEV_H=0 -DHAVE_SYS_MMAN_H=1 \
+		-DHAVE_SYS_SYSMACROS_H=0 -DHAVE_GRP_H=1 -DHAVE_LIBGEN_H=1 \
+		-DHAVE_LIBUTIL_H=0 -DHAVE_PATHS_H=1 -DHAVE_STDBOOL_H=1 \
+		-DHAVE_STDINT_H=1 -DHAVE_STRINGS_H=1 -DHAVE_ULIMIT_H=0 \
+		-DHAVE_VALUES_H=0 -DHAVE_CAN_INTTYPES=1 -DHAVE_CAN_UCBINTS=1 \
+		-DHAVE_CAN_INT8TYPE=1 -DHAVE_CAN_UCBINT8=1 -DHAVE_RLIM_T=1 \
+		-DHAVE_SIG_T=1 -DHAVE_SYS_SIGNAME=1 -DHAVE_SYS_SIGLIST=1 \
+		-DHAVE_STRSIGNAL=0 -DHAVE_GETRUSAGE=1 -DHAVE_KILLPG=1 \
+		-DHAVE_MKNOD=1 -DHAVE_MKSTEMP=1 -DHAVE_NICE=1 -DHAVE_REVOKE=1 \
+		-DHAVE_SETLOCALE_CTYPE=0 -DHAVE_LANGINFO_CODESET=0 \
+		-DHAVE_SETMODE=1 -DHAVE_SETRESUGID=1 -DHAVE_SETGROUPS=1 \
+		-DHAVE_STRCASESTR=1 -DHAVE_STRLCPY=1 -DHAVE_FLOCK_DECL=1 \
+		-DHAVE_REVOKE_DECL=1 -DHAVE_SYS_SIGLIST_DECL=1 \
+		-DHAVE_PERSISTENT_HISTORY=1 -DIN_MKSH
+COPTS+=		-std=gnu99 -Wall
+.endif
+
+USE_PRINTF_BUILTIN?=	0
+.if ${USE_PRINTF_BUILTIN} == 1
+.PATH: ${BSDSRCDIR}/usr.bin/printf
+SRCS+=		printf.c
+CPPFLAGS+=	-DMKSH_PRINTF_BUILTIN
+.endif
+
+LINKS+=		${BINDIR}/${PROG} ${BINDIR}/sh
+MLINKS+=	${PROG}.1 sh.1
+
+regress: ${PROG} check.pl check.t
+	-rm -rf regress-dir
+	mkdir -p regress-dir
+	echo export FNORD=666 >regress-dir/.mkshrc
+	HOME=$$(realpath regress-dir) perl ${.CURDIR}/check.pl \
+	    -s ${.CURDIR}/check.t -v -p ./${PROG}
+
+test-build: .PHONY
+	-rm -rf build-dir
+	mkdir -p build-dir
+	cd build-dir; env CC=${CC:Q} CFLAGS=${CFLAGS:M*:Q} \
+	    CPPFLAGS=${CPPFLAGS:M*:Q} LDFLAGS=${LDFLAGS:M*:Q} \
+	    LIBS= NOWARN=-Wno-error TARGET_OS= CPP= /bin/sh \
+	    ${.CURDIR}/Build.sh -Q -r && ./test.sh -v
+
+cleandir: clean-extra
+
+clean-extra: .PHONY
+	-rm -rf build-dir regress-dir printf.o printf.ln
+
+distribution:
+	sed 's!\$$I''d\([:$$]\)!$$M''irSecuCron\1!g' \
+	    ${.CURDIR}/dot.mkshrc >${DESTDIR}/etc/skel/.mkshrc
+	chown ${BINOWN}:${CONFGRP} ${DESTDIR}/etc/skel/.mkshrc
+	chmod 0644 ${DESTDIR}/etc/skel/.mkshrc
+
+.include <bsd.prog.mk>
Index: src/bin/mksh/check.t
diff -u src/bin/mksh/check.t:1.365 src/bin/mksh/check.t:1.395
--- src/bin/mksh/check.t:1.365	Thu Feb 25 20:18:14 2010
+++ src/bin/mksh/check.t	Fri Oct  1 19:04:37 2010
@@ -1,4 +1,4 @@
-# $MirOS: src/bin/mksh/check.t,v 1.365 2010/02/25 20:18:14 tg Exp $
+# $MirOS: src/bin/mksh/check.t,v 1.395 2010/10/01 19:04:37 tg Exp $
 # $OpenBSD: bksl-nl.t,v 1.2 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: history.t,v 1.5 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: read.t,v 1.3 2003/03/10 03:48:16 david Exp $
@@ -25,7 +25,7 @@
 # http://www.research.att.com/~gsf/public/ifs.sh
 
 expected-stdout:
-	@(#)MIRBSD KSH R39 2010/02/25
+	@(#)MIRBSD KSH R39 2010/10/01
 description:
 	Check version of shell.
 stdin:
@@ -185,6 +185,17 @@
 	tf
 	tf
 ---
+name: alias-10
+description:
+	Check that recursion is detected/avoided in aliases.
+	Regression, introduced during an old bugfix.
+stdin:
+	alias foo='print hello '
+	alias bar='foo world'
+	echo $(bar)
+expected-stdout:
+	hello world
+---
 name: arith-lazy-1
 description:
 	Check that only one side of ternary operator is evaluated
@@ -1036,11 +1047,17 @@
 	(echo -n '30 '; printf '<%s> ' ${IFS+foo 'b\
 	ar' baz}; echo .) 2>&- || (echo failed in 30; echo failed in 31)
 	(echo -n '32 '; printf '<%s> ' ${IFS+foo "b\
-	ar" baz}; echo .) 2>&- || (echo failed in 32; echo failed in 33)
-	(echo -n '34 '; printf '<%s> ' "${IFS+foo 'b\
-	ar' baz}"; echo .) 2>&- || (echo failed in 34; echo failed in 35)
-	(echo -n '36 '; printf '<%s> ' "${IFS+foo "b\
-	ar" baz}"; echo .) 2>&- || (echo failed in 36; echo failed in 37)
+	ar" baz}; echo .) 2>&- || echo failed in 32
+	(echo -n '33 '; printf '<%s> ' "${IFS+foo 'b\
+	ar' baz}"; echo .) 2>&- || echo failed in 33
+	(echo -n '34 '; printf '<%s> ' "${IFS+foo "b\
+	ar" baz}"; echo .) 2>&- || echo failed in 34
+	(echo -n '35 '; printf '<%s> ' ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 35
+	(echo -n '36 '; printf '<%s> ' "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 36
+	(echo -n '37 '; printf '<%s> ' ${v-a\ b} x ${v-c\ d}; echo .) 2>&- || echo failed in 37
+	(echo 38 ${IFS+x'a'y} / "${IFS+x'a'y}" .) 2>&- || echo failed in 38
+	foo="x'a'y"; (echo 39 ${foo%*'a'*} / "${foo%*'a'*}" .) 2>&- || echo failed in 39
+	foo="a b c"; (echo -n '40 '; printf '<%s> ' "${foo#a}"; echo .) 2>&- || echo failed in 40
 expected-stdout:
 	1 }z
 	2 ''z}
@@ -1074,8 +1091,14 @@
 	30 <foo> <b\
 	ar> <baz> .
 	32 <foo> <bar> <baz> .
-	34 <foo 'bar' baz> .
-	36 <foo bar baz> .
+	33 <foo 'bar' baz> .
+	34 <foo bar baz> .
+	35 <a> <b> <x> <a> <b> .
+	36 <a\ b> <x> <a\ b> .
+	37 <a b> <x> <c d> .
+	38 xay / x'a'y .
+	39 x' / x' .
+	40 < b c> .
 ---
 name: expand-unglob-dblq
 description:
@@ -2245,7 +2268,7 @@
 	hi
 	1	echo hi
 expected-stderr-pattern:
-	/(.*cannot unlink HISTFILE.*\n)?X*$/
+	/(.*can't unlink HISTFILE.*\n)?X*$/
 ---
 name: history-e-minus-1
 description:
@@ -3309,6 +3332,20 @@
 	dot B 3
 	C 3
 ---
+name: lineno-trap
+description:
+	Check if LINENO is tracked in traps
+stdin:
+	fail() {
+		echo "line <$1>"
+		exit 1
+	}
+	trap 'fail $LINENO' INT ERR
+	false
+expected-stdout:
+	line <6>
+expected-exit: 1
+---
 name: read-IFS-1
 description:
 	Simple test, default IFS
@@ -4384,6 +4421,53 @@
 expected-stdout:
 	123
 ---
+name: xxx-multi-assignment-posix-cmd
+description:
+	Check that the behaviour for multiple assignments with a
+	command name matches POSIX. See:
+	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
+stdin:
+	X=a Y=b; X=$Y Y=$X "$__progname" -c 'echo 1 $X $Y .'; echo 2 $X $Y .
+	unset X Y Z
+	X=a Y=${X=b} Z=$X "$__progname" -c 'echo 3 $Z .'
+	unset X Y Z
+	X=a Y=${X=b} Z=$X; echo 4 $Z .
+expected-stdout:
+	1 b a .
+	2 a b .
+	3 b .
+	4 a .
+---
+name: xxx-multi-assignment-posix-nocmd
+description:
+	Check that the behaviour for multiple assignments with no
+	command name matches POSIX (Debian #334182). See:
+	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
+stdin:
+	X=a Y=b; X=$Y Y=$X; echo 1 $X $Y .
+expected-stdout:
+	1 b b .
+---
+name: xxx-multi-assignment-posix-subassign
+description:
+	Check that the behaviour for multiple assignments matches POSIX:
+	- The assignment words shall be expanded in the current execution
+	  environment.
+	- The assignments happen in the temporary execution environment.
+stdin:
+	unset X Y Z
+	Z=a Y=${X:=b} sh -c 'echo +$X+ +$Y+ +$Z+'
+	echo /$X/
+	# Now for the special case:
+	unset X Y Z
+	X= Y=${X:=b} sh -c 'echo +$X+ +$Y+'
+	echo /$X/
+expected-stdout:
+	++ +b+ +a+
+	/b/
+	++ +b+
+	/b/
+---
 name: xxx-exec-environment-1
 description:
 	Check to see if exec sets it's environment correctly
@@ -4441,6 +4525,22 @@
 	/bad substitution/
 expected-exit: 1
 ---
+name: xxx-variable-syntax-2
+stdin:
+	set 0
+	echo ${*:0}
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
+name: xxx-variable-syntax-3
+stdin:
+	set -A foo 0
+	echo ${foo[*]:0}
+expected-stderr-pattern:
+	/bad substitution/
+expected-exit: 1
+---
 name: xxx-substitution-eval-order
 description:
 	Check order of evaluation of expressions
@@ -5780,6 +5880,15 @@
 	z w
 	v u
 ---
+name: varexpand-null-2
+description:
+	Ensure empty strings, when quoted, are expanded as empty strings
+stdin:
+	printf '<%s> ' 1 "${a}" 2 "${a#?}" + "${b%?}" 3 "${a=}" + "${b/c/d}"
+	echo .
+expected-stdout:
+	<1> <> <2> <> <+> <> <3> <> <+> <> .
+---
 name: print-funny-chars
 description:
 	Check print builtin's capability to output designated characters
@@ -6338,8 +6447,9 @@
 description:
 	Check if we can use a specific syntax idiom for ulimit
 stdin:
-	if ! x=$(ulimit -d); then
-		echo expected to fail on this OS
+	if ! x=$(ulimit -d) || [[ $x = unknown ]]; then
+		#echo expected to fail on this OS
+		echo okay
 	else
 		ulimit -dS $x && echo okay
 	fi
@@ -6448,7 +6558,7 @@
 expected-stdout:
 	===
 	mir
-expected-stderr-pattern: /.*: cannot (create|overwrite) .*/
+expected-stderr-pattern: /.*: can't (create|overwrite) .*/
 ---
 name: bashiop-3b
 description:
@@ -7262,3 +7372,75 @@
 expected-stdout:
 	1 .
 ---
+name: realpath-1
+description:
+	Check proper return values for realpath
+category: os:mirbsd
+stdin:
+	wd=$(realpath .)
+	mkdir dir
+	:>file
+	:>dir/file
+	ln -s dir lndir
+	ln -s file lnfile
+	ln -s nix lnnix
+	ln -s . lnself
+	i=0
+	chk() {
+		typeset x y
+		x=$(realpath "$wd/$1" 2>&1); y=$?
+		print $((++i)) "?$1" =${x##*$wd/} !$y
+	}
+	chk dir
+	chk dir/
+	chk dir/file
+	chk dir/nix
+	chk file
+	chk file/
+	chk file/file
+	chk file/nix
+	chk nix
+	chk nix/
+	chk nix/file
+	chk nix/nix
+	chk lndir
+	chk lndir/
+	chk lndir/file
+	chk lndir/nix
+	chk lnfile
+	chk lnfile/
+	chk lnfile/file
+	chk lnfile/nix
+	chk lnnix
+	chk lnnix/
+	chk lnnix/file
+	chk lnnix/nix
+	chk lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself
+	rm lnself
+expected-stdout:
+	1 ?dir =dir !0
+	2 ?dir/ =dir !0
+	3 ?dir/file =dir/file !0
+	4 ?dir/nix =dir/nix !0
+	5 ?file =file !0
+	6 ?file/ =file/: Not a directory !20
+	7 ?file/file =file/file: Not a directory !20
+	8 ?file/nix =file/nix: Not a directory !20
+	9 ?nix =nix !0
+	10 ?nix/ =nix !0
+	11 ?nix/file =nix/file: No such file or directory !2
+	12 ?nix/nix =nix/nix: No such file or directory !2
+	13 ?lndir =dir !0
+	14 ?lndir/ =dir !0
+	15 ?lndir/file =dir/file !0
+	16 ?lndir/nix =dir/nix !0
+	17 ?lnfile =file !0
+	18 ?lnfile/ =lnfile/: Not a directory !20
+	19 ?lnfile/file =lnfile/file: Not a directory !20
+	20 ?lnfile/nix =lnfile/nix: Not a directory !20
+	21 ?lnnix =nix !0
+	22 ?lnnix/ =nix !0
+	23 ?lnnix/file =lnnix/file: No such file or directory !2
+	24 ?lnnix/nix =lnnix/nix: No such file or directory !2
+	25 ?lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself =lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself: Too many levels of symbolic links !62
+---
Index: src/bin/mksh/dot.mkshrc
diff -u src/bin/mksh/dot.mkshrc:1.54 src/bin/mksh/dot.mkshrc:1.56
--- src/bin/mksh/dot.mkshrc:1.54	Thu Feb 25 20:48:10 2010
+++ src/bin/mksh/dot.mkshrc	Sun Jul 11 13:54:37 2010
@@ -1,5 +1,5 @@
 # $Id$
-# $MirOS: src/bin/mksh/dot.mkshrc,v 1.54 2010/02/25 20:48:10 tg Exp $
+# $MirOS: src/bin/mksh/dot.mkshrc,v 1.56 2010/07/11 13:54:37 tg Exp $
 #-
 # Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010
 #	Thorsten Glaser <tg@mirbsd.org>
@@ -31,7 +31,7 @@
 }
 PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&-||print \?)}@${HOSTNAME%%.*}:$(
 	typeset d=${PWD:-?} n p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
-	(( ${#d} > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && {
+	(( (${%d}>0 ? ${%d}: ${#d}) > (n = (COLUMNS/3<7 ? 7: COLUMNS/3)) )) && {
 	d=${d:(-n)}; p=...; } || p=; print -nr -- "$p$d") '"$PS1 "
 : ${MKSH:=$(whence -p mksh)}; export EDITOR HOSTNAME MKSH PS1 TERM USER
 alias ls=ls
@@ -73,7 +73,7 @@
 	cd "$t"
 }
 function dirs {
-	typeset d
+	typeset d dwidth
 	typeset -i isnoglob=0 fl=0 fv=0 fn=0 cpos=0
 
 	[[ $(set +o) == *@(-o noglob)@(| *) ]] && isnoglob=1
@@ -105,9 +105,11 @@
 		while (( fv < ${#DIRSTACK[*]} )); do
 			d=${DIRSTACK[fv]}
 			(( fl )) && d=${d/#~/$DIRSTACKBASE}
-			if (( fn && (cpos+=${#d}+1) >= 79 && ${#d} < 80 )); then
+			(( dwidth = (${%d} > 0 ? ${%d} : ${#d}) ))
+			if (( fn && (cpos += dwidth + 1) >= 79 && \
+			    dwidth < 80 )); then
 				print
-				(( cpos = ${#d} + 1 ))
+				(( cpos = dwidth + 1 ))
 			fi
 			print -nr -- "$d "
 			let fv++
@@ -335,7 +337,7 @@
 	done; }
 }
 
-: place customsations below this line
+: place customisations below this line
 
 for p in ~/.etc/bin ~/bin; do
 	[[ -d $p/. ]] || continue
@@ -352,4 +354,4 @@
 
 unset p
 
-: place customsations above this line
+: place customisations above this line
Index: src/bin/mksh/edit.c
diff -u src/bin/mksh/edit.c:1.190 src/bin/mksh/edit.c:1.201
--- src/bin/mksh/edit.c:1.190	Tue Feb 23 18:13:02 2010
+++ src/bin/mksh/edit.c	Tue Sep 14 21:26:09 2010
@@ -1,4 +1,4 @@
-/*	$OpenBSD: edit.c,v 1.33 2007/08/02 10:50:25 fgsch Exp $	*/
+/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
 /*	$OpenBSD: edit.h,v 1.8 2005/03/28 21:28:22 deraadt Exp $	*/
 /*	$OpenBSD: emacs.c,v 1.42 2009/06/02 06:47:47 halex Exp $	*/
 /*	$OpenBSD: vi.c,v 1.26 2009/06/29 22:50:19 martynas Exp $	*/
@@ -25,7 +25,20 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.190 2010/02/23 18:13:02 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.201 2010/09/14 21:26:09 tg Exp $");
+
+/*
+ * in later versions we might use libtermcap for this, but since external
+ * dependencies are problematic, this has not yet been decided on; another
+ * good string is "\033c" except on hardware terminals like the DEC VT420
+ * which do a full power cycle then...
+ */
+#ifndef MKSH_CLS_STRING
+#define MKSH_CLS_STRING		"\033[;H\033[J"
+#endif
+#ifndef MKSH_CLRTOEOL_STRING
+#define MKSH_CLRTOEOL_STRING	"\033[K"
+#endif
 
 /* tty driver characters we are interested in */
 typedef struct {
@@ -45,6 +58,8 @@
 #define XCF_FULLPATH	BIT(2)	/* command completion: store full path */
 #define XCF_COMMAND_FILE (XCF_COMMAND|XCF_FILE)
 
+static char editmode;
+static int xx_cols;			/* for Emacs mode */
 static int modified;			/* buffer has been "modified" */
 static char holdbuf[LINE];		/* place to hold last edit buffer */
 
@@ -67,7 +82,11 @@
 #endif
 
 #define x_flush()	shf_flush(shl_out)
+#ifdef MKSH_SMALL
+#define x_putc(c)	x_putcf(c)
+#else
 #define x_putc(c)	shf_putc((c), shl_out)
+#endif
 
 static int path_order_cmp(const void *aa, const void *bb);
 static char *add_glob(const char *, int)
@@ -84,6 +103,7 @@
 static int x_locate_word(const char *, int, int, int *, bool *);
 
 static int x_e_getmbc(char *);
+static int x_e_rebuildline(const char *);
 
 /* +++ generic editing functions +++ */
 
@@ -96,7 +116,6 @@
 	    edchars.eof = -2;
 	/* default value for deficient systems */
 	edchars.werase = 027;	/* ^W */
-	change_winsz();
 	x_init_emacs();
 }
 
@@ -118,8 +137,8 @@
 #endif
 	else
 		i = -1;		/* internal error */
+	editmode = 0;
 	x_mode(false);
-	change_winsz();
 	return (i);
 }
 
@@ -129,12 +148,22 @@
 x_getc(void)
 {
 	char c;
-	int n;
+	ssize_t n;
 
 	while ((n = blocking_read(STDIN_FILENO, &c, 1)) < 0 && errno == EINTR)
 		if (trap) {
 			x_mode(false);
 			runtraps(0);
+#ifdef SIGWINCH
+			if (got_winch) {
+				change_winsz();
+				if (x_cols != xx_cols && editmode == 1) {
+					/* redraw line in Emacs mode */
+					xx_cols = x_cols;
+					x_e_rebuildline(MKSH_CLRTOEOL_STRING);
+				}
+			}
+#endif
 			x_mode(true);
 		}
 	return ((n == 1) ? (int)(unsigned char)c : -1);
@@ -295,7 +324,7 @@
 	source = s;
 	if (yylex(ONEWORD | LQCHAR) != LWORD) {
 		source = sold;
-		internal_warningf("fileglob: substitute error");
+		internal_warningf("%s: %s", "fileglob", "bad substitution");
 		return (0);
 	}
 	source = sold;
@@ -395,7 +424,7 @@
 		int i, path_order = 0;
 
 		info = (struct path_order_info *)
-		    alloc(nwords * sizeof(struct path_order_info), ATEMP);
+		    alloc2(nwords, sizeof(struct path_order_info), ATEMP);
 		for (i = 0; i < nwords; i++) {
 			info[i].word = words[i];
 			info[i].base = x_basename(words[i], NULL);
@@ -550,7 +579,8 @@
 		if (*s == '\\' && s[1])
 			s++;
 		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$' ||
-		    (s[1] == '(' && vstrchr("*+?@!", *s)))
+		    (s[1] == '(' /*)*/ && /* *s in '*','?' already checked */
+		    (*s == '+' || *s == '@' || *s == '!')))
 			break;
 		else if (*s == '/')
 			saw_slash = true;
@@ -648,13 +678,15 @@
 static void
 glob_path(int flags, const char *pat, XPtrV *wp, const char *lpath)
 {
-	const char *sp, *p;
+	const char *sp = lpath, *p;
 	char *xp, **words;
-	int staterr, pathlen, patlen, oldsize, newsize, i, j;
+	size_t pathlen, patlen, oldsize, newsize, i, j;
+	int staterr;
 	XString xs;
 
-	patlen = strlen(pat) + 1;
-	sp = lpath;
+	patlen = strlen(pat);
+	checkoktoadd(patlen, 129 + X_EXTRA);
+	++patlen;
 	Xinit(xs, xp, patlen + 128, ATEMP);
 	while (sp) {
 		xp = Xstring(xs, xp);
@@ -771,8 +803,8 @@
 
 /* Separator for completion */
 #define	is_cfs(c)	((c) == ' ' || (c) == '\t' || (c) == '"' || (c) == '\'')
-			/* Separator for motion */
-#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$'))
+/* Separator for motion */
+#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$' || ((c) & 0x80)))
 
 #define X_NTABS		3			/* normal, meta1, meta2 */
 #define X_TABSZ		256			/* size of keydef tables etc */
@@ -804,7 +836,6 @@
  */
 static int x_adj_done;
 
-static int xx_cols;
 static int x_col;
 static int x_displen;
 static int x_arg;		/* general purpose arg */
@@ -1090,6 +1121,7 @@
 			x_load_hist(histptr - off);
 		x_nextcmd = -1;
 	}
+	editmode = 1;
 	while (1) {
 		x_flush();
 		if ((c = x_e_getc()) < 0)
@@ -1922,24 +1954,19 @@
 }
 
 static int
-x_cls(int c MKSH_A_UNUSED)
+x_e_rebuildline(const char *clrstr)
 {
-/*
- * in later versions we might use libtermcap for this, but since external
- * dependencies are problematic, this has not yet been decided on; another
- * good string is "\033c" except on hardware terminals like the DEC VT420
- * which do a full power cycle then...
- */
-#ifndef MKSH_CLS_STRING
-#define MKSH_CLS_STRING	"\033[;H\033[J"
-#endif
-	shf_fprintf(shl_out, MKSH_CLS_STRING);
-	x_putc('\r');
-	x_init_prompt();
-	x_redraw(0);
+	shf_puts(clrstr, shl_out);
+	x_adjust();
 	return (KSTD);
 }
 
+static int
+x_cls(int c MKSH_A_UNUSED)
+{
+	return (x_e_rebuildline(MKSH_CLS_STRING));
+}
+
 /* Redraw (part of) the line. If limit is < 0, the everything is redrawn
  * on a NEW line, otherwise limit is the screen column up to which needs
  * redrawing.
@@ -2220,7 +2247,7 @@
 
 	/*-
 	 * At this point, we have read the following octets so far:
-	 * - ESC+[ or ESC+O or Ctrl-X (PrÃ¦fix 2)
+	 * - ESC+[ or ESC+O or Ctrl-X (Prefix 2)
 	 * - 1 (vt_hack)
 	 * - ;
 	 * - 5 (Ctrl key combiner) or 3 (Alt key combiner)
@@ -2243,13 +2270,13 @@
 static char *
 x_mapin(const char *cp, Area *ap)
 {
-	char *new, *op;
+	char *news, *op;
 
 	/* for clang's static analyser, the nonnull attribute isn't enough */
 	mkssert(cp != NULL);
 
-	strdupx(new, cp, ap);
-	op = new;
+	strdupx(news, cp, ap);
+	op = news;
 	while (*cp) {
 		/* XXX -- should handle \^ escape? */
 		if (*cp == '^') {
@@ -2266,7 +2293,7 @@
 	}
 	*op = '\0';
 
-	return (new);
+	return (news);
 }
 
 static void
@@ -2331,7 +2358,7 @@
 #endif
 
 	if (x_tab == NULL) {
-		bi_errorf("cannot bind, not a tty");
+		bi_errorf("can't bind, not a tty");
 		return (1);
 	}
 	/* List function names */
@@ -2373,12 +2400,12 @@
 	    && ((*m1 != '~') || *(m1 + 1))
 #endif
 	    ) {
-		char msg[256] = "key sequence '";
+		char msg[256];
 		const char *c = a1;
-		m1 = msg + strlen(msg);
+		m1 = msg;
 		while (*c && m1 < (msg + sizeof(msg) - 3))
 			x_mapout2(*c++, &m1);
-		bi_errorf("%s' too long", msg);
+		bi_errorf("%s: %s", "too long key sequence", msg);
 		return (1);
 	}
 #ifndef MKSH_SMALL
@@ -2403,7 +2430,7 @@
 			    strcmp(x_ftab[f].xf_name, a2) == 0)
 				break;
 		if (f == NELEM(x_ftab) || x_ftab[f].xf_flags & XF_NOBIND) {
-			bi_errorf("%s: no such function", a2);
+			bi_errorf("%s: %s %s", a2, "no such", T_function);
 			return (1);
 		}
 	}
@@ -2441,7 +2468,7 @@
 	ainit(AEDIT);
 	x_nextcmd = -1;
 
-	x_tab = alloc(X_NTABS * sizeof(*x_tab), AEDIT);
+	x_tab = alloc2(X_NTABS, sizeof(*x_tab), AEDIT);
 	for (j = 0; j < X_TABSZ; j++)
 		x_tab[0][j] = XFUNC_insert;
 	for (i = 1; i < X_NTABS; i++)
@@ -2452,7 +2479,7 @@
 		    = x_defbindings[i].xdb_func;
 
 #ifndef MKSH_SMALL
-	x_atab = alloc(X_NTABS * sizeof(*x_atab), AEDIT);
+	x_atab = alloc2(X_NTABS, sizeof(*x_atab), AEDIT);
 	for (i = 1; i < X_NTABS; i++)
 		for (j = 0; j < X_TABSZ; j++)
 			x_atab[i][j] = NULL;
@@ -3287,7 +3314,7 @@
 static char		undocbuf[LINE];
 
 static struct edstate	*save_edstate(struct edstate *old);
-static void		restore_edstate(struct edstate *old, struct edstate *new);
+static void		restore_edstate(struct edstate *old, struct edstate *news);
 static void		free_edstate(struct edstate *old);
 
 static struct edstate	ebuf;
@@ -3380,6 +3407,7 @@
 	lastref = 1;
 	holdlen = 0;
 
+	editmode = 2;
 	x_flush();
 	while (1) {
 		if (macro.p) {
@@ -3886,7 +3914,7 @@
 			{
 				static char alias[] = "_\0";
 				struct tbl *ap;
-				int olen, nlen;
+				size_t olen, nlen;
 				char *p, *nbuf;
 
 				/* lookup letter in alias list... */
@@ -3903,6 +3931,10 @@
 				nlen = strlen(ap->val.s) + 1;
 				olen = !macro.p ? 2 :
 				    macro.len - (macro.p - macro.buf);
+				/*
+				 * at this point, it's fairly reasonable that
+				 * nlen + olen + 2 doesn't overflow
+				 */
 				nbuf = alloc(nlen + 1 + olen, APERM);
 				memcpy(nbuf, ap->val.s, nlen);
 				nbuf[nlen++] = cmd[1];
@@ -4548,25 +4580,25 @@
 static struct edstate *
 save_edstate(struct edstate *old)
 {
-	struct edstate *new;
+	struct edstate *news;
 
-	new = alloc(sizeof(struct edstate), APERM);
-	new->cbuf = alloc(old->cbufsize, APERM);
-	memcpy(new->cbuf, old->cbuf, old->linelen);
-	new->cbufsize = old->cbufsize;
-	new->linelen = old->linelen;
-	new->cursor = old->cursor;
-	new->winleft = old->winleft;
-	return (new);
+	news = alloc(sizeof(struct edstate), APERM);
+	news->cbuf = alloc(old->cbufsize, APERM);
+	memcpy(news->cbuf, old->cbuf, old->linelen);
+	news->cbufsize = old->cbufsize;
+	news->linelen = old->linelen;
+	news->cursor = old->cursor;
+	news->winleft = old->winleft;
+	return (news);
 }
 
 static void
-restore_edstate(struct edstate *new, struct edstate *old)
+restore_edstate(struct edstate *news, struct edstate *old)
 {
-	memcpy(new->cbuf, old->cbuf, old->linelen);
-	new->linelen = old->linelen;
-	new->cursor = old->cursor;
-	new->winleft = old->winleft;
+	memcpy(news->cbuf, old->cbuf, old->linelen);
+	news->linelen = old->linelen;
+	news->cursor = old->cursor;
+	news->winleft = old->winleft;
 	free_edstate(old);
 }
 
@@ -4785,7 +4817,7 @@
 	}
 	(void)histnum(n);
 	if ((hptr = *histpos()) == NULL) {
-		internal_warningf("grabhist: bad history array");
+		internal_warningf("%s: %s", "grabhist", "bad history array");
 		return (-1);
 	}
 	if (save)
Index: src/bin/mksh/emacsfn.h
diff -u src/bin/mksh/emacsfn.h:1.4 src/bin/mksh/emacsfn.h:1.5
--- src/bin/mksh/emacsfn.h:1.4	Wed Sep 23 18:04:55 2009
+++ src/bin/mksh/emacsfn.h	Sat Jul 17 22:09:33 2010
@@ -1,86 +1,86 @@
 #if defined(EMACSFN_DEFNS)
-__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.4 2009/09/23 18:04:55 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.5 2010/07/17 22:09:33 tg Exp $");
 #define FN(cname,sname,flags)	static int x_##cname(int);
 #elif defined(EMACSFN_ENUMS)
 #define FN(cname,sname,flags)	XFUNC_##cname,
 #define F0(cname,sname,flags)	XFUNC_##cname = 0,
 #elif defined(EMACSFN_ITEMS)
-#define FN(cname,sname,flags)	{ x_##cname, #sname, flags },
+#define FN(cname,sname,flags)	{ x_##cname, sname, flags },
 #endif
 
 #ifndef F0
 #define F0 FN
 #endif
 
-F0(abort, abort, 0)
-FN(beg_hist, beginning-of-history, 0)
-FN(cls, clear-screen, 0)
-FN(comment, comment, 0)
-FN(comp_comm, complete-command, 0)
-FN(comp_file, complete-file, 0)
-FN(comp_list, complete-list, 0)
-FN(complete, complete, 0)
-FN(del_back, delete-char-backward, XF_ARG)
-FN(del_bword, delete-word-backward, XF_ARG)
-FN(del_char, delete-char-forward, XF_ARG)
-FN(del_fword, delete-word-forward, XF_ARG)
-FN(del_line, kill-line, 0)
-FN(draw_line, redraw, 0)
+F0(abort, "abort", 0)
+FN(beg_hist, "beginning-of-history", 0)
+FN(cls, "clear-screen", 0)
+FN(comment, "comment", 0)
+FN(comp_comm, "complete-command", 0)
+FN(comp_file, "complete-file", 0)
+FN(comp_list, "complete-list", 0)
+FN(complete, "complete", 0)
+FN(del_back, "delete-char-backward", XF_ARG)
+FN(del_bword, "delete-word-backward", XF_ARG)
+FN(del_char, "delete-char-forward", XF_ARG)
+FN(del_fword, "delete-word-forward", XF_ARG)
+FN(del_line, "kill-line", 0)
+FN(draw_line, "redraw", 0)
 #ifndef MKSH_SMALL
-FN(edit_line, edit-line, XF_ARG)
+FN(edit_line, "edit-line", XF_ARG)
 #endif
-FN(end_hist, end-of-history, 0)
-FN(end_of_text, eot, 0)
-FN(enumerate, list, 0)
-FN(eot_del, eot-or-delete, XF_ARG)
-FN(error, error, 0)
-FN(expand, expand-file, 0)
+FN(end_hist, "end-of-history", 0)
+FN(end_of_text, "eot", 0)
+FN(enumerate, "list", 0)
+FN(eot_del, "eot-or-delete", XF_ARG)
+FN(error, "error", 0)
+FN(expand, "expand-file", 0)
 #ifndef MKSH_SMALL
-FN(fold_capitalise, capitalize-word, XF_ARG)
-FN(fold_lower, downcase-word, XF_ARG)
-FN(fold_upper, upcase-word, XF_ARG)
+FN(fold_capitalise, "capitalize-word", XF_ARG)
+FN(fold_lower, "downcase-word", XF_ARG)
+FN(fold_upper, "upcase-word", XF_ARG)
 #endif
-FN(goto_hist, goto-history, XF_ARG)
+FN(goto_hist, "goto-history", XF_ARG)
 #ifndef MKSH_SMALL
-FN(ins_string, macro-string, XF_NOBIND)
+FN(ins_string, "macro-string", XF_NOBIND)
 #endif
-FN(insert, auto-insert, XF_ARG)
-FN(kill, kill-to-eol, XF_ARG)
-FN(kill_region, kill-region, 0)
-FN(list_comm, list-command, 0)
-FN(list_file, list-file, 0)
-FN(literal, quote, 0)
-FN(meta1, prefix-1, XF_PREFIX)
-FN(meta2, prefix-2, XF_PREFIX)
-FN(meta_yank, yank-pop, 0)
-FN(mv_back, backward-char, XF_ARG)
-FN(mv_begin, beginning-of-line, 0)
-FN(mv_bword, backward-word, XF_ARG)
-FN(mv_end, end-of-line, 0)
-FN(mv_forw, forward-char, XF_ARG)
-FN(mv_fword, forward-word, XF_ARG)
-FN(newline, newline, 0)
-FN(next_com, down-history, XF_ARG)
-FN(nl_next_com, newline-and-next, 0)
-FN(noop, no-op, 0)
-FN(prev_com, up-history, XF_ARG)
-FN(prev_histword, prev-hist-word, XF_ARG)
-FN(search_char_back, search-character-backward, XF_ARG)
-FN(search_char_forw, search-character-forward, XF_ARG)
-FN(search_hist, search-history, 0)
+FN(insert, "auto-insert", XF_ARG)
+FN(kill, "kill-to-eol", XF_ARG)
+FN(kill_region, "kill-region", 0)
+FN(list_comm, "list-command", 0)
+FN(list_file, "list-file", 0)
+FN(literal, "quote", 0)
+FN(meta1, "prefix-1", XF_PREFIX)
+FN(meta2, "prefix-2", XF_PREFIX)
+FN(meta_yank, "yank-pop", 0)
+FN(mv_back, "backward-char", XF_ARG)
+FN(mv_begin, "beginning-of-line", 0)
+FN(mv_bword, "backward-word", XF_ARG)
+FN(mv_end, "end-of-line", 0)
+FN(mv_forw, "forward-char", XF_ARG)
+FN(mv_fword, "forward-word", XF_ARG)
+FN(newline, "newline", 0)
+FN(next_com, "down-history", XF_ARG)
+FN(nl_next_com, "newline-and-next", 0)
+FN(noop, "no-op", 0)
+FN(prev_com, "up-history", XF_ARG)
+FN(prev_histword, "prev-hist-word", XF_ARG)
+FN(search_char_back, "search-character-backward", XF_ARG)
+FN(search_char_forw, "search-character-forward", XF_ARG)
+FN(search_hist, "search-history", 0)
 #ifndef MKSH_SMALL
-FN(search_hist_dn, search-history-down, 0)
-FN(search_hist_up, search-history-up, 0)
+FN(search_hist_dn, "search-history-down", 0)
+FN(search_hist_up, "search-history-up", 0)
 #endif
-FN(set_arg, set-arg, XF_NOBIND)
-FN(set_mark, set-mark-command, 0)
-FN(transpose, transpose-chars, 0)
-FN(version, version, 0)
+FN(set_arg, "set-arg", XF_NOBIND)
+FN(set_mark, "set-mark-command", 0)
+FN(transpose, "transpose-chars", 0)
+FN(version, "version", 0)
 #ifndef MKSH_SMALL
-FN(vt_hack, vt100-hack, XF_ARG)
+FN(vt_hack, "vt100-hack", XF_ARG)
 #endif
-FN(xchg_point_mark, exchange-point-and-mark, 0)
-FN(yank, yank, 0)
+FN(xchg_point_mark, "exchange-point-and-mark", 0)
+FN(yank, "yank", 0)
 
 #undef FN
 #undef F0
Index: src/bin/mksh/eval.c
diff -u src/bin/mksh/eval.c:1.83 src/bin/mksh/eval.c:1.93
--- src/bin/mksh/eval.c:1.83	Thu Feb 25 20:18:15 2010
+++ src/bin/mksh/eval.c	Tue Sep 14 21:26:10 2010
@@ -1,4 +1,4 @@
-/*	$OpenBSD: eval.c,v 1.34 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: eval.c,v 1.35 2010/03/24 08:27:26 fgsch Exp $	*/
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.83 2010/02/25 20:18:15 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.93 2010/09/14 21:26:10 tg Exp $");
 
 /*
  * string expansion
@@ -108,7 +108,7 @@
 	s->start = s->str = cp;
 	source = s;
 	if (yylex(ONEWORD) != LWORD)
-		internal_errorf("substitute");
+		internal_errorf("bad substitution");
 	source = sold;
 	afree(s, ATEMP);
 	return (evalstr(yylval.cp, f));
@@ -188,7 +188,8 @@
 	short	stype;		/* [=+-?%#] action after expanded word */
 	short	base;		/* begin position of expanded word */
 	short	f;		/* saved value of f (DOPAT, etc) */
-	short	quote;		/* saved value of quote (for ${..[%#]..}) */
+	uint8_t	quotep;		/* saved value of quote (for ${..[%#]..}) */
+	uint8_t	quotew;		/* saved value of quote (for ${..[+-=]..}) */
 } SubType;
 
 void
@@ -263,7 +264,7 @@
 				quote = 1;
 				continue;
 			case CQUOTE:
-				quote = st->quote;	/* XXX correct? */
+				quote = st->quotew;
 				continue;
 			case COMSUB:
 				tilde_ok = 0;
@@ -333,7 +334,7 @@
 						*end = EOS;
 					str = snptreef(NULL, 64, "%S", beg);
 					afree(beg, ATEMP);
-					errorf("%s: bad substitution", str);
+					errorf("%s: %s", str, "bad substitution");
 				}
 				if (f & DOBLANK)
 					doblank++;
@@ -352,7 +353,7 @@
 					st->base = Xsavepos(ds, dp);
 					st->f = f;
 					st->var = x.var;
-					st->quote = quote;
+					st->quotew = st->quotep = quote;
 					/* skip qualifier(s) */
 					if (stype)
 						sp += slen;
@@ -517,7 +518,7 @@
 						/* ! DOBLANK,DOBRACE_,DOTILDE */
 						f = DOPAT | (f&DONTRUNCOMMAND) |
 						    DOTEMP_;
-						quote = 0;
+						st->quotew = quote = 0;
 						/* Prepend open pattern (so |
 						 * in a trim will work as
 						 * expected)
@@ -567,7 +568,7 @@
 				sp++; /* ({) skip the } or x */
 				tilde_ok = 0;	/* in case of ${unset:-} */
 				*dp = '\0';
-				quote = st->quote;
+				quote = st->quotep;
 				f = st->f;
 				if (f&DOBLANK)
 					doblank--;
@@ -583,7 +584,10 @@
 					 */
 					x.str = trimsub(str_val(st->var),
 						dp, st->stype);
-					type = strlen(x.str) ? XSUB : XNULLSUB;
+					if (x.str[0] != '\0' || st->quotep)
+						type = XSUB;
+					else
+						type = XNULLSUB;
 					if (f&DOBLANK)
 						doblank++;
 					st = st->prev;
@@ -970,7 +974,7 @@
 			}
 		}
 		if (Flag(FNOUNSET) && c == 0 && !zero_ok)
-			errorf("%s: parameter not set", sp);
+			errorf("%s: %s", sp, "parameter not set");
 		*stypep = 0; /* unqualified variable/string substitution */
 		xp->str = shf_smprintf("%d", c);
 		return (XSUB);
@@ -1016,6 +1020,8 @@
 		case '=':	/* can't assign to a vector */
 		case '%':	/* can't trim a vector (yet) */
 		case '#':
+		case '0':
+		case '/':
 			return (-1);
 		}
 		if (e->loc->argc == 0) {
@@ -1039,6 +1045,8 @@
 			case '%':	/* can't trim a vector (yet) */
 			case '#':
 			case '?':
+			case '0':
+			case '/':
 				return (-1);
 			}
 			XPinit(wv, 32);
@@ -1097,7 +1105,7 @@
 		state = XBASE;	/* expand word instead of variable value */
 	if (Flag(FNOUNSET) && xp->str == null && !zero_ok &&
 	    (ctype(c, C_SUBOP2) || (state != XBASE && c != '+')))
-		errorf("%s: parameter not set", sp);
+		errorf("%s: %s", sp, "parameter not set");
 	return (state);
 }
 
@@ -1126,13 +1134,13 @@
 		struct ioword *io = *t->ioact;
 		char *name;
 
-		if ((io->flag&IOTYPE) != IOREAD)
-			errorf("funny $() command: %s",
+		if ((io->flag & IOTYPE) != IOREAD)
+			errorf("%s: %s", "funny $() command",
 			    snptreef(NULL, 32, "%R", io));
 		shf = shf_open(name = evalstr(io->name, DOTILDE), O_RDONLY, 0,
 			SHF_MAPHI|SHF_CLEXEC);
 		if (shf == NULL)
-			errorf("%s: cannot open $() input", name);
+			errorf("%s: %s %s", name, "can't open", "$() input");
 		xp->split = 0;	/* no waitlast() */
 	} else {
 		int ofd1, pv[2];
@@ -1551,19 +1559,23 @@
 				count++;
 			else if ((*p == CBRACE && --count == 0) ||
 			    (*p == ',' && count == 1)) {
-				char *new;
+				char *news;
 				int l1, l2, l3;
 
+				/*
+				 * addition safe since these operate on
+				 * one string (separate substrings)
+				 */
 				l1 = brace_start - start;
 				l2 = (p - 1) - field_start;
 				l3 = end - brace_end;
-				new = alloc(l1 + l2 + l3 + 1, ATEMP);
-				memcpy(new, start, l1);
-				memcpy(new + l1, field_start, l2);
-				memcpy(new + l1 + l2, brace_end, l3);
-				new[l1 + l2 + l3] = '\0';
-				alt_expand(wp, new, new + l1,
-				    new + l1 + l2 + l3, fdo);
+				news = alloc(l1 + l2 + l3 + 1, ATEMP);
+				memcpy(news, start, l1);
+				memcpy(news + l1, field_start, l2);
+				memcpy(news + l1 + l2, brace_end, l3);
+				news[l1 + l2 + l3] = '\0';
+				alt_expand(wp, news, news + l1,
+				    news + l1 + l2 + l3, fdo);
 				field_start = p + 1;
 			}
 		}
Index: src/bin/mksh/exec.c
diff -u src/bin/mksh/exec.c:1.72 src/bin/mksh/exec.c:1.83
--- src/bin/mksh/exec.c:1.72	Sat Dec 12 22:27:06 2009
+++ src/bin/mksh/exec.c	Wed Sep 15 21:08:17 2010
@@ -1,7 +1,7 @@
 /*	$OpenBSD: exec.c,v 1.49 2009/01/29 23:27:26 jaredy Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,7 +22,11 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.72 2009/12/12 22:27:06 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.83 2010/09/15 21:08:17 tg Exp $");
+
+#ifndef MKSH_DEFAULT_EXECSHELL
+#define MKSH_DEFAULT_EXECSHELL	"/bin/sh"
+#endif
 
 static int comexec(struct op *, struct tbl *volatile, const char **,
     int volatile, volatile int *);
@@ -31,7 +35,7 @@
 static int iosetup(struct ioword *, struct tbl *);
 static int herein(const char *, int);
 static const char *do_selectargs(const char **, bool);
-static int dbteste_isa(Test_env *, Test_meta);
+static Test_op dbteste_isa(Test_env *, Test_meta);
 static const char *dbteste_getopnd(Test_env *, Test_op, bool);
 static void dbteste_error(Test_env *, int, const char *);
 
@@ -84,8 +88,8 @@
 			timex_hook(t, &up);
 		ap = (const char **)up;
 		if (Flag(FXTRACE) && ap[0]) {
-			shf_fprintf(shl_out, "%s",
-				substitute(str_val(global("PS4")), 0));
+			shf_puts(substitute(str_val(global("PS4")), 0),
+			    shl_out);
 			for (i = 0; ap[i]; i++)
 				shf_fprintf(shl_out, "%s%c", ap[i],
 				    ap[i + 1] ? ' ' : '\n');
@@ -97,7 +101,7 @@
 	flags &= ~XTIME;
 
 	if (t->ioact != NULL || t->type == TPIPE || t->type == TCOPROC) {
-		e->savefd = alloc(NUFILE * sizeof(short), ATEMP);
+		e->savefd = alloc2(NUFILE, sizeof(short), ATEMP);
 		/* initialise to not redirected */
 		memset(e->savefd, 0, NUFILE * sizeof(short));
 	}
@@ -408,6 +412,7 @@
 	int keepasn_ok;
 	int fcflags = FC_BI|FC_FUNC|FC_PATH;
 	bool bourne_function_call = false;
+	struct block *l_expand, *l_assign;
 
 	/* snag the last argument for $_ XXX not the same as AT&T ksh,
 	 * which only seems to set $_ after a newline (but not in
@@ -436,15 +441,16 @@
 	 */
 	keepasn_ok = 1;
 	while (tp && tp->type == CSHELL) {
-		fcflags = FC_BI|FC_FUNC|FC_PATH;/* undo effects of command */
+		/* undo effects of command */
+		fcflags = FC_BI|FC_FUNC|FC_PATH;
 		if (tp->val.f == c_builtin) {
-			if ((cp = *++ap) == NULL) {
+			if ((cp = *++ap) == NULL ||
+			    (!strcmp(cp, "--") && (cp = *++ap) == NULL)) {
 				tp = NULL;
 				break;
 			}
-			tp = findcom(cp, FC_BI);
-			if (tp == NULL)
-				errorf("builtin: %s: not a builtin", cp);
+			if ((tp = findcom(cp, FC_BI)) == NULL)
+				errorf("%s: %s: %s", T_builtin, cp, "not a builtin");
 			continue;
 		} else if (tp->val.f == c_exec) {
 			if (ap[1] == NULL)
@@ -466,8 +472,8 @@
 			fcflags = FC_BI|FC_PATH;
 			if (saw_p) {
 				if (Flag(FRESTRICTED)) {
-					warningf(true,
-					    "command -p: restricted");
+					warningf(true, "%s: %s",
+					    "command -p", "restricted");
 					rv = 1;
 					goto Leave;
 				}
@@ -483,10 +489,26 @@
 				subst_exstat = 0;
 				break;
 			}
+		} else if (tp->val.f == c_cat) {
+			/*
+			 * if we have any flags, do not use the builtin
+			 * in theory, we could allow -u, but that would
+			 * mean to use ksh_getopt here and possibly ad-
+			 * ded complexity and more code and isn't worth
+			 */
+			if (ap[1] && ap[1][0] == '-' && ap[1][1] != '\0' &&
+			    /* argument, begins with -, is not - or -- */
+			    (ap[1][1] != '-' || ap[1][2] != '\0'))
+				/* don't look for builtins or functions */
+				fcflags = FC_PATH;
+			else
+				/* go on, use the builtin */
+				break;
 		} else
 			break;
 		tp = findcom(ap[0], fcflags & (FC_BI|FC_FUNC));
 	}
+	l_expand = e->loc;
 	if (keepasn_ok && (!ap[0] || (tp && (tp->flag & KEEPASN))))
 		type_flags = 0;
 	else {
@@ -500,14 +522,20 @@
 		} else
 			type_flags = LOCAL|LOCAL_COPY|EXPORT;
 	}
+	l_assign = e->loc;
 	if (Flag(FEXPORT))
 		type_flags |= EXPORT;
 	for (i = 0; t->vars[i]; i++) {
+		/* do NOT lookup in the new var/fn block just created */
+		e->loc = l_expand;
 		cp = evalstr(t->vars[i], DOASNTILDE);
+		e->loc = l_assign;
+		/* but assign in there as usual */
+
 		if (Flag(FXTRACE)) {
 			if (i == 0)
-				shf_fprintf(shl_out, "%s",
-					substitute(str_val(global("PS4")), 0));
+				shf_puts(substitute(str_val(global("PS4")), 0),
+				    shl_out);
 			shf_fprintf(shl_out, "%s%c", cp,
 			    t->vars[i + 1] ? ' ' : '\n');
 			if (!t->vars[i + 1])
@@ -523,7 +551,7 @@
 		goto Leave;
 	} else if (!tp) {
 		if (Flag(FRESTRICTED) && vstrchr(cp, '/')) {
-			warningf(true, "%s: restricted", cp);
+			warningf(true, "%s: %s", cp, "restricted");
 			rv = 1;
 			goto Leave;
 		}
@@ -545,32 +573,31 @@
 
 			if (!tp->u.fpath) {
 				if (tp->u2.errno_) {
-					warningf(true,
-					    "%s: can't find function "
-					    "definition file - %s",
-					    cp, strerror(tp->u2.errno_));
+					warningf(true, "%s: %s %s: %s", cp,
+					    "can't find",
+					    "function definition file",
+					    strerror(tp->u2.errno_));
 					rv = 126;
 				} else {
-					warningf(true,
-					    "%s: can't find function "
-					    "definition file", cp);
+					warningf(true, "%s: %s %s", cp,
+					    "can't find",
+					    "function definition file");
 					rv = 127;
 				}
 				break;
 			}
 			if (include(tp->u.fpath, 0, NULL, 0) < 0) {
 				rv = errno;
-				warningf(true,
-				    "%s: can't open function definition file %s - %s",
-				    cp, tp->u.fpath, strerror(rv));
+				warningf(true, "%s: %s %s %s: %s", cp,
+				    "can't open", "function definition file",
+				    tp->u.fpath, strerror(rv));
 				rv = 127;
 				break;
 			}
 			if (!(ftp = findfunc(cp, hash(cp), false)) ||
 			    !(ftp->flag & ISSET)) {
-				warningf(true,
-				    "%s: function not defined by %s",
-				    cp, tp->u.fpath);
+				warningf(true, "%s: %s %s", cp,
+				    "function not defined by", tp->u.fpath);
 				rv = 127;
 				break;
 			}
@@ -639,7 +666,7 @@
 			/* NOTREACHED */
 		default:
 			quitenv(NULL);
-			internal_errorf("CFUNC %d", i);
+			internal_errorf("%s %d", "CFUNC", i);
 		}
 		break;
 	}
@@ -653,11 +680,11 @@
 			 * useful error message and set the exit status to 126.
 			 */
 			if (tp->u2.errno_) {
-				warningf(true, "%s: cannot execute - %s", cp,
-				    strerror(tp->u2.errno_));
+				warningf(true, "%s: %s: %s", cp,
+				    "can't execute", strerror(tp->u2.errno_));
 				rv = 126;	/* POSIX */
 			} else {
-				warningf(true, "%s: not found", cp);
+				warningf(true, "%s: %s", cp, "not found");
 				rv = 127;
 			}
 			break;
@@ -711,7 +738,7 @@
 	if (sh && *sh)
 		sh = search(sh, path, X_OK, NULL);
 	if (!sh || !*sh)
-		sh = "/bin/sh";
+		sh = MKSH_DEFAULT_EXECSHELL;
 
 	*tp->args-- = tp->str;
 
@@ -794,7 +821,7 @@
 
 	tp = ktsearch(&builtins, *wp, hash(*wp));
 	if (tp == NULL)
-		internal_errorf("shcomexec: %s", *wp);
+		internal_errorf("%s: %s", "shcomexec", *wp);
 	return (call_builtin(tp, wp));
 }
 
@@ -1082,11 +1109,11 @@
 	builtin_argv0 = wp[0];
 	builtin_flag = tp->flag;
 	shf_reopen(1, SHF_WR, shl_stdout);
-	shl_stdout_ok = 1;
+	shl_stdout_ok = true;
 	ksh_getopt_reset(&builtin_opt, GF_ERROR);
 	rv = (*tp->val.f)(wp);
 	shf_flush(shl_stdout);
-	shl_stdout_ok = 0;
+	shl_stdout_ok = false;
 	builtin_flag = 0;
 	builtin_argv0 = NULL;
 	return (rv);
@@ -1170,7 +1197,7 @@
 
 	if (do_open) {
 		if (Flag(FRESTRICTED) && (flags & O_CREAT)) {
-			warningf(true, "%s: restricted", cp);
+			warningf(true, "%s: %s", cp, "restricted");
 			return (-1);
 		}
 		u = open(cp, flags, 0666);
@@ -1179,7 +1206,7 @@
 		/* herein() may already have printed message */
 		if (u == -1) {
 			u = errno;
-			warningf(true, "cannot %s %s: %s",
+			warningf(true, "can't %s %s: %s",
 			    iotype == IODUP ? "dup" :
 			    (iotype == IOREAD || iotype == IOHERE) ?
 			    "open" : "create", cp, strerror(u));
@@ -1208,8 +1235,8 @@
 			int ev;
 
 			ev = errno;
-			warningf(true,
-			    "could not finish (dup) redirection %s: %s",
+			warningf(true, "%s %s %s",
+			    "can't finish (dup) redirection",
 			    snptreef(NULL, 32, "%R", &iotmp),
 			    strerror(ev));
 			if (iotype != IODUP)
@@ -1248,7 +1275,7 @@
 
 	/* ksh -c 'cat << EOF' can cause this... */
 	if (content == NULL) {
-		warningf(true, "here document missing");
+		warningf(true, "%s missing", "here document");
 		return (-2); /* special to iosetup(): don't print error */
 	}
 
@@ -1281,7 +1308,7 @@
 		s->start = s->str = content;
 		source = s;
 		if (yylex(ONEWORD|HEREDOC) != LWORD)
-			internal_errorf("herein: yylex");
+			internal_errorf("%s: %s", "herein", "yylex");
 		source = osource;
 		shf_puts(evalstr(yylval.cp, 0), shf);
 	} else
@@ -1292,9 +1319,7 @@
 	if (shf_close(shf) == EOF) {
 		i = errno;
 		close(fd);
-		fd = errno;
-		warningf(true, "error writing %s: %s, %s", h->name,
-		    strerror(i), strerror(fd));
+		warningf(true, "%s: %s: %s", "write", h->name, strerror(i));
 		return (-2);	/* special to iosetup(): don't print error */
 	}
 
@@ -1405,7 +1430,7 @@
 static char *
 plain_fmt_entry(char *buf, int buflen, int i, const void *arg)
 {
-	shf_snprintf(buf, buflen, "%s", ((const char * const *)arg)[i]);
+	strlcpy(buf, ((const char * const *)arg)[i], buflen);
 	return (buf);
 }
 
@@ -1434,19 +1459,20 @@
  *	[[ ... ]] evaluation routines
  */
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 dbteste_isa(Test_env *te, Test_meta meta)
 {
-	int ret = 0;
+	Test_op ret = TO_NONOP;
 	int uqword;
 	const char *p;
 
 	if (!*te->pos.wp)
-		return (meta == TM_END);
+		return (meta == TM_END ? TO_NONNULL : TO_NONOP);
 
 	/* unquoted word? */
 	for (p = *te->pos.wp; *p == CHAR; p += 2)
@@ -1464,13 +1490,13 @@
 			ret = test_isop(meta, buf);
 		}
 	} else if (meta == TM_END)
-		ret = 0;
+		ret = TO_NONOP;
 	else
-		ret = uqword &&
-		    strcmp(*te->pos.wp, dbtest_tokens[(int) meta]) == 0;
+		ret = (uqword && !strcmp(*te->pos.wp,
+		    dbtest_tokens[(int)meta])) ? TO_NONNULL : TO_NONOP;
 
 	/* Accept the token? */
-	if (ret)
+	if (ret != TO_NONOP)
 		te->pos.wp++;
 
 	return (ret);
Index: src/bin/mksh/expr.c
diff -u src/bin/mksh/expr.c:1.43 src/bin/mksh/expr.c:1.45
--- src/bin/mksh/expr.c:1.43	Mon Jan 25 14:38:00 2010
+++ src/bin/mksh/expr.c	Sat Aug 28 18:50:50 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.43 2010/01/25 14:38:00 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.45 2010/08/28 18:50:50 tg Exp $");
 
 /* The order of these enums is constrained by the order of opinfo[] */
 enum token {
@@ -269,26 +269,28 @@
 		default:
 			s = opinfo[(int)es->tok].name;
 		}
-		warningf(true, "%s: unexpected '%s'", es->expression, s);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "unexpected", s);
 		break;
 
 	case ET_BADLIT:
-		warningf(true, "%s: bad number '%s'", es->expression, str);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "bad number", str);
 		break;
 
 	case ET_RECURSIVE:
-		warningf(true, "%s: expression recurses on parameter '%s'",
-		    es->expression, str);
+		warningf(true, "%s: %s '%s'", es->expression,
+		    "expression recurses on parameter", str);
 		break;
 
 	case ET_LVALUE:
-		warningf(true, "%s: %s requires lvalue",
-		    es->expression, str);
+		warningf(true, "%s: %s %s",
+		    es->expression, str, "requires lvalue");
 		break;
 
 	case ET_RDONLY:
-		warningf(true, "%s: %s applied to read only variable",
-		    es->expression, str);
+		warningf(true, "%s: %s %s",
+		    es->expression, str, "applied to read only variable");
 		break;
 
 	default: /* keep gcc happy */
@@ -798,6 +800,7 @@
 }
 
 
+#ifndef MKSH_mirbsd_wcwidth
 /* --- begin of wcwidth.c excerpt --- */
 /*-
  * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
@@ -891,3 +894,4 @@
 	    (c >= 0xffe0 && c <= 0xffe6))) ? 2 : 1);
 }
 /* --- end of wcwidth.c excerpt --- */
+#endif
Index: src/bin/mksh/funcs.c
diff -u src/bin/mksh/funcs.c:1.151 src/bin/mksh/funcs.c:1.163
--- src/bin/mksh/funcs.c:1.151	Tue Feb 23 18:13:03 2010
+++ src/bin/mksh/funcs.c	Wed Sep 15 21:08:18 2010
@@ -1,5 +1,5 @@
 /*	$OpenBSD: c_ksh.c,v 1.33 2009/02/07 14:03:24 kili Exp $	*/
-/*	$OpenBSD: c_sh.c,v 1.40 2009/05/05 17:59:55 millert Exp $	*/
+/*	$OpenBSD: c_sh.c,v 1.41 2010/03/27 09:10:01 jmc Exp $	*/
 /*	$OpenBSD: c_test.c,v 1.18 2009/03/01 20:11:06 otto Exp $	*/
 /*	$OpenBSD: c_ulimit.c,v 1.17 2008/03/21 12:51:19 millert Exp $	*/
 
@@ -25,7 +25,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.151 2010/02/23 18:13:03 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.163 2010/09/15 21:08:18 tg Exp $");
 
 #if HAVE_KILLPG
 /*
@@ -59,14 +59,14 @@
 	{"*=:", c_label},
 	{"[", c_test},
 	{"*=break", c_brkcont},
-	{"=builtin", c_builtin},
+	{T_gbuiltin, c_builtin},
 	{"*=continue", c_brkcont},
 	{"*=eval", c_eval},
 	{"*=exec", c_exec},
 	{"*=exit", c_exitreturn},
 	{"+false", c_label},
 	{"*=return", c_exitreturn},
-	{"*=set", c_set},
+	{T_sgset, c_set},
 	{"*=shift", c_shift},
 	{"=times", c_times},
 	{"*=trap", c_trap},
@@ -77,7 +77,7 @@
 	{"ulimit", c_ulimit},
 	{"+umask", c_umask},
 	{"*=unset", c_unset},
-	{"+alias", c_alias},	/* no =: AT&T manual wrong */
+	{T_palias, c_alias},	/* no =: AT&T manual wrong */
 	{"+cd", c_cd},
 	{"chdir", c_cd},	/* dash compatibility hack */
 	{"+command", c_command},
@@ -95,13 +95,14 @@
 	{"pwd", c_pwd},
 	{"*=readonly", c_typeset},
 	{T__typeset, c_typeset},
-	{"+unalias", c_unalias},
+	{T_punalias, c_unalias},
 	{"whence", c_whence},
 #ifndef MKSH_UNEMPLOYED
 	{"+bg", c_fgbg},
 	{"+fg", c_fgbg},
 #endif
 	{"bind", c_bind},
+	{"cat", c_cat},
 #if HAVE_MKNOD
 	{"mknod", c_mknod},
 #endif
@@ -168,7 +169,7 @@
 static int test_aexpr(Test_env *, bool);
 static int test_nexpr(Test_env *, bool);
 static int test_primary(Test_env *, bool);
-static int ptest_isa(Test_env *, Test_meta);
+static Test_op ptest_isa(Test_env *, Test_meta);
 static const char *ptest_getopnd(Test_env *, Test_op, bool);
 static void ptest_error(Test_env *, int, const char *);
 static char *kill_fmt_entry(char *, int, int, const void *);
@@ -187,6 +188,14 @@
 	int symlinks = 32;	/* max. recursion depth */
 	int llen;
 	struct stat sb;
+#ifdef NO_PATH_MAX
+	size_t ldestlen = 0;
+#define pathlen sb.st_size
+#define pathcnd (ldestlen < (pathlen + 1))
+#else
+#define pathlen PATH_MAX
+#define pathcnd (!ldest)
+#endif
 
 	if (upath[0] == '/') {
 		/* upath is an absolute pathname */
@@ -195,10 +204,11 @@
 		/* upath is a relative pathname, prepend cwd */
 		if ((tp = ksh_get_wd(NULL)) == NULL || tp[0] != '/')
 			return (NULL);
-		ipath = shf_smprintf("%s/%s", tp, upath);
+		ipath = shf_smprintf("%s%s%s", tp, "/", upath);
 		afree(tp, ATEMP);
 	}
 
+	/* ipath and upath are in memory at the same time -> unchecked */
 	Xinit(xs, xp, strlen(ip = ipath) + 1, ATEMP);
 
 	while (*ip) {
@@ -231,11 +241,11 @@
 
 		/* store output position away, then append slash to output */
 		pos = Xsavepos(xs, xp);
-		Xcheck(xs, xp);
+		/* 1 for the '/' and len + 1 for tp and the NUL from below */
+		XcheckN(xs, xp, 1 + len + 1);
 		Xput(xs, xp, '/');
 
 		/* append next pathname component to output */
-		XcheckN(xs, xp, len + 1);
 		memcpy(xp, tp, len);
 		xp += len;
 		*xp = '\0';
@@ -268,29 +278,19 @@
 			}
 
 			/* get symlink(7) target */
+			if (pathcnd) {
 #ifdef NO_PATH_MAX
-			if (ldest) {
-				afree(ldest, ATEMP);
-				ldest = NULL;
-			}
-			{
-				struct stat hurd_sb;
-
-				if (lstat(Xstring(xs, xp), &hurd_sb))
-					goto notfound;
-				ldest = alloc(hurd_sb.st_size + 1, ATEMP);
-				if ((llen = readlink(Xstring(xs, xp), ldest,
-				    hurd_sb.st_size)) < 0)
+				if (notoktoadd(pathlen, 1)) {
+					errno = ENAMETOOLONG;
 					goto notfound;
+				}
+#endif
+				ldest = aresize(ldest, pathlen + 1, ATEMP);
 			}
-#else
-			if (!ldest)
-				ldest = alloc(PATH_MAX + 1, ATEMP);
-			if ((llen = readlink(Xstring(xs, xp), ldest,
-			    PATH_MAX)) < 0)
+			llen = readlink(Xstring(xs, xp), ldest, pathlen);
+			if (llen < 0)
 				/* oops... */
 				goto notfound;
-#endif
 			ldest[llen] = '\0';
 
 			/*
@@ -299,7 +299,7 @@
 			 */
 			xp = (ldest[0] == '/') ? Xstring(xs, xp) :
 			    Xrestpos(xs, xp, pos);
-			tp = shf_smprintf("%s/%s", ldest, ip);
+			tp = shf_smprintf("%s%s%s", ldest, *ip ? "/" : "", ip);
 			afree(ipath, ATEMP);
 			ip = ipath = tp;
 		}
@@ -318,6 +318,22 @@
 		Xput(xs, xp, '/');
 	Xput(xs, xp, '\0');
 
+	/*
+	 * if source path had a trailing slash, check if target path
+	 * is not a non-directory existing file
+	 */
+	if (ip > ipath && ip[-1] == '/') {
+		if (stat(Xstring(xs, xp), &sb)) {
+			if (errno != ENOENT)
+				goto notfound;
+		} else if (!S_ISDIR(sb.st_mode)) {
+			errno = ENOTDIR;
+			goto notfound;
+		}
+		/* target now either does not exist or is a directory */
+	}
+
+	/* return target path */
 	if (ldest != NULL)
 		afree(ldest, ATEMP);
 	afree(ipath, ATEMP);
@@ -331,6 +347,9 @@
 	Xfree(xs, xp);
 	errno = llen;
 	return (NULL);
+
+#undef pathlen
+#undef pathcnd
 }
 
 int
@@ -342,7 +361,7 @@
 	bool printpath = false;		/* print where we cd'd? */
 	struct tbl *pwd_s, *oldpwd_s;
 	XString xs;
-	char *dir, *allocd = NULL, *try, *pwd, *cdpath;
+	char *dir, *allocd = NULL, *tryp, *pwd, *cdpath;
 
 	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
 		switch (optc) {
@@ -386,11 +405,11 @@
 		}
 	} else if (!wp[2]) {
 		/* Two arguments - substitute arg1 in PWD for arg2 */
-		int ilen, olen, nlen, elen;
+		size_t ilen, olen, nlen, elen;
 		char *cp;
 
 		if (!current_wd[0]) {
-			bi_errorf("don't know current directory");
+			bi_errorf("can't determine current directory");
 			return (1);
 		}
 		/* substitute arg1 for arg2 in current path.
@@ -402,6 +421,12 @@
 			bi_errorf("bad substitution");
 			return (1);
 		}
+		/*-
+		 * ilen = part of current_wd before wp[0]
+		 * elen = part of current_wd after wp[0]
+		 * because current_wd and wp[1] need to be in memory at the
+		 * same time beforehand the addition can stay unchecked
+		 */
 		ilen = cp - current_wd;
 		olen = strlen(wp[0]);
 		nlen = strlen(wp[1]);
@@ -427,18 +452,18 @@
 	do {
 		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
 		if (physical)
-			rv = chdir(try = Xstring(xs, xp) + phys_path);
+			rv = chdir(tryp = Xstring(xs, xp) + phys_path);
 		else {
 			simplify_path(Xstring(xs, xp));
-			rv = chdir(try = Xstring(xs, xp));
+			rv = chdir(tryp = Xstring(xs, xp));
 		}
 	} while (rv < 0 && cdpath != NULL);
 
 	if (rv < 0) {
 		if (cdnode)
-			bi_errorf("%s: bad directory", dir);
+			bi_errorf("%s: %s", dir, "bad directory");
 		else
-			bi_errorf("%s - %s", try, strerror(errno));
+			bi_errorf("%s: %s", tryp, strerror(errno));
 		afree(allocd, ATEMP);
 		return (1);
 	}
@@ -510,7 +535,8 @@
 	if (p && access(p, R_OK) < 0)
 		p = NULL;
 	if (!p && !(p = allocd = ksh_get_wd(NULL))) {
-		bi_errorf("can't get current directory - %s", strerror(errno));
+		bi_errorf("%s: %s", "can't determine current directory",
+		    strerror(errno));
 		return (1);
 	}
 	shprintf("%s\n", p);
@@ -602,7 +628,7 @@
 				break;
 			case 'p':
 				if ((fd = coproc_getfd(W_OK, &emsg)) < 0) {
-					bi_errorf("-p: %s", emsg);
+					bi_errorf("%s: %s", "-p", emsg);
 					return (1);
 				}
 				break;
@@ -616,7 +642,7 @@
 				if (!*(s = builtin_opt.optarg))
 					fd = 0;
 				else if ((fd = check_fd(s, W_OK, &emsg)) < 0) {
-					bi_errorf("-u: %s: %s", s, emsg);
+					bi_errorf("%s: %s: %s", "-u", s, emsg);
 					return (1);
 				}
 				break;
@@ -785,22 +811,32 @@
 		if (vflag || (tp->type != CALIAS && tp->type != CEXEC &&
 		    tp->type != CTALIAS))
 			shf_puts(id, shl_stdout);
+		if (vflag)
+			switch (tp->type) {
+			case CKEYWD:
+			case CALIAS:
+			case CFUNC:
+			case CSHELL:
+				shf_puts(" is a", shl_stdout);
+				break;
+			}
+
 		switch (tp->type) {
 		case CKEYWD:
 			if (vflag)
-				shf_puts(" is a reserved word", shl_stdout);
+				shf_puts(" reserved word", shl_stdout);
 			break;
 		case CALIAS:
 			if (vflag)
-				shprintf(" is an %salias for ",
-				    (tp->flag & EXPORT) ? "exported " : null);
+				shprintf("n %s%s for ",
+				    (tp->flag & EXPORT) ? "exported " : null,
+				    T_alias);
 			if (!iam_whence && !vflag)
-				shprintf("alias %s=", id);
+				shprintf("%s %s=", T_alias, id);
 			print_value_quoted(tp->val.s);
 			break;
 		case CFUNC:
 			if (vflag) {
-				shf_puts(" is a", shl_stdout);
 				if (tp->flag & EXPORT)
 					shf_puts("n exported", shl_stdout);
 				if (tp->flag & TRACE)
@@ -811,13 +847,14 @@
 						shprintf(" (autoload from %s)",
 						    tp->u.fpath);
 				}
-				shf_puts(" function", shl_stdout);
+				shf_puts(T__function, shl_stdout);
 			}
 			break;
 		case CSHELL:
 			if (vflag)
-				shprintf(" is a%s shell builtin",
-				    (tp->flag & SPEC_BI) ? " special" : null);
+				shprintf("%s %s %s",
+				    (tp->flag & SPEC_BI) ? " special" : null,
+				    "shell", T_builtin);
 			break;
 		case CTALIAS:
 		case CEXEC:
@@ -825,14 +862,15 @@
 				if (vflag) {
 					shf_puts(" is ", shl_stdout);
 					if (tp->type == CTALIAS)
-						shprintf("a tracked %salias for ",
+						shprintf("a tracked %s%s for ",
 						    (tp->flag & EXPORT) ?
-						    "exported " : null);
+						    "exported " : null,
+						    T_alias);
 				}
 				shf_puts(tp->val.s, shl_stdout);
 			} else {
 				if (vflag)
-					shf_puts(" not found", shl_stdout);
+					shprintf(" %s\n", "not found");
 				rv = 1;
 			}
 			break;
@@ -1034,13 +1072,13 @@
 				if (fset | fclr) {
 					f->flag |= fset;
 					f->flag &= ~fclr;
-				} else
-					fptreef(shl_stdout, 0,
-					    f->flag & FKSH ?
-					    "function %s %T\n" :
-					    "%s() %T\n", wp[i], f->val.t);
+				} else {
+					fpFUNCTf(shl_stdout, 0, f->flag & FKSH,
+					    wp[i], f->val.t);
+					shf_putc('\n', shl_stdout);
+				}
 			} else if (!typeset(wp[i], fset, fclr, field, base)) {
-				bi_errorf("%s: not identifier", wp[i]);
+				bi_errorf("%s: %s", wp[i], "not identifier");
 				set_refflag = 0;
 				return (1);
 			}
@@ -1057,11 +1095,12 @@
 				if (flag && (vp->flag & flag) == 0)
 					continue;
 				if (thing == '-')
-					fptreef(shl_stdout, 0, vp->flag & FKSH ?
-					    "function %s %T\n" : "%s() %T\n",
+					fpFUNCTf(shl_stdout, 0,
+					    vp->flag & FKSH,
 					    vp->name, vp->val.t);
 				else
-					shprintf("%s\n", vp->name);
+					shf_puts(vp->name, shl_stdout);
+				shf_putc('\n', shl_stdout);
 			}
 		}
 	} else {
@@ -1109,27 +1148,27 @@
 						 */
 						shf_puts("typeset ", shl_stdout);
 						if (((vp->flag&(ARRAY|ASSOC))==ASSOC))
-							shf_puts("-n ", shl_stdout);
+							shprintf("%s ", "-n");
 						if ((vp->flag&INTEGER))
-							shf_puts("-i ", shl_stdout);
+							shprintf("%s ", "-i");
 						if ((vp->flag&EXPORT))
-							shf_puts("-x ", shl_stdout);
+							shprintf("%s ", "-x");
 						if ((vp->flag&RDONLY))
-							shf_puts("-r ", shl_stdout);
+							shprintf("%s ", "-r");
 						if ((vp->flag&TRACE))
-							shf_puts("-t ", shl_stdout);
+							shprintf("%s ", "-t");
 						if ((vp->flag&LJUST))
 							shprintf("-L%d ", vp->u2.field);
 						if ((vp->flag&RJUST))
 							shprintf("-R%d ", vp->u2.field);
 						if ((vp->flag&ZEROFIL))
-							shf_puts("-Z ", shl_stdout);
+							shprintf("%s ", "-Z");
 						if ((vp->flag&LCASEV))
-							shf_puts("-l ", shl_stdout);
+							shprintf("%s ", "-l");
 						if ((vp->flag&UCASEV_AL))
-							shf_puts("-u ", shl_stdout);
+							shprintf("%s ", "-u");
 						if ((vp->flag&INT_U))
-							shf_puts("-U ", shl_stdout);
+							shprintf("%s ", "-U");
 						shf_puts(vp->name, shl_stdout);
 						if (pflag) {
 							char *s = str_val(vp);
@@ -1248,12 +1287,12 @@
 	/* "hash -r" means reset all the tracked aliases.. */
 	if (rflag) {
 		static const char *args[] = {
-			"unalias", "-ta", NULL
+			T_unalias, "-ta", NULL
 		};
 
 		if (!tflag || *wp) {
-			shf_puts("alias: -r flag can only be used with -t"
-			    " and without arguments\n", shl_stdout);
+			shprintf("%s: -r flag can only be used with -t"
+			    " and without arguments\n", T_alias);
 			return (1);
 		}
 		ksh_getopt_reset(&builtin_opt, GF_ERROR);
@@ -1266,7 +1305,7 @@
 		for (p = ktsort(t); (ap = *p++) != NULL; )
 			if ((ap->flag & (ISSET|xflag)) == (ISSET|xflag)) {
 				if (pflag)
-					shf_puts("alias ", shl_stdout);
+					shprintf("%s ", T_alias);
 				shf_puts(ap->name, shl_stdout);
 				if (prefix != '+') {
 					shf_putc('=', shl_stdout);
@@ -1291,7 +1330,7 @@
 			ap = ktsearch(t, alias, h);
 			if (ap != NULL && (ap->flag&ISSET)) {
 				if (pflag)
-					shf_puts("alias ", shl_stdout);
+					shprintf("%s ", T_alias);
 				shf_puts(ap->name, shl_stdout);
 				if (prefix != '+') {
 					shf_putc('=', shl_stdout);
@@ -1299,7 +1338,8 @@
 				}
 				shf_putc('\n', shl_stdout);
 			} else {
-				shprintf("%s alias not found\n", alias);
+				shprintf("%s %s %s\n", alias, T_alias,
+				    "not found");
 				rv = 1;
 			}
 			continue;
@@ -1572,8 +1612,8 @@
 			if (j_kill(p, sig))
 				rv = 1;
 		} else if (!getn(p, &n)) {
-			bi_errorf("%s: arguments must be jobs or process IDs",
-			    p);
+			bi_errorf("%s: %s", p,
+			    "arguments must be jobs or process IDs");
 			rv = 1;
 		} else {
 			if (mksh_kill(n, sig) < 0) {
@@ -1608,22 +1648,22 @@
 
 	opts = *wp++;
 	if (!opts) {
-		bi_errorf("missing options argument");
+		bi_errorf("missing %s argument", "options");
 		return (1);
 	}
 
 	var = *wp++;
 	if (!var) {
-		bi_errorf("missing name argument");
+		bi_errorf("missing %s argument", "name");
 		return (1);
 	}
 	if (!*var || *skip_varname(var, true)) {
-		bi_errorf("%s: is not an identifier", var);
+		bi_errorf("%s: %s", var, "is not an identifier");
 		return (1);
 	}
 
 	if (e->loc->next == NULL) {
-		internal_warningf("c_getopts: no argv");
+		internal_warningf("%s: %s", "c_getopts", "no argv");
 		return (1);
 	}
 	/* Which arguments are we parsing... */
@@ -1766,7 +1806,7 @@
 	} else
 		n = 1;
 	if (n < 0) {
-		bi_errorf("%s: bad number", arg);
+		bi_errorf("%s: %s", arg, "bad number");
 		return (1);
 	}
 	if (l->argc < n) {
@@ -1984,7 +2024,7 @@
 		switch (optc) {
 		case 'p':
 			if ((fd = coproc_getfd(R_OK, &emsg)) < 0) {
-				bi_errorf("-p: %s", emsg);
+				bi_errorf("%s: %s", "-p", emsg);
 				return (1);
 			}
 			break;
@@ -1998,7 +2038,7 @@
 			if (!*(cp = builtin_opt.optarg))
 				fd = 0;
 			else if ((fd = check_fd(cp, R_OK, &emsg)) < 0) {
-				bi_errorf("-u: %s: %s", cp, emsg);
+				bi_errorf("%s: %s: %s", "-u", cp, emsg);
 				return (1);
 			}
 			break;
@@ -2112,7 +2152,7 @@
 		/* Must be done before setting export. */
 		if (vp->flag & RDONLY) {
 			shf_flush(shf);
-			bi_errorf("%s is read only", *wp);
+			bi_errorf("%s: %s", *wp, "is read only");
 			afree(wpalloc, ATEMP);
 			return (1);
 		}
@@ -2229,7 +2269,7 @@
 	while (*wp != NULL) {
 		p = gettrap(*wp++, true);
 		if (p == NULL) {
-			bi_errorf("bad signal %s", wp[-1]);
+			bi_errorf("bad signal '%s'", wp[-1]);
 			return (1);
 		}
 		settrap(p, s);
@@ -2250,7 +2290,7 @@
 	if (arg) {
 		if (!getn(arg, &n)) {
 			exstat = 1;
-			warningf(true, "%s: bad number", arg);
+			warningf(true, "%s: %s", arg, "bad number");
 		} else
 			exstat = n;
 	}
@@ -2295,7 +2335,7 @@
 	quit = n;
 	if (quit <= 0) {
 		/* AT&T ksh does this for non-interactive shells only - weird */
-		bi_errorf("%s: bad value", arg);
+		bi_errorf("%s: %s", arg, "bad value");
 		return (1);
 	}
 
@@ -2314,7 +2354,7 @@
 		 * scripts, but don't generate an error (ie, keep going).
 		 */
 		if (n == quit) {
-			warningf(true, "%s: cannot %s", wp[0], wp[0]);
+			warningf(true, "%s: %s %s", wp[0], "can't", wp[0]);
 			return (0);
 		}
 		/* POSIX says if n is too big, the last enclosing loop
@@ -2340,7 +2380,7 @@
 	const char **owp;
 
 	if (wp[1] == NULL) {
-		static const char *args[] = { "set", "-", NULL };
+		static const char *args[] = { T_set, "-", NULL };
 		return (c_typeset(args));
 	}
 
@@ -2355,7 +2395,7 @@
 		while (*++wp != NULL)
 			strdupx(*wp, *wp, &l->area);
 		l->argc = wp - owp - 1;
-		l->argv = alloc((l->argc + 2) * sizeof(char *), &l->area);
+		l->argv = alloc2(l->argc + 2, sizeof(char *), &l->area);
 		for (wp = l->argv; (*wp++ = *owp++) != NULL; )
 			;
 	}
@@ -2409,7 +2449,7 @@
 			afree(cp, ATEMP);
 
 			if ((vp->flag&RDONLY)) {
-				bi_errorf("%s is read only", vp->name);
+				bi_errorf("%s: %s", vp->name, "is read only");
 				return (1);
 			}
 			unset(vp, optc);
@@ -2539,10 +2579,11 @@
 			t->str[0] |= TF_POSIX;
 			break;
 		case '?':
-			errorf("time: -%s unknown option", opt.optarg);
+			errorf("time: -%s %s", opt.optarg,
+			    "unknown option");
 		case ':':
-			errorf("time: -%s requires an argument",
-			    opt.optarg);
+			errorf("time: -%s %s", opt.optarg,
+			    "requires an argument");
 		}
 	/* Copy command words down over options. */
 	if (opt.optind != 0) {
@@ -2630,28 +2671,28 @@
 
 		majnum = strtoul(argv[2], &c, 0);
 		if ((c == argv[2]) || (*c != '\0')) {
-			bi_errorf("non-numeric device major '%s'", argv[2]);
+			bi_errorf("non-numeric %s %s '%s'", "device", "major", argv[2]);
 			goto c_mknod_err;
 		}
 		minnum = strtoul(argv[3], &c, 0);
 		if ((c == argv[3]) || (*c != '\0')) {
-			bi_errorf("non-numeric device minor '%s'", argv[3]);
+			bi_errorf("non-numeric %s %s '%s'", "device", "minor", argv[3]);
 			goto c_mknod_err;
 		}
 		dv = makedev(majnum, minnum);
-		if ((unsigned long)major(dv) != majnum) {
-			bi_errorf("device major too large: %lu", majnum);
+		if ((unsigned long)(major(dv)) != majnum) {
+			bi_errorf("%s %s too large: %lu", "device", "major", majnum);
 			goto c_mknod_err;
 		}
-		if ((unsigned long)minor(dv) != minnum) {
-			bi_errorf("device minor too large: %lu", minnum);
+		if ((unsigned long)(minor(dv)) != minnum) {
+			bi_errorf("%s %s too large: %lu", "device", "minor", minnum);
 			goto c_mknod_err;
 		}
 		if (mknod(argv[0], mode, dv))
 			goto c_mknod_failed;
 	} else if (mkfifo(argv[0], mode)) {
  c_mknod_failed:
-		bi_errorf("%s: %s", *wp, strerror(errno));
+		bi_errorf("%s: %s", argv[0], strerror(errno));
  c_mknod_err:
 		rv = 1;
 	}
@@ -2660,19 +2701,12 @@
 		umask(oldmode);
 	return (rv);
  c_mknod_usage:
-	bi_errorf("usage: mknod [-m mode] name [b | c] major minor");
-	bi_errorf("usage: mknod [-m mode] name p");
+	bi_errorf("%s: %s", "usage", "mknod [-m mode] name b|c major minor");
+	bi_errorf("%s: %s", "usage", "mknod [-m mode] name p");
 	return (1);
 }
 #endif
 
-/* dummy function, special case in comexec() */
-int
-c_builtin(const char **wp MKSH_A_UNUSED)
-{
-	return (0);
-}
-
 /* test(1) accepts the following grammar:
 	oexpr	::= aexpr | aexpr "-o" oexpr ;
 	aexpr	::= nexpr | nexpr "-a" aexpr ;
@@ -3010,7 +3044,7 @@
 		if (te->flags & TEF_ERROR)
 			return (0);
 		if (!(*te->isa)(te, TM_CPAREN)) {
-			(*te->error)(te, 0, "missing closing paren");
+			(*te->error)(te, 0, "missing )");
 			return (0);
 		}
 		return (rv);
@@ -3054,31 +3088,33 @@
  * Plain test (test and [ .. ]) specific routines.
  */
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 ptest_isa(Test_env *te, Test_meta meta)
 {
 	/* Order important - indexed by Test_meta values */
 	static const char *const tokens[] = {
 		"-o", "-a", "!", "(", ")"
 	};
-	int rv;
+	Test_op rv;
 
 	if (te->pos.wp >= te->wp_end)
-		return (meta == TM_END);
+		return (meta == TM_END ? TO_NONNULL : TO_NONOP);
 
 	if (meta == TM_UNOP || meta == TM_BINOP)
 		rv = test_isop(meta, *te->pos.wp);
 	else if (meta == TM_END)
-		rv = 0;
+		rv = TO_NONOP;
 	else
-		rv = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;
+		rv = !strcmp(*te->pos.wp, tokens[(int)meta]) ?
+		    TO_NONNULL : TO_NONOP;
 
 	/* Accept the token? */
-	if (rv)
+	if (rv != TO_NONOP)
 		te->pos.wp++;
 
 	return (rv);
@@ -3118,6 +3154,49 @@
 static void print_ulimit(const struct limits *, int);
 static int set_ulimit(const struct limits *, const char *, int);
 
+/* Magic to divine the 'm' and 'v' limits */
+
+#ifdef RLIMIT_AS
+#if !defined(RLIMIT_VMEM) || (RLIMIT_VMEM == RLIMIT_AS) || \
+    !defined(RLIMIT_RSS) || (RLIMIT_VMEM == RLIMIT_RSS)
+#define ULIMIT_V_IS_AS
+#elif defined(RLIMIT_VMEM)
+#if !defined(RLIMIT_RSS) || (RLIMIT_RSS == RLIMIT_AS)
+#define ULIMIT_V_IS_AS
+#else
+#define ULIMIT_V_IS_VMEM
+#endif
+#endif
+#endif
+
+#ifdef RLIMIT_RSS
+#ifdef ULIMIT_V_IS_VMEM
+#define ULIMIT_M_IS_RSS
+#elif defined(RLIMIT_VMEM) && (RLIMIT_VMEM == RLIMIT_RSS)
+#define ULIMIT_M_IS_VMEM
+#else
+#define ULIMIT_M_IS_RSS
+#endif
+#if defined(ULIMIT_M_IS_RSS) && defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)
+#undef ULIMIT_M_IS_RSS
+#endif
+#endif
+
+#if !defined(RLIMIT_AS) && !defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_VMEM)
+#define ULIMIT_V_IS_VMEM
+#endif
+
+#if !defined(ULIMIT_V_IS_VMEM) && defined(RLIMIT_VMEM) && \
+    (!defined(RLIMIT_RSS) || (defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)))
+#define ULIMIT_M_IS_VMEM
+#endif
+
+#if defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_AS) && \
+    (RLIMIT_VMEM == RLIMIT_AS)
+#undef ULIMIT_M_IS_VMEM
+#endif
+
+
 int
 c_ulimit(const char **wp)
 {
@@ -3141,18 +3220,12 @@
 #ifdef RLIMIT_MEMLOCK
 		{ "lockedmem(KiB)", RLIMIT_MEMLOCK, 1024, 'l' },
 #endif
-#ifdef RLIMIT_RSS
-		{ "memory(KiB)", RLIMIT_RSS, 1024, 'm' },
-#endif
 #ifdef RLIMIT_NOFILE
 		{ "nofiles(descriptors)", RLIMIT_NOFILE, 1, 'n' },
 #endif
 #ifdef RLIMIT_NPROC
 		{ "processes", RLIMIT_NPROC, 1, 'p' },
 #endif
-#ifdef RLIMIT_VMEM
-		{ "vmemory(KiB)", RLIMIT_VMEM, 1024, 'v' },
-#endif
 #ifdef RLIMIT_SWAP
 		{ "swap(KiB)", RLIMIT_SWAP, 1024, 'w' },
 #endif
@@ -3162,6 +3235,46 @@
 #ifdef RLIMIT_TIME
 		{ "humantime(seconds)", RLIMIT_TIME, 1, 'T' },
 #endif
+#ifdef RLIMIT_NOVMON
+		{ "vnodemonitors", RLIMIT_NOVMON, 1, 'V' },
+#endif
+#ifdef RLIMIT_SIGPENDING
+		{ "sigpending", RLIMIT_SIGPENDING, 1, 'i' },
+#endif
+#ifdef RLIMIT_MSGQUEUE
+		{ "msgqueue(bytes)", RLIMIT_MSGQUEUE, 1, 'q' },
+#endif
+#ifdef RLIMIT_AIO_MEM
+		{ "AIOlockedmem(KiB)", RLIMIT_AIO_MEM, 1024, 'M' },
+#endif
+#ifdef RLIMIT_AIO_OPS
+		{ "AIOoperations", RLIMIT_AIO_OPS, 1, 'O' },
+#endif
+#ifdef RLIMIT_TCACHE
+		{ "cachedthreads", RLIMIT_TCACHE, 1, 'C' },
+#endif
+#ifdef RLIMIT_SBSIZE
+		{ "sockbufsiz(KiB)", RLIMIT_SBSIZE, 1024, 'B' },
+#endif
+#ifdef RLIMIT_PTHREAD
+		{ "threadsperprocess", RLIMIT_PTHREAD, 1, 'P' },
+#endif
+#ifdef RLIMIT_NICE
+		{ "maxnice", RLIMIT_NICE, 1, 'e' },
+#endif
+#ifdef RLIMIT_RTPRIO
+		{ "maxrtprio", RLIMIT_RTPRIO, 1, 'r' },
+#endif
+#if defined(ULIMIT_M_IS_RSS)
+		{ "resident-set(KiB)", RLIMIT_RSS, 1024, 'm' },
+#elif defined(ULIMIT_M_IS_VMEM)
+		{ "memory(KiB)", RLIMIT_VMEM, 1024, 'm' },
+#endif
+#if defined(ULIMIT_V_IS_VMEM)
+		{ "virtual-memory(KiB)", RLIMIT_VMEM, 1024, 'v' },
+#elif defined(ULIMIT_V_IS_AS)
+		{ "address-space(KiB)", RLIMIT_AS, 1024, 'v' },
+#endif
 		{ NULL, 0, 0, 0 }
 	};
 	static char opts[3 + NELEM(limits)];
@@ -3191,7 +3304,8 @@
 			all = true;
 			break;
 		case '?':
-			bi_errorf("usage: ulimit [-acdfHLlmnpSsTtvw] [value]");
+			bi_errorf("%s: %s", "usage",
+			    "ulimit [-acdfHLlmnpSsTtvw] [value]");
 			return (1);
 		default:
 			what = optc;
@@ -3247,7 +3361,7 @@
 	}
 
 	if (getrlimit(l->resource, &limit) < 0) {
-		/* some cannot be read, e.g. Linux RLIMIT_LOCKS */
+		/* some can't be read, e.g. Linux RLIMIT_LOCKS */
 		limit.rlim_cur = RLIM_INFINITY;
 		limit.rlim_max = RLIM_INFINITY;
 	}
@@ -3290,15 +3404,20 @@
 {
 	int rv = 1;
 
-	if (wp == NULL		/* argv */ ||
-	    wp[0] == NULL	/* name of builtin */ ||
-	    wp[1] == NULL	/* first argument */ ||
-	    wp[2] == NULL	/* second argument */ ||
-	    wp[3] != NULL	/* no further args please */)
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
+
+	/* check for exactly two arguments */
+	if (wp[0] == NULL	/* first argument */ ||
+	    wp[1] == NULL	/* second argument */ ||
+	    wp[2] != NULL	/* no further args please */)
 		bi_errorf(T_synerr);
-	else if ((rv = rename(wp[1], wp[2])) != 0) {
+	else if ((rv = rename(wp[0], wp[1])) != 0) {
 		rv = errno;
-		bi_errorf("failed: %s", strerror(rv));
+		bi_errorf("%s: %s", "failed", strerror(rv));
 	}
 
 	return (rv);
@@ -3310,31 +3429,101 @@
 	int rv = 1;
 	char *buf;
 
-	if (wp != NULL && wp[0] != NULL && wp[1] != NULL) {
-		if (strcmp(wp[1], "--")) {
-			if (wp[2] == NULL) {
-				wp += 1;
-				rv = 0;
-			}
-		} else {
-			if (wp[2] != NULL && wp[3] == NULL) {
-				wp += 2;
-				rv = 0;
-			}
-		}
-	}
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
 
-	if (rv)
+	/* check for exactly one argument */
+	if (wp[0] == NULL || wp[1] != NULL)
 		bi_errorf(T_synerr);
-	else if ((buf = do_realpath(*wp)) == NULL) {
+	else if ((buf = do_realpath(wp[0])) == NULL) {
 		rv = errno;
-		bi_errorf("%s: %s", *wp, strerror(rv));
+		bi_errorf("%s: %s", wp[0], strerror(rv));
 		if ((unsigned int)rv > 255)
 			rv = 255;
 	} else {
 		shprintf("%s\n", buf);
 		afree(buf, ATEMP);
+		rv = 0;
 	}
 
 	return (rv);
 }
+
+int
+c_cat(const char **wp)
+{
+	int fd = STDIN_FILENO, rv = 0;
+	ssize_t n, w;
+	const char *fn = "<stdin>";
+	char *buf, *cp;
+#define MKSH_CAT_BUFSIZ 4096
+
+	/* XXX uses malloc instead of lalloc (for alignment/speed) */
+	if ((buf = malloc(MKSH_CAT_BUFSIZ)) == NULL) {
+		bi_errorf("can't allocate %lu data bytes",
+		    (unsigned long)MKSH_CAT_BUFSIZ);
+		return (1);
+	}
+
+	/* skip argv[0] */
+	++wp;
+	if (wp[0] && !strcmp(wp[0], "--"))
+		/* skip "--" (options separator) */
+		++wp;
+
+	do {
+		if (*wp) {
+			fn = *wp++;
+			if (fn[0] == '-' && fn[1] == '\0')
+				fd = STDIN_FILENO;
+			else if ((fd = open(fn, O_RDONLY)) < 0) {
+				rv = errno;
+				bi_errorf("%s: %s", fn, strerror(rv));
+				rv = 1;
+				continue;
+			}
+		}
+		while (1) {
+			n = blocking_read(fd, (cp = buf), MKSH_CAT_BUFSIZ);
+			if (n == -1) {
+				if (errno == EINTR)
+					/* interrupted, try again */
+					continue;
+				/* an error occured during reading */
+				rv = errno;
+				bi_errorf("%s: %s", fn, strerror(rv));
+				rv = 1;
+				break;
+			} else if (n == 0)
+				/* end of file reached */
+				break;
+			while (n) {
+				w = write(STDOUT_FILENO, cp, n);
+				if (w == -1) {
+					if (errno == EINTR)
+						/* interrupted, try again */
+						continue;
+					/* an error occured during writing */
+					rv = errno;
+					bi_errorf("%s: %s", "<stdout>",
+					    strerror(rv));
+					rv = 1;
+					if (fd != STDIN_FILENO)
+						close(fd);
+					goto out;
+				}
+				n -= w;
+				cp += w;
+			}
+		}
+		if (fd != STDIN_FILENO)
+			close(fd);
+	} while (*wp);
+
+ out:
+	free(buf);
+	return (rv);
+}
Index: src/bin/mksh/histrap.c
diff -u src/bin/mksh/histrap.c:1.92 src/bin/mksh/histrap.c:1.102
--- src/bin/mksh/histrap.c:1.92	Fri Jan 29 09:34:28 2010
+++ src/bin/mksh/histrap.c	Tue Sep 14 21:26:13 2010
@@ -1,5 +1,5 @@
-/*	$OpenBSD: history.c,v 1.37 2009/07/02 16:29:15 martynas Exp $	*/
-/*	$OpenBSD: trap.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
+/*	$OpenBSD: history.c,v 1.39 2010/05/19 17:36:08 jasper Exp $	*/
+/*	$OpenBSD: trap.c,v 1.23 2010/05/19 17:36:08 jasper Exp $	*/
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@@ -26,7 +26,7 @@
 #include <sys/file.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.92 2010/01/29 09:34:28 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.102 2010/09/14 21:26:13 tg Exp $");
 
 /*-
  * MirOS: This is the default mapping type, and need not be specified.
@@ -50,7 +50,7 @@
 #endif
 
 static int hist_execute(char *);
-static int hist_replace(char **, const char *, const char *, int);
+static int hist_replace(char **, const char *, const char *, bool);
 static char **hist_get(const char *, bool, bool);
 static char **hist_get_oldest(void);
 static void histbackup(void);
@@ -72,13 +72,14 @@
 	struct temp *tf;
 	const char *p;
 	char *editor = NULL;
-	int gflag = 0, lflag = 0, nflag = 0, sflag = 0, rflag = 0;
+	bool gflag = false, lflag = false, nflag = false, rflag = false,
+	    sflag = false;
 	int optc;
 	const char *first = NULL, *last = NULL;
 	char **hfirst, **hlast, **hp;
 
 	if (!Flag(FTALKING_I)) {
-		bi_errorf("history functions not available");
+		bi_errorf("history %ss not available", T_function);
 		return (1);
 	}
 
@@ -88,28 +89,30 @@
 		case 'e':
 			p = builtin_opt.optarg;
 			if (ksh_isdash(p))
-				sflag++;
+				sflag = true;
 			else {
 				size_t len = strlen(p);
+
+				/* almost certainly not overflowing */
 				editor = alloc(len + 4, ATEMP);
 				memcpy(editor, p, len);
 				memcpy(editor + len, " $_", 4);
 			}
 			break;
 		case 'g': /* non-AT&T ksh */
-			gflag++;
+			gflag = true;
 			break;
 		case 'l':
-			lflag++;
+			lflag = true;
 			break;
 		case 'n':
-			nflag++;
+			nflag = true;
 			break;
 		case 'r':
-			rflag++;
+			rflag = true;
 			break;
 		case 's':	/* POSIX version of -e - */
-			sflag++;
+			sflag = true;
 			break;
 		/* kludge city - accept -num as -- -num (kind of) */
 		case '0': case '1': case '2': case '3': case '4':
@@ -186,11 +189,10 @@
 		 * when range is specified; AT&T ksh and pdksh allow out of
 		 * bounds for -l as well.
 		 */
-		hfirst = hist_get(first, (lflag || last) ? true : false,
-		    lflag ? true : false);
+		hfirst = hist_get(first, (lflag || last) ? true : false, lflag);
 		if (!hfirst)
 			return (1);
-		hlast = last ? hist_get(last, true, lflag ? true : false) :
+		hlast = last ? hist_get(last, true, lflag) :
 		    (lflag ? hist_get_newest(false) : hfirst);
 		if (!hlast)
 			return (1);
@@ -230,15 +232,16 @@
 
 	tf = maketemp(ATEMP, TT_HIST_EDIT, &e->temps);
 	if (!(shf = tf->shf)) {
-		bi_errorf("cannot create temp file %s - %s",
-		    tf->name, strerror(errno));
+		bi_errorf("can't %s temporary file %s: %s",
+		    "create", tf->name, strerror(errno));
 		return (1);
 	}
 	for (hp = rflag ? hlast : hfirst;
 	    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
 		shf_fprintf(shf, "%s\n", *hp);
 	if (shf_close(shf) == EOF) {
-		bi_errorf("error writing temporary file - %s", strerror(errno));
+		bi_errorf("can't %s temporary file %s: %s",
+		    "write", tf->name, strerror(errno));
 		return (1);
 	}
 
@@ -250,7 +253,7 @@
 		Source *sold = source;
 		int ret;
 
-		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_");
+		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_", 0);
 		source = sold;
 		if (ret)
 			return (ret);
@@ -263,11 +266,22 @@
 		int n;
 
 		if (!(shf = shf_open(tf->name, O_RDONLY, 0, 0))) {
-			bi_errorf("cannot open temp file %s", tf->name);
+			bi_errorf("can't %s temporary file %s: %s",
+			    "open", tf->name, strerror(errno));
 			return (1);
 		}
 
-		n = stat(tf->name, &statb) < 0 ? 128 : statb.st_size + 1;
+		if (stat(tf->name, &statb) < 0)
+			n = 128;
+		else {
+			if (notoktoadd(statb.st_size, 1 + X_EXTRA)) {
+				bi_errorf(T_intovfl,
+				    (unsigned long)statb.st_size, '+',
+				    1UL + X_EXTRA);
+				goto errout;
+			}
+			n = statb.st_size + 1;
+		}
 		Xinit(xs, xp, n, hist_source->areap);
 		while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
 			xp += n;
@@ -275,8 +289,9 @@
 				XcheckN(xs, xp, Xlength(xs, xp));
 		}
 		if (n < 0) {
-			bi_errorf("error reading temp file %s - %s",
-			    tf->name, strerror(shf_errno(shf)));
+			bi_errorf("can't %s temporary file %s: %s",
+			    "read", tf->name, strerror(shf_errno(shf)));
+ errout:
 			shf_close(shf);
 			return (1);
 		}
@@ -305,12 +320,15 @@
 		}
 		histsave(&hist_source->line, p, true, true);
 
-		shellf("%s\n", p); /* POSIX doesn't say this is done... */
-		if (q)		/* restore \n (trailing \n not restored) */
+		/* POSIX doesn't say this is done... */
+		shellf("%s\n", p);
+		if (q)
+			/* restore \n (trailing \n not restored) */
 			q[-1] = '\n';
 	}
 
-	/* Commands are executed here instead of pushing them onto the
+	/*
+	 * Commands are executed here instead of pushing them onto the
 	 * input 'cause POSIX says the redirection and variable assignments
 	 * in
 	 *	X=y fc -e - 42 2> /dev/null
@@ -318,13 +336,13 @@
 	 */
 	/* XXX: source should not get trashed by this.. */
 	sold = source;
-	ret = command(cmd);
+	ret = command(cmd, 0);
 	source = sold;
 	return (ret);
 }
 
 static int
-hist_replace(char **hp, const char *pat, const char *rep, int globr)
+hist_replace(char **hp, const char *pat, const char *rep, bool globr)
 {
 	char *line;
 
@@ -337,12 +355,12 @@
 		int len;
 		XString xs;
 		char *xp;
-		int any_subst = 0;
+		bool any_subst = false;
 
 		Xinit(xs, xp, 128, ATEMP);
 		for (s = *hp; (s1 = strstr(s, pat)) && (!any_subst || globr);
 		    s = s1 + pat_len) {
-			any_subst = 1;
+			any_subst = true;
 			len = s1 - s;
 			XcheckN(xs, xp, len + rep_len);
 			memcpy(xp, s, len);		/* first part */
@@ -351,7 +369,7 @@
 			xp += rep_len;
 		}
 		if (!any_subst) {
-			bi_errorf("substitution failed");
+			bi_errorf("bad substitution");
 			return (1);
 		}
 		len = strlen(s) + 1;
@@ -379,18 +397,18 @@
 			if (approx)
 				hp = hist_get_oldest();
 			else {
-				bi_errorf("%s: not in history", str);
+				bi_errorf("%s: %s", str, "not in history");
 				hp = NULL;
 			}
 		} else if ((ptrdiff_t)hp > (ptrdiff_t)histptr) {
 			if (approx)
 				hp = hist_get_newest(allow_cur);
 			else {
-				bi_errorf("%s: not in history", str);
+				bi_errorf("%s: %s", str, "not in history");
 				hp = NULL;
 			}
 		} else if (!allow_cur && hp == histptr) {
-			bi_errorf("%s: invalid range", str);
+			bi_errorf("%s: %s", str, "invalid range");
 			hp = NULL;
 		}
 	} else {
@@ -398,7 +416,7 @@
 
 		/* the -1 is to avoid the current fc command */
 		if ((n = findhist(histptr - history - 1, 0, str, anchored)) < 0)
-			bi_errorf("%s: not in history", str);
+			bi_errorf("%s: %s", str, "not in history");
 		else
 			hp = &history[n];
 	}
@@ -416,7 +434,7 @@
 	return (allow_cur ? histptr : histptr - 1);
 }
 
-/* Return a pointer to the newest command in the history */
+/* Return a pointer to the oldest command in the history */
 static char **
 hist_get_oldest(void)
 {
@@ -527,7 +545,7 @@
 			cursize = n;
 		}
 
-		history = aresize(history, n * sizeof(char *), APERM);
+		history = aresize2(history, n, sizeof(char *), APERM);
 
 		histsize = n;
 		histptr = history + cursize;
@@ -578,7 +596,7 @@
 {
 	if (history == (char **)NULL) {
 		histsize = HISTORYSIZE;
-		history = alloc(histsize * sizeof(char *), APERM);
+		history = alloc2(histsize, sizeof(char *), APERM);
 		histptr = history - 1;
 	}
 }
@@ -745,8 +763,9 @@
 				hist_finish();
 				if (rv) {
  hiniterr:
-					bi_errorf("cannot unlink HISTFILE %s"
-					    " - %s", hname, strerror(errno));
+					bi_errorf("can't %s %s: %s",
+					    "unlink HISTFILE", hname,
+					    strerror(errno));
 					hsize = 0;
 					return;
 				}
@@ -860,9 +879,10 @@
 	unsigned char *ep;
 
 	for (ep = base + *bytes; --ep > base; ) {
-		/* this doesn't really work: the 4 byte line number that is
-		 * encoded after the COMMAND byte can itself contain the
-		 * COMMAND byte....
+		/*
+		 * this doesn't really work: the 4 byte line number that
+		 * is encoded after the COMMAND byte can itself contain
+		 * the COMMAND byte....
 		 */
 		for (; ep > base && *ep != COMMAND; ep--)
 			;
@@ -954,7 +974,7 @@
 {
 	int	sizenow;
 	unsigned char	*base;
-	unsigned char	*new;
+	unsigned char	*news;
 	int	bytes;
 	unsigned char	hdr[5];
 
@@ -971,13 +991,13 @@
 			    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
 			if (base == (unsigned char *)MAP_FAILED)
 				goto bad;
-			new = base + hsize;
-			if (*new != COMMAND) {
+			news = base + hsize;
+			if (*news != COMMAND) {
 				munmap((caddr_t)base, sizenow);
 				goto bad;
 			}
 			hist_source->line--;
-			histload(hist_source, new, bytes);
+			histload(hist_source, news, bytes);
 			hist_source->line++;
 			lno = hist_source->line;
 			munmap((caddr_t)base, sizenow);
@@ -1083,7 +1103,8 @@
 #endif
 			if ((sigtraps[i].mess == NULL) ||
 			    (sigtraps[i].mess[0] == '\0'))
-				sigtraps[i].mess = shf_smprintf("Signal %d", i);
+				sigtraps[i].mess = shf_smprintf("%s %d",
+				    "Signal", i);
 		}
 	}
 	sigtraps[SIGEXIT_].name = "EXIT";	/* our name for signal 0 */
@@ -1094,7 +1115,7 @@
 
 	sigtraps[SIGINT].flags |= TF_DFL_INTR | TF_TTY_INTR;
 	sigtraps[SIGQUIT].flags |= TF_DFL_INTR | TF_TTY_INTR;
-	sigtraps[SIGTERM].flags |= TF_DFL_INTR;/* not fatal for interactive */
+	sigtraps[SIGTERM].flags |= TF_DFL_INTR; /* not fatal for interactive */
 	sigtraps[SIGHUP].flags |= TF_FATAL;
 	sigtraps[SIGCHLD].flags |= TF_SHELL_USES;
 
@@ -1119,7 +1140,7 @@
 static void
 alarm_catcher(int sig MKSH_A_UNUSED)
 {
-	int errno_ = errno;
+	/* this runs inside interrupt context, with errno saved */
 
 	if (ksh_tmout_state == TMOUT_READING) {
 		int left = alarm(0);
@@ -1130,7 +1151,6 @@
 		} else
 			alarm(left);
 	}
-	errno = errno_;
 }
 
 Trap *
@@ -1178,7 +1198,8 @@
 	errno = errno_;
 }
 
-/* called when we want to allow the user to ^C out of something - won't
+/*
+ * called when we want to allow the user to ^C out of something - won't
  * work if user has trapped SIGINT.
  */
 void
@@ -1188,7 +1209,8 @@
 		runtraps(TF_DFL_INTR|TF_FATAL);
 }
 
-/* called after EINTR to check if a signal with normally causes process
+/*
+ * called after EINTR to check if a signal with normally causes process
  * termination has been received.
  */
 int
@@ -1205,7 +1227,8 @@
 	return (0);
 }
 
-/* Returns the signal number of any pending traps: ie, a signal which has
+/*
+ * Returns the signal number of any pending traps: ie, a signal which has
  * occurred for which a trap has been set or for which the TF_DFL_INTR flag
  * is set.
  */
@@ -1237,7 +1260,8 @@
 		warningf(false, "timed out waiting for input");
 		unwind(LEXIT);
 	} else
-		/* XXX: this means the alarm will have no effect if a trap
+		/*
+		 * XXX: this means the alarm will have no effect if a trap
 		 * is caught after the alarm() was started...not good.
 		 */
 		ksh_tmout_state = TMOUT_EXECUTING;
@@ -1283,10 +1307,11 @@
 		p->trap = NULL;
 	}
 	oexstat = exstat;
-	/* Note: trapstr is fully parsed before anything is executed, thus
+	/*
+	 * Note: trapstr is fully parsed before anything is executed, thus
 	 * no problem with afree(p->trap) in settrap() while still in use.
 	 */
-	command(trapstr);
+	command(trapstr, current_lineno);
 	exstat = oexstat;
 	if (i == SIGEXIT_ || i == SIGERR_) {
 		if (p->flags & TF_CHANGED)
@@ -1352,7 +1377,8 @@
 				p->flags |= TF_EXEC_DFL;
 		}
 
-		/* assumes handler already set to what shell wants it
+		/*
+		 * assumes handler already set to what shell wants it
 		 * (normally trapsig, but could be j_sigchld() or SIG_IGN)
 		 */
 		return;
@@ -1362,7 +1388,8 @@
 	setsig(p, f, SS_RESTORE_CURR|SS_USER);
 }
 
-/* Called by c_print() when writing to a co-process to ensure SIGPIPE won't
+/*
+ * Called by c_print() when writing to a co-process to ensure SIGPIPE won't
  * kill shell (unless user catches it and exits)
  */
 int
@@ -1390,7 +1417,8 @@
 		setsig(&sigtraps[SIGPIPE], SIG_DFL, SS_RESTORE_CURR);
 }
 
-/* Set action for a signal. Action may not be set if original
+/*
+ * Set action for a signal. Action may not be set if original
  * action was SIG_IGN, depending on the value of flags and FTALKING.
  */
 int
@@ -1401,7 +1429,8 @@
 	if (p->signal == SIGEXIT_ || p->signal == SIGERR_)
 		return (1);
 
-	/* First time setting this signal? If so, get and note the current
+	/*
+	 * First time setting this signal? If so, get and note the current
 	 * setting.
 	 */
 	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
@@ -1411,7 +1440,8 @@
 		p->cursig = SIG_IGN;
 	}
 
-	/* Generally, an ignored signal stays ignored, except if
+	/*-
+	 * Generally, an ignored signal stays ignored, except if
 	 *	- the user of an interactive shell wants to change it
 	 *	- the shell wants for force a change
 	 */
@@ -1421,9 +1451,11 @@
 
 	setexecsig(p, flags & SS_RESTORE_MASK);
 
-	/* This is here 'cause there should be a way of clearing shtraps, but
-	 * don't know if this is a sane way of doing it. At the moment,
-	 * all users of shtrap are lifetime users (SIGCHLD, SIGALRM, SIGWINCH).
+	/*
+	 * This is here 'cause there should be a way of clearing
+	 * shtraps, but don't know if this is a sane way of doing
+	 * it. At the moment, all users of shtrap are lifetime
+	 * users (SIGALRM, SIGCHLD, SIGWINCH).
 	 */
 	if (!(flags & SS_USER))
 		p->shtrap = (sig_t)NULL;
Index: src/bin/mksh/jobs.c
diff -u src/bin/mksh/jobs.c:1.67 src/bin/mksh/jobs.c:1.72
--- src/bin/mksh/jobs.c:1.67	Thu Dec 31 14:05:43 2009
+++ src/bin/mksh/jobs.c	Sat Aug 28 20:22:19 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.67 2009/12/31 14:05:43 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.72 2010/08/28 20:22:19 tg Exp $");
 
 #if HAVE_KILLPG
 #define mksh_killpg		killpg
@@ -63,7 +63,7 @@
 #define JF_W_ASYNCNOTIFY 0x004	/* set if waiting and async notification ok */
 #define JF_XXCOM	0x008	/* set for $(command) jobs */
 #define JF_FG		0x010	/* running in foreground (also has tty pgrp) */
-#define JF_SAVEDTTY	0x020	/* j->ttystate is valid */
+#define JF_SAVEDTTY	0x020	/* j->ttystat is valid */
 #define JF_CHANGED	0x040	/* process has changed state */
 #define JF_KNOWN	0x080	/* $! referenced */
 #define JF_ZOMBIE	0x100	/* known, unwaited process */
@@ -87,7 +87,7 @@
 	int32_t	age;		/* number of jobs started */
 	Coproc_id coproc_id;	/* 0 or id of coprocess output pipe */
 #ifndef MKSH_UNEMPLOYED
-	struct termios ttystate;/* saved tty state for stopped jobs */
+	struct termios ttystat;	/* saved tty state for stopped jobs */
 	pid_t saved_ttypgrp;	/* saved tty process group for stopped jobs */
 #endif
 };
@@ -170,7 +170,8 @@
 	if (!mflagset && Flag(FTALKING))
 		Flag(FMONITOR) = 1;
 
-	/* shl_j is used to do asynchronous notification (used in
+	/*
+	 * shl_j is used to do asynchronous notification (used in
 	 * an interrupt handler, so need a distinct shf)
 	 */
 	shl_j = shf_fdopen(2, SHF_WR, NULL);
@@ -178,7 +179,8 @@
 	if (Flag(FMONITOR) || Flag(FTALKING)) {
 		int i;
 
-		/* the TF_SHELL_USES test is a kludge that lets us know if
+		/*
+		 * the TF_SHELL_USES test is a kludge that lets us know if
 		 * if the signals have been changed by the shell.
 		 */
 		for (i = NELEM(tt_sigs); --i >= 0; ) {
@@ -233,7 +235,8 @@
 
 #ifndef MKSH_UNEMPLOYED
 	if (kshpid == procpid && restore_ttypgrp >= 0) {
-		/* Need to restore the tty pgrp to what it was when the
+		/*
+		 * Need to restore the tty pgrp to what it was when the
 		 * shell started up, so that the process that started us
 		 * will be able to access the tty when we are done.
 		 * Also need to restore our process group in case we are
@@ -273,8 +276,8 @@
 				pid_t ttypgrp;
 
 				if ((ttypgrp = tcgetpgrp(tty_fd)) < 0) {
-					warningf(false,
-					    "j_init: tcgetpgrp() failed: %s",
+					warningf(false, "%s: %s %s: %s",
+					    "j_init", "tcgetpgrp", "failed",
 					    strerror(errno));
 					ttypgrp_ok = false;
 					break;
@@ -289,14 +292,13 @@
 			    SS_RESTORE_DFL|SS_FORCE);
 		if (ttypgrp_ok && kshpgrp != kshpid) {
 			if (setpgid(0, kshpid) < 0) {
-				warningf(false,
-				    "j_init: setpgid() failed: %s",
-				    strerror(errno));
+				warningf(false, "%s: %s %s: %s", "j_init",
+				    "setpgid", "failed", strerror(errno));
 				ttypgrp_ok = false;
 			} else {
 				if (tcsetpgrp(tty_fd, kshpid) < 0) {
-					warningf(false,
-					    "j_init: tcsetpgrp() failed: %s",
+					warningf(false, "%s: %s %s: %s",
+					    "j_init", "tcsetpgrp", "failed",
 					    strerror(errno));
 					ttypgrp_ok = false;
 				} else
@@ -305,7 +307,8 @@
 			}
 		}
 		if (use_tty && !ttypgrp_ok)
-			warningf(false, "warning: won't have full job control");
+			warningf(false, "%s: %s", "warning",
+			    "won't have full job control");
 		if (tty_fd >= 0)
 			tcgetattr(tty_fd, &tty_state);
 	} else {
@@ -337,19 +340,17 @@
 {
 	static Proc *last_proc;		/* for pipelines */
 
-	int i, rv = 0, forksleep;
+	int rv = 0, forksleep;
 	sigset_t omask;
-	Proc *p;
-	Job *j;
 	struct {
-#if !HAVE_ARC4RANDOM
-		pid_t thepid;
-#endif
-		unsigned char ischild;
+		Proc *p;
+		Job *j;
+		pid_t cldpid;
 	} pi;
 
 	if (flags & XEXEC)
-		/* Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
+		/*
+		 * Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
 		 * (also done in another execute() below)
 		 */
 		return (execute(t, flags & (XEXEC | XERROK), xerrok));
@@ -357,98 +358,93 @@
 	/* no SIGCHLDs while messing with job and process lists */
 	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
 
-	p = new_proc();
-	p->next = NULL;
-	p->state = PRUNNING;
-	p->status = 0;
-	p->pid = 0;
+	pi.p = new_proc();
+	pi.p->next = NULL;
+	pi.p->state = PRUNNING;
+	pi.p->status = 0;
+	pi.p->pid = 0;
 
 	/* link process into jobs list */
-	if (flags & XPIPEI) {	/* continuing with a pipe */
+	if (flags & XPIPEI) {
+		/* continuing with a pipe */
 		if (!last_job)
-			internal_errorf(
-			    "exchild: XPIPEI and no last_job - pid %d",
+			internal_errorf("%s %d",
+			    "exchild: XPIPEI and no last_job - pid",
 			    (int)procpid);
-		j = last_job;
+		pi.j = last_job;
 		if (last_proc)
-			last_proc->next = p;
-		last_proc = p;
+			last_proc->next = pi.p;
+		last_proc = pi.p;
 	} else {
-		j = new_job(); /* fills in j->job */
-		/* we don't consider XXCOMs foreground since they don't get
+		pi.j = new_job();	/* fills in pi.j->job */
+		/*
+		 * we don't consider XXCOMs foreground since they don't get
 		 * tty process group and we don't save or restore tty modes.
 		 */
-		j->flags = (flags & XXCOM) ? JF_XXCOM :
+		pi.j->flags = (flags & XXCOM) ? JF_XXCOM :
 		    ((flags & XBGND) ? 0 : (JF_FG|JF_USETTYMODE));
-		timerclear(&j->usrtime);
-		timerclear(&j->systime);
-		j->state = PRUNNING;
-		j->pgrp = 0;
-		j->ppid = procpid;
-		j->age = ++njobs;
-		j->proc_list = p;
-		j->coproc_id = 0;
-		last_job = j;
-		last_proc = p;
-		put_job(j, PJ_PAST_STOPPED);
+		timerclear(&pi.j->usrtime);
+		timerclear(&pi.j->systime);
+		pi.j->state = PRUNNING;
+		pi.j->pgrp = 0;
+		pi.j->ppid = procpid;
+		pi.j->age = ++njobs;
+		pi.j->proc_list = pi.p;
+		pi.j->coproc_id = 0;
+		last_job = pi.j;
+		last_proc = pi.p;
+		put_job(pi.j, PJ_PAST_STOPPED);
 	}
 
-	snptreef(p->command, sizeof(p->command), "%T", t);
+	snptreef(pi.p->command, sizeof(pi.p->command), "%T", t);
 
 	/* create child process */
 	forksleep = 1;
-	while ((i = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
+	while ((pi.cldpid = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
 		if (intrsig)	 /* allow user to ^C out... */
 			break;
 		sleep(forksleep);
 		forksleep <<= 1;
 	}
-	if (i < 0) {
-		kill_job(j, SIGKILL);
-		remove_job(j, "fork failed");
+	if (pi.cldpid < 0) {
+		kill_job(pi.j, SIGKILL);
+		remove_job(pi.j, "fork failed");
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		errorf("cannot fork - try again");
+		errorf("can't fork - try again");
 	}
-#if !HAVE_ARC4RANDOM
-#ifdef DEBUG
-	/* reduce extra 3 bytes of entropy, for Valgrind */
-	memset(&pi, 0, sizeof(pi));
-#endif
-	pi.thepid =
-#endif
-	    p->pid = (pi.ischild = i == 0) ? (procpid = getpid()) : i;
+	pi.p->pid = pi.cldpid ? pi.cldpid : (procpid = getpid());
 
-#if !HAVE_ARC4RANDOM
 	/*
 	 * ensure next child gets a (slightly) different $RANDOM sequence
 	 * from its parent process and other child processes
 	 */
 	change_random(&pi, sizeof(pi));
-#endif
 
 #ifndef MKSH_UNEMPLOYED
 	/* job control set up */
 	if (Flag(FMONITOR) && !(flags&XXCOM)) {
 		int	dotty = 0;
-		if (j->pgrp == 0) {	/* First process */
-			j->pgrp = p->pid;
+		if (pi.j->pgrp == 0) {	/* First process */
+			pi.j->pgrp = pi.p->pid;
 			dotty = 1;
 		}
 
 		/* set pgrp in both parent and child to deal with race
 		 * condition
 		 */
-		setpgid(p->pid, j->pgrp);
+		setpgid(pi.p->pid, pi.j->pgrp);
 		if (ttypgrp_ok && dotty && !(flags & XBGND))
-			tcsetpgrp(tty_fd, j->pgrp);
+			tcsetpgrp(tty_fd, pi.j->pgrp);
 	}
 #endif
 
 	/* used to close pipe input fd */
-	if (close_fd >= 0 && (((flags & XPCLOSE) && !pi.ischild) ||
-	    ((flags & XCCLOSE) && pi.ischild)))
+	if (close_fd >= 0 && (((flags & XPCLOSE) && pi.cldpid) ||
+	    ((flags & XCCLOSE) && !pi.cldpid)))
 		close(close_fd);
-	if (pi.ischild) {		/* child */
+	if (!pi.cldpid) {
+		/* child */
+
 		/* Do this before restoring signal */
 		if (flags & XCOPROC)
 			coproc_cleanup(false);
@@ -460,8 +456,8 @@
 		 * their inherited values.
 		 */
 		if (Flag(FMONITOR) && !(flags & XXCOM)) {
-			for (i = NELEM(tt_sigs); --i >= 0; )
-				setsig(&sigtraps[tt_sigs[i]], SIG_DFL,
+			for (forksleep = NELEM(tt_sigs); --forksleep >= 0; )
+				setsig(&sigtraps[tt_sigs[forksleep]], SIG_DFL,
 				    SS_RESTORE_DFL|SS_FORCE);
 		}
 #endif
@@ -479,12 +475,12 @@
 			setsig(&sigtraps[SIGQUIT], SIG_IGN,
 			    SS_RESTORE_IGN|SS_FORCE);
 			if ((!(flags & (XPIPEI | XCOPROC))) &&
-			    ((i = open("/dev/null", 0)) > 0)) {
-				(void)ksh_dup2(i, 0, true);
-				close(i);
+			    ((forksleep = open("/dev/null", 0)) > 0)) {
+				(void)ksh_dup2(forksleep, 0, true);
+				close(forksleep);
 			}
 		}
-		remove_job(j, "child");	/* in case of $(jobs) command */
+		remove_job(pi.j, "child");	/* in case of $(jobs) command */
 		nzombie = 0;
 #ifndef MKSH_UNEMPLOYED
 		ttypgrp_ok = false;
@@ -498,8 +494,9 @@
 #ifndef MKSH_SMALL
 		if (t->type == TPIPE)
 			unwind(LLEAVE);
-		internal_warningf("exchild: execute() returned");
-		fptreef(shl_out, 2, "exchild: tried to execute {\n%T\n}\n", t);
+		internal_warningf("%s: %s", "exchild", "execute() returned");
+		fptreef(shl_out, 2, "%s: tried to execute {\n%T\n}\n",
+		    "exchild", t);
 		shf_flush(shl_out);
 #endif
 		unwind(LLEAVE);
@@ -508,24 +505,27 @@
 
 	/* shell (parent) stuff */
 	if (!(flags & XPIPEO)) {	/* last process in a job */
-		j_startjob(j);
+		j_startjob(pi.j);
 		if (flags & XCOPROC) {
-			j->coproc_id = coproc.id;
-			coproc.njobs++; /* n jobs using co-process output */
-			coproc.job = (void *) j; /* j using co-process input */
+			pi.j->coproc_id = coproc.id;
+			/* n jobs using co-process output */
+			coproc.njobs++;
+			/* j using co-process input */
+			coproc.job = (void *)pi.j;
 		}
 		if (flags & XBGND) {
-			j_set_async(j);
+			j_set_async(pi.j);
 			if (Flag(FTALKING)) {
-				shf_fprintf(shl_out, "[%d]", j->job);
-				for (p = j->proc_list; p; p = p->next)
+				shf_fprintf(shl_out, "[%d]", pi.j->job);
+				for (pi.p = pi.j->proc_list; pi.p;
+				    pi.p = pi.p->next)
 					shf_fprintf(shl_out, " %d",
-					    (int)p->pid);
+					    (int)pi.p->pid);
 				shf_putchar('\n', shl_out);
 				shf_flush(shl_out);
 			}
 		} else
-			rv = j_waitj(j, JW_NONE, "jw:last proc");
+			rv = j_waitj(pi.j, JW_NONE, "jw:last proc");
 	}
 
 	sigprocmask(SIG_SETMASK, &omask, NULL);
@@ -562,14 +562,14 @@
 	j = last_job;
 	if (!j || !(j->flags & JF_STARTED)) {
 		if (!j)
-			warningf(true, "waitlast: no last job");
+			warningf(true, "%s: %s", "waitlast", "no last job");
 		else
-			internal_warningf("waitlast: not started");
+			internal_warningf("%s: %s", "waitlast", "not started");
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		return (125); /* not so arbitrary, non-zero value */
+		return (125);	/* not so arbitrary, non-zero value */
 	}
 
-	rv = j_waitj(j, JW_NONE, "jw:waitlast");
+	rv = j_waitj(j, JW_NONE, "waitlast");
 
 	sigprocmask(SIG_SETMASK, &omask, NULL);
 
@@ -591,7 +591,8 @@
 	*sigp = 0;
 
 	if (cp == NULL) {
-		/* wait for an unspecified job - always returns 0, so
+		/*
+		 * wait for an unspecified job - always returns 0, so
 		 * don't have to worry about exited/signaled jobs
 		 */
 		for (j = job_list; j; j = j->next)
@@ -717,7 +718,7 @@
 		/* attach tty to job */
 		if (j->state == PRUNNING) {
 			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
-				tcsetattr(tty_fd, TCSADRAIN, &j->ttystate);
+				tcsetattr(tty_fd, TCSADRAIN, &j->ttystat);
 			/* See comment in j_waitj regarding saved_ttypgrp. */
 			if (ttypgrp_ok &&
 			    tcsetpgrp(tty_fd, (j->flags & JF_SAVEDTTYPGRP) ?
@@ -727,10 +728,10 @@
 					tcsetattr(tty_fd, TCSADRAIN, &tty_state);
 				sigprocmask(SIG_SETMASK, &omask,
 				    NULL);
-				bi_errorf("1st tcsetpgrp(%d, %d) failed: %s",
-				    tty_fd,
-				    (int)((j->flags & JF_SAVEDTTYPGRP) ?
-				    j->saved_ttypgrp : j->pgrp),
+				bi_errorf("%s %s(%d, %ld) %s: %s",
+				    "1st", "tcsetpgrp", tty_fd,
+				    (long)((j->flags & JF_SAVEDTTYPGRP) ?
+				    j->saved_ttypgrp : j->pgrp), "failed",
 				    strerror(rv));
 				return (1);
 			}
@@ -749,12 +750,12 @@
 			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
 				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
 			if (ttypgrp_ok && tcsetpgrp(tty_fd, kshpgrp) < 0)
-				warningf(true,
-				    "fg: 2nd tcsetpgrp(%d, %ld) failed: %s",
-				    tty_fd, (long)kshpgrp, strerror(errno));
+				warningf(true, "%s %s(%d, %ld) %s: %s",
+				    "fg: 2nd", "tcsetpgrp", tty_fd,
+				    (long)kshpgrp, "failed", strerror(errno));
 		}
 		sigprocmask(SIG_SETMASK, &omask, NULL);
-		bi_errorf("cannot continue job %s: %s",
+		bi_errorf("%s %s %s", "can't continue job",
 		    cp, strerror(err));
 		return (1);
 	}
@@ -903,7 +904,8 @@
 	return (async_pid);
 }
 
-/* Make j the last async process
+/*
+ * Make j the last async process
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -915,7 +917,7 @@
 	if (async_job && (async_job->flags & (JF_KNOWN|JF_ZOMBIE)) == JF_ZOMBIE)
 		remove_job(async_job, "async");
 	if (!(j->flags & JF_STARTED)) {
-		internal_warningf("j_async: job not started");
+		internal_warningf("%s: %s", "j_async", "job not started");
 		return;
 	}
 	async_job = j;
@@ -929,8 +931,8 @@
 		if (!oldest) {
 			/* XXX debugging */
 			if (!(async_job->flags & JF_ZOMBIE) || nzombie != 1) {
-				internal_warningf("j_async: bad nzombie (%d)",
-				    nzombie);
+				internal_warningf("%s: bad nzombie (%d)",
+				    "j_async", nzombie);
 				nzombie = 0;
 			}
 			break;
@@ -939,7 +941,8 @@
 	}
 }
 
-/* Start a job: set STARTED, check for held signals and set j->last_proc
+/*
+ * Start a job: set STARTED, check for held signals and set j->last_proc
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -991,7 +994,7 @@
 			int oldf = j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY);
 			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
 			runtraps(TF_FATAL);
-			j->flags |= oldf; /* not reached... */
+			j->flags |= oldf;	/* not reached... */
 		}
 		if ((flags & JW_INTERRUPT) && (rv = trap_pending())) {
 			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
@@ -1019,17 +1022,18 @@
 			    (j->saved_ttypgrp = tcgetpgrp(tty_fd)) >= 0)
 				j->flags |= JF_SAVEDTTYPGRP;
 			if (tcsetpgrp(tty_fd, kshpgrp) < 0)
-				warningf(true,
-				    "j_waitj: tcsetpgrp(%d, %ld) failed: %s",
-				    tty_fd, (long)kshpgrp, strerror(errno));
+				warningf(true, "%s %s(%d, %ld) %s: %s",
+				    "j_waitj:", "tcsetpgrp", tty_fd,
+				    (long)kshpgrp, "failed", strerror(errno));
 			if (j->state == PSTOPPED) {
 				j->flags |= JF_SAVEDTTY;
-				tcgetattr(tty_fd, &j->ttystate);
+				tcgetattr(tty_fd, &j->ttystat);
 			}
 		}
 #endif
 		if (tty_fd >= 0) {
-			/* Only restore tty settings if job was originally
+			/*
+			 * Only restore tty settings if job was originally
 			 * started in the foreground. Problems can be
 			 * caused by things like 'more foobar &' which will
 			 * typically get and save the shell's vi/emacs tty
@@ -1042,7 +1046,8 @@
 				tcgetattr(tty_fd, &tty_state);
 			} else {
 				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
-				/* Don't use tty mode if job is stopped and
+				/*-
+				 * Don't use tty mode if job is stopped and
 				 * later restarted and exits. Consider
 				 * the sequence:
 				 *	vi foo (stopped)
@@ -1058,7 +1063,8 @@
 			}
 		}
 #ifndef MKSH_UNEMPLOYED
-		/* If it looks like user hit ^C to kill a job, pretend we got
+		/*
+		 * If it looks like user hit ^C to kill a job, pretend we got
 		 * one too to break out of for loops, etc. (AT&T ksh does this
 		 * even when not monitoring, but this doesn't make sense since
 		 * a tty generated ^C goes to the whole process group)
@@ -1097,7 +1103,8 @@
 	return (rv);
 }
 
-/* SIGCHLD handler to reap children and update job states
+/*
+ * SIGCHLD handler to reap children and update job states
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1105,14 +1112,16 @@
 static void
 j_sigchld(int sig MKSH_A_UNUSED)
 {
-	int		errno_ = errno;
-	Job		*j;
-	Proc		*p = NULL;
-	int		pid;
-	int		status;
-	struct rusage	ru0, ru1;
+	/* this runs inside interrupt context, with errno saved */
+
+	Job *j;
+	Proc *p = NULL;
+	pid_t pid;
+	int status;
+	struct rusage ru0, ru1;
 
-	/* Don't wait for any processes if a job is partially started.
+	/*
+	 * Don't wait for any processes if a job is partially started.
 	 * This is so we don't do away with the process group leader
 	 * before all the processes in a pipe line are started (so the
 	 * setpgid() won't fail)
@@ -1120,15 +1129,19 @@
 	for (j = job_list; j; j = j->next)
 		if (j->ppid == procpid && !(j->flags & JF_STARTED)) {
 			held_sigchld = 1;
-			goto finished;
+			return;
 		}
 
 	getrusage(RUSAGE_CHILDREN, &ru0);
 	do {
 		pid = waitpid(-1, &status, (WNOHANG|WUNTRACED));
 
-		if (pid <= 0)	/* return if would block (0) ... */
-			break;	/* ... or no children or interrupted (-1) */
+		/*
+		 * return if this would block (0) or no children
+		 * or interrupted (-1)
+		 */
+		if (pid <= 0)
+			return;
 
 		getrusage(RUSAGE_CHILDREN, &ru1);
 
@@ -1165,9 +1178,6 @@
 
 		check_job(j);	/* check to see if entire job is done */
 	} while (1);
-
- finished:
-	errno = errno_;
 }
 
 /*
@@ -1212,17 +1222,20 @@
 		break;
 	}
 
-	/* Note when co-process dies: can't be done in j_wait() nor
+	/*
+	 * Note when co-process dies: can't be done in j_wait() nor
 	 * remove_job() since neither may be called for non-interactive
 	 * shells.
 	 */
 	if (j->state == PEXITED || j->state == PSIGNALLED) {
-		/* No need to keep co-process input any more
+		/*
+		 * No need to keep co-process input any more
 		 * (at least, this is what ksh93d thinks)
 		 */
 		if (coproc.job == j) {
 			coproc.job = NULL;
-			/* XXX would be nice to get the closes out of here
+			/*
+			 * XXX would be nice to get the closes out of here
 			 * so they aren't done in the signal handler.
 			 * Would mean a check in coproc_getfd() to
 			 * do "if job == 0 && write >= 0, close write".
@@ -1238,7 +1251,8 @@
 	j->flags |= JF_CHANGED;
 #ifndef MKSH_UNEMPLOYED
 	if (Flag(FMONITOR) && !(j->flags & JF_XXCOM)) {
-		/* Only put stopped jobs at the front to avoid confusing
+		/*
+		 * Only put stopped jobs at the front to avoid confusing
 		 * the user (don't want finished jobs effecting %+ or %-)
 		 */
 		if (j->state == PSTOPPED)
@@ -1255,7 +1269,8 @@
 						fd = ep->savefd[2];
 				shf_reopen(fd, SHF_WR, shl_j);
 			}
-			/* Can't call j_notify() as it removes jobs. The job
+			/*
+			 * Can't call j_notify() as it removes jobs. The job
 			 * must stay in the job list as j_waitj() may be
 			 * running with this job.
 			 */
@@ -1299,7 +1314,8 @@
 	int	output = 0;
 
 	if (how == JP_PGRP) {
-		/* POSIX doesn't say what to do it there is no process
+		/*
+		 * POSIX doesn't say what to do it there is no process
 		 * group leader (ie, !FMONITOR). We arbitrarily return
 		 * last pid (which is what $! returns).
 		 */
@@ -1338,8 +1354,9 @@
 			if (WCOREDUMP(p->status))
 				coredumped = 1;
 #endif
-			/* kludge for not reporting 'normal termination signals'
-			 * (ie, SIGINT, SIGPIPE)
+			/*
+			 * kludge for not reporting 'normal termination
+			 * signals' (i.e. SIGINT, SIGPIPE)
 			 */
 			if (how == JP_SHORT && !coredumped &&
 			    (WTERMSIG(p->status) == SIGINT ||
@@ -1355,7 +1372,7 @@
 			if (p == j->proc_list)
 				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
 			else
-				shf_fprintf(shf, "%s", filler);
+				shf_puts(filler, shf);
 		}
 
 		if (how == JP_LONG)
@@ -1392,7 +1409,8 @@
 		shf_putc('\n', shf);
 }
 
-/* Convert % sequence to job
+/*
+ * Convert % sequence to job
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1409,8 +1427,10 @@
 		for (j = job_list; j != NULL; j = j->next)
 			if (j->last_proc && j->last_proc->pid == job)
 				return (j);
-		/* ...then look for process group (this is non-POSIX,
-		 * but should not break anything */
+		/*
+		 * ...then look for process group (this is non-POSIX,
+		 * but should not break anything
+		 */
 		for (j = job_list; j != NULL; j = j->next)
 			if (j->pgrp && j->pgrp == job)
 				return (j);
@@ -1484,7 +1504,8 @@
 static Job	*free_jobs;
 static Proc	*free_procs;
 
-/* allocate a new job and fill in the job number.
+/*
+ * allocate a new job and fill in the job number.
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1512,7 +1533,8 @@
 	return (newj);
 }
 
-/* Allocate new process struct
+/*
+ * Allocate new process struct
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
@@ -1530,7 +1552,8 @@
 	return (p);
 }
 
-/* Take job out of job_list and put old structures into free list.
+/*
+ * Take job out of job_list and put old structures into free list.
  * Keeps nzombies, last_job and async_job up to date.
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
@@ -1546,7 +1569,7 @@
 	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
 		;
 	if (curr != j) {
-		internal_warningf("remove_job: job not found (%s)", where);
+		internal_warningf("remove_job: job %s (%s)", "not found", where);
 		return;
 	}
 	*prev = curr->next;
@@ -1570,7 +1593,8 @@
 		async_job = NULL;
 }
 
-/* put j in a particular location (taking it out job_list if it is there
+/*
+ * put j in a particular location (taking it out job_list if it is there
  * already)
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
@@ -1606,7 +1630,8 @@
 	}
 }
 
-/* nuke a job (called when unable to start full job).
+/*
+ * nuke a job (called when unable to start full job).
  *
  * If jobs are compiled in then this routine expects sigchld to be blocked.
  */
Index: src/bin/mksh/lalloc.c
diff -u src/bin/mksh/lalloc.c:1.11 src/bin/mksh/lalloc.c:1.13
--- src/bin/mksh/lalloc.c:1.11	Sat Aug  8 13:08:51 2009
+++ src/bin/mksh/lalloc.c	Tue Sep 14 21:26:14 2010
@@ -1,26 +1,26 @@
 /*-
- * Copyright Â© 2009
+ * Copyright (c) 2009, 2010
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
  * are retained or reproduced in an accompanying document, permission
- * is granted to deal in this work without restriction, including unâ
+ * is granted to deal in this work without restriction, including un-
  * limited rights to use, publicly perform, distribute, sell, modify,
  * merge, give away, or sublicence.
  *
- * This work is provided âAS ISâ and WITHOUT WARRANTY of any kind, to
+ * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
  * the utmost extent permitted by applicable law, neither express nor
  * implied; without malicious intent or gross negligence. In no event
  * may a licensor, author or contributor be held liable for indirect,
  * direct, other damage, loss, or other issues arising in any way out
  * of dealing in the work, even if advised of the possibility of such
  * damage or existence of a defect, except proven that it results out
- * of said personâs immediate fault when using the work as intended.
+ * of said person's immediate fault when using the work as intended.
  */
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.11 2009/08/08 13:08:51 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.13 2010/09/14 21:26:14 tg Exp $");
 
 /* build with CPPFLAGS+= -DUSE_REALLOC_MALLOC=0 on ancient systems */
 #if defined(USE_REALLOC_MALLOC) && (USE_REALLOC_MALLOC == 0)
@@ -61,12 +61,22 @@
 #ifndef MKSH_SMALL
  fail:
 #endif
-			internal_errorf("rogue pointer %p", ptr);
+			internal_errorf("rogue pointer %lX",
+			    (long)(ptrdiff_t)ptr);
 		}
 	return (ap);
 }
 
 void *
+aresize2(void *ptr, size_t fac1, size_t fac2, Area *ap)
+{
+	if (fac1 && fac2 && (SIZE_MAX / fac1 < fac2))
+		internal_errorf(T_intovfl, (unsigned long)fac1, '*',
+		    (unsigned long)fac2);
+	return (aresize(ptr, fac1 * fac2, ap));
+}
+
+void *
 aresize(void *ptr, size_t numb, Area *ap)
 {
 	ALLOC_ITEM *lp = NULL;
@@ -79,13 +89,13 @@
 		pp->next = lp->next;
 	}
 
-	if ((numb >= SIZE_MAX - ALLOC_SIZE) ||
+	if (notoktoadd(numb, ALLOC_SIZE) ||
 	    (lp = remalloc(lp, numb + ALLOC_SIZE)) == NULL
 #ifndef MKSH_SMALL
 	    || ALLOC_ISUNALIGNED(lp)
 #endif
 	    )
-		internal_errorf("cannot allocate %lu data bytes",
+		internal_errorf("can't allocate %lu data bytes",
 		    (unsigned long)numb);
 	/* this only works because Area is an ALLOC_ITEM */
 	lp->next = ap->next;
Index: src/bin/mksh/lex.c
diff -u src/bin/mksh/lex.c:1.110 src/bin/mksh/lex.c:1.121
--- src/bin/mksh/lex.c:1.110	Thu Feb 25 20:18:16 2010
+++ src/bin/mksh/lex.c	Tue Sep 14 21:26:14 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.110 2010/02/25 20:18:16 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.121 2010/09/14 21:26:14 tg Exp $");
 
 /*
  * states while lexing word
@@ -355,6 +355,7 @@
 					/* FALLTHROUGH */
 				case '\\':
 				case '$': case '`':
+ store_qchar:
 					*wp++ = QCHAR;
 					*wp++ = c;
 					break;
@@ -687,15 +688,31 @@
 			*wp++ = c;
 			break;
 
+		case SQBRACE:
+			if (c == '\\') {
+				/*
+				 * perform POSIX "quote removal" if the back-
+				 * slash is "special", i.e. same cases as the
+				 * {case '\\':} in Subst: plus closing brace;
+				 * in mksh code "quote removal" on '\c' means
+				 * write QCHAR+c, otherwise CHAR+\+CHAR+c are
+				 * emitted (in heredocquote:)
+				 */
+				if ((c = getsc()) == '"' || c == '\\' ||
+				    c == '$' || c == '`' || c == /*{*/'}')
+					goto store_qchar;
+				goto heredocquote;
+			}
+			goto common_SQBRACE;
+
 		case SBRACE:
 			if (c == '\'')
 				goto open_ssquote;
-			/* FALLTHROUGH */
-		case SQBRACE:
-			if (c == '"')
-				goto open_sdquote;
 			else if (c == '\\')
 				goto getsc_qchar;
+ common_SQBRACE:
+			if (c == '"')
+				goto open_sdquote;
 			else if (c == '$')
 				goto subst_dollar;
 			else if (c == '`')
@@ -708,9 +725,8 @@
 			break;
 
 		case STBRACE:
-			/* Same as SBRACE, except (,|,) treated specially */
-			/*{*/
-			if (c == '}') {
+			/* Same as SBASE, except (,|,) treated specially */
+			if (c == /*{*/ '}') {
 				POP_STATE();
 				*wp++ = CSUBST;
 				*wp++ = /*{*/ '}';
@@ -928,7 +944,7 @@
 
 #ifndef MKSH_SMALL
 	if (state == SLETARRAY && statep->ls_sletarray.nparen != -1)
-		yyerror("%s: ')' missing\n", T_synerr);
+		yyerror("%s: %s\n", T_synerr, "missing )");
 #endif
 
 	/* This done to avoid tests for SHEREDELIM wherever SBASE tested */
@@ -1094,7 +1110,7 @@
 			else {
 				Source *s = source;
 
-				while (s->flags & SF_HASALIAS)
+				while (s && (s->flags & SF_HASALIAS))
 					if (s->u.tblp == p)
 						return (LWORD);
 					else
@@ -1191,7 +1207,8 @@
 		ungetsc(c);
 		while ((c = getsc()) != '\n') {
 			if (c == 0)
-				yyerror("here document '%s' unclosed\n", eof);
+				yyerror("%s '%s' unclosed\n", "here document",
+				    eof);
 			Xcheck(xs, xp);
 			Xput(xs, xp, c);
 		}
@@ -1232,19 +1249,12 @@
 	Source *s;
 
 	s = alloc(sizeof(Source), areap);
+	memset(s, 0, sizeof(Source));
 	s->type = type;
 	s->str = null;
-	s->start = NULL;
-	s->line = 0;
-	s->errline = 0;
-	s->file = NULL;
-	s->flags = 0;
-	s->next = NULL;
 	s->areap = areap;
 	if (type == SFILE || type == SSTDIN)
 		XinitN(s->xs, 256, s->areap);
-	else
-		memset(&s->xs, 0, sizeof(s->xs));
 	return (s);
 }
 
@@ -1376,6 +1386,8 @@
 		ksh_tmout_state = TMOUT_READING;
 		alarm(ksh_tmout);
 	}
+	if (interactive)
+		change_winsz();
 	if (have_tty && (
 #if !MKSH_S_NOVI
 	    Flag(FVI) ||
@@ -1389,9 +1401,9 @@
 		xp[nread] = '\0';
 		xp += nread;
 	} else {
-		if (interactive) {
+		if (interactive)
 			pprompt(prompt, 0);
-		} else
+		else
 			s->line++;
 
 		while (1) {
@@ -1434,7 +1446,7 @@
 		int linelen;
 
 		linelen = Xlength(s->xs, xp);
-		XcheckN(s->xs, xp, fc_e_n + /* NUL */ 1);
+		XcheckN(s->xs, xp, Tn_fc_e_ + /* NUL */ 1);
 		/* reload after potential realloc */
 		cp = Xstring(s->xs, xp);
 		/* change initial '!' into space */
@@ -1442,10 +1454,10 @@
 		/* NUL terminate the current string */
 		*xp = '\0';
 		/* move the actual string forward */
-		memmove(cp + fc_e_n, cp, linelen + /* NUL */ 1);
-		xp += fc_e_n;
+		memmove(cp + Tn_fc_e_, cp, linelen + /* NUL */ 1);
+		xp += Tn_fc_e_;
 		/* prepend it with "fc -e -" */
-		memcpy(cp, fc_e_, fc_e_n);
+		memcpy(cp, T_fc_e_, Tn_fc_e_);
 	}
 #endif
 	s->start = s->str = cp;
@@ -1737,12 +1749,12 @@
 static Lex_state *
 push_state_(State_info *si, Lex_state *old_end)
 {
-	Lex_state *new = alloc(STATE_BSIZE * sizeof(Lex_state), ATEMP);
+	Lex_state *news = alloc2(STATE_BSIZE, sizeof(Lex_state), ATEMP);
 
-	new[0].ls_info.base = old_end;
-	si->base = &new[0];
-	si->end = &new[STATE_BSIZE];
-	return (&new[1]);
+	news[0].ls_info.base = old_end;
+	si->base = &news[0];
+	si->end = &news[STATE_BSIZE];
+	return (&news[1]);
 }
 
 static Lex_state *
Index: src/bin/mksh/main.c
diff -u src/bin/mksh/main.c:1.162 src/bin/mksh/main.c:1.172
--- src/bin/mksh/main.c:1.162	Fri Jan 29 09:34:29 2010
+++ src/bin/mksh/main.c	Tue Sep 14 21:26:14 2010
@@ -1,4 +1,4 @@
-/*	$OpenBSD: main.c,v 1.45 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: main.c,v 1.46 2010/05/19 17:36:08 jasper Exp $	*/
 /*	$OpenBSD: tty.c,v 1.9 2006/03/14 22:08:01 deraadt Exp $	*/
 /*	$OpenBSD: io.c,v 1.22 2006/03/17 16:30:13 millert Exp $	*/
 /*	$OpenBSD: table.c,v 1.13 2009/01/17 22:06:44 millert Exp $	*/
@@ -33,7 +33,7 @@
 #include <locale.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/main.c,v 1.162 2010/01/29 09:34:29 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/main.c,v 1.172 2010/09/14 21:26:14 tg Exp $");
 
 extern char **environ;
 
@@ -42,10 +42,21 @@
 extern gid_t kshgid, kshegid;
 #endif
 
+#ifndef MKSHRC_PATH
+#define MKSHRC_PATH	"~/.mkshrc"
+#endif
+
+#ifndef MKSH_DEFAULT_TMPDIR
+#define MKSH_DEFAULT_TMPDIR	"/tmp"
+#endif
+
 static void reclaim(void);
 static void remove_temps(struct temp *);
 void chvt_reinit(void);
 Source *mksh_init(int, const char *[]);
+#ifdef SIGWINCH
+static void x_sigwinch(int);
+#endif
 
 static const char initifs[] = "IFS= \t\n";
 
@@ -57,13 +68,15 @@
 	T_typeset, "-x", "HOME", "PATH", "RANDOM", "SHELL", NULL,
 	T_typeset, "-i10", "COLUMNS", "LINES", "OPTIND", "PGRP", "PPID",
 	    "RANDOM", "SECONDS", "TMOUT", "USER_ID", NULL,
-	"alias",
+	T_alias,
 	"integer=typeset -i",
 	T_local_typeset,
 	"hash=alias -t",	/* not "alias -t --": hash -r needs to work */
 	"type=whence -v",
 #ifndef MKSH_UNEMPLOYED
+#ifndef ANDROID
 	"stop=kill -STOP",
+#endif
 	"suspend=kill -STOP $$",
 #endif
 	"autoload=typeset -fu",
@@ -71,12 +84,12 @@
 	"history=fc -l",
 	"nameref=typeset -n",
 	"nohup=nohup ",
-	r_fc_e_,
+	T_r_fc_e_,
 	"source=PATH=$PATH:. command .",
 	"login=exec login",
 	NULL,
 	 /* this is what AT&T ksh seems to track, with the addition of emacs */
-	"alias", "-tU",
+	T_alias, "-tU",
 	"cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
 	"make", "mv", "pr", "rm", "sed", "sh", "vi", "who", NULL,
 	NULL
@@ -84,8 +97,7 @@
 
 static int initio_done;
 
-static struct env env;
-struct env *e = &env;
+struct env *e = &kshstate_v.env_;
 
 void
 chvt_reinit(void)
@@ -94,10 +106,6 @@
 	ksheuid = geteuid();
 	kshpgrp = getpgrp();
 	kshppid = getppid();
-
-#if !HAVE_ARC4RANDOM
-	change_random(&kshstate_, sizeof(kshstate_));
-#endif
 }
 
 Source *
@@ -111,7 +119,7 @@
 	struct tbl *vp;
 	struct stat s_stdin;
 #if !defined(_PATH_DEFPATH) && defined(_CS_PATH)
-	size_t k;
+	ssize_t k;
 	char *cp;
 #endif
 
@@ -132,8 +140,8 @@
 	ainit(&aperm);		/* initialise permanent Area */
 
 	/* set up base environment */
-	env.type = E_NONE;
-	ainit(&env.area);
+	kshstate_v.env_.type = E_NONE;
+	ainit(&kshstate_v.env_.area);
 	newblock();		/* set up global l->vars and l->funs */
 
 	/* Do this first so output routines (eg, errorf, shellf) can work */
@@ -173,7 +181,7 @@
 	def_path = _PATH_DEFPATH;
 #else
 #ifdef _CS_PATH
-	if ((k = confstr(_CS_PATH, NULL, 0)) != (size_t)-1 && k > 0 &&
+	if ((k = confstr(_CS_PATH, NULL, 0)) > 0 &&
 	    confstr(_CS_PATH, cp = alloc(k + 1, APERM), k + 1) == k + 1)
 		def_path = cp;
 	else
@@ -286,13 +294,10 @@
 	vp->flag |= INT_U;
 	setint((vp = global("PPID")), (mksh_uari_t)kshppid);
 	vp->flag |= INT_U;
-	setint((vp = global("RANDOM")), (mksh_uari_t)hash(kshname));
+	setint((vp = global("RANDOM")), (mksh_uari_t)evilhash(kshname));
 	vp->flag |= INT_U;
 	setint((vp = global("USER_ID")), (mksh_uari_t)ksheuid);
 	vp->flag |= INT_U;
-#if HAVE_ARC4RANDOM
-	Flag(FARC4RANDOM) = 1;		/* initialised */
-#endif
 
 	/* Set this before parsing arguments */
 #if HAVE_SETRESUGID
@@ -320,7 +325,7 @@
 	if (Flag(FCOMMAND)) {
 		s = pushs(SSTRING, ATEMP);
 		if (!(s->start = s->str = argv[argi++]))
-			errorf("-c requires an argument");
+			errorf("%s %s", "-c", "requires an argument");
 #ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
 		/* compatibility to MidnightBSD 0.1 /bin/sh (kludge) */
 		if (Flag(FSH) && argv[argi] && !strcmp(argv[argi], "--"))
@@ -334,7 +339,7 @@
 		s->u.shf = shf_open(s->file, O_RDONLY, 0,
 		    SHF_MAPHI | SHF_CLEXEC);
 		if (s->u.shf == NULL) {
-			shl_stdout_ok = 0;
+			shl_stdout_ok = false;
 			warningf(true, "%s: %s", s->file, strerror(errno));
 			/* mandated by SUSv4 */
 			exstat = 127;
@@ -399,6 +404,12 @@
 		x_init();
 	}
 
+#ifdef SIGWINCH
+	sigtraps[SIGWINCH].flags |= TF_SHELL_USES;
+	setsig(&sigtraps[SIGWINCH], x_sigwinch,
+	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
+#endif
+
 	l = e->loc;
 	l->argv = &argv[argi - 1];
 	l->argc = argc - argi;
@@ -415,7 +426,7 @@
 	 * user will know why things broke.
 	 */
 	if (!current_wd[0] && Flag(FTALKING))
-		warningf(false, "Cannot determine current working directory");
+		warningf(false, "can't determine current directory");
 
 	if (Flag(FLOGIN)) {
 		include(KSH_SYSTEM_PROFILE, 0, NULL, 1);
@@ -429,7 +440,7 @@
 		char *env_file;
 
 		/* include $ENV */
-		env_file = substitute(substitute("${ENV:-~/.mkshrc}", 0),
+		env_file = substitute(substitute("${ENV:-" MKSHRC_PATH "}", 0),
 		    DOTILDE);
 		if (*env_file != '\0')
 			include(env_file, 0, NULL, 1);
@@ -461,9 +472,14 @@
 {
 	Source *s;
 
-	if ((s = mksh_init(argc, argv)))
-		/* doesnât return */
+	kshstate_v.lcg_state_ = 5381;
+
+	if ((s = mksh_init(argc, argv))) {
+		/* put more entropy into the LCG */
+		change_random(s, sizeof(*s));
+		/* doesn't return */
 		shell(s, true);
+	}
 	return (1);
 }
 
@@ -512,7 +528,7 @@
 			unwind(i);
 			/* NOTREACHED */
 		default:
-			internal_errorf("include: %d", i);
+			internal_errorf("%s %d", "include", i);
 			/* NOTREACHED */
 		}
 	}
@@ -532,13 +548,15 @@
 	return (i & 0xff);	/* & 0xff to ensure value not -1 */
 }
 
+/* spawn a command into a shell optionally keeping track of the line number */
 int
-command(const char *comm)
+command(const char *comm, int line)
 {
 	Source *s;
 
 	s = pushs(SSTRING, ATEMP);
 	s->start = s->str = comm;
+	s->line = line;
 	return (shell(s, false));
 }
 
@@ -596,7 +614,7 @@
 		default:
 			source = old_source;
 			quitenv(NULL);
-			internal_errorf("shell: %d", i);
+			internal_errorf("%s %d", "shell", i);
 			/* NOTREACHED */
 		}
 	}
@@ -617,7 +635,7 @@
 		t = compile(s);
 		if (t != NULL && t->type == TEOF) {
 			if (wastty && Flag(FIGNOREEOF) && --attempts > 0) {
-				shellf("Use 'exit' to leave ksh\n");
+				shellf("Use 'exit' to leave mksh\n");
 				s->type = SSTDIN;
 			} else if (wastty && !really_exit &&
 			    j_stopped_running()) {
@@ -841,8 +859,8 @@
 	if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
 		tty_devtty = 0;
 		if (need_tty)
-			warningf(false,
-			    "No controlling tty (open /dev/tty: %s)",
+			warningf(false, "%s: %s %s: %s",
+			    "No controlling tty", "open", "/dev/tty",
 			    strerror(errno));
 	}
 	if (tfd < 0) {
@@ -853,20 +871,18 @@
 			tfd = 2;
 		else {
 			if (need_tty)
-				warningf(false,
-				    "Can't find tty file descriptor");
+				warningf(false, "can't find tty fd");
 			return;
 		}
 	}
 	if ((tty_fd = fcntl(tfd, F_DUPFD, FDBASE)) < 0) {
 		if (need_tty)
-			warningf(false, "j_ttyinit: dup of tty fd failed: %s",
-			    strerror(errno));
+			warningf(false, "%s: %s %s: %s", "j_ttyinit",
+			    "dup of tty fd", "failed", strerror(errno));
 	} else if (fcntl(tty_fd, F_SETFD, FD_CLOEXEC) < 0) {
 		if (need_tty)
-			warningf(false,
-			    "j_ttyinit: can't set close-on-exec flag: %s",
-			    strerror(errno));
+			warningf(false, "%s: %s: %s", "j_ttyinit",
+			    "can't set close-on-exec flag", strerror(errno));
 		close(tty_fd);
 		tty_fd = -1;
 	} else if (init_ttystate)
@@ -890,7 +906,7 @@
 {
 	va_list va;
 
-	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
+	shl_stdout_ok = false;	/* debugging: note that stdout not valid */
 	exstat = 1;
 	if (*fmt != 1) {
 		error_prefix(true);
@@ -925,7 +941,7 @@
 {
 	va_list va;
 
-	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
+	shl_stdout_ok = false;	/* debugging: note that stdout not valid */
 	exstat = 1;
 	if (*fmt != 1) {
 		error_prefix(true);
@@ -1243,13 +1259,14 @@
 	char *pathname;
 	const char *dir;
 
-	dir = tmpdir ? tmpdir : "/tmp";
+	dir = tmpdir ? tmpdir : MKSH_DEFAULT_TMPDIR;
 #if HAVE_MKSTEMP
 	len = strlen(dir) + 6 + 10 + 1;
 #else
 	pathname = tempnam(dir, "mksh.");
 	len = ((pathname == NULL) ? 0 : strlen(pathname)) + 1;
 #endif
+	/* reasonably sure that this will not overflow */
 	tp = alloc(sizeof(struct temp) + len, ap);
 	tp->name = (char *)&tp[1];
 #if !HAVE_MKSTEMP
@@ -1264,7 +1281,7 @@
 	tp->shf = NULL;
 	tp->type = type;
 #if HAVE_MKSTEMP
-	shf_snprintf(pathname, len, "%s/mksh.XXXXXXXXXX", dir);
+	shf_snprintf(pathname, len, "%s%s", dir, "/mksh.XXXXXXXXXX");
 	if ((fd = mkstemp(pathname)) >= 0)
 #else
 	if (tp->name[0] && (fd = open(tp->name, O_CREAT | O_RDWR, 0600)) >= 0)
@@ -1290,26 +1307,6 @@
 static struct tbl *ktscan(struct table *, const char *, uint32_t,
     struct tbl ***);
 
-/* Bob Jenkins' one-at-a-time hash */
-uint32_t
-oaathash_full(register const uint8_t *bp)
-{
-	register uint32_t h = 0;
-	register uint8_t c;
-
-	while ((c = *bp++)) {
-		h += c;
-		h += h << 10;
-		h ^= h >> 6;
-	}
-
-	h += h << 3;
-	h ^= h >> 11;
-	h += h << 15;
-
-	return (h);
-}
-
 static void
 texpand(struct table *tp, size_t nsize)
 {
@@ -1317,7 +1314,7 @@
 	struct tbl *tblp, **pp;
 	struct tbl **ntblp, **otblp = tp->tbls;
 
-	ntblp = alloc(nsize * sizeof(struct tbl *), tp->areap);
+	ntblp = alloc2(nsize, sizeof(struct tbl *), tp->areap);
 	for (i = 0; i < nsize; i++)
 		ntblp[i] = NULL;
 	tp->size = nsize;
@@ -1396,7 +1393,7 @@
 ktenter(struct table *tp, const char *n, uint32_t h)
 {
 	struct tbl **pp, *p;
-	int len;
+	size_t len;
 
 	if (tp->size == 0)
 		texpand(tp, INIT_TBLS);
@@ -1411,8 +1408,9 @@
 	}
 
 	/* create new tbl entry */
-	len = strlen(n) + 1;
-	p = alloc(offsetof(struct tbl, name[0]) + len, tp->areap);
+	len = strlen(n);
+	checkoktoadd(len, offsetof(struct tbl, name[0]) + 1);
+	p = alloc(offsetof(struct tbl, name[0]) + ++len, tp->areap);
 	p->flag = 0;
 	p->type = 0;
 	p->areap = tp->areap;
@@ -1460,7 +1458,8 @@
 	size_t i;
 	struct tbl **p, **sp, **dp;
 
-	p = alloc((tp->size + 1) * sizeof(struct tbl *), ATEMP);
+	/* tp->size + 1 will not overflow */
+	p = alloc2(tp->size + 1, sizeof(struct tbl *), ATEMP);
 	sp = tp->tbls;		/* source */
 	dp = p;			/* dest */
 	i = (size_t)tp->size;
@@ -1472,3 +1471,13 @@
 	p[i] = NULL;
 	return (p);
 }
+
+#ifdef SIGWINCH
+static void
+x_sigwinch(int sig MKSH_A_UNUSED)
+{
+	/* this runs inside interrupt context, with errno saved */
+
+	got_winch = 1;
+}
+#endif
Index: src/bin/mksh/misc.c
diff -u src/bin/mksh/misc.c:1.138 src/bin/mksh/misc.c:1.148
--- src/bin/mksh/misc.c:1.138	Fri Jan 29 09:34:29 2010
+++ src/bin/mksh/misc.c	Sun Sep 19 19:28:22 2010
@@ -29,7 +29,7 @@
 #include <grp.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.138 2010/01/29 09:34:29 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.148 2010/09/19 19:28:22 tg Exp $");
 
 unsigned char chtypes[UCHAR_MAX + 1];	/* type bits for unsigned char */
 
@@ -45,6 +45,17 @@
 static void chvt(const char *);
 #endif
 
+#ifdef SETUID_CAN_FAIL_WITH_EAGAIN
+/* we don't need to check for other codes, EPERM won't happen */
+#define DO_SETUID(func, argvec) do {					\
+	if ((func argvec) && errno == EAGAIN)				\
+		errorf("%s failed with EAGAIN, probably due to a"	\
+		    " too low process limit; aborting", #func);		\
+} while (/* CONSTCOND */ 0)
+#else
+#define DO_SETUID(func, argvec) func argvec
+#endif
+
 /*
  * Fast character classes
  */
@@ -82,12 +93,15 @@
 
 /* called from XcheckN() to grow buffer */
 char *
-Xcheck_grow_(XString *xsp, const char *xp, unsigned int more)
+Xcheck_grow_(XString *xsp, const char *xp, size_t more)
 {
 	const char *old_beg = xsp->beg;
 
-	xsp->len += more > xsp->len ? more : xsp->len;
-	xsp->beg = aresize(xsp->beg, xsp->len + 8, xsp->areap);
+	if (more < xsp->len)
+		more = xsp->len;
+	/* (xsp->len + X_EXTRA) never overflows */
+	checkoktoadd(more, xsp->len + X_EXTRA);
+	xsp->beg = aresize(xsp->beg, (xsp->len += more) + X_EXTRA, xsp->areap);
 	xsp->end = xsp->beg + xsp->len;
 	return (xsp->beg + (xp - old_beg));
 }
@@ -167,11 +181,12 @@
 		print_columns(shl_stdout, n, options_fmt_entry, &oi,
 		    octs + 4, oi.opt_width + 4, true);
 	} else {
-		/* short version Ã¡ la AT&T ksh93 */
-		shf_puts("set", shl_stdout);
+		/* short version like AT&T ksh93 */
+		shf_puts(T_set, shl_stdout);
 		while (i < (int)NELEM(options)) {
 			if (Flag(i) && options[i].name)
-				shprintf(" -o %s", options[i].name);
+				shprintf("%s %s %s", null, "-o",
+				    options[i].name);
 			++i;
 		}
 		shf_putc('\n', shl_stdout);
@@ -221,14 +236,16 @@
 #if HAVE_SETRESUGID
 		gid_t kshegid = getgid();
 
-		setresgid(kshegid, kshegid, kshegid);
+		DO_SETUID(setresgid, (kshegid, kshegid, kshegid));
 #if HAVE_SETGROUPS
+		/* setgroups doesn't EAGAIN on Linux */
 		setgroups(1, &kshegid);
 #endif
-		setresuid(ksheuid, ksheuid, ksheuid);
+		DO_SETUID(setresuid, (ksheuid, ksheuid, ksheuid));
 #else
+		/* seteuid, setegid, setgid don't EAGAIN on Linux */
 		seteuid(ksheuid = kshuid = getuid());
-		setuid(ksheuid);
+		DO_SETUID(setuid, (ksheuid));
 		setegid(kshegid = kshgid = getgid());
 		setgid(kshegid);
 #endif
@@ -329,6 +346,14 @@
 				break;
 			}
 			i = option(go.optarg);
+#ifndef MKSH_NO_DEPRECATED_WARNING
+			if ((enum sh_flag)i == FARC4RANDOM) {
+				warningf(true, "Do not use set Â±o arc4random,"
+				    " it will be removed in the next version"
+				    " of mksh!");
+				return (0);
+			}
+#endif
 			if ((i != (size_t)-1) && set == Flag(i))
 				/* Don't check the context if the flag
 				 * isn't changing - makes "set -o interactive"
@@ -339,7 +364,7 @@
 			else if ((i != (size_t)-1) && (options[i].flags & what))
 				change_flag((enum sh_flag)i, what, set);
 			else {
-				bi_errorf("%s: bad option", go.optarg);
+				bi_errorf("%s: %s", go.optarg, "bad option");
 				return (-1);
 			}
 			break;
@@ -393,7 +418,7 @@
 		    argv[go.optind]);
 
 	if (arrayset && (!*array || *skip_varname(array, false))) {
-		bi_errorf("%s: is not an identifier", array);
+		bi_errorf("%s: %s", array, "is not an identifier");
 		return (-1);
 	}
 	if (sortargs) {
@@ -450,7 +475,7 @@
 	int rv;
 
 	if (!(rv = getn(as, ai)))
-		bi_errorf("%s: bad number", as);
+		bi_errorf("%s: %s", as, "bad number");
 	return (rv);
 }
 
@@ -689,19 +714,21 @@
 static const unsigned char *
 cclass(const unsigned char *p, int sub)
 {
-	int c, d, not, found = 0;
+	int c, d, notp, found = 0;
 	const unsigned char *orig_p = p;
 
-	if ((not = (ISMAGIC(*p) && *++p == NOT)))
+	if ((notp = (ISMAGIC(*p) && *++p == NOT)))
 		p++;
 	do {
 		c = *p++;
 		if (ISMAGIC(c)) {
 			c = *p++;
 			if ((c & 0x80) && !ISMAGIC(c)) {
-				c &= 0x7f;/* extended pattern matching: *+?@! */
+				/* extended pattern matching: *+?@! */
+				c &= 0x7F;
 				/* XXX the ( char isn't handled as part of [] */
-				if (c == ' ') /* simile for @: plain (..) */
+				if (c == ' ')
+					/* simile for @: plain (..) */
 					c = '(' /*)*/;
 			}
 		}
@@ -726,7 +753,7 @@
 			found = 1;
 	} while (!(ISMAGIC(p[0]) && p[1] == ']'));
 
-	return ((found != not) ? p+2 : NULL);
+	return ((found != notp) ? p+2 : NULL);
 }
 
 /* Look for next ) or | (if match_sep) in *(foo|bar) pattern */
@@ -824,9 +851,10 @@
 			go->buf[0] = c;
 			go->optarg = go->buf;
 		} else {
-			warningf(true, "%s%s-%c: unknown option",
+			warningf(true, "%s%s-%c: %s",
 			    (go->flags & GF_NONAME) ? "" : argv[0],
-			    (go->flags & GF_NONAME) ? "" : ": ", c);
+			    (go->flags & GF_NONAME) ? "" : ": ", c,
+			    "unknown option");
 			if (go->flags & GF_ERROR)
 				bi_errorfz();
 		}
@@ -850,9 +878,10 @@
 				go->optarg = go->buf;
 				return (':');
 			}
-			warningf(true, "%s%s-'%c' requires argument",
+			warningf(true, "%s%s-%c: %s",
 			    (go->flags & GF_NONAME) ? "" : argv[0],
-			    (go->flags & GF_NONAME) ? "" : ": ", c);
+			    (go->flags & GF_NONAME) ? "" : ": ", c,
+			    "requires an argument");
 			if (go->flags & GF_ERROR)
 				bi_errorfz();
 			return ('?');
@@ -1013,19 +1042,20 @@
 	}
 }
 
-/* Like read(2), but if read fails due to non-blocking flag, resets flag
- * and restarts read.
+/*
+ * Like read(2), but if read fails due to non-blocking flag,
+ * resets flag and restarts read.
  */
-int
-blocking_read(int fd, char *buf, int nbytes)
+ssize_t
+blocking_read(int fd, char *buf, size_t nbytes)
 {
-	int ret;
-	int tried_reset = 0;
+	ssize_t ret;
+	bool tried_reset = false;
 
 	while ((ret = read(fd, buf, nbytes)) < 0) {
 		if (!tried_reset && errno == EAGAIN) {
 			if (reset_nonblock(fd) > 0) {
-				tried_reset = 1;
+				tried_reset = true;
 				continue;
 			}
 			errno = EAGAIN;
@@ -1035,7 +1065,8 @@
 	return (ret);
 }
 
-/* Reset the non-blocking flag on the specified file descriptor.
+/*
+ * Reset the non-blocking flag on the specified file descriptor.
  * Returns -1 if there was an error, 0 if non-blocking wasn't set,
  * 1 if it was.
  */
@@ -1266,6 +1297,9 @@
 	struct stat sb;
 	int fd;
 
+	/* for entropy */
+	kshstate_f.h = evilhash(fn);
+
 	if (*fn == '-') {
 		memcpy(dv, "-/dev/null", sizeof("-/dev/null"));
 		fn = dv + 1;
@@ -1276,42 +1310,44 @@
 			if (stat(dv, &sb)) {
 				strlcpy(dv + 8, fn, sizeof(dv) - 8);
 				if (stat(dv, &sb))
-					errorf("chvt: can't find tty %s", fn);
+					errorf("%s: %s %s", "chvt",
+					    "can't find tty", fn);
 			}
 			fn = dv;
 		}
 		if (!(sb.st_mode & S_IFCHR))
-			errorf("chvt: not a char device: %s", fn);
+			errorf("%s %s %s", "chvt: not a char", "device", fn);
 		if ((sb.st_uid != 0) && chown(fn, 0, 0))
-			warningf(false, "chvt: cannot chown root %s", fn);
+			warningf(false, "%s: %s %s", "chvt", "can't chown root", fn);
 		if (((sb.st_mode & 07777) != 0600) && chmod(fn, (mode_t)0600))
-			warningf(false, "chvt: cannot chmod 0600 %s", fn);
+			warningf(false, "%s: %s %s", "chvt", "can't chmod 0600", fn);
 #if HAVE_REVOKE
 		if (revoke(fn))
 #endif
-			warningf(false, "chvt: cannot revoke %s, new shell is"
-			    " potentially insecure", fn);
+			warningf(false, "%s: %s %s", "chvt",
+			    "new shell is potentially insecure, can't revoke",
+			    fn);
 	}
 	if ((fd = open(fn, O_RDWR)) == -1) {
 		sleep(1);
 		if ((fd = open(fn, O_RDWR)) == -1)
-			errorf("chvt: cannot open %s", fn);
+			errorf("%s: %s %s", "chvt", "can't open", fn);
 	}
 	switch (fork()) {
 	case -1:
-		errorf("chvt: %s failed", "fork");
+		errorf("%s: %s %s", "chvt", "fork", "failed");
 	case 0:
 		break;
 	default:
 		exit(0);
 	}
 	if (setsid() == -1)
-		errorf("chvt: %s failed", "setsid");
+		errorf("%s: %s %s", "chvt", "setsid", "failed");
 	if (fn != dv + 1) {
 		if (ioctl(fd, TIOCSCTTY, NULL) == -1)
-			errorf("chvt: %s failed", "TIOCSCTTY");
+			errorf("%s: %s %s", "chvt", "TIOCSCTTY", "failed");
 		if (tcflush(fd, TCIOFLUSH))
-			errorf("chvt: %s failed", "TCIOFLUSH");
+			errorf("%s: %s %s", "chvt", "TCIOFLUSH", "failed");
 	}
 	ksh_dup2(fd, 0, false);
 	ksh_dup2(fd, 1, false);
Index: src/bin/mksh/mksh.1
diff -u src/bin/mksh/mksh.1:1.217 src/bin/mksh/mksh.1:1.241
--- src/bin/mksh/mksh.1:1.217	Thu Feb 25 21:05:00 2010
+++ src/bin/mksh/mksh.1	Fri Sep 24 20:21:43 2010
@@ -1,5 +1,5 @@
-.\" $MirOS: src/bin/mksh/mksh.1,v 1.217 2010/02/25 21:05:00 tg Exp $
-.\" $OpenBSD: ksh.1,v 1.130 2010/02/25 13:45:54 schwarze Exp $
+.\" $MirOS: src/bin/mksh/mksh.1,v 1.241 2010/09/24 20:21:43 tg Exp $
+.\" $OpenBSD: ksh.1,v 1.138 2010/09/20 07:41:17 jmc Exp $
 .\"-
 .\" Copyright Â© 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 .\"	Thorsten Glaser <tg@mirbsd.org>
@@ -71,7 +71,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: February 25 2010 $
+.Dd $Mdocdate: September 24 2010 $
 .\"
 .\" Check which macro package we use
 .\"
@@ -154,9 +154,12 @@
 .Op Fl +abCefhiklmnprUuvXx
 .Op Fl T Ar /dev/ttyCn | \-
 .Op Fl +o Ar option
-.Oo Fl c Ar string \*(Ba Fl s \*(Ba
-.Ar \ file\ \&
-.Op Ar argument ... Oc
+.Oo
+.Fl c Ar string \*(Ba
+.Fl s \*(Ba
+.Ar file
+.Op Ar argument ...
+.Oc
 .Ek
 .Sh DESCRIPTION
 .Nm
@@ -386,7 +389,7 @@
 is used in
 .Ic case
 statements;
-.Ql (( .. ))
+.Ql \&(( .. ))
 is used in arithmetic expressions;
 and lastly,
 .Ql \&( .. )\&
@@ -595,21 +598,12 @@
 word of a command (i.e. they can't be preceded by parameter assignments or
 redirections):
 .Bd -literal -offset indent
-case     else     function     then      !
-do       esac     if           time      [[
+case     else     function     then      !       (
+do       esac     if           time      [[      ((
 done     fi       in           until     {
 elif     for      select       while     }
 .Ed
 .Pp
-.Sy Note :
-Some shells (but not this one) execute control structure commands in a
-subshell when one or more of their file descriptors are redirected, so any
-environment changes inside them may fail.
-To be portable, the
-.Ic exec
-statement should be used instead to redirect file descriptors before the
-control structure.
-.Pp
 In the following compound command descriptions, command lists (denoted as
 .Em list )
 that are followed by reserved words must end with a semicolon, a newline, or
@@ -641,7 +635,7 @@
 .Ql }
 are reserved words, not meta-characters.
 .It Xo case Ar word No in
-.Oo Op (
+.Oo Op \&(
 .Ar \ pattern
 .Op \*(Ba Ar pattern
 .No ... No )
@@ -833,7 +827,7 @@
 Note that redirections specified after a function definition are
 performed whenever the function is executed, not when the function definition
 is executed.
-.It Ar name Ns () Ar command
+.It Ar name Ns \&() Ar command
 Mostly the same as
 .Ic function
 (see
@@ -842,11 +836,11 @@
 Whitespace (space or tab) after
 .Ar name
 will be ignored most of the time.
-.It Xo function Ar name Ns ()
+.It Xo function Ar name Ns \&()
 .No { Ar list ; No }
 .Xc
 The same as
-.Ar name Ns ()
+.Ar name Ns \&()
 .Pq Nm bash Ns ism .
 The
 .Ic function
@@ -859,7 +853,7 @@
 reserved word is described in the
 .Sx Command execution
 section.
-.It (( Ar expression No ))
+.It \&(( Ar expression No ))
 The arithmetic expression
 .Ar expression
 is evaluated; equivalent to
@@ -897,22 +891,6 @@
 .Sq \&! )
 must be unquoted.
 .It
-The second operand of the
-.Sq !=
-and
-.Sq =
-expressions are patterns (e.g. the comparison
-.Ic [[ foobar = f*r ]]
-succeeds).
-.It
-The single argument form of
-.Ic test ,
-which tests if the argument has a non-zero length, is not portable,
-e.g. instead of
-.No \&[ Ar str No \&]
-use
-.No \&[[ \-n Ar str No \&]] .
-.It
 Parameter, command, and arithmetic substitutions are performed as expressions
 are evaluated and lazy expression evaluation is used for the
 .Ql &&
@@ -927,6 +905,23 @@
 .Bd -literal -offset indent
 $ [[ \-r foo && $(\*(Ltfoo) = b*r ]]
 .Ed
+.It
+The second operand of the
+.Sq !=
+and
+.Sq =
+expressions are patterns (e.g. the comparison
+.Ic \&[[ foobar = f*r ]]
+succeeds).
+This even works indirectly:
+.Bd -literal -offset indent
+$ bar=foobar; baz=\*(aqf*r\*(aq
+$ [[ $bar = $baz ]]; echo $?
+$ [[ $bar = "$baz" ]]; echo $?
+.Ed
+.Pp
+Perhaps surprisingly, the first comparision succeeds,
+whereas the second doesn't.
 .El
 .El
 .Ss Quoting
@@ -1232,8 +1227,7 @@
 Note that
 .Ic $(\*(Ltfoo)
 has the same effect as
-.Ic $(cat foo) ,
-but it is carried out more efficiently because no process is started.
+.Ic $(cat foo) .
 .Pp
 .Sy Note :
 .Pf $( Ns Ar command Ns \&)
@@ -1265,9 +1259,9 @@
 where
 .Ar expr
 is an arithmetic expression.
-Array indices are currently limited to the range 0 through 4294967295, (for
+Array indices are currently limited in
 .Nm
-only; portable maximum is 1023), inclusive.
+to the range 0 through 4294967295, inclusive.
 That is, they are a 32-bit unsigned integer.
 Parameter substitutions take the form
 .Pf $ Ns Ar name ,
@@ -1419,9 +1413,11 @@
 Note that, for all of the above,
 .Ar word
 is actually considered quoted, and special parsing rules apply.
-The parsing rules also differ on whether the expression is
-double-quoted with respect to the single quote
-.Pq Dq \*(aq .
+The parsing rules also differ on whether the expression is double-quoted:
+.Ar word
+then uses double-quoting rules, except for the double quote itself
+.Pq Sq \&"
+and the closing brace, which, if backslash escaped, gets quote removal applied.
 .Pp
 In the above modifiers, the
 .Ql \&:
@@ -1450,8 +1446,8 @@
 of the string value of parameter
 .Ar name .
 .Pp
-.It Pf ${# Ns Ar name Ns [*]}
-.It Pf ${# Ns Ar name Ns [@]}
+.It Pf ${# Ns Ar name Ns \&[*]}
+.It Pf ${# Ns Ar name Ns \&[@]}
 The number of elements in the array
 .Ar name .
 .Pp
@@ -1460,7 +1456,7 @@
 .Pq in screen columns
 of the string value of parameter
 .Ar name ,
-or -1 if
+or \-1 if
 .Pf ${ Ns Ar name Ns }
 contains a control character.
 .Pp
@@ -1476,8 +1472,8 @@
 command (which is an alias for
 .Ic typeset Fl n ) .
 .Pp
-.It Pf ${! Ns Ar name Ns [*]}
-.It Pf ${! Ns Ar name Ns [@]}
+.It Pf ${! Ns Ar name Ns \&[*]}
+.It Pf ${! Ns Ar name Ns \&[@]}
 The names of indices (keys) in the array
 .Ar name .
 .Pp
@@ -1887,6 +1883,13 @@
 x=$(print \e\e001)
 PS1="$x$(print \e\er)$x$(tput smso)$x\e$PWD$x$(tput rmso)$x\*(Gt "
 .Ed
+.Pp
+Due to pressure from David G. Korn,
+.Nm
+now also supports the following form:
+.Bd -literal -offset indent
+PS1=$'\e1\er\e1\ee[7m\e1$PWD\e1\ee[0m\e1\*(Gt '
+.Ed
 .It Ev PS2
 Secondary prompt string, by default
 .Sq \*(Gt\ \& ,
@@ -1911,14 +1914,10 @@
 .Dv NULL
 if the shell doesn't know where it is.
 .It Ev RANDOM
-Every time
+Each time
 .Ev RANDOM
-is referenced, it is assigned a 15-bit pseudo-random number, i.e. between
-0 and 32767, first, which is taken from
-.Xr arc4random 3
-if available,
-a Linear Congruential PRNG
-otherwise.
+is referenced, it is assigned a number between 0 and 32767 from
+a Linear Congruential PRNG first.
 .It Ev REPLY
 Default parameter for the
 .Ic read
@@ -2034,7 +2033,7 @@
 or
 .Ql \&!
 characters or
-.Dq [..]
+.Dq \&[..]
 sequences.
 Once brace expansion has been performed, the shell replaces file
 name patterns with the sorted names of all the files that match the pattern
@@ -2045,12 +2044,12 @@
 Matches any single character.
 .It \&*
 Matches any sequence of octets.
-.It [..]
+.It \&[..]
 Matches any of the octets inside the brackets.
 Ranges of octets can be specified by separating two octets by a
 .Ql \-
 (e.g.\&
-.Dq [a0\-9]
+.Dq \&[a0\-9]
 matches the letter
 .Sq a
 or any digit).
@@ -2065,7 +2064,7 @@
 .Ql \&!
 appearing at the start of the list has special meaning (see below), so to
 represent itself it must be quoted or appear later in the list.
-.It [!..]
+.It \&[!..]
 Like [..],
 except it matches any octet not inside the brackets.
 .Sm off
@@ -2164,10 +2163,6 @@
 option is set, any directories that result from file name generation are marked
 with a trailing
 .Ql / .
-.Pp
-The POSIX character classes (i.e.\&
-.Pf [: Ns Ar class-name Ns :]
-inside a [..] expression) are not implemented.
 .Ss Input/output redirection
 When a command is executed, its standard input, standard output, and standard
 error (file descriptors 0, 1, and 2, respectively) are normally inherited from
@@ -2334,7 +2329,11 @@
 any redirections must appear at the end.
 Redirections are processed after
 pipelines are created and in the order they are given, so the following
-will print an error with a line number prepended to it:
+will print an error with a line number prepended to it, if you have a
+.Xr cat 1
+that supports the
+.Fl n
+option:
 .Pp
 .D1 $ cat /foo/bar 2\*(Gt&1 \*(Gt/dev/null \*(Ba cat \-n
 .Pp
@@ -2610,7 +2609,7 @@
 Functions are defined using either Korn shell
 .Ic function Ar function-name
 syntax or the Bourne/POSIX shell
-.Ar function-name Ns ()
+.Ar function-name Ns \&()
 syntax (see below for the difference between the two forms).
 Functions are like
 .Li .\(hyscripts
@@ -2698,7 +2697,7 @@
 .Ic function
 reserved word are treated differently in the following ways from functions
 defined with the
-.Ic ()
+.Ic \&()
 notation:
 .Bl -bullet
 .It
@@ -2787,10 +2786,10 @@
 .Nm
 regular commands
 .Pp
-.Ic \&[ , chdir , bind , echo ,
-.Ic let , mknod , print , printf ,
-.Ic pwd , realpath , rename , test ,
-.Ic ulimit , whence
+.Ic \&[ , chdir , bind , cat ,
+.Ic echo , let , mknod , print ,
+.Ic printf , pwd , realpath , rename ,
+.Ic test , ulimit , whence
 .Pp
 In the future, the additional
 .Nm
@@ -2965,11 +2964,31 @@
 .Ar level
 defaults to 1.
 .Pp
-.It Ic builtin Ar command Op Ar arg ...
+.It Xo
+.Ic builtin
+.Op Fl \-
+.Ar command Op Ar arg ...
+.Xc
 Execute the built-in command
 .Ar command .
 .Pp
 .It Xo
+.Ic cat
+.Op Fl \-
+.Op Ar
+.Xc
+Read files sequentially, in command line order, and write them to
+standard output.
+If
+.Ar file
+is a single dash
+.Pq Sq -
+or absent, read from standard input.
+If any options are given, an external
+.Xr cat 1
+utility is invoked instead.
+.Pp
+.It Xo
 .Ic cd
 .Op Fl LP
 .Op Ar dir
@@ -3412,7 +3431,7 @@
 If an error occurs during
 the parsing or evaluation of an expression, the exit status is greater than 1.
 Since expressions may need to be quoted,
-.No (( Ar expr No ))
+.No \&(( Ar expr No ))
 is syntactic sugar for
 .No let \&" Ns Ar expr Ns \&" .
 .Pp
@@ -3420,7 +3439,7 @@
 .Ic mknod
 .Op Fl m Ar mode
 .Ar name
-.Op Cm b \*(Ba Cm c
+.Cm b\*(Bac
 .Ar major minor
 .Xc
 .It Xo
@@ -3508,14 +3527,14 @@
 .Pp
 .It Ic printf Ar format Op Ar arguments ...
 Formatted output.
-The same as the utility
+Approximately the same as the utility
 .Xr printf 1 ,
-except that it may use the same
+except that it uses the same
 .Sx Backslash expansion
-code as the rest of
+and I/O code as the rest of
 .Nm mksh .
 This is not normally part of
-.Nm mksh ,
+.Nm mksh ;
 however, distributors may have added this as builtin as a speed hack.
 .Pp
 .It Ic pwd Op Fl LP
@@ -3636,8 +3655,20 @@
 .Xc
 Prints the resolved absolute pathname corresponding to
 .Ar name .
+If
+.Ar name
+ends with a slash
+.Pq Sq / ,
+it's also checked for existence and whether it is a directory; otherwise,
+.Ic realpath
+returns 0 if the pathname either exists or can be created immediately,
+i.e. all but the last component exist and are directories.
 .Pp
-.It Ic rename Ar from to
+.It Xo
+.Ic rename
+.Op Fl \-
+.Ar from to
+.Xc
 Renames the file
 .Ar from
 to
@@ -3848,10 +3879,10 @@
 the value of
 .Ev PS4 .
 .It Ic arc4random
-If this shell option, which cannot be unset, exists,
-.Xr arc4random 3
-is used for the value of
-.Ev RANDOM .
+Deprecated, will be removed in
+.Nm
+R40.
+Do not use, emits a warning to stderr.
 .It Ic bgnice
 Background jobs are run with lower priority.
 .It Ic braceexpand
@@ -4229,8 +4260,12 @@
 .Sq Fl n .
 Use tests like
 .Dq if \&[ x\&"$foo\&" = x"bar" \&]
-instead, or the double-bracket operator:
+instead, or the double-bracket operator
 .Dq if \&[[ $foo = bar \&]]
+or, to avoid pattern matching (see
+.Ic \&[[
+above):
+.Dq if \&[[ $foo = "$bar" \&]]
 .Pp
 .It Xo
 .Ic time
@@ -4382,7 +4417,7 @@
 .Pq Ic + .
 Values for parameters may optionally be specified.
 For
-.Ar name Ns [*] ,
+.Ar name Ns \&[*] ,
 the change affects the entire array, and no value may be specified.
 If
 .Ic typeset
@@ -4541,7 +4576,7 @@
 .Pp
 .It Xo
 .Ic ulimit
-.Op Fl acdfHLlmnpSsTtvw
+.Op Fl aBCcdefHiLlMmnOPpqrSsTtVvw
 .Op Ar value
 .Xc
 Display or set process limits.
@@ -4564,6 +4599,13 @@
 Display all limits; unless
 .Fl H
 is used, soft limits are displayed.
+.It Fl B Ar n
+Set the socket buffer size to
+.Ar n
+kibibytes.
+.It Fl C Ar n
+Set the number of cached threads to
+.Ar n .
 .It Fl c Ar n
 Impose a size limit of
 .Ar n
@@ -4572,6 +4614,9 @@
 Impose a size limit of
 .Ar n
 kibibytes on the size of the data area.
+.It Fl e Ar n
+Set the maximum niceness to
+.Ar n .
 .It Fl f Ar n
 Impose a size limit of
 .Ar n
@@ -4579,12 +4624,19 @@
 size may be read).
 .It Fl H
 Set the hard limit only (the default is to set both hard and soft limits).
+.It Fl i Ar n
+Set the number of pending signals to
+.Ar n .
 .It Fl L Ar n
 Control flocks; documentation is missing.
 .It Fl l Ar n
 Impose a limit of
 .Ar n
 kibibytes on the amount of locked (wired) physical memory.
+.It Fl M Ar n
+Set the AIO locked memory to
+.Ar n
+kibibytes.
 .It Fl m Ar n
 Impose a limit of
 .Ar n
@@ -4593,10 +4645,25 @@
 Impose a limit of
 .Ar n
 file descriptors that can be open at once.
+.It Fl O Ar n
+Set the number of AIO operations to
+.Ar n .
+.It Fl P Ar n
+Limit the number of threads per process to
+.Ar n .
 .It Fl p Ar n
 Impose a limit of
 .Ar n
 processes that can be run by the user at any one time.
+.It Fl q Ar n
+Limit the size of
+.Px
+message queues to
+.Ar n
+bytes.
+.It Fl r Ar n
+Set the maximum real-time priority to
+.Ar n .
 .It Fl S
 Set the soft limit only (the default is to set both hard and soft limits).
 .It Fl s Ar n
@@ -4611,6 +4678,9 @@
 Impose a time limit of
 .Ar n
 CPU seconds spent in user mode to be used by each process.
+.It Fl V Ar n
+Set the number of vnode monitors on Haiku to
+.Ar n .
 .It Fl v Ar n
 Impose a limit of
 .Ar n
@@ -4677,9 +4747,12 @@
 or functions
 .Pq Fl f .
 With
-.Ar parameter Ns [*] ,
+.Ar parameter Ns \&[*] ,
 attributes are kept, only values are unset.
 .Pp
+The exit status is non-zero if any of the parameters have the read-only
+attribute set, zero otherwise.
+.Pp
 .It Ic wait Op Ar job ...
 Wait for the specified job(s) to finish.
 The exit status of
@@ -4779,7 +4852,7 @@
 .Pp
 When a job is created, it is assigned a job number.
 For interactive shells, this number is printed inside
-.Dq [..] ,
+.Dq \&[..] ,
 followed by the process IDs of the processes in the job when an asynchronous
 command is run.
 A job may be referred to in the
@@ -5855,6 +5928,7 @@
 Used only if
 .Ev ENV
 is unset or empty.
+The location can be changed at compile time (for embedded systems).
 .It Pa \*(TI/.profile
 User's login profile.
 .It Pa /etc/profile
@@ -5866,6 +5940,7 @@
 .El
 .Sh SEE ALSO
 .Xr awk 1 ,
+.Xr cat 1 ,
 .Xr ed 1 ,
 .Xr getopt 1 ,
 .Xr sed 1 ,
@@ -5881,7 +5956,6 @@
 .Xr pipe 2 ,
 .Xr rename 2 ,
 .Xr wait 2 ,
-.Xr arc4random 3 ,
 .Xr getopt 3 ,
 .Xr nl_langinfo 3 ,
 .Xr setlocale 3 ,
@@ -5969,37 +6043,44 @@
 .Sh CAVEATS
 .Nm
 only supports the Unicode BMP (Basic Multilingual Plane).
-Pipelines are executed in subshells.
 It has a different scope model from
 .At
 .Nm ksh ,
 which leads to subtile differences in semantics for identical builtins.
+.Pp
+The parts of a pipeline, like below, are executed in subshells.
+Thus, variable assignments inside them fail.
+Use co-processes instead.
+.Bd -literal -offset indent
+foo \*(Ba bar \*(Ba read baz            # will not change $baz
+foo \*(Ba bar \*(Ba& read \-p baz        # will, however, do so
+.Ed
 .Sh BUGS
 Suspending (using \*(haZ) pipelines like the one below will only suspend
 the currently running part of the pipeline; in this example,
 .Dq fubar
-is immediately printed on suspension (but not later).
+is immediately printed on suspension (but not later after an
+.Ic fg ) .
 .Bd -literal -offset indent
 $ sleep 666 && echo fubar
 .Ed
 .Pp
-Some parts of the parser are not recursive; things like the following
-example will fail because of the parenthesis asymmetry:
+Some parts of the parser are not recursive; the following
+code fails because of the parenthesis asymmetry
+.Pq RedHat BZ#496791 .
+A workaround exists; use
+.Ql x=$(cat) \*(Lt\*(Lt"EOF"
+instead to merely slurp the string.
 .Bd -literal -offset indent
 x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
-.Ed
-.Pp
-Patches welcome.
-.Pp
-The parts of a pipeline, like below, are executed in subshells.
-Thus, variable assignments inside them fail.
-This is actually a feature; use co-processes instead.
-.Bd -literal -offset indent
-foo \*(Ba bar \*(Ba read baz    # will not change $baz
+# above fails to parse; below is the workaround
+x=$(eval $(cat)) \*(Lt\*(Lt"EOF"
+case $foo in bar) echo $bar ;; *) echo $baz ;; esac
+EOF
 .Ed
 .Pp
 This document attempts to describe
-.Nm mksh\ R39c
+.Nm mksh\ R39c+CVS
 and up,
 compiled without any options impacting functionality, such as
 .Dv MKSH_SMALL ,
Index: src/bin/mksh/setmode.c
diff -u src/bin/mksh/setmode.c:1.14 src/bin/mksh/setmode.c:1.15
--- src/bin/mksh/setmode.c:1.14	Wed Jun 10 18:12:48 2009
+++ src/bin/mksh/setmode.c	Tue Sep 14 21:26:16 2010
@@ -33,14 +33,10 @@
  * SUCH DAMAGE.
  */
 
-#if defined(HAVE_CONFIG_H) && (HAVE_CONFIG_H != 0)
-/* usually when packaged with third-party software */
-#ifdef CONFIG_H_FILENAME
-#include CONFIG_H_FILENAME
+#ifdef IN_MKSH
+#include "sh.h"
+#undef SETMODE_DEBUG
 #else
-#include "config.h"
-#endif
-#endif
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -55,20 +51,36 @@
 #include <stdio.h>
 #endif
 
+#endif
+
 __SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
-__RCSID("$MirOS: src/bin/mksh/setmode.c,v 1.14 2009/06/10 18:12:48 tg Rel $");
-__RCSID("$miros: src/lib/libc/gen/setmode.c,v 1.12 2009/06/10 18:12:42 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/setmode.c,v 1.15 2010/09/14 21:26:16 tg Exp $");
+__RCSID("$miros: src/lib/libc/gen/setmode.c,v 1.14 2010/09/14 21:26:04 tg Exp $");
+
+#ifdef IN_MKSH
 
-/* for mksh */
 #ifdef ksh_isdigit
 #undef isdigit
 #define isdigit		ksh_isdigit
 #endif
 
+#else
+
 #ifndef S_ISTXT
 #define S_ISTXT		0001000
 #endif
 
+#ifndef SIZE_MAX
+#ifdef SIZE_T_MAX
+#define SIZE_MAX	SIZE_T_MAX
+#else
+#define SIZE_MAX	((size_t)-1)
+#endif
+#endif
+
+#endif
+
+
 #define	SET_LEN		6	/* initial # of bitcmd struct to malloc */
 #define	SET_LEN_INCR	4	/* # of bitcmd structs to add as needed */
 
@@ -165,12 +177,15 @@
 		}
 }
 
+#define notoktomul(a, b)	((a) && (b) && (SIZE_MAX / (a) < (b)))
+
 #define	ADDCMD(a, b, c, d)						\
 	if (set >= endset) {						\
 		BITCMD *newset;						\
 		setlen += SET_LEN_INCR;					\
-		newset = realloc(saveset, sizeof(BITCMD) * setlen);	\
-		if (newset == NULL) {					\
+		if (notoktomul(setlen, sizeof(BITCMD)) ||		\
+		    (newset = realloc(saveset, setlen *			\
+		    sizeof(BITCMD))) == NULL) {				\
 			free(saveset);					\
 			return (NULL);					\
 		}							\
@@ -210,7 +225,8 @@
 
 	setlen = SET_LEN + 2;
 
-	if ((set = calloc(sizeof(BITCMD), setlen)) == NULL)
+	if (notoktomul(setlen, sizeof(BITCMD)) ||
+	    (set = malloc(setlen * sizeof(BITCMD))) == NULL)
 		return (NULL);
 	saveset = set;
 	endset = set + (setlen - 2);
Index: src/bin/mksh/sh.h
diff -u src/bin/mksh/sh.h:1.383 src/bin/mksh/sh.h:1.417
--- src/bin/mksh/sh.h:1.383	Thu Feb 25 20:18:17 2010
+++ src/bin/mksh/sh.h	Fri Oct  1 19:04:38 2010
@@ -4,7 +4,7 @@
 /*	$OpenBSD: tree.h,v 1.10 2005/03/28 21:28:22 deraadt Exp $	*/
 /*	$OpenBSD: expand.h,v 1.6 2005/03/30 17:16:37 deraadt Exp $	*/
 /*	$OpenBSD: lex.h,v 1.11 2006/05/29 18:22:24 otto Exp $	*/
-/*	$OpenBSD: proto.h,v 1.32 2009/01/29 23:27:26 jaredy Exp $	*/
+/*	$OpenBSD: proto.h,v 1.33 2010/05/19 17:36:08 jasper Exp $	*/
 /*	$OpenBSD: c_test.h,v 1.4 2004/12/20 11:34:26 otto Exp $	*/
 /*	$OpenBSD: tty.h,v 1.5 2004/12/20 11:34:26 otto Exp $	*/
 
@@ -141,18 +141,22 @@
 #undef __SCCSID
 #define __IDSTRING_CONCAT(l,p)		__LINTED__ ## l ## _ ## p
 #define __IDSTRING_EXPAND(l,p)		__IDSTRING_CONCAT(l,p)
+#ifdef MKSH_DONT_EMIT_IDSTRING
+#define __IDSTRING(prefix, string)	/* nothing */
+#else
 #define __IDSTRING(prefix, string)				\
 	static const char __IDSTRING_EXPAND(__LINE__,prefix) []	\
 	    MKSH_A_USED = "@(""#)" #prefix ": " string
+#endif
 #define __COPYRIGHT(x)		__IDSTRING(copyright,x)
 #define __RCSID(x)		__IDSTRING(rcsid,x)
 #define __SCCSID(x)		__IDSTRING(sccsid,x)
 #endif
 
 #ifdef EXTERN
-__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.383 2010/02/25 20:18:17 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.417 2010/10/01 19:04:38 tg Exp $");
 #endif
-#define MKSH_VERSION "R39 2010/02/25"
+#define MKSH_VERSION "R39 2010/10/01"
 
 #ifndef MKSH_INCLUDES_ONLY
 
@@ -188,6 +192,23 @@
 #define true 1
 #endif
 
+#if !HAVE_CAN_INTTYPES
+#if !HAVE_CAN_UCBINTS
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+#else
+typedef u_int32_t uint32_t;
+#endif
+#endif
+
+#if !HAVE_CAN_INT8TYPE
+#if !HAVE_CAN_UCBINT8
+typedef unsigned char uint8_t;
+#else
+typedef u_int8_t uint8_t;
+#endif
+#endif
+
 /* extra macros */
 
 #ifndef timerclear
@@ -251,10 +272,6 @@
 #define DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
 #endif
 
-#if !defined(RLIMIT_VMEM) && defined(RLIMIT_AS)
-#define RLIMIT_VMEM	RLIMIT_AS
-#endif
-
 #if !defined(MAP_FAILED)
 /* XXX imake style */
 #  if defined(__linux)
@@ -276,16 +293,6 @@
 
 /* OS-dependent additions (functions, variables, by OS) */
 
-#if !HAVE_ARC4RANDOM_DECL
-extern u_int32_t arc4random(void);
-extern void arc4random_addrandom(unsigned char *, int)
-    MKSH_A_BOUNDED(string, 1, 2);
-#endif
-
-#if !HAVE_ARC4RANDOM_PUSHB_DECL
-extern uint32_t arc4random_pushb(const void *, size_t);
-#endif
-
 #if !HAVE_FLOCK_DECL
 extern int flock(int, int);
 #endif
@@ -327,6 +334,15 @@
 extern int __cdecl setegid(gid_t);
 #endif
 
+/* remove redundances */
+
+#if defined(MirBSD) && (MirBSD >= 0x08A8)
+#define MKSH_mirbsd_wcwidth
+#define utf_wcwidth(i) wcwidth((__WCHAR_TYPE__)i)
+extern int wcwidth(__WCHAR_TYPE__);
+#endif
+
+
 /* some useful #defines */
 #ifdef EXTERN
 # define I__(i) = i
@@ -365,25 +381,6 @@
 
 #define LINE		4096	/* input line size */
 
-EXTERN struct {
-	const char *kshname_;	/* $0 */
-	pid_t kshpid_;		/* $$, shell PID */
-	pid_t procpid_;		/* PID of executing process */
-	pid_t kshpgrp_;		/* process group of shell */
-	uid_t ksheuid_;		/* effective UID of shell */
-	pid_t kshppid_;		/* PID of parent of shell */
-	int exstat_;		/* exit status */
-	int subst_exstat_;	/* exit status of last $(..)/`..` */
-} kshstate_;
-#define kshname		kshstate_.kshname_
-#define kshpid		kshstate_.kshpid_
-#define procpid		kshstate_.procpid_
-#define kshpgrp		kshstate_.kshpgrp_
-#define ksheuid		kshstate_.ksheuid_
-#define kshppid		kshstate_.kshppid_
-#define exstat		kshstate_.exstat_
-#define subst_exstat	kshstate_.subst_exstat_
-
 EXTERN const char *safe_prompt; /* safe prompt if PS1 substitution fails */
 EXTERN const char initvsn[] I__("KSH_VERSION=@(#)MIRBSD KSH " MKSH_VERSION);
 #define KSH_VERSION	(initvsn + /* "KSH_VERSION=@(#)" */ 16)
@@ -519,6 +516,18 @@
 #define ATEMP	&e->area
 
 /*
+ * flags (the order of these enums MUST match the order in misc.c(options[]))
+ */
+enum sh_flag {
+#define SHFLAGS_ENUMS
+#include "sh_flags.h"
+	FNFLAGS		/* (place holder: how many flags are there) */
+};
+
+#define Flag(f)	(kshstate_v.shell_flags_[(int)(f)])
+#define UTFMODE	Flag(FUNICODE)
+
+/*
  * parsing & execution environment
  */
 extern struct env {
@@ -565,6 +574,44 @@
 #define LSHELL	8	/* return to interactive shell() */
 #define LAEXPR	9	/* error in arithmetic expression */
 
+/*
+ * some kind of global shell state, for change_random() mostly
+ */
+
+EXTERN struct mksh_kshstate_v {
+	/* for change_random */
+	struct timeval cr_tv;	/* timestamp */
+	const void *cr_dp;	/* argument address */
+	size_t cr_dsz;		/* argument length */
+	uint32_t lcg_state_;	/* previous LCG state */
+	/* global state */
+	pid_t procpid_;		/* PID of executing process */
+	int exstat_;		/* exit status */
+	int subst_exstat_;	/* exit status of last $(..)/`..` */
+	struct env env_;	/* top-level parsing & execution env. */
+	uint8_t shell_flags_[FNFLAGS];
+} kshstate_v;
+EXTERN struct mksh_kshstate_f {
+	const char *kshname_;	/* $0 */
+	pid_t kshpid_;		/* $$, shell PID */
+	pid_t kshpgrp_;		/* process group of shell */
+	uid_t ksheuid_;		/* effective UID of shell */
+	pid_t kshppid_;		/* PID of parent of shell */
+	uint32_t h;		/* some kind of hash */
+} kshstate_f;
+#define kshname		kshstate_f.kshname_
+#define kshpid		kshstate_f.kshpid_
+#define procpid		kshstate_v.procpid_
+#define kshpgrp		kshstate_f.kshpgrp_
+#define ksheuid		kshstate_f.ksheuid_
+#define kshppid		kshstate_f.kshppid_
+#define exstat		kshstate_v.exstat_
+#define subst_exstat	kshstate_v.subst_exstat_
+
+/* evil hack: return hash(kshstate_f concat (kshstate_f'.h:=hash(arg))) */
+uint32_t evilhash(const char *);
+
+
 /* option processing */
 #define OF_CMDLINE	0x01	/* command line */
 #define OF_SET		0x02	/* set builtin */
@@ -580,30 +627,32 @@
 };
 extern const struct shoption options[];
 
-/*
- * flags (the order of these enums MUST match the order in misc.c(options[]))
- */
-enum sh_flag {
-#define SHFLAGS_ENUMS
-#include "sh_flags.h"
-	FNFLAGS		/* (place holder: how many flags are there) */
-};
-
-#define Flag(f)	(shell_flags[(int)(f)])
-#define UTFMODE	Flag(FUNICODE)
-
-EXTERN unsigned char shell_flags[FNFLAGS];
-
 /* null value for variable; comparision pointer for unset */
 EXTERN char null[] I__("");
 /* helpers for string pooling */
-#define T_synerr "syntax error"
-EXTERN const char r_fc_e_[] I__("r=fc -e -");
-#define fc_e_		(r_fc_e_ + 2)		/* "fc -e -" */
-#define fc_e_n		7			/* strlen(fc_e_) */
+EXTERN const char T_intovfl[] I__("integer overflow %lu %c %lu prevented");
+#if defined(__GNUC__)
+/* trust this to have string pooling; -Wformat bitches otherwise */
+#define T_synerr	"syntax error"
+#else
+EXTERN const char T_synerr[] I__("syntax error");
+#endif
+EXTERN const char T_r_fc_e_[] I__("r=fc -e -");
+#define T_fc_e_		(T_r_fc_e_ + 2)		/* "fc -e -" */
+#define Tn_fc_e_	7			/* strlen(T_fc_e_) */
 EXTERN const char T_local_typeset[] I__("local=typeset");
 #define T__typeset	(T_local_typeset + 5)	/* "=typeset" */
 #define T_typeset	(T_local_typeset + 6)	/* "typeset" */
+EXTERN const char T_palias[] I__("+alias");
+#define T_alias		(T_palias + 1)		/* "alias" */
+EXTERN const char T_punalias[] I__("+unalias");
+#define T_unalias	(T_punalias + 1)	/* "unalias" */
+EXTERN const char T_sgset[] I__("*=set");
+#define T_set		(T_sgset + 2)		/* "set" */
+EXTERN const char T_gbuiltin[] I__("=builtin");
+#define T_builtin	(T_gbuiltin + 1)	/* "builtin" */
+EXTERN const char T__function[] I__(" function");
+#define T_function	(T__function + 1)	/* "function" */
 
 enum temp_type {
 	TT_HEREDOC_EXP,	/* expanded heredoc */
@@ -626,7 +675,7 @@
 #define shl_spare	(&shf_iob[0])	/* for c_read()/c_print() */
 #define shl_stdout	(&shf_iob[1])
 #define shl_out		(&shf_iob[2])
-EXTERN int shl_stdout_ok;
+EXTERN bool shl_stdout_ok;
 
 /*
  * trap handlers
@@ -662,16 +711,23 @@
 #define SS_RESTORE_IGN	3	/* restore to SIG_IGN */
 #define SS_FORCE	BIT(3)	/* set signal even if original signal ignored */
 #define SS_USER		BIT(4)	/* user is doing the set (ie, trap command) */
-#define SS_SHTRAP	BIT(5)	/* trap for internal use (CHLD,ALRM,WINCH) */
+#define SS_SHTRAP	BIT(5)	/* trap for internal use (ALRM, CHLD, WINCH) */
 
 #define SIGEXIT_	0	/* for trap EXIT */
 #define SIGERR_		NSIG	/* for trap ERR */
 
 EXTERN volatile sig_atomic_t trap;	/* traps pending? */
 EXTERN volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
-EXTERN volatile sig_atomic_t fatal_trap;/* received a fatal signal */
+EXTERN volatile sig_atomic_t fatal_trap; /* received a fatal signal */
 extern	Trap	sigtraps[NSIG+1];
 
+/* got_winch = 1 when we need to re-adjust the window size */
+#ifdef SIGWINCH
+EXTERN volatile sig_atomic_t got_winch I__(1);
+#else
+#define got_winch	true
+#endif
+
 /*
  * TMOUT support
  */
@@ -723,13 +779,13 @@
 #define GI_MINUSMINUS	BIT(2)	/* arguments were ended with -- */
 
 typedef struct {
-	const char	*optarg;
-	int		optind;
-	int		uoptind;/* what user sees in $OPTIND */
-	int		flags;	/* see GF_* */
-	int		info;	/* see GI_* */
-	unsigned int	p;	/* 0 or index into argv[optind - 1] */
-	char		buf[2];	/* for bad option OPTARG value */
+	const char *optarg;
+	int optind;
+	int uoptind;		/* what user sees in $OPTIND */
+	int flags;		/* see GF_* */
+	int info;		/* see GI_* */
+	unsigned int p;		/* 0 or index into argv[optind - 1] */
+	char buf[2];		/* for bad option OPTARG value */
 } Getopt;
 
 EXTERN Getopt builtin_opt;	/* for shell builtin commands */
@@ -860,7 +916,7 @@
 		char *s;		/* string */
 		mksh_ari_t i;		/* integer */
 		mksh_uari_t u;		/* unsigned integer */
-		int (*f)(const char **);/* int function */
+		int (*f)(const char **); /* int function */
 		struct op *t;		/* "function" tree */
 	} val;			/* value */
 	union {
@@ -1079,11 +1135,11 @@
  * IO redirection
  */
 struct ioword {
-	int	unit;	/* unit affected */
-	int	flag;	/* action (below) */
-	char	*name;	/* file name (unused if heredoc) */
-	char	*delim;	/* delimiter for <<,<<- */
-	char	*heredoc;/* content of heredoc */
+	int	unit;		/* unit affected */
+	int	flag;		/* action (below) */
+	char	*name;		/* file name (unused if heredoc) */
+	char	*delim;		/* delimiter for <<,<<- */
+	char	*heredoc;	/* content of heredoc */
 };
 
 /* ioword.flag - type of redirection */
@@ -1173,7 +1229,7 @@
 #define XcheckN(xs, xp, n) do {					\
 	int more = ((xp) + (n)) - (xs).end;			\
 	if (more > 0)						\
-		(xp) = Xcheck_grow_(&(xs), (xp), more);		\
+		(xp) = Xcheck_grow_(&(xs), (xp), (size_t)more);	\
 } while (/* CONSTCOND */ 0)
 
 /* check for overflow, expand string */
@@ -1194,7 +1250,7 @@
 #define Xsavepos(xs, xp)	((xp) - (xs).beg)
 #define Xrestpos(xs, xp, n)	((xs).beg + (n))
 
-char *Xcheck_grow_(XString *, const char *, unsigned int);
+char *Xcheck_grow_(XString *, const char *, size_t);
 
 /*
  * expandable vector of generic pointers
@@ -1207,7 +1263,7 @@
 
 #define XPinit(x, n) do {					\
 	void **vp__;						\
-	vp__ = alloc((n) * sizeof(void *), ATEMP);		\
+	vp__ = alloc2((n), sizeof(void *), ATEMP);		\
 	(x).cur = (x).beg = vp__;				\
 	(x).end = vp__ + (n);					\
 } while (/* CONSTCOND */ 0)
@@ -1215,8 +1271,8 @@
 #define XPput(x, p) do {					\
 	if ((x).cur >= (x).end) {				\
 		size_t n = XPsize(x);				\
-		(x).beg = aresize((x).beg,			\
-		    n * 2 * sizeof(void *), ATEMP);		\
+		(x).beg = aresize2((x).beg,			\
+		    n, 2 * sizeof(void *), ATEMP);		\
 		(x).cur = (x).beg + n;				\
 		(x).end = (x).cur + n;				\
 	}							\
@@ -1225,7 +1281,7 @@
 
 #define XPptrv(x)	((x).beg)
 #define XPsize(x)	((x).cur - (x).beg)
-#define XPclose(x)	aresize((x).beg, XPsize(x) * sizeof(void *), ATEMP)
+#define XPclose(x)	aresize2((x).beg, XPsize(x), sizeof(void *), ATEMP)
 #define XPfree(x)	afree((x).beg, ATEMP)
 
 #define IDENT	64
@@ -1342,12 +1398,21 @@
 /* user and system time of last j_waitjed job */
 EXTERN struct timeval j_usrtime, j_systime;
 
+#define notoktoadd(val, cnst)	((val) > (SIZE_MAX - (cnst)))
+#define checkoktoadd(val, cnst) do {					\
+	if (notoktoadd((val), (cnst)))					\
+		internal_errorf(T_intovfl, (unsigned long)(val),	\
+		    '+', (unsigned long)(cnst));			\
+} while (/* CONSTCOND */ 0)
+
 /* lalloc.c */
 void ainit(Area *);
 void afreeall(Area *);
 /* these cannot fail and can take NULL (not for ap) */
-#define alloc(n, ap)	aresize(NULL, (n), (ap))
+#define alloc(n, ap)		aresize(NULL, (n), (ap))
+#define alloc2(m, n, ap)	aresize2(NULL, (m), (n), (ap))
 void *aresize(void *, size_t, Area *);
+void *aresize2(void *, size_t, size_t, Area *);
 void afree(void *, Area *);	/* can take NULL */
 /* edit.c */
 #ifndef MKSH_SMALL
@@ -1387,7 +1452,9 @@
 int utf_mbswidth(const char *);
 const char *utf_skipcols(const char *, int);
 size_t utf_ptradj(const char *);
+#ifndef MKSH_mirbsd_wcwidth
 int utf_wcwidth(unsigned int);
+#endif
 /* funcs.c */
 int c_hash(const char **);
 int c_cd(const char **);
@@ -1427,13 +1494,15 @@
 int timex(struct op *, int, volatile int *);
 void timex_hook(struct op *, char ** volatile *);
 int c_exec(const char **);
-int c_builtin(const char **);
+/* dummy function (just need pointer value), special case in comexec() */
+#define c_builtin shcomexec
 int c_test(const char **);
 #if HAVE_MKNOD
 int c_mknod(const char **);
 #endif
 int c_realpath(const char **);
 int c_rename(const char **);
+int c_cat(const char **);
 /* histrap.c */
 void init_histvec(void);
 void hist_init(Source *);
@@ -1500,7 +1569,7 @@
 int promptlen(const char *);
 /* main.c */
 int include(const char *, int, const char **, int);
-int command(const char *);
+int command(const char *, int);
 int shell(Source *volatile, int volatile);
 void unwind(int) MKSH_A_NORETURN;
 void newenv(int);
@@ -1573,7 +1642,7 @@
     char *(*)(char *, int, int, const void *),
     const void *, int, int, bool);
 void strip_nuls(char *, int);
-int blocking_read(int, char *, int)
+ssize_t blocking_read(int, char *, size_t)
     MKSH_A_BOUNDED(buffer, 2, 3);
 int reset_nonblock(int);
 char *ksh_get_wd(size_t *);
@@ -1621,6 +1690,7 @@
 const char *wdscan(const char *, int);
 char *wdstrip(const char *, bool, bool);
 void tfree(struct op *, Area *);
+int fpFUNCTf(struct shf *, int, bool, const char *, struct op *);
 /* var.c */
 void newblock(void);
 void popblock(void);
@@ -1639,9 +1709,7 @@
 int is_wdvarname(const char *, int);
 int is_wdvarassign(const char *);
 char **makenv(void);
-#if !HAVE_ARC4RANDOM
 void change_random(const void *, size_t);
-#endif
 void change_winsz(void);
 int array_ref_len(const char *);
 char *arrayname(const char *);
@@ -1658,7 +1726,9 @@
 	TO_FILRD, TO_FILGZ, TO_FILTT, TO_FILSETU, TO_FILWR, TO_FILEX,
 	/* binary operators */
 	TO_STEQL, TO_STNEQ, TO_STLT, TO_STGT, TO_INTEQ, TO_INTNE, TO_INTGT,
-	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT
+	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT,
+	/* not an operator */
+	TO_NONNULL	/* !TO_NONOP */
 };
 typedef enum Test_op Test_op;
 
@@ -1678,19 +1748,18 @@
 #define TEF_ERROR	BIT(0)		/* set if we've hit an error */
 #define TEF_DBRACKET	BIT(1)		/* set if [[ .. ]] test */
 
-typedef struct test_env Test_env;
-struct test_env {
+typedef struct test_env {
 	union {
-		const char **wp;/* used by ptest_* */
-		XPtrV *av;	/* used by dbtestp_* */
+		const char **wp;	/* used by ptest_* */
+		XPtrV *av;		/* used by dbtestp_* */
 	} pos;
-	const char **wp_end;	/* used by ptest_* */
-	int (*isa)(Test_env *, Test_meta);
-	const char *(*getopnd) (Test_env *, Test_op, bool);
-	int (*eval)(Test_env *, Test_op, const char *, const char *, bool);
-	void (*error)(Test_env *, int, const char *);
-	int flags;		/* TEF_* */
-};
+	const char **wp_end;		/* used by ptest_* */
+	Test_op (*isa)(struct test_env *, Test_meta);
+	const char *(*getopnd) (struct test_env *, Test_op, bool);
+	int (*eval)(struct test_env *, Test_op, const char *, const char *, bool);
+	void (*error)(struct test_env *, int, const char *);
+	int flags;			/* TEF_* */
+} Test_env;
 
 extern const char *const dbtest_tokens[];
 
Index: src/bin/mksh/sh_flags.h
diff -u src/bin/mksh/sh_flags.h:1.5 src/bin/mksh/sh_flags.h:1.7
--- src/bin/mksh/sh_flags.h:1.5	Thu Jan 28 15:18:51 2010
+++ src/bin/mksh/sh_flags.h	Tue Jul 13 13:07:58 2010
@@ -1,5 +1,5 @@
 #if defined(SHFLAGS_DEFNS)
-__RCSID("$MirOS: src/bin/mksh/sh_flags.h,v 1.5 2010/01/28 15:18:51 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh_flags.h,v 1.7 2010/07/13 13:07:58 tg Exp $");
 #define FN(sname,cname,ochar,flags)	/* nothing */
 #elif defined(SHFLAGS_ENUMS)
 #define FN(sname,cname,ochar,flags)	cname,
@@ -21,10 +21,8 @@
 /* -a	all new parameters are created with the export attribute */
 F0("allexport", FEXPORT, 'a', OF_ANY)
 
-#if HAVE_ARC4RANDOM
-/* ./.	backwards compat: available if arc4random(3) is used for $RANDOM */
-FN("arc4random", FARC4RANDOM, 0, OF_INTERNAL)
-#endif
+/* ./.	backwards compat: dummy, emits a warning */
+FN("arc4random", FARC4RANDOM, 0, OF_ANY)
 
 #if HAVE_NICE
 /* ./.	bgnice */
Index: src/bin/mksh/shf.c
diff -u src/bin/mksh/shf.c:1.35 src/bin/mksh/shf.c:1.40
--- src/bin/mksh/shf.c:1.35	Sat Nov 28 14:28:03 2009
+++ src/bin/mksh/shf.c	Tue Sep 14 21:26:17 2010
@@ -18,11 +18,13 @@
  * of dealing in the work, even if advised of the possibility of such
  * damage or existence of a defect, except proven that it results out
  * of said person's immediate fault when using the work as intended.
+ *-
+ * Use %lX instead of %p and floating point isn't supported at all.
  */
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.35 2009/11/28 14:28:03 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.40 2010/09/14 21:26:17 tg Exp $");
 
 /* flags to shf_emptybuf() */
 #define EB_READSW	0x01	/* about to switch to reading */
@@ -45,7 +47,8 @@
 shf_open(const char *name, int oflags, int mode, int sflags)
 {
 	struct shf *shf;
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 	int fd;
 
 	/* Done before open so if alloca fails, fd won't be lost. */
@@ -83,7 +86,8 @@
 struct shf *
 shf_fdopen(int fd, int sflags, struct shf *shf)
 {
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 
 	/* use fcntl() to figure out correct read/write flags */
 	if (sflags & SHF_GETFL) {
@@ -108,7 +112,7 @@
 	}
 
 	if (!(sflags & (SHF_RD | SHF_WR)))
-		internal_errorf("shf_fdopen: missing read/write");
+		internal_errorf("%s: %s", "shf_fdopen", "missing read/write");
 
 	if (shf) {
 		if (bsize) {
@@ -140,7 +144,8 @@
 struct shf *
 shf_reopen(int fd, int sflags, struct shf *shf)
 {
-	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
+	int bsize = /* at most 512 */
+	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 
 	/* use fcntl() to figure out correct read/write flags */
 	if (sflags & SHF_GETFL) {
@@ -165,9 +170,9 @@
 	}
 
 	if (!(sflags & (SHF_RD | SHF_WR)))
-		internal_errorf("shf_reopen: missing read/write");
+		internal_errorf("%s: %s", "shf_reopen", "missing read/write");
 	if (!shf || !shf->buf || shf->bsize < bsize)
-		internal_errorf("shf_reopen: bad shf/buf/bsize");
+		internal_errorf("%s: %s", "shf_reopen", "bad shf/buf/bsize");
 
 	/* assumes shf->buf and shf->bsize already set up */
 	shf->fd = fd;
@@ -196,7 +201,7 @@
 {
 	/* can't have a read+write string */
 	if (!(!(sflags & SHF_RD) ^ !(sflags & SHF_WR)))
-		internal_errorf("shf_sopen: flags 0x%x", sflags);
+		internal_errorf("%s: flags 0x%X", "shf_sopen", sflags);
 
 	if (!shf) {
 		shf = alloc(sizeof(struct shf), ATEMP);
@@ -289,7 +294,7 @@
 		return ((shf->flags & SHF_WR) ? EOF : 0);
 
 	if (shf->fd < 0)
-		internal_errorf("shf_flush: no fd");
+		internal_errorf("%s: %s", "shf_flush", "no fd");
 
 	if (shf->flags & SHF_ERROR) {
 		errno = shf->errno_;
@@ -319,7 +324,7 @@
 	int ret = 0;
 
 	if (!(shf->flags & SHF_STRING) && shf->fd < 0)
-		internal_errorf("shf_emptybuf: no fd");
+		internal_errorf("%s: %s", "shf_emptybuf", "no fd");
 
 	if (shf->flags & SHF_ERROR) {
 		errno = shf->errno_;
@@ -342,7 +347,7 @@
 		    !(shf->flags & SHF_ALLOCB))
 			return (EOF);
 		/* allocate more space for buffer */
-		nbuf = aresize(shf->buf, 2 * shf->wbsize, shf->areap);
+		nbuf = aresize2(shf->buf, 2, shf->wbsize, shf->areap);
 		shf->rp = nbuf + (shf->rp - shf->buf);
 		shf->wp = nbuf + (shf->wp - shf->buf);
 		shf->rbsize += shf->wbsize;
@@ -395,11 +400,13 @@
 static int
 shf_fillbuf(struct shf *shf)
 {
+	ssize_t n;
+
 	if (shf->flags & SHF_STRING)
 		return (0);
 
 	if (shf->fd < 0)
-		internal_errorf("shf_fillbuf: no fd");
+		internal_errorf("%s: %s", "shf_fillbuf", "no fd");
 
 	if (shf->flags & (SHF_EOF | SHF_ERROR)) {
 		if (shf->flags & SHF_ERROR)
@@ -414,23 +421,20 @@
 
 	shf->rp = shf->buf;
 	while (1) {
-		shf->rnleft = blocking_read(shf->fd, (char *) shf->buf,
-		    shf->rbsize);
-		if (shf->rnleft < 0 && errno == EINTR &&
-		    !(shf->flags & SHF_INTERRUPT))
+		n = blocking_read(shf->fd, (char *)shf->buf, shf->rbsize);
+		if (n < 0 && errno == EINTR && !(shf->flags & SHF_INTERRUPT))
 			continue;
 		break;
 	}
-	if (shf->rnleft <= 0) {
-		if (shf->rnleft < 0) {
-			shf->flags |= SHF_ERROR;
-			shf->errno_ = errno;
-			shf->rnleft = 0;
-			shf->rp = shf->buf;
-			return (EOF);
-		}
-		shf->flags |= SHF_EOF;
+	if (n < 0) {
+		shf->flags |= SHF_ERROR;
+		shf->errno_ = errno;
+		shf->rnleft = 0;
+		shf->rp = shf->buf;
+		return (EOF);
 	}
+	if ((shf->rnleft = n) == 0)
+		shf->flags |= SHF_EOF;
 	return (0);
 }
 
@@ -445,10 +449,10 @@
 	int ncopy;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_read: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_read", shf->flags);
 
 	if (bsize <= 0)
-		internal_errorf("shf_read: bsize %d", bsize);
+		internal_errorf("%s: %s %d", "shf_write", "bsize", bsize);
 
 	while (bsize > 0) {
 		if (shf->rnleft == 0 &&
@@ -480,7 +484,7 @@
 	char *orig_buf = buf;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_getse: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_getse", shf->flags);
 
 	if (bsize <= 0)
 		return (NULL);
@@ -515,7 +519,7 @@
 shf_getchar(struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_getchar: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_getchar", shf->flags);
 
 	if (shf->rnleft == 0 && (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
 		return (EOF);
@@ -530,7 +534,7 @@
 shf_ungetc(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf("shf_ungetc: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_ungetc", shf->flags);
 
 	if ((shf->flags & SHF_ERROR) || c == EOF ||
 	    (shf->rp == shf->buf && shf->rnleft))
@@ -565,7 +569,7 @@
 shf_putchar(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_WR))
-		internal_errorf("shf_putchar: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_putchar", shf->flags);
 
 	if (c == EOF)
 		return (EOF);
@@ -575,7 +579,7 @@
 		int n;
 
 		if (shf->fd < 0)
-			internal_errorf("shf_putchar: no fd");
+			internal_errorf("%s: %s", "shf_putchar", "no fd");
 		if (shf->flags & SHF_ERROR) {
 			errno = shf->errno_;
 			return (EOF);
@@ -619,10 +623,10 @@
 	int n, ncopy, orig_nbytes = nbytes;
 
 	if (!(shf->flags & SHF_WR))
-		internal_errorf("shf_write: flags %x", shf->flags);
+		internal_errorf("%s: flags 0x%X", "shf_write", shf->flags);
 
 	if (nbytes < 0)
-		internal_errorf("shf_write: nbytes %d", nbytes);
+		internal_errorf("%s: %s %d", "shf_write", "nbytes", nbytes);
 
 	/* Don't buffer if buffer is empty and we're writting a large amount. */
 	if ((ncopy = shf->wnleft) &&
@@ -636,32 +640,45 @@
 		shf->wnleft -= ncopy;
 	}
 	if (nbytes > 0) {
-		/* Flush deals with strings and sticky errors */
-		if (shf_emptybuf(shf, EB_GROW) == EOF)
-			return (EOF);
-		if (nbytes > shf->wbsize) {
-			ncopy = nbytes;
-			if (shf->wbsize)
-				ncopy -= nbytes % shf->wbsize;
-			nbytes -= ncopy;
-			while (ncopy > 0) {
-				n = write(shf->fd, buf, ncopy);
-				if (n < 0) {
-					if (errno == EINTR &&
-					    !(shf->flags & SHF_INTERRUPT))
-						continue;
-					shf->flags |= SHF_ERROR;
-					shf->errno_ = errno;
-					shf->wnleft = 0;
-					/* Note: fwrite(3S) returns 0 for
-					 * errors - this doesn't */
+		if (shf->flags & SHF_STRING) {
+			/* resize buffer until there's enough space left */
+			while (nbytes > shf->wnleft)
+				if (shf_emptybuf(shf, EB_GROW) == EOF)
 					return (EOF);
+			/* then write everything into the buffer */
+		} else {
+			/* flush deals with sticky errors */
+			if (shf_emptybuf(shf, EB_GROW) == EOF)
+				return (EOF);
+			/* write chunks larger than window size directly */
+			if (nbytes > shf->wbsize) {
+				ncopy = nbytes;
+				if (shf->wbsize)
+					ncopy -= nbytes % shf->wbsize;
+				nbytes -= ncopy;
+				while (ncopy > 0) {
+					n = write(shf->fd, buf, ncopy);
+					if (n < 0) {
+						if (errno == EINTR &&
+						    !(shf->flags & SHF_INTERRUPT))
+							continue;
+						shf->flags |= SHF_ERROR;
+						shf->errno_ = errno;
+						shf->wnleft = 0;
+						/*
+						 * Note: fwrite(3) returns 0
+						 * for errors - this doesn't
+						 */
+						return (EOF);
+					}
+					buf += n;
+					ncopy -= n;
 				}
-				buf += n;
-				ncopy -= n;
 			}
+			/* ... and buffer the rest */
 		}
 		if (nbytes > 0) {
+			/* write remaining bytes to buffer */
 			memcpy(shf->wp, buf, nbytes);
 			shf->wp += nbytes;
 			shf->wnleft -= nbytes;
@@ -692,7 +709,8 @@
 	int n;
 
 	if (!buf || bsize <= 0)
-		internal_errorf("shf_snprintf: buf %p, bsize %d", buf, bsize);
+		internal_errorf("shf_snprintf: buf %lX, bsize %d",
+		    (long)(ptrdiff_t)buf, bsize);
 
 	shf_sopen(buf, bsize, SHF_WR, &shf);
 	va_start(args, fmt);
@@ -842,11 +860,6 @@
 		}
 
 		switch (c) {
-		case 'p': /* pointer */
-			flags &= ~(FL_LONG | FL_SHORT);
-			flags |= (sizeof(char *) > sizeof(int)) ?
-			    /* hope it fits.. */ FL_LONG : 0;
-			/* aaahhh... */
 		case 'd':
 		case 'i':
 		case 'o':
@@ -904,7 +917,6 @@
 					*--cp = '0';
 				break;
 
-			case 'p':
 			case 'x': {
 				const char *digits = (flags & FL_UPPER) ?
 				    digits_uc : digits_lc;
Index: src/bin/mksh/syn.c
diff -u src/bin/mksh/syn.c:1.48 src/bin/mksh/syn.c:1.52
--- src/bin/mksh/syn.c:1.48	Sat Dec 12 22:27:10 2009
+++ src/bin/mksh/syn.c	Tue Sep 14 21:26:18 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.48 2009/12/12 22:27:10 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.52 2010/09/14 21:26:18 tg Exp $");
 
 struct nesting_state {
 	int start_token;	/* token than began nesting (eg, FOR) */
@@ -50,7 +50,7 @@
 static void nesting_pop(struct nesting_state *);
 static int assign_command(char *);
 static int inalias(struct source *);
-static int dbtestp_isa(Test_env *, Test_meta);
+static Test_op dbtestp_isa(Test_env *, Test_meta);
 static const char *dbtestp_getopnd(Test_env *, Test_op, bool);
 static int dbtestp_eval(Test_env *, Test_op, const char *,
     const char *, bool);
@@ -181,7 +181,7 @@
 		if (*ident != 0) /* unquoted */
 			iop->flag |= IOEVAL;
 		if (herep > &heres[HERES - 1])
-			yyerror("too many <<s\n");
+			yyerror("too many %ss\n", "<<");
 		*herep++ = iop;
 	} else
 		iop->name = yylval.cp;
@@ -231,7 +231,8 @@
 	XPtrV args, vars;
 	struct nesting_state old_nesting;
 
-	iops = alloc((NUFILE + 1) * sizeof(struct ioword *), ATEMP);
+	/* NUFILE is small enough to leave this addition unchecked */
+	iops = alloc2((NUFILE + 1), sizeof(struct ioword *), ATEMP);
 	XPinit(args, 16);
 	XPinit(vars, 16);
 
@@ -257,7 +258,8 @@
 			case REDIR:
 				while ((iop = synio(cf)) != NULL) {
 					if (iopn >= NUFILE)
-						yyerror("too many redirections\n");
+						yyerror("too many %ss\n",
+						    "redirection");
 					iops[iopn++] = iop;
 				}
 				break;
@@ -403,8 +405,8 @@
 		t = newtp((c == FOR) ? TFOR : TSELECT);
 		musthave(LWORD, ARRAYVAR);
 		if (!is_wdvarname(yylval.cp, true))
-			yyerror("%s: bad identifier\n",
-			    c == FOR ? "for" : "select");
+			yyerror("%s: %s\n", c == FOR ? "for" : "select",
+			    "bad identifier");
 		strdupx(t->str, ident, ATEMP);
 		nesting_push(&old_nesting, c);
 		t->vars = wordlist();
@@ -466,7 +468,7 @@
 
 	while ((iop = synio(syniocf)) != NULL) {
 		if (iopn >= NUFILE)
-			yyerror("too many redirections\n");
+			yyerror("too many %ss\n", "redirection");
 		iops[iopn++] = iop;
 	}
 
@@ -475,7 +477,7 @@
 		t->ioact = NULL;
 	} else {
 		iops[iopn++] = NULL;
-		iops = aresize(iops, iopn * sizeof(struct ioword *), ATEMP);
+		iops = aresize2(iops, iopn, sizeof(struct ioword *), ATEMP);
 		t->ioact = iops;
 	}
 
@@ -622,7 +624,7 @@
 	 */
 	for (p = sname; *p; p++)
 		if (ctype(*p, C_QUOTE))
-			yyerror("%s: invalid function name\n", sname);
+			yyerror("%s: %s\n", sname, "invalid function name");
 
 	/* Note that POSIX allows only compound statements after foo(), sh and
 	 * AT&T ksh allow any command, go with the later since it shouldn't
@@ -655,12 +657,13 @@
 	if ((t->left = get_command(CONTIN)) == NULL) {
 		char *tv;
 		/*
-		 * Probably something like foo() followed by eof or ;.
+		 * Probably something like foo() followed by EOF or ';'.
 		 * This is accepted by sh and ksh88.
 		 * To make "typeset -f foo" work reliably (so its output can
 		 * be used as input), we pretend there is a colon here.
 		 */
 		t->left = newtp(TCOM);
+		/* (2 * sizeof(char *)) is small enough */
 		t->left->args = alloc(2 * sizeof(char *), ATEMP);
 		t->left->args[0] = tv = alloc(3, ATEMP);
 		tv[0] = CHAR;
@@ -739,7 +742,7 @@
 	{ "do",		DO,	true },
 	{ "done",	DONE,	true },
 	{ "in",		IN,	true },
-	{ "function",	FUNCTION, true },
+	{ T_function,	FUNCTION, true },
 	{ "time",	TIME,	true },
 	{ "{",		'{',	true },
 	{ "}",		'}',	true },
@@ -796,7 +799,7 @@
 			goto Again;
 		}
 		/* don't quote the EOF */
-		yyerror("%s: unexpected EOF\n", T_synerr);
+		yyerror("%s: %s %s\n", T_synerr, "unexpected", "EOF");
 		/* NOTREACHED */
 
 	case LWORD:
@@ -882,7 +885,7 @@
 {
 	if (!*s)
 		return (0);
-	return ((strcmp(s, "alias") == 0) ||
+	return ((strcmp(s, T_alias) == 0) ||
 	    (strcmp(s, "export") == 0) ||
 	    (strcmp(s, "readonly") == 0) ||
 	    (strcmp(s, T_typeset) == 0));
@@ -917,42 +920,45 @@
 const char db_lthan[] = { CHAR, '<', EOS };
 const char db_gthan[] = { CHAR, '>', EOS };
 
-/* Test if the current token is a whatever. Accepts the current token if
+/*
+ * Test if the current token is a whatever. Accepts the current token if
  * it is. Returns 0 if it is not, non-zero if it is (in the case of
  * TM_UNOP and TM_BINOP, the returned value is a Test_op).
  */
-static int
+static Test_op
 dbtestp_isa(Test_env *te, Test_meta meta)
 {
 	int c = tpeek(ARRAYVAR | (meta == TM_BINOP ? 0 : CONTIN));
 	int uqword;
 	char *save = NULL;
-	int ret = 0;
+	Test_op ret = TO_NONOP;
 
 	/* unquoted word? */
 	uqword = c == LWORD && *ident;
 
 	if (meta == TM_OR)
-		ret = c == LOGOR;
+		ret = c == LOGOR ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_AND)
-		ret = c == LOGAND;
+		ret = c == LOGAND ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_NOT)
-		ret = uqword && strcmp(yylval.cp, dbtest_tokens[(int) TM_NOT]) == 0;
+		ret = (uqword && !strcmp(yylval.cp,
+		    dbtest_tokens[(int)TM_NOT])) ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_OPAREN)
-		ret = c == '(' /*)*/;
+		ret = c == '(' /*)*/ ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_CPAREN)
-		ret = c == /*(*/ ')';
+		ret = c == /*(*/ ')' ? TO_NONNULL : TO_NONOP;
 	else if (meta == TM_UNOP || meta == TM_BINOP) {
 		if (meta == TM_BINOP && c == REDIR &&
 		    (yylval.iop->flag == IOREAD || yylval.iop->flag == IOWRITE)) {
-			ret = 1;
+			ret = TO_NONNULL;
 			save = wdcopy(yylval.iop->flag == IOREAD ?
 			    db_lthan : db_gthan, ATEMP);
 		} else if (uqword && (ret = test_isop(meta, ident)))
 			save = yylval.cp;
 	} else /* meta == TM_END */
-		ret = uqword && strcmp(yylval.cp, db_close) == 0;
-	if (ret) {
+		ret = (uqword && !strcmp(yylval.cp,
+		    db_close)) ? TO_NONNULL : TO_NONOP;
+	if (ret != TO_NONOP) {
 		ACCEPT;
 		if (meta < NELEM(dbtest_tokens))
 			save = wdcopy(dbtest_tokens[(int)meta], ATEMP);
Index: src/bin/mksh/tree.c
diff -u src/bin/mksh/tree.c:1.30 src/bin/mksh/tree.c:1.32
--- src/bin/mksh/tree.c:1.30	Thu Feb 25 20:18:19 2010
+++ src/bin/mksh/tree.c	Tue Sep 14 21:26:19 2010
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.30 2010/02/25 20:18:19 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.32 2010/09/14 21:26:19 tg Exp $");
 
 #define INDENT	4
 
@@ -164,12 +164,10 @@
 		fptreef(shf, indent, "%T& ", t->left);
 		break;
 	case TFUNCT:
-		fptreef(shf, indent,
-		    t->u.ksh_func ? "function %s %T" : "%s() %T",
-		    t->str, t->left);
+		fpFUNCTf(shf, indent, t->u.ksh_func, t->str, t->left);
 		break;
 	case TTIME:
-		fptreef(shf, indent, "time %T", t->left);
+		fptreef(shf, indent, "%s %T", "time", t->left);
 		break;
 	default:
 		shf_puts("<botch>", shf);
@@ -456,7 +454,7 @@
 	else {
 		for (tw = (const char **)t->vars; *tw++ != NULL; )
 			;
-		rw = r->vars = alloc((tw - (const char **)t->vars + 1) *
+		rw = r->vars = alloc2(tw - (const char **)t->vars + 1,
 		    sizeof(*tw), ap);
 		for (tw = (const char **)t->vars; *tw != NULL; )
 			*rw++ = wdcopy(*tw++, ap);
@@ -468,7 +466,7 @@
 	else {
 		for (tw = t->args; *tw++ != NULL; )
 			;
-		r->args = (const char **)(rw = alloc((tw - t->args + 1) *
+		r->args = (const char **)(rw = alloc2(tw - t->args + 1,
 		    sizeof(*tw), ap));
 		for (tw = t->args; *tw != NULL; )
 			*rw++ = wdcopy(*tw++, ap);
@@ -638,7 +636,7 @@
 
 	for (ior = iow; *ior++ != NULL; )
 		;
-	ior = alloc((ior - iow + 1) * sizeof(struct ioword *), ap);
+	ior = alloc2(ior - iow + 1, sizeof(struct ioword *), ap);
 
 	for (i = 0; iow[i] != NULL; i++) {
 		struct ioword *p, *q;
@@ -714,3 +712,12 @@
 	}
 	afree(iow, ap);
 }
+
+int
+fpFUNCTf(struct shf *shf, int i, bool isksh, const char *k, struct op *v)
+{
+	if (isksh)
+		return (fptreef(shf, i, "%s %s %T", T_function, k, v));
+	else
+		return (fptreef(shf, i, "%s() %T", k, v));
+}
Index: src/bin/mksh/var.c
diff -u src/bin/mksh/var.c:1.104 src/bin/mksh/var.c:1.114
--- src/bin/mksh/var.c:1.104	Thu Jan 28 20:26:52 2010
+++ src/bin/mksh/var.c	Sun Sep 19 19:21:20 2010
@@ -22,7 +22,11 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/var.c,v 1.104 2010/01/28 20:26:52 tg Exp $");
+#if defined(__OpenBSD__)
+#include <sys/sysctl.h>
+#endif
+
+__RCSID("$MirOS: src/bin/mksh/var.c,v 1.114 2010/09/19 19:21:20 tg Exp $");
 
 /*
  * Variables
@@ -36,7 +40,7 @@
 static struct tbl vtemp;
 static struct table specials;
 static char *formatstr(struct tbl *, const char *);
-static void export(struct tbl *, const char *);
+static void exportprep(struct tbl *, const char *);
 static int special(const char *);
 static void unspecial(const char *);
 static void getspec(struct tbl *);
@@ -46,12 +50,9 @@
 static mksh_ari_t intval(struct tbl *);
 static struct tbl *arraysearch(struct tbl *, uint32_t);
 static const char *array_index_calc(const char *, bool *, uint32_t *);
-#if !HAVE_ARC4RANDOM
 static uint32_t oaathash_update(register uint32_t, register const uint8_t *,
     register size_t);
-
-static uint32_t lcg_state = 5381;
-#endif
+static uint32_t oaathash_finalise(register uint32_t);
 
 uint8_t set_refflag = 0;
 
@@ -392,7 +393,7 @@
 	base = getint(vp, &num, false);
 	if (base == -1)
 		/* XXX check calls - is error here ok by POSIX? */
-		errorf("%s: bad number", str_val(vp));
+		errorf("%s: %s", str_val(vp), "bad number");
 	return (num);
 }
 
@@ -405,7 +406,7 @@
 
 	error_ok &= ~0x4;
 	if ((vq->flag & RDONLY) && !no_ro_check) {
-		warningf(true, "%s: is read only", vq->name);
+		warningf(true, "%s: %s", vq->name, "is read only");
 		if (!error_ok)
 			errorfz();
 		return (0);
@@ -425,7 +426,7 @@
 		if (s && (vq->flag & (UCASEV_AL|LCASEV|LJUST|RJUST)))
 			s = salloc = formatstr(vq, s);
 		if ((vq->flag&EXPORT))
-			export(vq, s);
+			exportprep(vq, s);
 		else {
 			strdupx(vq->val.s, s, vq->areap);
 			vq->flag |= ALLOC;
@@ -644,14 +645,17 @@
  * make vp->val.s be "name=value" for quick exporting.
  */
 static void
-export(struct tbl *vp, const char *val)
+exportprep(struct tbl *vp, const char *val)
 {
 	char *xp;
 	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
-	int namelen = strlen(vp->name);
-	int vallen = strlen(val) + 1;
+	size_t namelen, vallen;
+
+	namelen = strlen(vp->name);
+	vallen = strlen(val) + 1;
 
 	vp->flag |= ALLOC;
+	/* since name+val are both in memory this can go unchecked */
 	xp = alloc(namelen + 1 + vallen, vp->areap);
 	memcpy(vp->val.s = xp, vp->name, namelen);
 	xp += namelen;
@@ -684,8 +688,8 @@
 	mkssert(*var != 0);
 	if (*val == '[') {
 		if (set_refflag)
-			errorf("%s: reference variable cannot be an array",
-			    var);
+			errorf("%s: %s", var,
+			    "reference variable can't be an array");
 		len = array_ref_len(val);
 		if (len == 0)
 			return (NULL);
@@ -711,7 +715,7 @@
 			return (NULL);
 		strdupx(tvar, var, ATEMP);
 		val = NULL;
-		/* handle foo[*] â foo (whole array) mapping for R39b */
+		/* handle foo[*] => foo (whole array) mapping for R39b */
 		len = strlen(tvar);
 		if (len > 3 && tvar[len-3] == '[' && tvar[len-2] == '*' &&
 		    tvar[len-1] == ']')
@@ -721,7 +725,7 @@
 	/* Prevent typeset from creating a local PATH/ENV/SHELL */
 	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0 ||
 	    strcmp(tvar, "ENV") == 0 || strcmp(tvar, "SHELL") == 0))
-		errorf("%s: restricted", tvar);
+		errorf("%s: %s", tvar, "restricted");
 
 	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? true : false) :
 	    global(tvar);
@@ -755,7 +759,7 @@
 	if ((vpbase->flag&RDONLY) &&
 	    (val || clr || (set & ~EXPORT)))
 		/* XXX check calls - is error here ok by POSIX? */
-		errorf("%s: is read only", tvar);
+		errorf("%s: %s", tvar, "is read only");
 	afree(tvar, ATEMP);
 
 	/* most calls are with set/clr == 0 */
@@ -836,7 +840,7 @@
 	/* only x[0] is ever exported, so use vpbase */
 	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER) &&
 	    vpbase->type == 0)
-		export(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
+		exportprep(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
 
 	return (vp);
 }
@@ -982,7 +986,7 @@
 	return ((char **)XPclose(denv));
 }
 
-#if !HAVE_ARC4RANDOM
+/* Bob Jenkins' one-at-a-time hash */
 static uint32_t
 oaathash_update(register uint32_t h, register const uint8_t *cp,
     register size_t n)
@@ -996,33 +1000,64 @@
 	return (h);
 }
 
-void
-change_random(const void *vp, size_t n)
+static uint32_t
+oaathash_finalise(register uint32_t h)
 {
-	register uint32_t h = 0x100;
-	struct {
-		const void *sp, *bp, *dp;
-		size_t dsz;
-		struct timeval tv;
-		uint32_t s;
-	} i;
-
-	i.dp = vp;
-	i.dsz = n;
-	i.s = lcg_state;
-	i.bp = &lcg_state;
-	i.sp = &i;
-	gettimeofday(&i.tv, NULL);
-	h = oaathash_update(oaathash_update(h, (void *)&i, sizeof(i)), vp, n);
-
-	/* oaathash_finalise */
 	h += h << 3;
 	h ^= h >> 11;
 	h += h << 15;
 
-	lcg_state = h;
+	return (h);
 }
+
+uint32_t
+oaathash_full(register const uint8_t *bp)
+{
+	register uint32_t h = 0;
+	register uint8_t c;
+
+	while ((c = *bp++)) {
+		h += c;
+		h += h << 10;
+		h ^= h >> 6;
+	}
+
+	return (oaathash_finalise(h));
+}
+
+void
+change_random(const void *vp, size_t n)
+{
+	register uint32_t h = 0x100;
+#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
+	uint32_t i;
+#endif
+
+	kshstate_v.cr_dp = vp;
+	kshstate_v.cr_dsz = n;
+	gettimeofday(&kshstate_v.cr_tv, NULL);
+	h = oaathash_update(oaathash_update(h, (void *)&kshstate_v,
+	    sizeof(kshstate_v)), vp, n);
+	kshstate_v.lcg_state_ = oaathash_finalise(h);
+
+#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
+	/*
+	 * either we have very check entropy get and push available,
+	 * with malloc() pulling in this code already anyway, or the
+	 * user requested us to use the old functions
+	 */
+#if defined(arc4random_pushb_fast)
+	arc4random_pushb_fast(&kshstate_v.lcg_state_,
+	    sizeof(kshstate_v.lcg_state_));
+	i = arc4random();
+#else
+	i = arc4random_pushb(&kshstate_v.lcg_state_,
+	    sizeof(kshstate_v.lcg_state_));
+#endif
+	h = oaathash_update(h, (void *)&i, sizeof(i));
+	kshstate_v.lcg_state_ = oaathash_finalise(h);
 #endif
+}
 
 /*
  * handle special variables with side effects - PATH, SECONDS.
@@ -1074,15 +1109,12 @@
 			return;
 		break;
 	case V_RANDOM:
-#if HAVE_ARC4RANDOM
-		i = arc4random() & 0x7FFF;
-#else
 		/*
 		 * this is the same Linear Congruential PRNG as Borland
 		 * C/C++ allegedly uses in its built-in rand() function
 		 */
-		i = ((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF;
-#endif
+		i = ((kshstate_v.lcg_state_ =
+		    22695477 * kshstate_v.lcg_state_ + 1) >> 16) & 0x7FFF;
 		break;
 	case V_HISTSIZE:
 		i = histsize;
@@ -1196,25 +1228,11 @@
 			x_lins = i;
 		break;
 	case V_RANDOM:
-#if HAVE_ARC4RANDOM
-#if HAVE_ARC4RANDOM_PUSHB
-		if (Flag(FARC4RANDOM))
-			/*
-			 * things like initialisation, environment import,
-			 * etc. are already done
-			 */
-			arc4random_pushb(&i, sizeof(i));
-		else
-			/* during start-up phase or somesuch */
-#endif	/* HAVE_ARC4RANDOM_PUSHB */
-			arc4random_addrandom((void *)&i, sizeof(i));
-#else	/* !HAVE_ARC4RANDOM */
 		/*
-		 * mksh R40+ no longer has the traditional repeatability
+		 * mksh R39d+ no longer has the traditional repeatability
 		 * of $RANDOM sequences, but always retains state
 		 */
 		change_random(&i, sizeof(i));
-#endif	/* !HAVE_ARC4RANDOM */
 		break;
 	case V_SECONDS:
 		{
@@ -1259,13 +1277,12 @@
 		unspecial(vp->name);
 		break;
 
-	/* AT&T ksh man page says OPTIND, OPTARG and _ lose special meaning,
-	 * but OPTARG does not (still set by getopts) and _ is also still
-	 * set in various places.
-	 * Don't know what AT&T does for:
-	 *		HISTSIZE, HISTFILE,
-	 * Unsetting these in AT&T ksh does not loose the 'specialness':
-	 * no effect: IFS, COLUMNS, PATH, TMPDIR
+	/*
+	 * AT&T ksh man page says OPTIND, OPTARG and _ lose special
+	 * meaning, but OPTARG does not (still set by getopts) and _ is
+	 * also still set in various places. Don't know what AT&T does
+	 * for HISTSIZE, HISTFILE. Unsetting these in AT&T ksh does not
+	 * loose the 'specialness': IFS, COLUMNS, PATH, TMPDIR
 	 */
 	}
 }
@@ -1277,7 +1294,7 @@
 static struct tbl *
 arraysearch(struct tbl *vp, uint32_t val)
 {
-	struct tbl *prev, *curr, *new;
+	struct tbl *prev, *curr, *news;
 	size_t len;
 
 	vp->flag = (vp->flag | (ARRAY|DEFINED)) & ~ASSOC;
@@ -1293,25 +1310,26 @@
 	if (curr && curr->ua.index == val) {
 		if (curr->flag&ISSET)
 			return (curr);
-		new = curr;
+		news = curr;
 	} else
-		new = NULL;
-	len = strlen(vp->name) + 1;
-	if (!new) {
-		new = alloc(offsetof(struct tbl, name[0]) + len, vp->areap);
-		memcpy(new->name, vp->name, len);
-	}
-	new->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
-	new->type = vp->type;
-	new->areap = vp->areap;
-	new->u2.field = vp->u2.field;
-	new->ua.index = val;
-
-	if (curr != new) {		/* not reusing old array entry */
-		prev->u.array = new;
-		new->u.array = curr;
+		news = NULL;
+	if (!news) {
+		len = strlen(vp->name);
+		checkoktoadd(len, 1 + offsetof(struct tbl, name[0]));
+		news = alloc(offsetof(struct tbl, name[0]) + ++len, vp->areap);
+		memcpy(news->name, vp->name, len);
+	}
+	news->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
+	news->type = vp->type;
+	news->areap = vp->areap;
+	news->u2.field = vp->u2.field;
+	news->ua.index = val;
+
+	if (curr != news) {		/* not reusing old array entry */
+		prev->u.array = news;
+		news->u.array = curr;
 	}
-	return (new);
+	return (news);
 }
 
 /* Return the length of an array reference (eg, [1+2]) - cp is assumed
@@ -1368,7 +1386,7 @@
 
 	/* Note: AT&T ksh allows set -A but not set +A of a read-only var */
 	if ((vp->flag&RDONLY))
-		errorf("%s: is read only", var);
+		errorf("%s: %s", var, "is read only");
 	/* This code is quite non-optimal */
 	if (reset)
 		/* trash existing values and attributes */
@@ -1433,7 +1451,7 @@
 	}
 
 #ifdef TIOCGWINSZ
-	/* check if window size has changed since first time */
+	/* check if window size has changed */
 	if (tty_fd >= 0) {
 		struct winsize ws;
 
@@ -1451,4 +1469,19 @@
 		x_cols = 80;
 	if (x_lins < MIN_LINS)
 		x_lins = 24;
+
+#ifdef SIGWINCH
+	got_winch = 0;
+#endif
+}
+
+uint32_t
+evilhash(const char *s)
+{
+	register uint32_t h = 0x100;
+
+	h = oaathash_update(h, (void *)&kshstate_f, sizeof(kshstate_f));
+	kshstate_f.h = oaathash_full((const uint8_t *)s);
+	return (oaathash_finalise(oaathash_update(h,
+	    (void *)&kshstate_f.h, sizeof(kshstate_f.h))));
 }
