diff -Nurd -x'*~' anacron-2.3.orig/0anacron.daily anacron-2.3/0anacron.daily
--- anacron-2.3.orig/0anacron.daily	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/0anacron.daily	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# anacron's cron script
+#
+# This script updates anacron time stamps. It is called through run-parts
+# either by anacron itself or by cron.
+#
+# The script is called "0anacron" to assure that it will be executed
+# _before_ all other scripts.
+
+test -x @PREFIX@/sbin/anacron || exit 0
+anacron -u cron.daily
diff -Nurd -x'*~' anacron-2.3.orig/0anacron.monthly anacron-2.3/0anacron.monthly
--- anacron-2.3.orig/0anacron.monthly	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/0anacron.monthly	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# anacron's cron script
+#
+# This script updates anacron time stamps. It is called through run-parts
+# either by anacron itself or by cron.
+#
+# The script is called "0anacron" to assure that it will be executed
+# _before_ all other scripts.
+
+test -x @PREFIX@/sbin/anacron || exit 0
+anacron -u cron.monthly
diff -Nurd -x'*~' anacron-2.3.orig/0anacron.weekly anacron-2.3/0anacron.weekly
--- anacron-2.3.orig/0anacron.weekly	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/0anacron.weekly	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# anacron's cron script
+#
+# This script updates anacron time stamps. It is called through run-parts
+# either by anacron itself or by cron.
+#
+# The script is called "0anacron" to assure that it will be executed
+# _before_ all other scripts.
+
+test -x @PREFIX@/sbin/anacron || exit 0
+anacron -u cron.weekly
diff -Nurd -x'*~' anacron-2.3.orig/Makefile anacron-2.3/Makefile
--- anacron-2.3.orig/Makefile	2000-06-22 18:26:11.000000000 -0400
+++ anacron-2.3/Makefile	2005-12-01 12:55:52.000000000 -0500
@@ -20,15 +20,15 @@
 
 
 PREFIX = 
-BINDIR = $(PREFIX)/usr/sbin
-MANDIR = $(PREFIX)/usr/man
-CFLAGS = -Wall -pedantic -O2
+BINDIR = $(PREFIX)/sbin
+MANDIR = $(PREFIX)/share/man
+CFLAGS = -Wall -pedantic -O2 -I.
 #CFLAGS = -Wall -O2 -g -DDEBUG
 
 # If you change these, please update the man-pages too
 # Only absolute paths here, please
-SPOOLDIR = /var/spool/anacron
-ANACRONTAB = /etc/anacrontab
+SPOOLDIR = $(PREFIX)/var/spool/anacron
+ANACRONTAB = $(PREFIX)/etc/anacrontab
 
 RELEASE = 2.3
 package_name = anacron-$(RELEASE)
@@ -49,13 +49,6 @@
 .PHONY: all
 all: anacron
 
-# This makefile generates header file dependencies auto-magically
-%.d: %.c
-	$(SHELL) -ec "$(CC) -MM $(ALL_CPPFLAGS) $< \
-	| sed '1s/^\(.*\)\.o[ :]*/\1.d &/1' > $@"
-
-include $(csources:.c=.d)
-
 anacron: $(objects)
 	$(CC) $(LDFLAGS) $^ $(LOADLIBES) -o $@
 
@@ -64,7 +57,7 @@
 
 .PHONY: installdirs
 installdirs:
-	$(INSTALL_DIR) $(BINDIR) $(PREFIX)$(SPOOLDIR) \
+	$(INSTALL_DIR) $(BINDIR) $(SPOOLDIR) \
 		$(MANDIR)/man5 $(MANDIR)/man8
 
 .PHONY: install
diff -Nurd -x'*~' anacron-2.3.orig/README anacron-2.3/README
--- anacron-2.3.orig/README	2000-06-22 18:32:43.000000000 -0400
+++ anacron-2.3/README	2005-12-01 12:55:39.000000000 -0500
@@ -102,12 +102,12 @@
 3. Comment these jobs out of their crontab files.  (You may have to
    use the "crontab" command for this.  See the cron documentation.)
 
-4. Put them in /etc/anacrontab.  Note that the format is not the same
+4. Put them in @PREFIX@/etc/anacrontab.  Note that the format is not the same
    as the crontab entries.  See the anacrontab(5) manpage.  Here's an
    example from a typical Debian system:
 
 -----Cut
-# /etc/anacrontab example
+# @PREFIX@/etc/anacrontab example
 SHELL=/bin/sh
 PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
 # format: period delay job-identifier command
diff -Nurd -x'*~' anacron-2.3.orig/README.Fink anacron-2.3/README.Fink
--- anacron-2.3.orig/README.Fink	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/README.Fink	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,56 @@
+-----------------------------------------------
+Automating OS X System Maintenance with Anacron
+
+The default install of OS X schedules the cron jobs specified in
+/etc/{daily,weekly,monthly} to run at 3am, 4am, and 5am respectively.
+This schedule is good in the sense that the tasks will run at a time
+when the computer is unlikely to be in use. However, if the computer
+is a laptop or office computer that is shut off at the end of the day,
+these tasks (including rotating the logfiles, cleaning out /tmp, etc.)
+will _never_ be run.
+
+One solution to this problem is to put these system cron jobs under
+anacron's control. Doing this has both an upside and a downside:
+
+Upside:   The tasks _will_ be run once a day/week/month.
+Downside: The precise time of day when this will happen is not
+          guaranteed.
+
+If you want to do this, you must make three changes to the crontabs:
+
+1) Edit @PREFIX@/etc/anacrontab and uncomment the lines for
+   cron.daily, cron.weekly, and cron.monthly:
+
+##period   delay    job-identifier   command
+   1        5       cron.daily       sh /etc/daily	2>&1 | tee /var/log/daily.out	| mail -s "`hostname` daily output"   root
+   7       10       cron.weekly      sh /etc/weekly	2>&1 | tee /var/log/weekly.out	| mail -s "`hostname` weekly output"  root
+  30       15       cron.monthly     sh /etc/monthly	2>&1 | tee /var/log/monthly.out | mail -s "`hostname` monthly output" root
+
+2) Comment out the corresponding cron.daily, cron.weekly, cron.monthly
+   lines in /etc/crontab:
+
+# do daily/weekly/monthly maintenance
+#15     3       *       *       *       root    sh /etc/daily   2>&1 | tee /var/log/daily.out   | mail -s "`hostname` daily output"   root
+#30     4       *       *       6       root    sh /etc/weekly  2>&1 | tee /var/log/weekly.out  | mail -s "`hostname` weekly output"  root
+#30     5       1       *       *       root    sh /etc/monthly 2>&1 | tee /var/log/monthly.out | mail -s "`hostname` monthly output" root
+
+
+3) Add a line to /etc/crontab to run anacron at whatever schedule you
+   would prefer. (Keep in mind that running anacron doesn't
+   necessarily do anything; it merely checks to see if anything listed
+   in @PREFIX@/etc/anacrontab is due to be run. If not, it just exits. 
+
+   As an example, if you wanted it to run once a day at 8.30 in the
+   morning you would add the line:
+
+#min    hour    mday    month   wday    user    command
+30	8	*	*	*	root	@PREFIX/sbin/anacron -s
+
+   For more on the various permutations of this, consult the crontab.5
+   manpage. 
+
+   One other thing to note is that anacron is run by default at
+   boot-time, so if the computer isn't on at the time you set in the
+   line above, it'll still be guaranteed to run the next time you turn
+   on the computer.
+
diff -Nurd -x'*~' anacron-2.3.orig/anacron.8 anacron-2.3/anacron.8
--- anacron-2.3.orig/anacron.8	2000-06-22 18:42:05.000000000 -0400
+++ anacron-2.3/anacron.8	2005-12-01 12:55:39.000000000 -0500
@@ -18,7 +18,7 @@
 usually controlled by \fBcron\fR.
 .PP
 When executed, Anacron reads a list of jobs from a configuration file, normally
-.I /etc/anacrontab
+.I @PREFIX@/etc/anacrontab
 (see \fBanacrontab(5)\fR).  This file
 contains the list of jobs that Anacron controls.  Each
 job entry specifies a period in days, 
@@ -84,7 +84,7 @@
 .TP
 .B -n
 Run jobs now.  Ignore the delay specifications in the
-.I /etc/anacrontab
+.I @PREFIX@/etc/anacrontab
 file.  This options implies \fB-s\fR.
 .TP
 .B -d
@@ -117,11 +117,11 @@
 for more information.
 .SH FILES
 .TP
-.I /etc/anacrontab
+.I @PREFIX@/etc/anacrontab
 Contains specifications of jobs.  See \fBanacrontab(5)\fR for a complete
 description.
 .TP
-.I /var/spool/anacron
+.I @PREFIX@/var/spool/anacron
 This directory is used by Anacron for storing timestamp files.
 .SH "SEE ALSO"
 .B anacrontab(5), cron(8), tzset(3)
diff -Nurd -x'*~' anacron-2.3.orig/anacrontab.5 anacron-2.3/anacrontab.5
--- anacron-2.3.orig/anacrontab.5	2000-06-20 19:12:18.000000000 -0400
+++ anacron-2.3/anacrontab.5	2005-12-01 12:55:39.000000000 -0500
@@ -1,9 +1,9 @@
 .TH ANACRONTAB 5 1998-02-02 "Itai Tzur" "Anacron Users' Manual"
 .SH NAME
-/etc/anacrontab \- configuration file for anacron
+@PREFIX@/etc/anacrontab \- configuration file for anacron
 .SH DESCRIPTION
 The file
-.I /etc/anacrontab
+.I @PREFIX@/etc/anacrontab
 describes the jobs controlled by \fBanacron(8)\fR.  Its lines can be of
 three kinds:  job-description lines, environment
 assignments, or empty lines.
@@ -43,6 +43,6 @@
 .PP
 The Anacron
 .I README
-file.
+file. (@PREFIX@/share/doc/anacron/README)
 .SH AUTHOR
 Itai Tzur <itzur@actcom.co.il>
diff -Nurd -x'*~' anacron-2.3.orig/anacrontab.fink anacron-2.3/anacrontab.fink
--- anacron-2.3.orig/anacrontab.fink	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/anacrontab.fink	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,31 @@
+# @PREFIX@/etc/anacrontab example
+SHELL=/bin/sh
+PATH=@PREFIX@/sbin:@PREFIX@/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
+
+#----------------------------
+# Tasks defined by scripts in the @PREFIX@/etc/cron.{daily,weekly,monthly} directories
+#
+
+##period   delay    job-identifier   command
+   1        5        cron.daily       nice run-parts --report @PREFIX@/etc/cron.daily
+   7       10        cron.weekly      nice run-parts --report @PREFIX@/etc/cron.weekly
+  30       15        cron.monthly     nice run-parts --report @PREFIX@/etc/cron.monthly
+
+
+#----------------------------
+# Standard MacOS X cron jobs (If you would like anacron to be responsible for running these jobs,
+#                             uncomment the lines below and comment out the corresponding lines in
+#                             the system crontab at /etc/crontab)
+
+##period   delay    job-identifier   command
+#   1        5       syscron.daily    periodic daily
+#   7       10       syscron.weekly   periodic weekly
+#  30       15       syscron.monthly  periodic monthly
+
+
+#-----------------------------
+# Example ancillary cron jobs
+
+##period   delay    job-identifier    command
+#  1        20       locate.updatedb   csh /usr/libexec/locate.updatedb 
+#  1        25       makewhatis.local  sh /usr/libexec/makewhatis.local @PREFIX@/share/man/ 
diff -Nurd -x'*~' anacron-2.3.orig/gregor.c anacron-2.3/gregor.c
--- anacron-2.3.orig/gregor.c	2000-06-22 18:50:40.000000000 -0400
+++ anacron-2.3/gregor.c	2005-12-01 13:17:07.000000000 -0500
@@ -22,6 +22,7 @@
 */
 
 
+#include <stdlib.h>
 #include <limits.h>
 #include "gregor.h"
 
@@ -65,7 +66,7 @@
 {
     int dn;
     int i;
-    const int isleap; /* save three calls to leap() */
+    int isleap; /* save three calls to leap() */
 
     /* Some validity checks */
 
diff -Nurd -x'*~' anacron-2.3.orig/log.c anacron-2.3/log.c
--- anacron-2.3.orig/log.c	2000-06-22 18:55:13.000000000 -0400
+++ anacron-2.3/log.c	2005-12-01 13:01:45.000000000 -0500
@@ -34,6 +34,7 @@
  * and "explain" messages when we're in the foreground, and not "quiet".
  */
 
+#include <stdlib.h>
 #include <unistd.h>
 #include <syslog.h>
 #include <stdio.h>
diff -Nurd -x'*~' anacron-2.3.orig/main.c anacron-2.3/main.c
--- anacron-2.3.orig/main.c	2000-06-22 18:58:07.000000000 -0400
+++ anacron-2.3/main.c	2005-12-01 13:09:26.000000000 -0500
@@ -22,6 +22,7 @@
 */
 
 
+#include <stdlib.h>
 #include <time.h>
 #include <stdio.h>
 #include <unistd.h>
diff -Nurd -x'*~' anacron-2.3.orig/matchrx.c anacron-2.3/matchrx.c
--- anacron-2.3.orig/matchrx.c	2000-06-20 19:12:18.000000000 -0400
+++ anacron-2.3/matchrx.c	2005-12-01 13:15:58.000000000 -0500
@@ -26,6 +26,7 @@
 #include <regex.h>
 #include <stdarg.h>
 #include <stdlib.h>
+#include <string.h>
 #include "matchrx.h"
 
 int
diff -Nurd -x'*~' anacron-2.3.orig/obstack.c anacron-2.3/obstack.c
--- anacron-2.3.orig/obstack.c	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/obstack.c	2005-12-01 13:09:20.000000000 -0500
@@ -0,0 +1,613 @@
+/* obstack.c - subroutines used implicitly by object stack macros
+   Copyright (C) 1988-1994,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  Its master source is NOT part of
+   the C library, however.  The master source lives in /gd/gnu/lib.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "obstack.h"
+
+/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
+   incremented whenever callers compiled using an old obstack.h can no
+   longer properly call the functions in this obstack.c.  */
+#define OBSTACK_INTERFACE_VERSION 1
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself, and the installed library
+   supports the same library interface we do.  This code is part of the GNU
+   C Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object
+   files, it is simpler to just do this in the source for each such file.  */
+
+#include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
+#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
+#include <gnu-versions.h>
+#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
+#define ELIDE_CODE
+#endif
+#endif
+
+
+#ifndef ELIDE_CODE
+
+
+#if defined (__STDC__) && __STDC__
+#define POINTER void *
+#else
+#define POINTER char *
+#endif
+
+/* Determine default alignment.  */
+struct fooalign {char x; double d;};
+#define DEFAULT_ALIGNMENT  \
+  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
+/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
+   But in fact it might be less smart and round addresses to as much as
+   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
+union fooround {long x; double d;};
+#define DEFAULT_ROUNDING (sizeof (union fooround))
+
+/* When we copy a long block of data, this is the unit to do it with.
+   On some machines, copying successive ints does not work;
+   in such a case, redefine COPYING_UNIT to `long' (if that works)
+   or `char' as a last resort.  */
+#ifndef COPYING_UNIT
+#define COPYING_UNIT int
+#endif
+
+
+/* The functions allocating more room by calling `obstack_chunk_alloc'
+   jump to the handler pointed to by `obstack_alloc_failed_handler'.
+   This can be set to a user defined function which should either
+   abort gracefully or use longjump - but shouldn't return.  This
+   variable by default points to the internal function
+   `print_and_abort'.  */
+#if defined (__STDC__) && __STDC__
+static void print_and_abort (void);
+void (*obstack_alloc_failed_handler) (void) = print_and_abort;
+#else
+static void print_and_abort ();
+void (*obstack_alloc_failed_handler) () = print_and_abort;
+#endif
+
+/* Exit value used when `print_and_abort' is used.  */
+#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifndef EXIT_FAILURE
+#define EXIT_FAILURE 1
+#endif
+int obstack_exit_failure = EXIT_FAILURE;
+
+/* The non-GNU-C macros copy the obstack into this global variable
+   to avoid multiple evaluation.  */
+
+struct obstack *_obstack;
+
+/* Define a macro that either calls functions with the traditional malloc/free
+   calling interface, or calls functions with the mmalloc/mfree interface
+   (that adds an extra first argument), based on the state of use_extra_arg.
+   For free, do not use ?:, since some compilers, like the MIPS compilers,
+   do not allow (expr) ? void : void.  */
+
+#if defined (__STDC__) && __STDC__
+#define CALL_CHUNKFUN(h, size) \
+  (((h) -> use_extra_arg) \
+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
+   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
+
+#define CALL_FREEFUN(h, old_chunk) \
+  do { \
+    if ((h) -> use_extra_arg) \
+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
+    else \
+      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
+  } while (0)
+#else
+#define CALL_CHUNKFUN(h, size) \
+  (((h) -> use_extra_arg) \
+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
+   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
+
+#define CALL_FREEFUN(h, old_chunk) \
+  do { \
+    if ((h) -> use_extra_arg) \
+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
+    else \
+      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
+  } while (0)
+#endif
+
+
+/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
+   Objects start on multiples of ALIGNMENT (0 means use default).
+   CHUNKFUN is the function to use to allocate chunks,
+   and FREEFUN the function to free them.
+
+   Return nonzero if successful, calls obstack_alloc_failed_handler if
+   allocation fails.  */
+
+int
+_obstack_begin (h, size, alignment, chunkfun, freefun)
+     struct obstack *h;
+     int size;
+     int alignment;
+#if defined (__STDC__) && __STDC__
+     POINTER (*chunkfun) (long);
+     void (*freefun) (void *);
+#else
+     POINTER (*chunkfun) ();
+     void (*freefun) ();
+#endif
+{
+  register struct _obstack_chunk *chunk; /* points to new chunk */
+
+  if (alignment == 0)
+    alignment = (int) DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+	 Use the values for range checking, because if range checking is off,
+	 the extra bytes won't be missed terribly, but if range checking is on
+	 and we used a larger request, a whole extra 4096 bytes would be
+	 allocated.
+
+	 These number are irrelevant to the new GNU malloc.  I suspect it is
+	 less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1)
+		   & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+#if defined (__STDC__) && __STDC__
+  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+#else
+  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
+  h->freefun = freefun;
+#endif
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->use_extra_arg = 0;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+  if (!chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->next_free = h->object_base = chunk->contents;
+  h->chunk_limit = chunk->limit
+    = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  h->alloc_failed = 0;
+  return 1;
+}
+
+int
+_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
+     struct obstack *h;
+     int size;
+     int alignment;
+#if defined (__STDC__) && __STDC__
+     POINTER (*chunkfun) (POINTER, long);
+     void (*freefun) (POINTER, POINTER);
+#else
+     POINTER (*chunkfun) ();
+     void (*freefun) ();
+#endif
+     POINTER arg;
+{
+  register struct _obstack_chunk *chunk; /* points to new chunk */
+
+  if (alignment == 0)
+    alignment = (int) DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+	 Use the values for range checking, because if range checking is off,
+	 the extra bytes won't be missed terribly, but if range checking is on
+	 and we used a larger request, a whole extra 4096 bytes would be
+	 allocated.
+
+	 These number are irrelevant to the new GNU malloc.  I suspect it is
+	 less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1)
+		   & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+#if defined(__STDC__) && __STDC__
+  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+#else
+  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
+  h->freefun = freefun;
+#endif
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->extra_arg = arg;
+  h->use_extra_arg = 1;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+  if (!chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->next_free = h->object_base = chunk->contents;
+  h->chunk_limit = chunk->limit
+    = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  h->alloc_failed = 0;
+  return 1;
+}
+
+/* Allocate a new current chunk for the obstack *H
+   on the assumption that LENGTH bytes need to be added
+   to the current object, or a new object of length LENGTH allocated.
+   Copies any partial object from the end of the old chunk
+   to the beginning of the new one.  */
+
+void
+_obstack_newchunk (h, length)
+     struct obstack *h;
+     int length;
+{
+  register struct _obstack_chunk *old_chunk = h->chunk;
+  register struct _obstack_chunk *new_chunk;
+  register long	new_size;
+  register long obj_size = h->next_free - h->object_base;
+  register long i;
+  long already;
+  char *object_base;
+
+  /* Compute size for new chunk.  */
+  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;
+  if (new_size < h->chunk_size)
+    new_size = h->chunk_size;
+
+  /* Allocate and initialize the new chunk.  */
+  new_chunk = CALL_CHUNKFUN (h, new_size);
+  if (!new_chunk)
+    (*obstack_alloc_failed_handler) ();
+  h->chunk = new_chunk;
+  new_chunk->prev = old_chunk;
+  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
+
+  /* Compute an aligned object_base in the new chunk */
+  object_base =
+    __INT_TO_PTR ((__PTR_TO_INT (new_chunk->contents) + h->alignment_mask)
+		  & ~ (h->alignment_mask));
+
+  /* Move the existing object to the new chunk.
+     Word at a time is fast and is safe if the object
+     is sufficiently aligned.  */
+  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
+    {
+      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
+	   i >= 0; i--)
+	((COPYING_UNIT *)object_base)[i]
+	  = ((COPYING_UNIT *)h->object_base)[i];
+      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
+	 but that can cross a page boundary on a machine
+	 which does not do strict alignment for COPYING_UNITS.  */
+      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
+    }
+  else
+    already = 0;
+  /* Copy remaining bytes one by one.  */
+  for (i = already; i < obj_size; i++)
+    object_base[i] = h->object_base[i];
+
+  /* If the object just copied was the only data in OLD_CHUNK,
+     free that chunk and remove it from the chain.
+     But not if that chunk might contain an empty object.  */
+  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
+    {
+      new_chunk->prev = old_chunk->prev;
+      CALL_FREEFUN (h, old_chunk);
+    }
+
+  h->object_base = object_base;
+  h->next_free = h->object_base + obj_size;
+  /* The new chunk certainly contains no empty object yet.  */
+  h->maybe_empty_object = 0;
+}
+
+/* Return nonzero if object OBJ has been allocated from obstack H.
+   This is here for debugging.
+   If you use it in a program, you are probably losing.  */
+
+#if defined (__STDC__) && __STDC__
+/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
+   obstack.h because it is just for debugging.  */
+int _obstack_allocated_p (struct obstack *h, POINTER obj);
+#endif
+
+int
+_obstack_allocated_p (h, obj)
+     struct obstack *h;
+     POINTER obj;
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = (h)->chunk;
+  /* We use >= rather than > since the object cannot be exactly at
+     the beginning of the chunk but might be an empty object exactly
+     at the end of an adjacent chunk.  */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      lp = plp;
+    }
+  return lp != 0;
+}
+
+/* Free objects in obstack H, including OBJ and everything allocate
+   more recently than OBJ.  If OBJ is zero, free everything in H.  */
+
+#undef obstack_free
+
+/* This function has two names with identical definitions.
+   This is the first one, called from non-ANSI code.  */
+
+void
+_obstack_free (h, obj)
+     struct obstack *h;
+     POINTER obj;
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+	 chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
+/* This function is used from ANSI code.  */
+
+void
+obstack_free (h, obj)
+     struct obstack *h;
+     POINTER obj;
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+	 chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
+int
+_obstack_memory_used (h)
+     struct obstack *h;
+{
+  register struct _obstack_chunk* lp;
+  register int nbytes = 0;
+
+  for (lp = h->chunk; lp != 0; lp = lp->prev)
+    {
+      nbytes += lp->limit - (char *) lp;
+    }
+  return nbytes;
+}
+
+/* Define the error handler.  */
+#ifndef _
+# if defined HAVE_LIBINTL_H || defined _LIBC
+#  include <libintl.h>
+#  ifndef _
+#   define _(Str) gettext (Str)
+#  endif
+# else
+#  define _(Str) (Str)
+# endif
+#endif
+#if defined _LIBC && defined USE_IN_LIBIO
+# include <libio/iolibio.h>
+# define fputs(s, f) _IO_fputs (s, f)
+#endif
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+#  define __attribute__(Spec) /* empty */
+# endif
+#endif
+
+static void
+__attribute__ ((noreturn))
+print_and_abort ()
+{
+  fputs (_("memory exhausted"), stderr);
+  fputc ('\n', stderr);
+  exit (obstack_exit_failure);
+}
+
+#if 0
+/* These are now turned off because the applications do not use it
+   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
+
+/* Now define the functional versions of the obstack macros.
+   Define them to simply use the corresponding macros to do the job.  */
+
+#if defined (__STDC__) && __STDC__
+/* These function definitions do not work with non-ANSI preprocessors;
+   they won't pass through the macro names in parentheses.  */
+
+/* The function names appear in parentheses in order to prevent
+   the macro-definitions of the names from being expanded there.  */
+
+POINTER (obstack_base) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_base (obstack);
+}
+
+POINTER (obstack_next_free) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_next_free (obstack);
+}
+
+int (obstack_object_size) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_object_size (obstack);
+}
+
+int (obstack_room) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_room (obstack);
+}
+
+int (obstack_make_room) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  return obstack_make_room (obstack, length);
+}
+
+void (obstack_grow) (obstack, data, length)
+     struct obstack *obstack;
+     const POINTER data;
+     int length;
+{
+  obstack_grow (obstack, data, length);
+}
+
+void (obstack_grow0) (obstack, data, length)
+     struct obstack *obstack;
+     const POINTER data;
+     int length;
+{
+  obstack_grow0 (obstack, data, length);
+}
+
+void (obstack_1grow) (obstack, character)
+     struct obstack *obstack;
+     int character;
+{
+  obstack_1grow (obstack, character);
+}
+
+void (obstack_blank) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  obstack_blank (obstack, length);
+}
+
+void (obstack_1grow_fast) (obstack, character)
+     struct obstack *obstack;
+     int character;
+{
+  obstack_1grow_fast (obstack, character);
+}
+
+void (obstack_blank_fast) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  obstack_blank_fast (obstack, length);
+}
+
+POINTER (obstack_finish) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_finish (obstack);
+}
+
+POINTER (obstack_alloc) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  return obstack_alloc (obstack, length);
+}
+
+POINTER (obstack_copy) (obstack, address, length)
+     struct obstack *obstack;
+     const POINTER address;
+     int length;
+{
+  return obstack_copy (obstack, address, length);
+}
+
+POINTER (obstack_copy0) (obstack, address, length)
+     struct obstack *obstack;
+     const POINTER address;
+     int length;
+{
+  return obstack_copy0 (obstack, address, length);
+}
+
+#endif /* __STDC__ */
+
+#endif /* 0 */
+
+#endif	/* !ELIDE_CODE */
diff -Nurd -x'*~' anacron-2.3.orig/obstack.h anacron-2.3/obstack.h
--- anacron-2.3.orig/obstack.h	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/obstack.h	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,605 @@
+/* obstack.h - object stack macros
+   Copyright (C) 1988,89,90,91,92,93,94,96,97,98,99 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  Its master source is NOT part of
+   the C library, however.  The master source lives in /gd/gnu/lib.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Summary:
+
+All the apparent functions defined here are macros. The idea
+is that you would use these pre-tested macros to solve a
+very specific set of problems, and they would run fast.
+Caution: no side-effects in arguments please!! They may be
+evaluated MANY times!!
+
+These macros operate a stack of objects.  Each object starts life
+small, and may grow to maturity.  (Consider building a word syllable
+by syllable.)  An object can move while it is growing.  Once it has
+been "finished" it never changes address again.  So the "top of the
+stack" is typically an immature growing object, while the rest of the
+stack is of mature, fixed size and fixed address objects.
+
+These routines grab large chunks of memory, using a function you
+supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
+by calling `obstack_chunk_free'.  You must define them and declare
+them before using any obstack macros.
+
+Each independent stack is represented by a `struct obstack'.
+Each of the obstack macros expects a pointer to such a structure
+as the first argument.
+
+One motivation for this package is the problem of growing char strings
+in symbol tables.  Unless you are "fascist pig with a read-only mind"
+--Gosper's immortal quote from HAKMEM item 154, out of context--you
+would not like to put any arbitrary upper limit on the length of your
+symbols.
+
+In practice this often means you will build many short symbols and a
+few long symbols.  At the time you are reading a symbol you don't know
+how long it is.  One traditional method is to read a symbol into a
+buffer, realloc()ating the buffer every time you try to read a symbol
+that is longer than the buffer.  This is beaut, but you still will
+want to copy the symbol from the buffer to a more permanent
+symbol-table entry say about half the time.
+
+With obstacks, you can work differently.  Use one obstack for all symbol
+names.  As you read a symbol, grow the name in the obstack gradually.
+When the name is complete, finalize it.  Then, if the symbol exists already,
+free the newly read name.
+
+The way we do this is to take a large chunk, allocating memory from
+low addresses.  When you want to build a symbol in the chunk you just
+add chars above the current "high water mark" in the chunk.  When you
+have finished adding chars, because you got to the end of the symbol,
+you know how long the chars are, and you can create a new object.
+Mostly the chars will not burst over the highest address of the chunk,
+because you would typically expect a chunk to be (say) 100 times as
+long as an average object.
+
+In case that isn't clear, when we have enough chars to make up
+the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
+so we just point to it where it lies.  No moving of chars is
+needed and this is the second win: potentially long strings need
+never be explicitly shuffled. Once an object is formed, it does not
+change its address during its lifetime.
+
+When the chars burst over a chunk boundary, we allocate a larger
+chunk, and then copy the partly formed object from the end of the old
+chunk to the beginning of the new larger chunk.  We then carry on
+accreting characters to the end of the object as we normally would.
+
+A special macro is provided to add a single char at a time to a
+growing object.  This allows the use of register variables, which
+break the ordinary 'growth' macro.
+
+Summary:
+	We allocate large chunks.
+	We carve out one object at a time from the current chunk.
+	Once carved, an object never moves.
+	We are free to append data of any size to the currently
+	  growing object.
+	Exactly one object is growing in an obstack at any one time.
+	You can run one obstack per control block.
+	You may have as many control blocks as you dare.
+	Because of the way we do it, you can `unwind' an obstack
+	  back to a previous state. (You may remove objects much
+	  as you would with a stack.)
+*/
+
+
+/* Don't do the contents of this file more than once.  */
+
+#ifndef _OBSTACK_H
+#define _OBSTACK_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* We use subtraction of (char *) 0 instead of casting to int
+   because on word-addressable machines a simple cast to int
+   may ignore the byte-within-word field of the pointer.  */
+
+#ifndef __PTR_TO_INT
+# define __PTR_TO_INT(P) ((P) - (char *) 0)
+#endif
+
+#ifndef __INT_TO_PTR
+# define __INT_TO_PTR(P) ((P) + (char *) 0)
+#endif
+
+/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is
+   defined, as with GNU C, use that; that way we don't pollute the
+   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is
+   available, include it and use ptrdiff_t.  In traditional C, long is
+   the best that we can do.  */
+
+#ifdef __PTRDIFF_TYPE__
+# define PTR_INT_TYPE __PTRDIFF_TYPE__
+#else
+# ifdef HAVE_STDDEF_H
+#  include <stddef.h>
+#  define PTR_INT_TYPE ptrdiff_t
+# else
+#  define PTR_INT_TYPE long
+# endif
+#endif
+
+#if defined _LIBC || defined HAVE_STRING_H
+# include <string.h>
+# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))
+#else
+# ifdef memcpy
+#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))
+# else
+#  define _obstack_memcpy(To, From, N) bcopy ((From), (To), (N))
+# endif
+#endif
+
+struct _obstack_chunk		/* Lives at front of each chunk. */
+{
+  char  *limit;			/* 1 past end of this chunk */
+  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
+  char	contents[4];		/* objects begin here */
+};
+
+struct obstack		/* control current object in current chunk */
+{
+  long	chunk_size;		/* preferred size to allocate chunks in */
+  struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
+  char	*object_base;		/* address of object we are building */
+  char	*next_free;		/* where to add next char to current object */
+  char	*chunk_limit;		/* address of char after current chunk */
+  PTR_INT_TYPE temp;		/* Temporary for some macros.  */
+  int   alignment_mask;		/* Mask of alignment for each object. */
+#if defined __STDC__ && __STDC__
+  /* These prototypes vary based on `use_extra_arg', and we use
+     casts to the prototypeless function type in all assignments,
+     but having prototypes here quiets -Wstrict-prototypes.  */
+  struct _obstack_chunk *(*chunkfun) (void *, long);
+  void (*freefun) (void *, struct _obstack_chunk *);
+  void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+#else
+  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */
+  void (*freefun) ();		/* User's function to free a chunk.  */
+  char *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+#endif
+  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
+  unsigned maybe_empty_object:1;/* There is a possibility that the current
+				   chunk contains a zero-length object.  This
+				   prevents freeing the chunk if we allocate
+				   a bigger chunk to replace it. */
+  unsigned alloc_failed:1;	/* No longer used, as we now call the failed
+				   handler on error, but retained for binary
+				   compatibility.  */
+};
+
+/* Declare the external functions we use; they are in obstack.c.  */
+
+#if defined __STDC__ && __STDC__
+extern void _obstack_newchunk (struct obstack *, int);
+extern void _obstack_free (struct obstack *, void *);
+extern int _obstack_begin (struct obstack *, int, int,
+			    void *(*) (long), void (*) (void *));
+extern int _obstack_begin_1 (struct obstack *, int, int,
+			     void *(*) (void *, long),
+			     void (*) (void *, void *), void *);
+extern int _obstack_memory_used (struct obstack *);
+#else
+extern void _obstack_newchunk ();
+extern void _obstack_free ();
+extern int _obstack_begin ();
+extern int _obstack_begin_1 ();
+extern int _obstack_memory_used ();
+#endif
+
+#if defined __STDC__ && __STDC__
+
+/* Do the function-declarations after the structs
+   but before defining the macros.  */
+
+void obstack_init (struct obstack *obstack);
+
+void * obstack_alloc (struct obstack *obstack, int size);
+
+void * obstack_copy (struct obstack *obstack, const void *address, int size);
+void * obstack_copy0 (struct obstack *obstack, const void *address, int size);
+
+void obstack_free (struct obstack *obstack, void *block);
+
+void obstack_blank (struct obstack *obstack, int size);
+
+void obstack_grow (struct obstack *obstack, const void *data, int size);
+void obstack_grow0 (struct obstack *obstack, const void *data, int size);
+
+void obstack_1grow (struct obstack *obstack, int data_char);
+void obstack_ptr_grow (struct obstack *obstack, const void *data);
+void obstack_int_grow (struct obstack *obstack, int data);
+
+void * obstack_finish (struct obstack *obstack);
+
+int obstack_object_size (struct obstack *obstack);
+
+int obstack_room (struct obstack *obstack);
+void obstack_make_room (struct obstack *obstack, int size);
+void obstack_1grow_fast (struct obstack *obstack, int data_char);
+void obstack_ptr_grow_fast (struct obstack *obstack, const void *data);
+void obstack_int_grow_fast (struct obstack *obstack, int data);
+void obstack_blank_fast (struct obstack *obstack, int size);
+
+void * obstack_base (struct obstack *obstack);
+void * obstack_next_free (struct obstack *obstack);
+int obstack_alignment_mask (struct obstack *obstack);
+int obstack_chunk_size (struct obstack *obstack);
+int obstack_memory_used (struct obstack *obstack);
+
+#endif /* __STDC__ */
+
+/* Non-ANSI C cannot really support alternative functions for these macros,
+   so we do not declare them.  */
+
+/* Error handler called when `obstack_chunk_alloc' failed to allocate
+   more memory.  This can be set to a user defined function which
+   should either abort gracefully or use longjump - but shouldn't
+   return.  The default action is to print a message and abort.  */
+#if defined __STDC__ && __STDC__
+extern void (*obstack_alloc_failed_handler) (void);
+#else
+extern void (*obstack_alloc_failed_handler) ();
+#endif
+
+/* Exit value used when `print_and_abort' is used.  */
+extern int obstack_exit_failure;
+
+/* Pointer to beginning of object being allocated or to be allocated next.
+   Note that this might not be the final address of the object
+   because a new chunk might be needed to hold the final size.  */
+
+#define obstack_base(h) ((h)->object_base)
+
+/* Size for allocating ordinary chunks.  */
+
+#define obstack_chunk_size(h) ((h)->chunk_size)
+
+/* Pointer to next byte not yet allocated in current chunk.  */
+
+#define obstack_next_free(h)	((h)->next_free)
+
+/* Mask specifying low bits that should be clear in address of an object.  */
+
+#define obstack_alignment_mask(h) ((h)->alignment_mask)
+
+/* To prevent prototype warnings provide complete argument list in
+   standard C version.  */
+#if defined __STDC__ && __STDC__
+
+# define obstack_init(h)					\
+  _obstack_begin ((h), 0, 0,					\
+		  (void *(*) (long)) obstack_chunk_alloc, 	\
+		  (void (*) (void *)) obstack_chunk_free)
+
+# define obstack_begin(h, size)					\
+  _obstack_begin ((h), (size), 0,				\
+		  (void *(*) (long)) obstack_chunk_alloc, 	\
+		  (void (*) (void *)) obstack_chunk_free)
+
+# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
+  _obstack_begin ((h), (size), (alignment),				   \
+		  (void *(*) (long)) (chunkfun), 			   \
+		  (void (*) (void *)) (freefun))
+
+# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+  _obstack_begin_1 ((h), (size), (alignment),				\
+		    (void *(*) (void *, long)) (chunkfun),		\
+		    (void (*) (void *, void *)) (freefun), (arg))
+
+# define obstack_chunkfun(h, newchunkfun) \
+  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
+
+# define obstack_freefun(h, newfreefun) \
+  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))
+
+#else
+
+# define obstack_init(h)						\
+  _obstack_begin ((h), 0, 0,						\
+		  (void *(*) ()) obstack_chunk_alloc, 			\
+		  (void (*) ()) obstack_chunk_free)
+
+# define obstack_begin(h, size)						\
+  _obstack_begin ((h), (size), 0,					\
+		  (void *(*) ()) obstack_chunk_alloc,			\
+		  (void (*) ()) obstack_chunk_free)
+
+# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
+  _obstack_begin ((h), (size), (alignment),				   \
+		  (void *(*) ()) (chunkfun), 				   \
+		  (void (*) ()) (freefun))
+
+# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+  _obstack_begin_1 ((h), (size), (alignment),				\
+		    (void *(*) ()) (chunkfun), 				\
+		    (void (*) ()) (freefun), (arg))
+
+# define obstack_chunkfun(h, newchunkfun) \
+  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))
+
+# define obstack_freefun(h, newfreefun) \
+  ((h) -> freefun = (void (*)()) (newfreefun))
+
+#endif
+
+#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)
+
+#define obstack_blank_fast(h,n) ((h)->next_free += (n))
+
+#define obstack_memory_used(h) _obstack_memory_used (h)
+
+#if defined __GNUC__ && defined __STDC__ && __STDC__
+/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
+   does not implement __extension__.  But that compiler doesn't define
+   __GNUC_MINOR__.  */
+# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
+#  define __extension__
+# endif
+
+/* For GNU C, if not -traditional,
+   we can define these macros to compute all args only once
+   without using a global variable.
+   Also, we can avoid using the `temp' slot, to make faster code.  */
+
+# define obstack_object_size(OBSTACK)					\
+  __extension__								\
+  ({ struct obstack *__o = (OBSTACK);					\
+     (unsigned) (__o->next_free - __o->object_base); })
+
+# define obstack_room(OBSTACK)						\
+  __extension__								\
+  ({ struct obstack *__o = (OBSTACK);					\
+     (unsigned) (__o->chunk_limit - __o->next_free); })
+
+# define obstack_make_room(OBSTACK,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->chunk_limit - __o->next_free < __len)			\
+     _obstack_newchunk (__o, __len);					\
+   (void) 0; })
+
+# define obstack_empty_p(OBSTACK)					\
+  __extension__								\
+  ({ struct obstack *__o = (OBSTACK);					\
+     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })
+
+# define obstack_grow(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len);					\
+   _obstack_memcpy (__o->next_free, (where), __len);			\
+   __o->next_free += __len;						\
+   (void) 0; })
+
+# define obstack_grow0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len + 1);				\
+   _obstack_memcpy (__o->next_free, (where), __len);			\
+   __o->next_free += __len;						\
+   *(__o->next_free)++ = 0;						\
+   (void) 0; })
+
+# define obstack_1grow(OBSTACK,datum)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + 1 > __o->chunk_limit)				\
+     _obstack_newchunk (__o, 1);					\
+   *(__o->next_free)++ = (datum);					\
+   (void) 0; })
+
+/* These assume that the obstack alignment is good enough for pointers
+   or ints, and that the data added so far to the current object
+   shares that much alignment.  */
+
+# define obstack_ptr_grow(OBSTACK,datum)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (void *));				\
+   *((void **)__o->next_free)++ = (datum);				\
+   (void) 0; })
+
+# define obstack_int_grow(OBSTACK,datum)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (int));				\
+   *((int *)__o->next_free)++ = (datum);				\
+   (void) 0; })
+
+# define obstack_ptr_grow_fast(h,aptr)					\
+  (*((void **) (h)->next_free)++ = (aptr))
+
+# define obstack_int_grow_fast(h,aint)					\
+  (*((int *) (h)->next_free)++ = (aint))
+
+# define obstack_blank(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->chunk_limit - __o->next_free < __len)			\
+     _obstack_newchunk (__o, __len);					\
+   __o->next_free += __len;						\
+   (void) 0; })
+
+# define obstack_alloc(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_blank (__h, (length));					\
+   obstack_finish (__h); })
+
+# define obstack_copy(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+# define obstack_copy0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow0 (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+/* The local variable is named __o1 to avoid a name conflict
+   when obstack_blank is called.  */
+# define obstack_finish(OBSTACK)  					\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   void *value;								\
+   value = (void *) __o1->object_base;					\
+   if (__o1->next_free == value)					\
+     __o1->maybe_empty_object = 1;					\
+   __o1->next_free							\
+     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\
+		     & ~ (__o1->alignment_mask));			\
+   if (__o1->next_free - (char *)__o1->chunk				\
+       > __o1->chunk_limit - (char *)__o1->chunk)			\
+     __o1->next_free = __o1->chunk_limit;				\
+   __o1->object_base = __o1->next_free;					\
+   value; })
+
+# define obstack_free(OBSTACK, OBJ)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   void *__obj = (OBJ);							\
+   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
+     __o->next_free = __o->object_base = (char *)__obj;			\
+   else (obstack_free) (__o, __obj); })
+
+#else /* not __GNUC__ or not __STDC__ */
+
+# define obstack_object_size(h) \
+ (unsigned) ((h)->next_free - (h)->object_base)
+
+# define obstack_room(h)		\
+ (unsigned) ((h)->chunk_limit - (h)->next_free)
+
+# define obstack_empty_p(h) \
+ ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)
+
+/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
+   so that we can avoid having void expressions
+   in the arms of the conditional expression.
+   Casting the third operand to void was tried before,
+   but some compilers won't accept it.  */
+
+# define obstack_make_room(h,length)					\
+( (h)->temp = (length),							\
+  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))
+
+# define obstack_grow(h,where,length)					\
+( (h)->temp = (length),							\
+  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
+  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
+  (h)->next_free += (h)->temp)
+
+# define obstack_grow0(h,where,length)					\
+( (h)->temp = (length),							\
+  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),			\
+  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
+  (h)->next_free += (h)->temp,						\
+  *((h)->next_free)++ = 0)
+
+# define obstack_1grow(h,datum)						\
+( (((h)->next_free + 1 > (h)->chunk_limit)				\
+   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
+  (*((h)->next_free)++ = (datum)))
+
+# define obstack_ptr_grow(h,datum)					\
+( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
+  (*((const char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = (datum)))
+
+# define obstack_int_grow(h,datum)					\
+( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
+  (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = (datum)))
+
+# define obstack_ptr_grow_fast(h,aptr)					\
+  (*((const char **) (h)->next_free)++ = (aptr))
+
+# define obstack_int_grow_fast(h,aint)					\
+  (*((int *) (h)->next_free)++ = (aint))
+
+# define obstack_blank(h,length)					\
+( (h)->temp = (length),							\
+  (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
+  ((h)->next_free += (h)->temp))
+
+# define obstack_alloc(h,length)					\
+ (obstack_blank ((h), (length)), obstack_finish ((h)))
+
+# define obstack_copy(h,where,length)					\
+ (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_copy0(h,where,length)					\
+ (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
+
+# define obstack_finish(h)  						\
+( ((h)->next_free == (h)->object_base					\
+   ? (((h)->maybe_empty_object = 1), 0)					\
+   : 0),								\
+  (h)->temp = __PTR_TO_INT ((h)->object_base),				\
+  (h)->next_free							\
+    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
+		    & ~ ((h)->alignment_mask)),				\
+  (((h)->next_free - (char *) (h)->chunk				\
+    > (h)->chunk_limit - (char *) (h)->chunk)				\
+   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
+  (h)->object_base = (h)->next_free,					\
+  __INT_TO_PTR ((h)->temp))
+
+# if defined __STDC__ && __STDC__
+#  define obstack_free(h,obj)						\
+( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
+  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
+   ? (int) ((h)->next_free = (h)->object_base				\
+	    = (h)->temp + (char *) (h)->chunk)				\
+   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))
+# else
+#  define obstack_free(h,obj)						\
+( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
+  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
+   ? (int) ((h)->next_free = (h)->object_base				\
+	    = (h)->temp + (char *) (h)->chunk)				\
+   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))
+# endif
+
+#endif /* not __GNUC__ or not __STDC__ */
+
+#ifdef __cplusplus
+}	/* C++ */
+#endif
+
+#endif /* obstack.h */
diff -Nurd -x'*~' anacron-2.3.orig/update-anacron anacron-2.3/update-anacron
--- anacron-2.3.orig/update-anacron	1969-12-31 19:00:00.000000000 -0500
+++ anacron-2.3/update-anacron	2005-12-01 12:55:39.000000000 -0500
@@ -0,0 +1,113 @@
+#!/bin/sh
+#
+# Add anacron to the system's crontab (so anacron will be run automatically)
+#
+
+PREFIX=@PREFIX@
+
+if [ `id -u` -ne 0 ]; then
+  echo "You must be root to run update-anacron."
+  exit 1
+fi
+
+echo 
+echo "This script allows you to decide whether you would like for anacron to"
+echo "run at startup, then to periodically check for system tasks that need"
+echo "to be run.  Alternatively you could run anacron by hand once a day"
+echo "(by typing \`anacron -s' ), though this sort of defeats the purpose of"
+echo "installing a command scheduler in the first place..."
+echo 
+
+if [ "x$1" = "xpostinst" ]; then
+    echo
+    echo "If you wish to make changes to your anacron settings in the "
+    echo "future, you can run this script again with the command:"
+    echo "update-anacron"
+    echo
+    echo
+fi
+
+
+# Make sure all necessary files/dirs are present
+#
+if [ ! -d "$PREFIX/etc/cron.daily" ]; then
+  echo "The directory $PREFIX/etc/cron.daily is missing."
+  echo "update-anacron cannot continue without this directory."
+  exit 1
+fi
+
+if [ ! -d "$PREFIX/etc/cron.weekly" ]; then
+  echo "The directory $PREFIX/etc/cron.weekly is missing."
+  echo "update-anacron cannot continue without this directory."
+  exit 1
+fi
+
+if [ ! -d "$PREFIX/etc/cron.monthly" ]; then
+  echo "The directory $PREFIX/etc/cron.monthly is missing."
+  echo "update-anacron cannot continue without this directory."
+  exit 1
+fi
+
+if [ ! -f "$PREFIX/etc/anacrontab" ]; then
+  echo "The file $PREFIX/etc/anacrontab is missing."
+  echo "update-anacron cannot continue without this file."
+  exit 1
+fi
+
+# Check whether the system crontab already contains an entry for anacron
+PARSE_CRONTAB=""
+if [ -f "/etc/crontab" ]; then
+    PARSE_CRONTAB=`grep $PREFIX/sbin/anacron /etc/crontab | grep -v "^#"`
+fi
+PARSE_CRONTAB=`grep $PREFIX/sbin/anacron /etc/crontab | grep -v "^#"`
+if [ -z "$PARSE_CRONTAB" ]; then
+    echo "Anacron is not currently set up to be run periodically by cron."
+    echo "Would you like for anacron to be run automatically?"
+    /bin/echo  "In most cases, you probably want to say yes to this option. [Y/n] \c"
+    read answer
+
+    answer=`echo $answer | sed 's/^[yY].*$/y/'`
+    if [ -z "$answer" -o "x$answer" = "xy" ]; then
+	if [ ! -f "/etc/crontab" ]; then
+	    touch /etc/crontab
+	    echo "" >> /etc/crontab
+	fi	    
+	# Add anacron to /etc/crontab
+	echo "10      *       *       *       *       root    $PREFIX/sbin/anacron -s" >> /etc/crontab
+	daemonic enable anacron
+	echo
+	echo "Added anacron to task schedule, and will run at startup"
+    else
+	echo
+	echo "No changes made. Anacron must be run manually."
+    fi
+else
+    echo "It looks like anacron is already set up to be run automatically by"
+    echo "/bin/cron. I found the following entry in the system crontab:"
+    echo " min     hour    mday    month   wday    user    command"
+    echo " $PARSE_CRONTAB"
+    echo 
+
+    /bin/echo "Would you like to remove anacron from the task schedule? [y/N] \c"
+    read answer
+
+    answer=`echo $answer | sed 's/^[yY].*$/y/'`
+    if [ "x$answer" = "xy" ]; then
+	# Remove anacron from /etc/crontab
+	cat /etc/crontab | grep -v "$PREFIX/sbin/anacron" > /etc/a_very_temporary_crontab
+	mv /etc/a_very_temporary_crontab /etc/crontab
+	daemonic disable anacron
+	echo
+	echo "Removed anacron from task schedule."
+    else
+	echo
+	echo "No changes made. Anacron will still be run automatically"
+    fi
+fi
+
+
+
+
+
+exit 0
+
