diff -Nurd synfig-0.64.0.orig/configure synfig-0.64.0/configure
--- synfig-0.64.0.orig/configure	2013-05-09 12:33:30.000000000 -0400
+++ synfig-0.64.0/configure	2021-03-30 01:22:02.000000000 -0400
@@ -22450,13 +22450,13 @@
 /* end confdefs.h.  */
 
 
-		#include <tr1/unordered_map>
+		#include <unordered_map>
 
 int
 main ()
 {
 
-		std::tr1::unordered_map<int,int>::const_iterator iter;
+		std::unordered_map<int,int>::const_iterator iter;
 
   ;
   return 0;
@@ -22470,6 +22470,48 @@
 $as_echo "#define HASH_MAP_CLASS HASH_MAP_NAMESPACE::unordered_map" >>confdefs.h
 
 
+$as_echo "#define HASH_MAP_H <unordered_map>" >>confdefs.h
+
+
+$as_echo "#define HASH_MAP_NAMESPACE std" >>confdefs.h
+
+
+$as_echo "#define FUNCTIONAL_H <functional>" >>confdefs.h
+
+
+$as_echo "#define FUNCTIONAL_HASH_ON_STRING 1" >>confdefs.h
+
+
+else
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for tr1/unordered_map<int,int>::const_iterator" >&5
+$as_echo_n "checking for tr1/unordered_map<int,int>::const_iterator... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+			#include <tr1/unordered_map>
+
+int
+main ()
+{
+
+			std::tr1::unordered_map<int,int>::const_iterator iter;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HASH_MAP_CLASS HASH_MAP_NAMESPACE::unordered_map" >>confdefs.h
+
+
 $as_echo "#define HASH_MAP_H <tr1/unordered_map>" >>confdefs.h
 
 
@@ -22484,9 +22526,9 @@
 
 else
 
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	for ac_header in ext/hash_map
+		for ac_header in ext/hash_map
 do :
   ac_fn_cxx_check_header_mongrel "$LINENO" "ext/hash_map" "ac_cv_header_ext_hash_map" "$ac_includes_default"
 if test "x$ac_cv_header_ext_hash_map" = xyes; then :
@@ -22509,7 +22551,7 @@
 
 else
 
-		as_fn_error $? "C++ compiler does not seem to support unordered containers" "$LINENO" 5
+			as_fn_error $? "C++ compiler does not seem to support unordered containers" "$LINENO" 5
 
 fi
 
@@ -22519,6 +22561,9 @@
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 # Check for unordered_set or hash_set headers
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for unordered_set<int,int>::const_iterator" >&5
 $as_echo_n "checking for unordered_set<int,int>::const_iterator... " >&6; }
@@ -22526,13 +22571,13 @@
 /* end confdefs.h.  */
 
 
-		#include <tr1/unordered_set>
+		#include <unordered_set>
 
 int
 main ()
 {
 
-		std::tr1::unordered_set<int,int>::const_iterator iter;
+		std::unordered_set<int,int>::const_iterator iter;
 
   ;
   return 0;
@@ -22546,6 +22591,42 @@
 $as_echo "#define HASH_SET_CLASS HASH_SET_NAMESPACE::unordered_set" >>confdefs.h
 
 
+$as_echo "#define HASH_SET_H <unordered_set>" >>confdefs.h
+
+
+$as_echo "#define HASH_SET_NAMESPACE std" >>confdefs.h
+
+
+else
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for tr1/unordered_set<int,int>::const_iterator" >&5
+$as_echo_n "checking for tr1/unordered_set<int,int>::const_iterator... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+			#include <tr1/unordered_set>
+
+int
+main ()
+{
+
+			std::tr1::unordered_set<int,int>::const_iterator iter;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HASH_SET_CLASS HASH_SET_NAMESPACE::unordered_set" >>confdefs.h
+
+
 $as_echo "#define HASH_SET_H <tr1/unordered_set>" >>confdefs.h
 
 
@@ -22554,9 +22635,9 @@
 
 else
 
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	for ac_header in ext/hash_set
+		for ac_header in ext/hash_set
 do :
   ac_fn_cxx_check_header_mongrel "$LINENO" "ext/hash_set" "ac_cv_header_ext_hash_set" "$ac_includes_default"
 if test "x$ac_cv_header_ext_hash_set" = xyes; then :
@@ -22576,7 +22657,7 @@
 
 else
 
-		as_fn_error $? "C++ compiler does not seem to support unordered containers" "$LINENO" 5
+			as_fn_error $? "C++ compiler does not seem to support unordered containers" "$LINENO" 5
 
 fi
 
@@ -22586,6 +22667,9 @@
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 
 
 
diff -Nurd synfig-0.64.0.orig/configure.ac synfig-0.64.0/configure.ac
--- synfig-0.64.0.orig/configure.ac	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/configure.ac	2021-03-30 01:22:02.000000000 -0400
@@ -39,6 +39,7 @@
 AC_PROG_CPP
 AC_PROG_CXXCPP
 AC_PROG_INSTALL
+AX_CXX_COMPILE_STDCXX([11], [noext])
 
 AC_LANG([C++])
 
@@ -159,28 +160,14 @@
 	with_magickpp="yes"
 ])
 if test $with_magickpp = "yes" ; then {
-  AC_CHECK_HEADER([Magick++.h],[
-  	MAGICKPP_LIBS="-lMagick++"
-  	AC_DEFINE(HAVE_MAGICKPP,[], [ Define if Magick++ library is available ] )
-  	AC_SUBST(MAGICKPP_LIBS)
-  	AM_CONDITIONAL(HAVE_LIBMAGICKPP,true)
-	AC_CHECK_LIB(Magick,OptimizeImageTransparency,[
-		AC_DEFINE(HAVE_MAGICK_OPTIMIZE,[], [ Define if Magick++ defines OptimizeImageTransparency() ] )
-		AM_CONDITIONAL(HAVE_MAGICK_OPTIMIZE,true)
+	PKG_CHECK_MODULES(MAGICKPP, Magick++ >= 6.4.2,[
+		with_magickpp="yes"
+                AM_CONDITIONAL(HAVE_LIBMAGICKPP,true)
 	],[
-		AC_MSG_RESULT([ *** OptimizeImageTransparency() not available - need ImageMagick 6.3 or newer ])
-		AM_CONDITIONAL(HAVE_MAGICK_OPTIMIZE,false)
+                with_magickpp="no"
+                AC_MSG_RESULT([ *** Magick++ Output target disabled])
+                AM_CONDITIONAL(HAVE_LIBMAGICKPP,false)
 	])
-  ],[
-	with_magickpp="no"
-  	AC_MSG_RESULT([ *** Magick++ Output target disabled])
-  	TARGET_MAGICKPP="no"
-  	AM_CONDITIONAL(HAVE_LIBMAGICKPP,false)
-	AM_CONDITIONAL(HAVE_MAGICK_OPTIMIZE,false)
-  ])
-} else {
-	AM_CONDITIONAL(HAVE_LIBMAGICKPP,false)
-	AM_CONDITIONAL(HAVE_MAGICK_OPTIMIZE,false)
 } ; fi
 
 
@@ -407,13 +394,13 @@
 CONFIG_DEPS="$CONFIG_DEPS ETL"
 
 
-PKG_CHECK_MODULES(LIBXMLPP, libxml++-2.6,[
-	CONFIG_DEPS="$CONFIG_DEPS libxml++-2.6"
+PKG_CHECK_MODULES(LIBXMLPP, libxml++-2.6 libxml-2.0,[
+	CONFIG_DEPS="$CONFIG_DEPS libxml++-2.6 libxml-2.0"
 ],[
-	PKG_CHECK_MODULES(LIBXMLPP, libxml++-1.0,[
-		CONFIG_DEPS="$CONFIG_DEPS libxml++-1.0"
+	PKG_CHECK_MODULES(LIBXMLPP, libxml++-1.0 libxml-2.0,[
+		CONFIG_DEPS="$CONFIG_DEPS libxml++-1.0 libxml-2.0"
 	],[
-		AC_MSG_ERROR([ ** You need to install libxml++, either verison 2.6 or 1.0.])
+		AC_MSG_ERROR([ ** You need to install libxml++, either verison 2.6 or 1.0, and libxml.])
 	])
 ])
 
@@ -526,25 +513,41 @@
 AC_MSG_CHECKING([for unordered_map<int,int>::const_iterator])
 AC_COMPILE_IFELSE([
 	AC_LANG_PROGRAM([
-		[#include <tr1/unordered_map>]
+		[#include <unordered_map>]
 	],[
-		[std::tr1::unordered_map<int,int>::const_iterator iter;]
+		[std::unordered_map<int,int>::const_iterator iter;]
 	])],[
 	AC_MSG_RESULT([yes])
 	AC_DEFINE([HASH_MAP_CLASS],[HASH_MAP_NAMESPACE::unordered_map],[The template name for unordered maps.])
-	AC_DEFINE([HASH_MAP_H],[<tr1/unordered_map>],[The header file to include for unordered maps.])
-	AC_DEFINE([HASH_MAP_NAMESPACE],[std::tr1],[The namespace for unordered maps.])
-	AC_DEFINE([FUNCTIONAL_H],[<tr1/functional>],[The header file for hash<T>.])
+	AC_DEFINE([HASH_MAP_H],[<unordered_map>],[The header file to include for unordered maps.])
+	AC_DEFINE([HASH_MAP_NAMESPACE],[std],[The namespace for unordered maps.])
+	AC_DEFINE([FUNCTIONAL_H],[<functional>],[The header file for hash<T>.])
 	AC_DEFINE([FUNCTIONAL_HASH_ON_STRING],[1],[Define to 1 if hash<T> needs to use T=String rather than T=char* to hash strings.])
 ],[
 	AC_MSG_RESULT([no])
-	AC_CHECK_HEADERS([ext/hash_map],[
-		AC_DEFINE([HASH_MAP_CLASS],[HASH_MAP_NAMESPACE::hash_map],[The template name for unordered maps.])
-		AC_DEFINE([HASH_MAP_H],[<ext/hash_map>],[The header file to include for unordered maps.])
-		AC_DEFINE([HASH_MAP_NAMESPACE],[__gnu_cxx],[The namespace for unordered maps.])
-		AC_DEFINE([FUNCTIONAL_H],[<ext/functional>],[The header file for hash<T>.])
+	AC_MSG_CHECKING([for tr1/unordered_map<int,int>::const_iterator])
+	AC_COMPILE_IFELSE([
+		AC_LANG_PROGRAM([
+			[#include <tr1/unordered_map>]
+		],[
+			[std::tr1::unordered_map<int,int>::const_iterator iter;]
+		])],[
+		AC_MSG_RESULT([yes])
+		AC_DEFINE([HASH_MAP_CLASS],[HASH_MAP_NAMESPACE::unordered_map],[The template name for unordered maps.])
+		AC_DEFINE([HASH_MAP_H],[<tr1/unordered_map>],[The header file to include for unordered maps.])
+		AC_DEFINE([HASH_MAP_NAMESPACE],[std::tr1],[The namespace for unordered maps.])
+		AC_DEFINE([FUNCTIONAL_H],[<tr1/functional>],[The header file for hash<T>.])
+		AC_DEFINE([FUNCTIONAL_HASH_ON_STRING],[1],[Define to 1 if hash<T> needs to use T=String rather than T=char* to hash strings.])
 	],[
-		AC_MSG_ERROR([C++ compiler does not seem to support unordered containers])
+		AC_MSG_RESULT([no])
+		AC_CHECK_HEADERS([ext/hash_map],[
+			AC_DEFINE([HASH_MAP_CLASS],[HASH_MAP_NAMESPACE::hash_map],[The template name for unordered maps.])
+			AC_DEFINE([HASH_MAP_H],[<ext/hash_map>],[The header file to include for unordered maps.])
+			AC_DEFINE([HASH_MAP_NAMESPACE],[__gnu_cxx],[The namespace for unordered maps.])
+			AC_DEFINE([FUNCTIONAL_H],[<ext/functional>],[The header file for hash<T>.])
+		],[
+			AC_MSG_ERROR([C++ compiler does not seem to support unordered containers])
+		])
 	])
 ])
 
@@ -552,22 +555,36 @@
 AC_MSG_CHECKING([for unordered_set<int,int>::const_iterator])
 AC_COMPILE_IFELSE([
 	AC_LANG_PROGRAM([
-		[#include <tr1/unordered_set>]
+		[#include <unordered_set>]
 	],[
-		[std::tr1::unordered_set<int,int>::const_iterator iter;]
+		[std::unordered_set<int,int>::const_iterator iter;]
 	])],[
 	AC_MSG_RESULT([yes])
 	AC_DEFINE([HASH_SET_CLASS],[HASH_SET_NAMESPACE::unordered_set],[The template name for unordered sets.])
-	AC_DEFINE([HASH_SET_H],[<tr1/unordered_set>],[The header file to include for unordered sets.])
-	AC_DEFINE([HASH_SET_NAMESPACE],[std::tr1],[The namespace for unordered sets.])
+	AC_DEFINE([HASH_SET_H],[<unordered_set>],[The header file to include for unordered sets.])
+	AC_DEFINE([HASH_SET_NAMESPACE],[std],[The namespace for unordered sets.])
 ],[
 	AC_MSG_RESULT([no])
-	AC_CHECK_HEADERS([ext/hash_set],[
-		AC_DEFINE([HASH_SET_CLASS],[HASH_SET_NAMESPACE::hash_set],[The template name for unordered sets.])
-		AC_DEFINE([HASH_SET_H],[<ext/hash_set>],[The header file to include for unordered sets.])
-		AC_DEFINE([HASH_SET_NAMESPACE],[__gnu_cxx],[The namespace for unordered sets.])
+	AC_MSG_CHECKING([for tr1/unordered_set<int,int>::const_iterator])
+	AC_COMPILE_IFELSE([
+		AC_LANG_PROGRAM([
+			[#include <tr1/unordered_set>]
+		],[
+			[std::tr1::unordered_set<int,int>::const_iterator iter;]
+		])],[
+		AC_MSG_RESULT([yes])
+		AC_DEFINE([HASH_SET_CLASS],[HASH_SET_NAMESPACE::unordered_set],[The template name for unordered sets.])
+		AC_DEFINE([HASH_SET_H],[<tr1/unordered_set>],[The header file to include for unordered sets.])
+		AC_DEFINE([HASH_SET_NAMESPACE],[std::tr1],[The namespace for unordered sets.])
 	],[
-		AC_MSG_ERROR([C++ compiler does not seem to support unordered containers])
+		AC_MSG_RESULT([no])
+		AC_CHECK_HEADERS([ext/hash_set],[
+			AC_DEFINE([HASH_SET_CLASS],[HASH_SET_NAMESPACE::hash_set],[The template name for unordered sets.])
+			AC_DEFINE([HASH_SET_H],[<ext/hash_set>],[The header file to include for unordered sets.])
+			AC_DEFINE([HASH_SET_NAMESPACE],[__gnu_cxx],[The namespace for unordered sets.])
+		],[
+			AC_MSG_ERROR([C++ compiler does not seem to support unordered containers])
+		])
 	])
 ])
 
@@ -665,8 +682,8 @@
 AC_SUBST(CONFIG_DEPS)
 AC_SUBST(ETL_CFLAGS)
 
-SYNFIG_LIBS="$VIMAGE_LIBS $LIBXMLPP_LIBS $LIBCAIRO_LIBS $LIBCAIROMM_LIBS $LIBPANGO_LIBS $ETL_LIBS $LIBSIGC_LIBS $LTLIBINTL"
-SYNFIG_CFLAGS="$LIBXMLPP_CFLAGS $LIBCAIRO_CFLAGS $LIBCAIROMM_CFLAGS $LIBPANGO_CFLAGS $ETL_CFLAGS $LIBSIGC_CFLAGS $CONFIG_CFLAGS -DSYNFIG_NO_DEPRECATED -DLOCALEDIR=\\\"$localedir\\\""
+SYNFIG_LIBS="$VIMAGE_LIBS $LIBXMLPP_LIBS $MAGICKPP_LIBS $LIBCAIRO_LIBS $LIBCAIROMM_LIBS $LIBPANGO_LIBS $ETL_LIBS $LIBSIGC_LIBS $LTLIBINTL"
+SYNFIG_CFLAGS="$LIBXMLPP_CFLAGS $MAGICKPP_CFLAGS $LIBCAIRO_CFLAGS $LIBCAIROMM_CFLAGS $LIBPANGO_CFLAGS $ETL_CFLAGS $LIBSIGC_CFLAGS $CONFIG_CFLAGS -DSYNFIG_NO_DEPRECATED -DLOCALEDIR=\\\"$localedir\\\""
 
 CONFIG_CFLAGS="`echo $CONFIG_CFLAGS | sed s/-mno-cygwin//g | sed s/-mwindows//g`"
 SYNFIG_CFLAGS="`echo $SYNFIG_CFLAGS | sed s/-mno-cygwin//g | sed s/-mwindows//g`"
@@ -760,6 +777,7 @@
 "'$'"CXXFLAGS ------------------------> '$CXXFLAGS'
 "'$'"SYNFIG_LIBS ---------------------> '$SYNFIG_LIBS'
 "'$'"LIBXMLPP_LIBS -------------------> '$LIBXMLPP_LIBS'
+"'$'"MAGICKPP_LIBS -------------------> '$MAGICKPP_LIBS'
 "'$'"LIBCAIRO_LIBS -------------------> '$LIBCAIRO_LIBS'
 "'$'"LIBCAIROMM_LIBS -----------------> '$LIBCAIROMM_LIBS'
 "'$'"LIBPANGO_LIBS -------------------> '$LIBPANGO_LIBS'
diff -Nurd synfig-0.64.0.orig/m4/ax_cxx_compile_stdcxx.m4 synfig-0.64.0/m4/ax_cxx_compile_stdcxx.m4
--- synfig-0.64.0.orig/m4/ax_cxx_compile_stdcxx.m4	1969-12-31 19:00:00.000000000 -0500
+++ synfig-0.64.0/m4/ax_cxx_compile_stdcxx.m4	2021-03-29 20:30:01.000000000 -0400
@@ -0,0 +1,558 @@
+# ===========================================================================
+#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the specified
+#   version of the C++ standard.  If necessary, add switches to CXXFLAGS to
+#   enable support.  VERSION may be '11' (for the C++11 standard) or '14'
+#   (for the C++14 standard).
+#
+#   The second argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The third argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline support for the specified C++ standard is
+#   required and that the macro should error out if no mode with that
+#   support is found.  If specified 'optional', then configuration proceeds
+#   regardless, after defining HAVE_CXX${VERSION} if and only if a
+#   supporting mode is found.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 1
+
+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
+dnl  (serial version number 13).
+
+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
+  m4_if([$1], [11], [],
+        [$1], [14], [],
+        [$1], [17], [m4_fatal([support for C++17 not yet implemented in AX_CXX_COMPILE_STDCXX])],
+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$2], [], [],
+        [$2], [ext], [],
+        [$2], [noext], [],
+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
+  AC_LANG_PUSH([C++])dnl
+  ac_success=no
+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
+  ax_cv_cxx_compile_cxx$1,
+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+    [ax_cv_cxx_compile_cxx$1=yes],
+    [ax_cv_cxx_compile_cxx$1=no])])
+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
+    ac_success=yes
+  fi
+
+  m4_if([$2], [noext], [], [dnl
+  if test x$ac_success = xno; then
+    for switch in -std=gnu++$1 -std=gnu++0x; do
+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                     $cachevar,
+        [ac_save_CXXFLAGS="$CXXFLAGS"
+         CXXFLAGS="$CXXFLAGS $switch"
+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+          [eval $cachevar=yes],
+          [eval $cachevar=no])
+         CXXFLAGS="$ac_save_CXXFLAGS"])
+      if eval test x\$$cachevar = xyes; then
+        CXXFLAGS="$CXXFLAGS $switch"
+        ac_success=yes
+        break
+      fi
+    done
+  fi])
+
+  m4_if([$2], [ext], [], [dnl
+  if test x$ac_success = xno; then
+    dnl HP's aCC needs +std=c++11 according to:
+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
+    dnl Cray's crayCC needs "-h std=c++11"
+    for switch in -std=c++$1 -std=c++0x +std=c++$1 "-h std=c++$1"; do
+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                     $cachevar,
+        [ac_save_CXXFLAGS="$CXXFLAGS"
+         CXXFLAGS="$CXXFLAGS $switch"
+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+          [eval $cachevar=yes],
+          [eval $cachevar=no])
+         CXXFLAGS="$ac_save_CXXFLAGS"])
+      if eval test x\$$cachevar = xyes; then
+        CXXFLAGS="$CXXFLAGS $switch"
+        ac_success=yes
+        break
+      fi
+    done
+  fi])
+  AC_LANG_POP([C++])
+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
+    if test x$ac_success = xno; then
+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
+    fi
+  else
+    if test x$ac_success = xno; then
+      HAVE_CXX$1=0
+      AC_MSG_NOTICE([No compiler with C++$1 support was found])
+    else
+      HAVE_CXX$1=1
+      AC_DEFINE(HAVE_CXX$1,1,
+                [define if the compiler supports basic C++$1 syntax])
+    fi
+
+    AC_SUBST(HAVE_CXX$1)
+  fi
+])
+
+
+dnl  Test body for checking C++11 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+)
+
+
+dnl  Test body for checking C++14 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+)
+
+
+dnl  Tests for new features in C++11
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+]])
+
+
+dnl  Tests for new features in C++14
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
+
+// If the compiler admits that it is not ready for C++14, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201402L
+
+#error "This is not a C++14 compiler"
+
+#else
+
+namespace cxx14
+{
+
+  namespace test_polymorphic_lambdas
+  {
+
+    int
+    test()
+    {
+      const auto lambda = [](auto&&... args){
+        const auto istiny = [](auto x){
+          return (sizeof(x) == 1UL) ? 1 : 0;
+        };
+        const int aretiny[] = { istiny(args)... };
+        return aretiny[0];
+      };
+      return lambda(1, 1L, 1.0f, '1');
+    }
+
+  }
+
+  namespace test_binary_literals
+  {
+
+    constexpr auto ivii = 0b0000000000101010;
+    static_assert(ivii == 42, "wrong value");
+
+  }
+
+  namespace test_generalized_constexpr
+  {
+
+    template < typename CharT >
+    constexpr unsigned long
+    strlen_c(const CharT *const s) noexcept
+    {
+      auto length = 0UL;
+      for (auto p = s; *p; ++p)
+        ++length;
+      return length;
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("x") == 1UL, "");
+    static_assert(strlen_c("test") == 4UL, "");
+    static_assert(strlen_c("another\0test") == 7UL, "");
+
+  }
+
+  namespace test_lambda_init_capture
+  {
+
+    int
+    test()
+    {
+      auto x = 0;
+      const auto lambda1 = [a = x](int b){ return a + b; };
+      const auto lambda2 = [a = lambda1(x)](){ return a; };
+      return lambda2();
+    }
+
+  }
+
+  namespace test_digit_seperators
+  {
+
+    constexpr auto ten_million = 100'000'000;
+    static_assert(ten_million == 100000000, "");
+
+  }
+
+  namespace test_return_type_deduction
+  {
+
+    auto f(int& x) { return x; }
+    decltype(auto) g(int& x) { return x; }
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static constexpr auto value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static constexpr auto value = true;
+    };
+
+    int
+    test()
+    {
+      auto x = 0;
+      static_assert(is_same<int, decltype(f(x))>::value, "");
+      static_assert(is_same<int&, decltype(g(x))>::value, "");
+      return x;
+    }
+
+  }
+
+}  // namespace cxx14
+
+#endif  // __cplusplus >= 201402L
+
+]])
diff -Nurd synfig-0.64.0.orig/src/modules/mod_magickpp/trgt_magickpp.cpp synfig-0.64.0/src/modules/mod_magickpp/trgt_magickpp.cpp
--- synfig-0.64.0.orig/src/modules/mod_magickpp/trgt_magickpp.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/modules/mod_magickpp/trgt_magickpp.cpp	2021-03-30 01:34:21.000000000 -0400
@@ -53,20 +53,19 @@
 /* === M E T H O D S ======================================================= */
 
 template <class Container>
-MagickLib::Image* copy_image_list(Container& container)
+MagickCore::Image* copy_image_list(Container& container)
 {
 	typedef typename Container::iterator Iter;
-	MagickLib::Image* previous = 0;
-	MagickLib::Image* first = NULL;
-	MagickLib::ExceptionInfo exceptionInfo;
-	MagickLib::GetExceptionInfo(&exceptionInfo);
+	MagickCore::Image* previous = 0;
+	MagickCore::Image* first = NULL;
+	MagickCore::ExceptionInfo* exceptionInfo = MagickCore::AcquireExceptionInfo();
 	for (Iter iter = container.begin(); iter != container.end(); ++iter)
 	{
-		MagickLib::Image* current;
+		MagickCore::Image* current;
 
 		try
 		{
-			current = CloneImage(iter->image(), 0, 0, Magick::MagickTrue, &exceptionInfo);
+			current = CloneImage(iter->image(), 0, 0, Magick::MagickTrue, exceptionInfo);
 
 			if (!first) first = current;
 
@@ -81,13 +80,13 @@
 		}
 	}
 
+	exceptionInfo = MagickCore::DestroyExceptionInfo(exceptionInfo);
 	return first;
 }
 
 magickpp_trgt::~magickpp_trgt()
 {
-	MagickLib::ExceptionInfo exceptionInfo;
-	MagickLib::GetExceptionInfo(&exceptionInfo);
+	MagickCore::ExceptionInfo* exceptionInfo = MagickCore::AcquireExceptionInfo();
 
 	try
 	{
@@ -101,7 +100,7 @@
 			image.fileName(filename);
 			try
 			{
-				SetImageInfo(image.imageInfo(),Magick::MagickTrue,&exceptionInfo);
+				SetImageInfo(image.imageInfo(),Magick::MagickTrue,exceptionInfo);
 				can_adjoin = image.adjoin();
 			}
 			catch(Magick::Warning warning) {
@@ -118,7 +117,6 @@
 			for_each(images.begin(), images.end(), Magick::animationDelayImage(delay));
 
 			// optimize the images (only write the pixels that change from frame to frame
-#ifdef HAVE_MAGICK_OPTIMIZE
 			// make a completely new image list
 			// this is required because:
 			//   RemoveDuplicateLayers wants a linked list of images, and removes some of them
@@ -126,7 +124,7 @@
 			//   when we destroy our container, the image is re-freed, failing an assertion
 
 			synfig::info("copying image list");
-			MagickLib::Image *image_list = copy_image_list(images);
+			MagickCore::Image *image_list = copy_image_list(images);
 
 			synfig::info("clearing old image list");
 			images.clear();
@@ -136,7 +134,7 @@
 				synfig::info("removing duplicate frames");
 				try
 				{
-					RemoveDuplicateLayers(&image_list, &exceptionInfo);
+					RemoveDuplicateLayers(&image_list, exceptionInfo);
 				}
 				catch(Magick::Warning warning) {
 					synfig::warning("exception '%s'", warning.what());
@@ -148,7 +146,7 @@
 				synfig::info("optimizing layers");
 				try
 				{
-					image_list = OptimizeImageLayers(image_list,&exceptionInfo);
+					image_list = OptimizeImageLayers(image_list,exceptionInfo);
 				}
 				catch(Magick::Warning warning) {
 					synfig::warning("exception '%s'", warning.what());
@@ -160,7 +158,7 @@
 				synfig::info("optimizing layer transparency");
 				try
 				{
-					OptimizeImageTransparency(image_list,&exceptionInfo);
+					OptimizeImageTransparency(image_list,exceptionInfo);
 				}
 				catch(Magick::Warning warning) {
 					synfig::warning("exception '%s'", warning.what());
@@ -169,18 +167,6 @@
 
 			synfig::info("recreating image list");
 			insertImages(&images, image_list);
-#else
-			synfig::info("not optimizing images");
-			// DeconstructImages is available in ImageMagic 6.2.* but it doesn't take
-			// the 'dispose' method into account, so for frames with transparency where
-			// nothing is moving, we end up with objects disappearing when they shouldn't
-
-			// linkImages(images.begin(), images.end());
-			// MagickLib::Image* new_images = DeconstructImages(images.begin()->image(),&exceptionInfo);
-			// unlinkImages(images.begin(), images.end());
-			// images.clear();
-			// insertImages(&images, new_images);
-#endif
 		}
 		else if (multiple_images)
 		{
@@ -214,6 +200,7 @@
 	if (buffer1 != NULL) delete [] buffer1;
 	if (buffer2 != NULL) delete [] buffer2;
 	if (color_buffer != NULL) delete [] color_buffer;
+	exceptionInfo = MagickCore::DestroyExceptionInfo(exceptionInfo);
 }
 
 bool
diff -Nurd synfig-0.64.0.orig/src/modules/mod_noise/distort.cpp synfig-0.64.0/src/modules/mod_noise/distort.cpp
--- synfig-0.64.0.orig/src/modules/mod_noise/distort.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/modules/mod_noise/distort.cpp	2021-03-30 01:18:06.000000000 -0400
@@ -165,7 +165,7 @@
 		return context.hit_check(point);
 	if(color_func(point,0,context).get_a()>0.5)
 		return const_cast<NoiseDistort*>(this);
-	return false;
+	return synfig::Layer::Handle();
 }
 
 bool
diff -Nurd synfig-0.64.0.orig/src/modules/mod_noise/noise.cpp synfig-0.64.0/src/modules/mod_noise/noise.cpp
--- synfig-0.64.0.orig/src/modules/mod_noise/noise.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/modules/mod_noise/noise.cpp	2021-03-30 01:18:12.000000000 -0400
@@ -202,7 +202,7 @@
 		return context.hit_check(point);
 	if(color_func(point,0,context).get_a()>0.5)
 		return const_cast<Noise*>(this);
-	return false;
+	return synfig::Layer::Handle();
 }
 
 bool
diff -Nurd synfig-0.64.0.orig/src/modules/mod_noise/random_noise.cpp synfig-0.64.0/src/modules/mod_noise/random_noise.cpp
--- synfig-0.64.0.orig/src/modules/mod_noise/random_noise.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/modules/mod_noise/random_noise.cpp	2021-03-30 01:16:13.000000000 -0400
@@ -118,26 +118,26 @@
 			//figure polynomials for each point
 			const float txf[] =
 			{
-				0.5*dx*(dx*(dx*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dx*(dx*(3*dx - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dx*(dx*(-3*dx + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dx*dx*(dx-1)				//-t^2 + t^3
+				0.5f*dx*(dx*(dx*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dx*(dx*(3.f*dx - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dx*(dx*(-3.f*dx + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dx*dx*(dx-1.f)						//-t^2 + t^3
 			};
 
 			const float tyf[] =
 			{
-				0.5*dy*(dy*(dy*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dy*(dy*(3*dy - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dy*(dy*(-3*dy + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dy*dy*(dy-1)				//-t^2 + t^3
+				0.5f*dy*(dy*(dy*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dy*(dy*(3.f*dy - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dy*(dy*(-3.f*dy + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dy*dy*(dy-1.f)						//-t^2 + t^3
 			};
 
 			const float ttf[] =
 			{
-				0.5*dt*(dt*(dt*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dt*(dt*(3*dt - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dt*(dt*(-3*dt + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dt*dt*(dt-1)				//-t^2 + t^3
+				0.5f*dt*(dt*(dt*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dt*(dt*(3.f*dt - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dt*(dt*(-3.f*dt + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dt*dt*(dt-1.f)						//-t^2 + t^3
 			};
 
 			//evaluate polynomial for each row
diff -Nurd synfig-0.64.0.orig/src/modules/mod_particle/random.cpp synfig-0.64.0/src/modules/mod_particle/random.cpp
--- synfig-0.64.0.orig/src/modules/mod_particle/random.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/modules/mod_particle/random.cpp	2021-03-30 01:14:40.000000000 -0400
@@ -107,26 +107,26 @@
 			//figure polynomials for each point
 			const float txf[] =
 			{
-				0.5*dx*(dx*(dx*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dx*(dx*(3*dx - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dx*(dx*(-3*dx + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dx*dx*(dx-1)				//-t^2 + t^3
+				0.5f*dx*(dx*(dx*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dx*(dx*(3.f*dx - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dx*(dx*(-3.f*dx + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dx*dx*(dx-1.f)						//-t^2 + t^3
 			};
 
 			const float tyf[] =
 			{
-				0.5*dy*(dy*(dy*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dy*(dy*(3*dy - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dy*(dy*(-3*dy + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dy*dy*(dy-1)				//-t^2 + t^3
+				0.5f*dy*(dy*(dy*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dy*(dy*(3.f*dy - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dy*(dy*(-3.f*dy + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dy*dy*(dy-1.f)						//-t^2 + t^3
 			};
 
 			const float ttf[] =
 			{
-				0.5*dt*(dt*(dt*(-1) + 2) - 1),	//-t + 2t^2 -t^3
-				0.5*(dt*(dt*(3*dt - 5)) + 2), 	//2 - 5t^2 + 3t^3
-				0.5*dt*(dt*(-3*dt + 4) + 1),	//t + 4t^2 - 3t^3
-				0.5*dt*dt*(dt-1)				//-t^2 + t^3
+				0.5f*dt*(dt*(dt*(-1.f) + 2.f) - 1.f),	//-t + 2t^2 -t^3
+				0.5f*(dt*(dt*(3.f*dt - 5.f)) + 2.f), 	//2 - 5t^2 + 3t^3
+				0.5f*dt*(dt*(-3.f*dt + 4.f) + 1.f),		//t + 4t^2 - 3t^3
+				0.5f*dt*dt*(dt-1.f)						//-t^2 + t^3
 			};
 
 			//evaluate polynomial for each row
diff -Nurd synfig-0.64.0.orig/src/synfig/color.cpp synfig-0.64.0/src/synfig/color.cpp
--- synfig-0.64.0.orig/src/synfig/color.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/color.cpp	2021-03-30 00:00:38.000000000 -0400
@@ -50,6 +50,10 @@
 
 /* === G L O B A L S ======================================================= */
 
+const Color::value_type Color::ceil=1;	
+const Color::value_type Color::floor=0;
+const float CairoColor::range=CairoColor::ceil-CairoColor::floor;
+
 /* === P R O C E D U R E S ================================================= */
 
 /* === M E T H O D S ======================================================= */
diff -Nurd synfig-0.64.0.orig/src/synfig/color.h synfig-0.64.0/src/synfig/color.h
--- synfig-0.64.0.orig/src/synfig/color.h	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/color.h	2021-03-30 00:08:52.000000000 -0400
@@ -117,8 +117,8 @@
 
 public:
 	
-	static const value_type ceil=1;	
-	static const value_type floor=0;
+	static const value_type ceil;
+	static const value_type floor;
 	
 	const String get_string(void)const;
 
@@ -586,7 +586,7 @@
 public:
 	static const unsigned char ceil=255;	
 	static const unsigned char floor=0;
-	static const float range=ceil-floor;
+	static const float range;
 	static const value_type amask=0xFF<<24;
 	static const value_type rmask=0xFF<<16;
 	static const value_type gmask=0xFF<<8;
@@ -736,12 +736,12 @@
 	CairoColor(const CairoColorAccumulator& c);
 	CairoColor(int r, int g, int b, int a);
 	
-	const value_type get_pixel()const {return pixel; }
-	const unsigned char get_a()const { return pixel>>24; }
-	const unsigned char get_r()const { return pixel>>16; }
-	const unsigned char get_g()const { return pixel>>8; }
-	const unsigned char get_b()const { return pixel; }
-	const unsigned char get_alpha()const { return get_a(); }
+	value_type get_pixel()const {return pixel; }
+	unsigned char get_a()const { return pixel>>24; }
+	unsigned char get_r()const { return pixel>>16; }
+	unsigned char get_g()const { return pixel>>8; }
+	unsigned char get_b()const { return pixel; }
+	unsigned char get_alpha()const { return get_a(); }
 	
 	const String get_string(void)const;
 
diff -Nurd synfig-0.64.0.orig/src/synfig/exception.h synfig-0.64.0/src/synfig/exception.h
--- synfig-0.64.0.orig/src/synfig/exception.h	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/exception.h	2021-03-30 01:22:02.000000000 -0400
@@ -28,7 +28,7 @@
 /* === H E A D E R S ======================================================= */
 
 #include <stdexcept>
-#include "string_decl.h"
+#include "string.h"
 
 /* === M A C R O S ========================================================= */
 
diff -Nurd synfig-0.64.0.orig/src/synfig/layer.h synfig-0.64.0/src/synfig/layer.h
--- synfig-0.64.0.orig/src/synfig/layer.h	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/layer.h	2021-03-30 01:22:02.000000000 -0400
@@ -29,7 +29,6 @@
 
 /* === H E A D E R S ======================================================= */
 
-#include "string_decl.h"
 #include <map>
 #include <ETL/handle>
 #include "real.h"
diff -Nurd synfig-0.64.0.orig/src/synfig/main.cpp synfig-0.64.0/src/synfig/main.cpp
--- synfig-0.64.0.orig/src/synfig/main.cpp	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/main.cpp	2021-03-30 00:24:26.000000000 -0400
@@ -241,23 +241,23 @@
 		locations.push_back(getenv("SYNFIG_MODULE_LIST"));
 	else
 	{
-		locations.push_back("./"MODULE_LIST_FILENAME);
-		locations.push_back("../etc/"MODULE_LIST_FILENAME);
+		locations.push_back("./" MODULE_LIST_FILENAME);
+		locations.push_back("../etc/" MODULE_LIST_FILENAME);
 		if(getenv("HOME"))
 			locations.push_back(strprintf("%s/.synfig/%s", getenv("HOME"), MODULE_LIST_FILENAME));
 	#ifdef SYSCONFDIR
-		locations.push_back(SYSCONFDIR"/"MODULE_LIST_FILENAME);
+		locations.push_back(SYSCONFDIR"/" MODULE_LIST_FILENAME);
 	#endif
-		locations.push_back(prefix+"/etc/"+MODULE_LIST_FILENAME);
-		locations.push_back("/usr/local/etc/"MODULE_LIST_FILENAME);
+		locations.push_back(prefix + "/etc/" + MODULE_LIST_FILENAME);
+		locations.push_back("/usr/local/etc/" MODULE_LIST_FILENAME);
 	#ifdef __APPLE__
-		locations.push_back("/Library/Frameworks/synfig.framework/Resources/"MODULE_LIST_FILENAME);
-		locations.push_back("/Library/Synfig/"MODULE_LIST_FILENAME);
+		locations.push_back("/Library/Frameworks/synfig.framework/Resources/" MODULE_LIST_FILENAME);
+		locations.push_back("/Library/Synfig/" MODULE_LIST_FILENAME);
 		if(getenv("HOME"))
 			locations.push_back(strprintf("%s/Library/Synfig/%s", getenv("HOME"), MODULE_LIST_FILENAME));
 	#endif
 	#ifdef WIN32
-		locations.push_back("C:\\Program Files\\Synfig\\etc\\"MODULE_LIST_FILENAME);
+		locations.push_back("C:\\Program Files\\Synfig\\etc\\" MODULE_LIST_FILENAME);
 	#endif
 	}
 
diff -Nurd synfig-0.64.0.orig/src/synfig/target.h synfig-0.64.0/src/synfig/target.h
--- synfig-0.64.0.orig/src/synfig/target.h	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/target.h	2021-03-30 01:22:02.000000000 -0400
@@ -30,7 +30,7 @@
 /* === H E A D E R S ======================================================= */
 
 #include <sigc++/signal.h>
-#include "string_decl.h"
+#include "string.h"
 #include <utility>
 #include <map>
 #include <ETL/handle>
diff -Nurd synfig-0.64.0.orig/src/synfig/time.h synfig-0.64.0/src/synfig/time.h
--- synfig-0.64.0.orig/src/synfig/time.h	2013-05-09 12:32:41.000000000 -0400
+++ synfig-0.64.0/src/synfig/time.h	2021-03-30 01:22:02.000000000 -0400
@@ -28,7 +28,7 @@
 
 /* === H E A D E R S ======================================================= */
 
-#include "string_decl.h"
+#include "string.h"
 
 /* === M A C R O S ========================================================= */
 
