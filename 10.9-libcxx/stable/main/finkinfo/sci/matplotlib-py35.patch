diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/font_manager.py matplotlib-3.0.3/lib/matplotlib/font_manager.py
--- matplotlib-3.0.3.orig/lib/matplotlib/font_manager.py	2019-03-01 04:33:08.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/font_manager.py	2019-03-13 21:56:39.000000000 +0100
@@ -127,6 +127,11 @@
     "/Library/Fonts/",
     "/Network/Library/Fonts/",
     "/System/Library/Fonts/",
+    # new XQuartz font location
+    "/opt/X11/share/fonts",
+    "/opt/X11/share/fonts/TTF",
+    # fonts installed via Fink
+    "@PREFIX@/lib/X11/fonts",
     # fonts installed via MacPorts
     "/opt/local/share/fonts",
 ]
diff -ruNd matplotlib-3.0.3.orig/setup.cfg.template matplotlib-3.0.3/setup.cfg.template
--- matplotlib-3.0.3.orig/setup.cfg.template	2019-03-01 04:33:08.000000000 +0100
+++ matplotlib-3.0.3/setup.cfg.template	2019-03-13 22:55:39.000000000 +0100
@@ -13,7 +13,7 @@
 # set this to True.  It will download and build a specific version of
 # FreeType, and then use that to build the ft2font extension.  This
 # ensures that test images are exactly reproducible.
-#local_freetype = False
+local_freetype = True
 
 [status]
 # To suppress display of the dependencies and their versions
@@ -62,9 +62,15 @@
 #           otherwise skip silently. This is the default
 #           behavior
 #
-#agg = auto
+agg = True
+cairo = True
+gtk = True
 #macosx = auto
-#tkagg = auto
+tkagg = True
+gtkagg = True
+qt4agg = True
+qt5agg = True
+wxagg = True
 #windowing = auto
 
 [rc_options]
@@ -78,6 +84,7 @@
 # modules.  The default is determined by fallback.
 #
 #backend = Agg
+backend = Qt5Agg
 
 [package_data]
 # Package additional files found in the lib/matplotlib directories.
diff -ruNd matplotlib-3.0.3.orig/setupext.py matplotlib-3.0.3/setupext.py
--- matplotlib-3.0.3.orig/setupext.py	2019-03-01 04:33:08.000000000 +0100
+++ matplotlib-3.0.3/setupext.py	2019-03-13 21:56:39.000000000 +0100
@@ -1197,9 +1197,9 @@
             env = {**os.environ,
                    "CFLAGS": "{} -fPIC".format(os.environ.get("CFLAGS", ""))}
             subprocess.check_call(
-                ["./configure", "--with-zlib=no", "--with-bzip2=no",
-                 "--with-png=no", "--with-harfbuzz=no"],
-                env=env, cwd=src_path)
+                ["./configure --prefix=@PREFIX@ --libdir=@PREFIX@/lib/freetype219/lib",
+                 "--with-zlib=no", "--with-bzip2=no", "--with-png=no", "--with-harfbuzz=no"],
+                shell=True, env=env, cwd=src_path)
             subprocess.check_call(["make"], env=env, cwd=src_path)
         else:
             # compilation on windows
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/__init__.py matplotlib-3.0.3/lib/matplotlib/__init__.py
--- matplotlib-3.0.3.orig/lib/matplotlib/__init__.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/__init__.py	2019-05-29 00:17:44.000000000 +0200
@@ -472,7 +472,7 @@
 def checkdep_inkscape():
     if checkdep_inkscape.version is None:
         try:
-            s = subprocess.Popen(['inkscape', '-V'],
+            s = subprocess.Popen(['inkscape', '-z', '-V'],
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
             stdout, stderr = s.communicate()
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/testing/conftest.py matplotlib-3.0.3/lib/matplotlib/testing/conftest.py
--- matplotlib-3.0.3.orig/lib/matplotlib/testing/conftest.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/testing/conftest.py	2020-10-19 19:17:59.000000000 +0200
@@ -24,19 +24,19 @@
     with _cleanup_cm():
 
         backend = None
-        backend_marker = request.keywords.get('backend')
+        backend_marker = request.node.get_closest_marker('backend')
         if backend_marker is not None:
             assert len(backend_marker.args) == 1, \
                 "Marker 'backend' must specify 1 backend."
-            backend = backend_marker.args[0]
+            backend, = backend_marker.args
             prev_backend = matplotlib.get_backend()

         style = '_classic_test'  # Default of cleanup and image_comparison too.
-        style_marker = request.keywords.get('style')
+        style_marker = request.node.get_closest_marker('style')
         if style_marker is not None:
             assert len(style_marker.args) == 1, \
                 "Marker 'style' must specify 1 style."
-            style = style_marker.args[0]
+            style, = style_marker.args

         matplotlib.testing.setup()
         if backend is not None:
@@ -73,7 +73,7 @@
     # pytest won't get confused.
     # We annotate the decorated function with any parameters captured by this
     # fixture so that they can be used by the wrapper in image_comparison.
-    baseline_images = request.keywords['baseline_images'].args[0]
+    baseline_images, = request.node.get_closest_marker('baseline_images').args
     if baseline_images is None:
         # Allow baseline image list to be produced on the fly based on current
         # parametrization.
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_pdf.py matplotlib-3.0.3/lib/matplotlib/tests/test_backend_pdf.py
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_pdf.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_backend_pdf.py	2020-10-19 19:33:33.000000000 +0200
@@ -192,7 +192,7 @@
 
 
 # This tests tends to hit a TeX cache lock on AppVeyor.
-@pytest.mark.flaky(reruns=3)
+@pytest.mark.flaky(max_runs=3, min_passes=2)
 @needs_usetex
 def test_missing_psfont(monkeypatch):
     """An error is raised if a TeX font lacks a Type-1 equivalent"""
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_ps.py matplotlib-3.0.3/lib/matplotlib/tests/test_backend_ps.py
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_ps.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_backend_ps.py	2020-10-19 19:33:33.000000000 +0200
@@ -24,7 +24,7 @@
 
 
 # This tests tends to hit a TeX cache lock on AppVeyor.
-@pytest.mark.flaky(reruns=3)
+@pytest.mark.flaky(max_runs=3, min_passes=2)
 @pytest.mark.parametrize('format, use_log, rcParams', [
     ('ps', False, {}),
     pytest.param('ps', False, {'ps.usedistiller': 'ghostscript'},
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backends_interactive.py matplotlib-3.0.3/lib/matplotlib/tests/test_backends_interactive.py
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backends_interactive.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_backends_interactive.py	2020-10-19 19:33:33.000000000 +0200
@@ -109,7 +109,7 @@
 
 
 @pytest.mark.parametrize("backend", _get_testable_interactive_backends())
-@pytest.mark.flaky(reruns=3)
+@pytest.mark.flaky(max_runs=3, min_passes=2)
 def test_interactive_backend(backend):
     if subprocess.run([sys.executable, "-c", _test_script],
                       env={**os.environ, "MPLBACKEND": backend},
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_lines.py matplotlib-3.0.3/lib/matplotlib/tests/test_lines.py
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_lines.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_lines.py	2020-10-19 19:33:33.000000000 +0200
@@ -18,7 +18,7 @@
 
 # Runtimes on a loaded system are inherently flaky. Not so much that a rerun
 # won't help, hopefully.
-@pytest.mark.flaky(reruns=3)
+@pytest.mark.flaky(max_runs=3, min_passes=1)
 def test_invisible_Line_rendering():
     """
     Github issue #1256 identified a bug in Line.draw method
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_nbagg.py matplotlib-3.0.3/lib/matplotlib/tests/test_backend_nbagg.py
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_backend_nbagg.py	2019-03-01 04:33:38.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_backend_nbagg.py	2019-05-29 00:45:44.000000000 +0200
@@ -15,7 +15,7 @@
     """
     with tempfile.NamedTemporaryFile(suffix=".ipynb",
                                      mode='w+t') as fout:
-        args = ["jupyter", "nbconvert", "--to", "notebook", "--execute",
+        args = ["jupyter-py@PY_PKG@", "nbconvert", "--to", "notebook", "--execute",
           "--ExecutePreprocessor.timeout=500",
           "--output", fout.name, nb_file]
         subprocess.check_call(args)
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/tests/test_nbagg_01.ipynb matplotlib-3.0.3/lib/matplotlib/tests/test_nbagg_01.ipynb
--- matplotlib-3.0.3.orig/lib/matplotlib/tests/test_nbagg_01.ipynb	2019-04-01 02:50:07.000000000 +0200
+++ matplotlib-3.0.3/lib/matplotlib/tests/test_nbagg_01.ipynb	2019-05-29 01:15:44.000000000 +0200
@@ -843,7 +843,7 @@
   "kernelspec": {
    "display_name": "Python 3",
    "language": "python",
-   "name": "python3"
+   "name": "python@PY_RAW@"
   },
   "language_info": {
    "codemirror_mode": {
@@ -854,7 +854,7 @@
    "mimetype": "text/x-python",
    "name": "python",
    "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
+   "pygments_lexer": "ipython3-py@PY_PKG@",
    "version": "3.6.3"
   },
   "toc": {
diff -ruNd matplotlib-3.0.3.orig/lib/matplotlib/backends/backend_wx.py matplotlib-3.0.3/lib/matplotlib/backends/backend_wx.py
--- matplotlib-3.0.3.orig/lib/matplotlib/backends/backend_wx.py	2019-02-26 01:18:32.000000000 +0100
+++ matplotlib-3.0.3/lib/matplotlib/backends/backend_wx.py	2019-06-10 02:03:44.000000000 +0200
@@ -1243,7 +1243,7 @@
             # Rationale for line above: see issue 2941338.
         except AttributeError:
             pass  # classic toolbar lacks the attribute
-        if not self.IsBeingDeleted():
+        if self and not self.IsBeingDeleted():
             wx.Frame.Destroy(self, *args, **kwargs)
             if self.toolbar is not None:
                 self.toolbar.Destroy()
diff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py
--- a/lib/matplotlib/cbook/__init__.py     2019-03-01 04:33:38.000000000 +0100
+++ b/lib/matplotlib/cbook/__init__.py     2019-06-07 20:02:00.000000000 +0200
@@ -1393,7 +1393,9 @@
     """
     # Iterate over columns for ndarrays, over rows otherwise.
     X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X))
-    if X.ndim == 1 and X.dtype.type != np.object_:
+    if len(X) == 0:
+        return [[]]
+    elif X.ndim == 1 and np.ndim(X[0]) == 0:
         # 1D array of scalars: directly return it.
         return [X]
     elif X.ndim in [1, 2]:
diff --git a/lib/matplotlib/tests/test_cbook.py b/lib/matplotlib/tests/test_cbook.py
--- a/lib/matplotlib/tests/test_cbook.py     2019-03-01 04:33:38.000000000 +0100
+++ b/lib/matplotlib/tests/test_cbook.py     2019-06-07 20:03:30.000000000 +0200
@@ -494,6 +494,66 @@ class dummy():
     assert 1 == next(it)
 
 
+def test_reshape2d():
+    class dummy():
+        pass
+    xnew = cbook._reshape_2D([], 'x')
+    assert np.shape(xnew) == (1, 0)
+
+    x = [dummy() for j in range(5)]
+
+    xnew = cbook._reshape_2D(x, 'x')
+    assert np.shape(xnew) == (1, 5)
+
+    x = np.arange(5)
+    xnew = cbook._reshape_2D(x, 'x')
+    assert np.shape(xnew) == (1, 5)
+
+    x = [[dummy() for j in range(5)] for i in range(3)]
+    xnew = cbook._reshape_2D(x, 'x')
+    assert np.shape(xnew) == (3, 5)
+
+    # this is strange behaviour, but...
+    x = np.random.rand(3, 5)
+    xnew = cbook._reshape_2D(x, 'x')
+    assert np.shape(xnew) == (5, 3)
+
+    # Now test with a list of lists with different lengths, which means the
+    # array will internally be converted to a 1D object array of lists
+    x = [[1, 2, 3], [3, 4], [2]]
+    xnew = cbook._reshape_2D(x, 'x')
+    assert isinstance(xnew, list)
+    assert isinstance(xnew[0], np.ndarray) and xnew[0].shape == (3,)
+    assert isinstance(xnew[1], np.ndarray) and xnew[1].shape == (2,)
+    assert isinstance(xnew[2], np.ndarray) and xnew[2].shape == (1,)
+
+    # We now need to make sure that this works correctly for Numpy subclasses
+    # where iterating over items can return subclasses too, which may be
+    # iterable even if they are scalars. To emulate this, we make a Numpy
+    # array subclass that returns Numpy 'scalars' when iterating or accessing
+    # values, and these are technically iterable if checking for example
+    # isinstance(x, collections.abc.Iterable).
+
+    class ArraySubclass(np.ndarray):
+
+        def __iter__(self):
+            for value in super().__iter__():
+                yield np.array(value)
+
+        def __getitem__(self, item):
+            return np.array(super().__getitem__(item))
+
+    v = np.arange(10, dtype=float)
+    x = ArraySubclass((10,), dtype=float, buffer=v.data)
+
+    xnew = cbook._reshape_2D(x, 'x')
+
+    # We check here that the array wasn't split up into many individual
+    # ArraySubclass, which is what used to happen due to a bug in _reshape_2D
+    assert len(xnew) == 1
+    assert isinstance(xnew[0], ArraySubclass)
+
+
 def test_safe_first_element_pandas_series(pd):
     # delibrately create a pandas series with index not starting from 0
     s = pd.Series(range(5), index=range(10, 15))
