diff -uNr blt2.4z.orig/Makefile.in blt2.4z/Makefile.in
--- blt2.4z.orig/Makefile.in	2002-02-18 19:11:43.000000000 -0500
+++ blt2.4z/Makefile.in	2013-07-15 11:15:51.000000000 -0400
@@ -47,9 +47,9 @@
 	(cd library; $(MAKE) install)
 	(cd man; $(MAKE) install)
 	(cd demos; $(MAKE) install)
-	$(INSTALL_DATA) $(srcdir)/README $(INSTALL_DIR)$(scriptdir)
-	$(INSTALL_DATA) $(srcdir)/PROBLEMS $(INSTALL_DIR)$(scriptdir)
-	$(INSTALL_DATA) $(srcdir)/NEWS $(INSTALL_DIR)$(scriptdir)
+	$(INSTALL_DATA) $(srcdir)/README $(INSTALL_ROOT)$(scriptdir)
+	$(INSTALL_DATA) $(srcdir)/PROBLEMS $(INSTALL_ROOT)$(scriptdir)
+	$(INSTALL_DATA) $(srcdir)/NEWS $(INSTALL_ROOT)$(scriptdir)
 
 mkdirs:
 	@for i in $(instdirs) ; do \
@@ -72,4 +72,8 @@
 	config.status config.cache config.log Makefile 
 
 distclean: clean
+	(cd src; $(MAKE) distclean)
+	(cd library; $(MAKE) distclean)
+	(cd man; $(MAKE) distclean)
+	(cd demos; $(MAKE) distclean)
 	$(RM) $(GENERATED_FILES)
diff -uNr blt2.4z.orig/configure blt2.4z/configure
--- blt2.4z.orig/configure	2002-10-04 01:33:59.000000000 -0400
+++ blt2.4z/configure	2020-11-08 09:13:14.000000000 -0600
@@ -2371,6 +2371,7 @@
 #line 2372 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <stdlib.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -2410,6 +2411,7 @@
 #line 2411 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <stdlib.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -2449,6 +2451,7 @@
 #line 2450 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <stdlib.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -2488,6 +2491,7 @@
 #line 2489 "configure"
 #include "confdefs.h"
 #include <stdio.h>
+#include <stdlib.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
@@ -3396,6 +3396,9 @@
   *-hpux*)
     SHLIB_SUFFIX="sl"
     ;;
+  *-darwin*)
+    SHLIB_SUFFIX="dylib"
+    ;;
   *)
     SHLIB_SUFFIX="so"
     ;;
@@ -3851,7 +3854,7 @@
 SHLIB_LD_FLAGS="$TCL_LD_FLAGS"
 SHLIB_RUNPATH="$TCL_LD_SEARCH_FLAGS"
 
-SHLIB_SUFFIX=".so"
+SHLIB_SUFFIX=".${SHLIB_SUFFIX}"
 SHLIB_TARGET=""
 SHLIB_CFLAGS=""
 SHLIB_LIB_SPECS="${JPEG_LIB_SPEC}"
@@ -4000,7 +4003,6 @@
       SHLIB_CFLAGS="+Z"
       SHLIB_LD="ld"
       SHLIB_LD_FLAGS="-b -E -n +s +b,${loader_run_path}:."
-      SHLIB_SUFFIX=".sl"
 
       # The run path is included in both LDFLAGS and SHLIB_LD_FLAGS
       # because SHLIB_LD is ld and LD is cc/gcc.
@@ -4208,6 +4210,9 @@
     SHLIB_LD_FLAGS=" -Wl,-Bexport"
     ;;
   
+  *-darwin*)
+    ;;
+
   *)
     build_shared="no"
     ;;
diff -uNr blt2.4z.orig/library/Makefile.in blt2.4z/library/Makefile.in
--- blt2.4z.orig/library/Makefile.in	2002-07-14 19:33:24.000000000 -0400
+++ blt2.4z/library/Makefile.in	2013-07-15 11:15:51.000000000 -0400
@@ -29,6 +29,7 @@
 		tabnotebook.tcl \
 		tabset.tcl \
 		treeview.tcl \
+		ZoomStack.itcl \
 		tclIndex \
 		$(cursors)
 
@@ -58,7 +59,7 @@
 	for i in $(miscFiles) ; do \
 	    $(INSTALL_DATA) $(srcdir)/$$i $(INSTALL_ROOT)$(scriptdir) ; \
 	done 
-	$(INSTALL_DATA) pkgIndex.tcl $(scriptdir)
+	$(INSTALL_DATA) pkgIndex.tcl $(INSTALL_ROOT)$(scriptdir)
 
 mkdirs:
 	@for i in $(instdirs) ; do \
diff -uNr blt2.4z.orig/library/Makefile.vc blt2.4z/library/Makefile.vc
--- blt2.4z.orig/library/Makefile.vc	2002-08-21 02:20:51.000000000 -0400
+++ blt2.4z/library/Makefile.vc	2013-07-15 11:15:51.000000000 -0400
@@ -6,7 +6,6 @@
 include ../win/makedefs
 
 version =	$(BLT_MAJOR_VERSION).$(BLT_MINOR_VERSION)
-pkgdir =	$(libdir)/tcl$(v1)/blt$(version)
 srcdir =	.
 
 cursors = 	treeview.cur
@@ -30,8 +29,7 @@
 		tclIndex
 
 instdirs =	$(prefix) $(exec_prefix) $(libdir) \
-		$(scriptdir) $(scriptdir)/dd_protocols $(libdir)/tcl$(v1) \
-		$(pkgdir)
+		$(scriptdir) $(scriptdir)/dd_protocols $(libdir)/tcl$(v1)
 
 all: build-pkgindex
 
@@ -62,7 +60,6 @@
 
 install-pkgindex: pkgIndex.tcl
 	$(INSTALL_DATA) pkgIndex.tcl $(scriptdir)
-	$(INSTALL_DATA) pkgIndex.tcl $(pkgdir)
 
 clean:
 	$(RM) pkgIndex.tcl
diff -uNr blt2.4z.orig/library/ZoomStack.itcl blt2.4z/library/ZoomStack.itcl
--- blt2.4z.orig/library/ZoomStack.itcl	2001-02-07 00:42:26.000000000 -0500
+++ blt2.4z/library/ZoomStack.itcl	2013-07-15 11:15:51.000000000 -0400
@@ -1,4 +1,6 @@
-import add itcl
+#import add itcl
+package require Itcl
+namespace import itcl::*
 
 class ZoomStackGraph {
 
@@ -48,6 +50,7 @@
     private method SaveCoords { x y } 
     private method Zoom {}
     private method Unzoom {}
+    private method Empty { }
     private method Push { cmd }
     private method Pop {}
     private method MarkPoint { x y }
diff -uNr blt2.4z.orig/library/pkgIndex.tcl.in blt2.4z/library/pkgIndex.tcl.in
--- blt2.4z.orig/library/pkgIndex.tcl.in	2002-07-14 19:33:24.000000000 -0400
+++ blt2.4z/library/pkgIndex.tcl.in	2013-07-15 11:15:51.000000000 -0400
@@ -8,27 +8,14 @@
 
     # Determine whether to load the full BLT library or
     # the "lite" tcl-only version.
-    
+
     if { [info commands tk] == "tk" } {
-        set name ${prefix}BLT${version_no_dots}${suffix}
-    } else {
-        set name ${prefix}BLTlite${version_no_dots}${suffix}
-    }
-    
-    global tcl_platform
-    if { $tcl_platform(platform) == "unix" } {
-	set library [file join $dir $name]
-	if { ![file exists $library] } {
-	    # Try the parent directory.
-	    set library [file join [file dirname $dir] $name]
-	}
-	if { ![file exists $library] } {
-	    # Default to the path generated at compilation.
-	    set library [file join "%LIB_DIR%" $name]
-	}
+        set name ${prefix}BLT.2${suffix}
     } else {
-	set library $name
+        set name ${prefix}BLTlite.2${suffix}
     }
+
+    set library [file join [file dirname $dir] $name]
     load $library BLT
 }
 
diff -uNr blt2.4z.orig/src/Makefile.in blt2.4z/src/Makefile.in
--- blt2.4z.orig/src/Makefile.in	2002-07-15 05:31:29.000000000 -0400
+++ blt2.4z/src/Makefile.in	2013-07-15 11:15:51.000000000 -0400
@@ -230,7 +230,8 @@
 
 distclean: clean
 	$(RM) $(srcdir)/*.bak $(srcdir)/*\~ $(srcdir)/"#"*  Makefile
-	$(RM) bltConfig.h Makefile TAGS
+	$(RM) bltConfig.h bltHash.h Makefile TAGS
+	(cd shared; $(MAKE) distclean)
 
 .c.o:
 	$(CC) -c $(CC_SWITCHES) $<
diff -uNr blt2.4z.orig/src/Makefile.vc blt2.4z/src/Makefile.vc
--- blt2.4z.orig/src/Makefile.vc	2002-09-07 16:12:10.000000000 -0400
+++ blt2.4z/src/Makefile.vc	2013-07-15 11:15:51.000000000 -0400
@@ -3,16 +3,15 @@
 # 	Makefile for BLT library using VC++.
 # ------------------------------------------------------------------------
 
-include	      e:/src/blt/win/makedefs
+include	      ../win/makedefs
 
-TOOLS32       =	c:/Program\ Files/Microsoft\ Visual\ Studio/Vc98
 AR            =	lib.exe -link50compat
 LD            =	link.exe
 CC            =	cl.exe
 rc32          =	rc.exe
 
 ifeq ($(WITH_JPEG),0)
-EXTRA_DEFINES = 
+EXTRA_DEFINES =
 endif
 ifeq ($(WITH_JPEG),1)
 EXTRA_DEFINES = -DHAVE_JPEGLIB_H=1
@@ -21,23 +20,23 @@
 JPEGINC	      = $(JPEGDIR)
 endif
 ifeq ($(WITH_JPEG),2)
-EXTRA_DEFINES = -DHAVE_IJL_H=1 
+EXTRA_DEFINES = -DHAVE_IJL_H=1
 JPEGDIR       =	c:/Program\ Files/Intel/IJL
 JPEGLIB	      =	$(JPEGDIR)/lib/ijl15l.lib
 JPEGINC	      = $(JPEGDIR)/Include
 endif
 
 # ------------------------------------------------------------------------
-# 	C Compiler options 
+# 	C Compiler options
 # ------------------------------------------------------------------------
 
 DEFINES       =	-D_X86_=1 -D__STDC__ -DWIN32 -DCONSOLE -D_MT \
-		$(DEBUG_DEFINES) $(SHLIB_DEFINES) $(EXTRA_DEFINES) 
+		$(DEBUG_DEFINES) $(SHLIB_DEFINES) $(EXTRA_DEFINES)
 
 ifeq ($(SHARED),1)
 SHLIB_DEFINES =	-D_DLL
 SHLIB_TARGET  =	build-dll
-LIBS          =	$(COMMON_LIBS) 
+LIBS          =	$(COMMON_LIBS)
 else
 SHLIB_DEFINES =	-D_CTYPE_DISABLE_MACROS
 LIBS          =	$(COMMON_LIBS) $(EXTRA_LIBS)
@@ -45,23 +44,23 @@
 
 ifeq ($(DEBUG),1)
 CFLAGS        =	-Z7 -Od
-DEBUG_LDFLAGS =	-debug:full -debugtype:cv  
+DEBUG_LDFLAGS =	-debug:full -debugtype:cv
 DEBUG_DEFINES = -DUSE_TCLALLOC=0
-TK_LIB        =	$(TKDIR)/win/Debug/tk$(v2)d.lib  
-TCL_LIB       =	$(TCLDIR)/win/Debug/tcl$(v2)d.lib 
+TK_LIB        =	$(TKDIR)/win/Debug/tk$(v2)d.lib
+TCL_LIB       =	$(TCLDIR)/win/Debug/tcl$(v2)d.lib
 MSVCRT        =	msvcrtd.lib
 else
-CFLAGS        =	-Ox -GB -GD 
-DEBUG_LDFLAGS =	-debug:full -debugtype:cv  
-TK_LIB        =	$(TKDIR)/win/Release/tk$(v2).lib  
-TCL_LIB       =	$(TCLDIR)/win/Release/tcl$(v2).lib 
+CFLAGS        =	-Ox -GB
+DEBUG_LDFLAGS =	-debug:full -debugtype:cv
+TK_LIB        =	$(TKDIR)/win/Release/tk$(v2).lib
+TCL_LIB       =	$(TCLDIR)/win/Release/tcl$(v2).lib
 MSVCRT        =	msvcrt.lib
 endif
 
-EXTRA_CFLAGS  =	-nologo -W3 
+EXTRA_CFLAGS  =	-nologo -W3
 
 # ------------------------------------------------------------------------
-# 	Linker flags and options 
+# 	Linker flags and options
 # ------------------------------------------------------------------------
 
 COMMON_LDFLAGS = -nodefaultlib -release -nologo -warn:3 \
@@ -72,14 +71,14 @@
 SHLIB_LDFLAGS = $(COMMON_LDFLAGS) \
 		-subsystem:console -entry:mainCRTStartup \
 		-subsystem:windows -entry:WinMainCRTStartup \
-		-entry:_DllMainCRTStartup$(DLLENTRY) -dll  
+		-entry:_DllMainCRTStartup$(DLLENTRY) -dll
 
 LDFLAGS       =	$(COMMON_LDFLAGS) \
-		-fixed:NO -stack:2300000 
+		-fixed:NO -stack:2300000
 
 COMMON_LIBS   =	$(TK_LIB) $(TCL_LIB) \
 		$(MSVCRT) \
-		kernel32.lib user32.lib 
+		kernel32.lib user32.lib
 
 EXTRA_LIBS    =	$(OLELIB) \
 		$(JPEGLIB) \
@@ -89,11 +88,11 @@
 		winspool.lib \
 		comdlg32.lib
 
-TCL_ONLY_LIBS = $(TCL_LIB) $(MSVCRT)  kernel32.lib user32.lib advapi32.lib 
+TCL_ONLY_LIBS = $(TCL_LIB) $(MSVCRT)  kernel32.lib user32.lib advapi32.lib
 
 
 # ------------------------------------------------------------------------
-# 	Source and target installation directories 
+# 	Source and target installation directories
 # ------------------------------------------------------------------------
 
 srcdir        =	.
@@ -108,7 +107,6 @@
 TCLDIR        =	$(srcdir)/../../tcl$(v3)
 TKDIR         =	$(srcdir)/../../tk$(v3)
 INCLUDES      =	-I. -I$(srcdir) \
-		-I$(TOOLS32)/include \
 		-I$(JPEGINC) \
 		-I$(TCLDIR)/win -I$(TCLDIR)/generic \
 		-I$(TKDIR)/win -I$(TKDIR)/generic -I$(TKDIR)/xlib \
@@ -122,9 +120,9 @@
 # ------------------------------------------------------------------------
 
 N_OBJS       =	bltTed.o
-V3_OBJS       =	bltTri.o bltGrMt.o 
+V3_OBJS       =	bltTri.o bltGrMt.o
 
-TK_OBJS       =	tkButton.o tkFrame.o tkScrollbar.o 
+TK_OBJS       =	tkButton.o tkFrame.o tkScrollbar.o
 
 GRAPH_OBJS =	bltGrAxis.o \
 		bltGrBar.o \
@@ -137,7 +135,7 @@
 		bltGrMisc.o \
 		bltGrPen.o \
 		bltGrPs.o \
-		bltGraph.o 
+		bltGraph.o
 
 TCL_ONLY_OBJS =	bltAlloc.o \
 		bltArrayObj.o \
@@ -161,8 +159,7 @@
 		bltWatch.o  \
 		bltWinPipe.o \
 		bltWinUtil.o \
-		bltWinDde.o \
-		pure_api.o
+		bltWinDde.o
 
 DEMO_OBJS     =	tkConsole.o bltWinMain.o
 
@@ -196,14 +193,14 @@
 		bltWindow.o \
 		bltObjConfig.o \
 		bltWinop.o \
-		$(TK_OBJS) $(N_OBJS) 
+		$(TK_OBJS) $(N_OBJS)
 
 NOT_YET       =	bltContainer.o bltCutBuffer.o bltColor.o
 
 HEADERS       =	blt.h bltChain.h bltVector.h bltTree.h bltPool.h bltHash.h
 
 # GNU Make-specific macro
-SRCS          =	$(patsubst %.o,$(srcdir)/%.c,$(OBJS)) 
+SRCS          =	$(patsubst %.o,$(srcdir)/%.c,$(OBJS))
 
 shell_name    = bltwish
 version       =	$(BLT_MAJOR_VERSION)$(BLT_MINOR_VERSION)
@@ -214,9 +211,9 @@
 
 lib_name =	BLT$(version)
 lib_a =		BLT$(version).lib
-lib_so =	BLT$(version).dll		
+lib_so =	BLT$(version).dll
 tcl_only_lib_a = BLTlite$(version).lib
-tcl_only_lib_so = BLTlite$(version).dll		
+tcl_only_lib_so = BLTlite$(version).dll
 
 CC_SWITCHES   =	$(CFLAGS) $(EXTRA_CFLAGS) $(DEFINES) $(INCLUDES)
 VPATH         =	$(srcdir)
@@ -232,21 +229,19 @@
 build-dll: build-library $(lib_so) $(tcl_only_lib_so)
 
 $(bltwish): $(lib_a) tkConsole.o  bltWinMain.c
-	$(RM) $(bltwish) 
+	$(RM) $(bltwish)
 	$(CC) -c $(CC_SWITCHES) -DTCLLIBPATH=\"$(TCLLIBPATH)\" \
 		-FobltWinMain.o $(srcdir)/bltWinMain.c
-	LIB=$(TOOLS32)/lib \
 	$(LD) $(LDFLAGS) tkConsole.o bltWinMain.o -out:$(bltwish) \
-		$(lib_a) $(LIBS) 
+		$(lib_a) $(LIBS)
 
 $(bltsh): $(tcl_only_lib_a) bltWinMain.c
-	$(RM) $(bltsh) 
+	$(RM) $(bltsh)
 	$(CC) -c $(CC_SWITCHES) -DTCL_ONLY \
 		-DTCLLIBPATH=\"$(TCLLIBPATH)\" \
 		-FobltWinMain.o $(srcdir)/bltWinMain.c
-	LIB=$(TOOLS32)/lib \
 	$(LD) $(LDFLAGS) bltWinMain.o -out:$(bltsh) \
-		$(tcl_only_lib_a) $(TCL_ONLY_LIBS) 
+		$(tcl_only_lib_a) $(TCL_ONLY_LIBS)
 
 $(lib_a):  bltHash.h $(OBJS) bltInit.c
 	$(RM) bltInit.o
@@ -260,7 +255,6 @@
 	$(CC) -c $(CC_SWITCHES) -DBLT_LIBRARY=\"$(BLT_LIBRARY)\" \
 		-FobltInit.o $(srcdir)/bltInit.c
 	$(RM) $@
-	LIB=$(TOOLS32)/lib \
 	$(LD) $(SHLIB_LDFLAGS) -out:$@ bltInit.o $(OBJS) $(SHLIB_LD_LIBS)
 
 $(tcl_only_lib_a):  bltHash.h $(TCL_ONLY_OBJS) bltInit.c
@@ -268,16 +262,15 @@
 	$(CC) -c $(CC_SWITCHES) -DTCL_ONLY -DBLT_LIBRARY=\"$(BLT_LIBRARY)\" \
 		-FobltInit.o $(srcdir)/bltInit.c
 	$(RM) $@
-	$(AR) -out:$@ bltInit.o $(TCL_ONLY_OBJS) 
+	$(AR) -out:$@ bltInit.o $(TCL_ONLY_OBJS)
 
 $(tcl_only_lib_so): $(tcl_only_lib_a) $(TCL_ONLY_OBJS) bltInit.c
 	$(RM) bltInit.o
 	$(CC) -c $(CC_SWITCHES) -DTCL_ONLY -DBLT_LIBRARY=\"$(BLT_LIBRARY)\" \
 		-FobltInit.o $(srcdir)/bltInit.c
 	$(RM) $@
-	LIB=$(TOOLS32)/lib \
 	$(LD) $(SHLIB_LDFLAGS) -out:$@ bltInit.o $(TCL_ONLY_OBJS) \
-		$(TCL_ONLY_LIBS) 
+		$(TCL_ONLY_LIBS)
 
 bltHash.h: bltHash.h.in
 	sed -e 's/@SIZEOF_VOID_P@/4/' \
@@ -295,7 +288,7 @@
 	    fi ; \
         done
 
-install-binaries: install-lib install-demos 
+install-binaries: install-lib install-demos
 
 install-demos: build-demos
 	$(INSTALL) $(bltwish) $(bindir)/$(bltwish)
@@ -303,8 +296,8 @@
 	$(INSTALL) $(bltsh) $(bindir)/$(bltsh)
 	$(INSTALL) $(bltsh) $(bindir)/$(bltsh2)
 
-install-lib: $(lib_so) $(lib_a) 
-	$(INSTALL_DATA) $(lib_so) $(bindir)
+install-lib: $(lib_so) $(lib_a)
+	$(INSTALL_DATA) $(lib_so) $(libdir)
 	$(INSTALL_DATA) $(lib_a) $(libdir)
 	$(INSTALL_DATA) $(tcl_only_lib_so) $(bindir)
 	$(INSTALL_DATA) $(tcl_only_lib_a) $(libdir)
@@ -321,11 +314,11 @@
 	$(RM) *.o *.pdb *.exp \
 		$(lib_a) $(lib_so) $(tcl_only_lib_a) $(tcl_only_lib_so) \
 		$(bltwish) $(bltsh) $(bltwish2) $(bltsh2)
-	$(RM) $(srcdir)/*.bak $(srcdir)/*\~ $(srcdir)/"#"*  
+	$(RM) $(srcdir)/*.bak $(srcdir)/*\~ $(srcdir)/"#"*
+	$(RM) bltHash.h
 
 distclean: clean
 	$(RM) Makefile
 
-.c.o:
+%.o : %.c
 	$(CC) -c $(CC_SWITCHES) -Fo$*.o $<
-
diff -uNr blt2.4z.orig/src/bltAlloc.c blt2.4z/src/bltAlloc.c
--- blt2.4z.orig/src/bltAlloc.c	2002-07-22 18:44:36.000000000 -0400
+++ blt2.4z/src/bltAlloc.c	2013-07-15 11:15:51.000000000 -0400
@@ -40,14 +40,23 @@
  * Tcl_Alloc/Tcl_Free routines because they don't automatically cause
  * a panic when not enough memory is available. There are cases (such 
  * as allocating a very large vector) where it's recoverable.
+ *
+ * Using private is dangerous.
+ * Tcl changes mem functions for debug which will conflict then with BLT
+ * stick to public API
  */
-EXTERN Blt_MallocProc TclpAlloc;
-EXTERN Blt_FreeProc TclpFree;
-EXTERN Blt_ReallocProc TclpRealloc;
-
-Blt_MallocProc *Blt_MallocProcPtr = TclpAlloc;
-Blt_FreeProc *Blt_FreeProcPtr = TclpFree; 
-Blt_ReallocProc *Blt_ReallocProcPtr = TclpRealloc; 
+//EXTERN Blt_MallocProc TclpAlloc;
+//EXTERN Blt_FreeProc TclpFree;
+//EXTERN Blt_ReallocProc TclpRealloc;
+
+//Blt_MallocProc *Blt_MallocProcPtr = TclpAlloc;
+//Blt_FreeProc *Blt_FreeProcPtr = TclpFree; 
+//Blt_ReallocProc *Blt_ReallocProcPtr = TclpRealloc;
+
+Blt_MallocProc *Blt_MallocProcPtr = (Blt_MallocProc *)Tcl_Alloc;
+Blt_FreeProc *Blt_FreeProcPtr = (Blt_FreeProc *)Tcl_Free; 
+Blt_ReallocProc *Blt_ReallocProcPtr = (Blt_ReallocProc *)Tcl_Realloc; 
+
 #else
 
 Blt_MallocProc *Blt_MallocProcPtr = malloc;
diff -uNr blt2.4z.orig/src/bltBeep.c blt2.4z/src/bltBeep.c
--- blt2.4z.orig/src/bltBeep.c	2002-04-27 20:05:03.000000000 -0400
+++ blt2.4z/src/bltBeep.c	2013-07-15 11:15:51.000000000 -0400
@@ -51,7 +51,7 @@
     int argc;			/* Number of arguments. */
     char **argv;		/* Argument strings. */
 {
-    int percent;
+    int percent= 0;
 
     if (argc > 2) {
 	Tcl_AppendResult(interp, "wrong # args: should be \"",
diff -uNr blt2.4z.orig/src/bltBgexec.c blt2.4z/src/bltBgexec.c
--- blt2.4z.orig/src/bltBgexec.c	2002-09-18 18:30:50.000000000 -0400
+++ blt2.4z/src/bltBgexec.c	2013-07-15 11:15:51.000000000 -0400
@@ -58,7 +58,7 @@
 typedef int Process;
 #endif
 
-#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0))
 typedef void *Tcl_Encoding;	/* Make up dummy type for encoding.  */
 #endif
 
@@ -276,7 +276,7 @@
     int objc;			/*  */
 #endif
 
-    int flags;			
+    int flags;
 
     Tcl_File file;		/* Used for backward compatability
 				 * with Tcl 7.5 */
@@ -370,35 +370,35 @@
     StringToSignal, (Blt_SwitchFreeProc *)NULL, (ClientData)0,
 };
 
-static Blt_SwitchSpec switchSpecs[] = 
+static Blt_SwitchSpec switchSpecs[] =
 {
-    {BLT_SWITCH_STRING, "-decodeoutput", 
+    {BLT_SWITCH_STRING, "-decodeoutput",
          Blt_Offset(BackgroundInfo, outputEncodingName), 0},
-    {BLT_SWITCH_STRING, "-decodeerror", 
+    {BLT_SWITCH_STRING, "-decodeerror",
          Blt_Offset(BackgroundInfo, errorEncodingName), 0},
-    {BLT_SWITCH_BOOLEAN, "-echo", 
+    {BLT_SWITCH_BOOLEAN, "-echo",
          Blt_Offset(BackgroundInfo, sink2.echo), 0},
-    {BLT_SWITCH_STRING, "-error", 
+    {BLT_SWITCH_STRING, "-error",
          Blt_Offset(BackgroundInfo, sink2.doneVar), 0},
-    {BLT_SWITCH_STRING, "-update", 
+    {BLT_SWITCH_STRING, "-update",
 	Blt_Offset(BackgroundInfo, sink1.updateVar), 0},
-    {BLT_SWITCH_STRING, "-output", 
+    {BLT_SWITCH_STRING, "-output",
         Blt_Offset(BackgroundInfo, sink1.doneVar), 0},
-    {BLT_SWITCH_STRING, "-lasterror", 
+    {BLT_SWITCH_STRING, "-lasterror",
 	Blt_Offset(BackgroundInfo, sink2.updateVar), 0},
-    {BLT_SWITCH_STRING, "-lastoutput", 
+    {BLT_SWITCH_STRING, "-lastoutput",
 	Blt_Offset(BackgroundInfo, sink1.updateVar), 0},
-    {BLT_SWITCH_LIST, "-onerror", 
+    {BLT_SWITCH_LIST, "-onerror",
 	Blt_Offset(BackgroundInfo, sink2.updateCmd), 0},
-    {BLT_SWITCH_LIST, "-onoutput", 
+    {BLT_SWITCH_LIST, "-onoutput",
 	Blt_Offset(BackgroundInfo, sink1.updateCmd), 0},
-    {BLT_SWITCH_BOOLEAN, "-keepnewline", 
+    {BLT_SWITCH_BOOLEAN, "-keepnewline",
 	Blt_Offset(BackgroundInfo, keepNewline), 0},
-    {BLT_SWITCH_BOOLEAN, "-check", 
+    {BLT_SWITCH_INT, "-check",
 	Blt_Offset(BackgroundInfo, interval), 0},
-    {BLT_SWITCH_CUSTOM, "-killsignal", 
+    {BLT_SWITCH_CUSTOM, "-killsignal",
 	Blt_Offset(BackgroundInfo, signalNum), 0, &killSignalSwitch},
-    {BLT_SWITCH_BOOLEAN, "-linebuffered", 
+    {BLT_SWITCH_BOOLEAN, "-linebuffered",
 	Blt_Offset(BackgroundInfo, lineBuffered), 0},
     {BLT_SWITCH_END, NULL, 0, 0}
 };
@@ -517,7 +517,7 @@
  *	Returns the next block of data since the last time this
  *	routine was called.
  *
- *---------------------------------------------------------------------- 
+ *----------------------------------------------------------------------
  */
 static unsigned char *
 NextBlock(sinkPtr, lengthPtr)
@@ -531,7 +531,7 @@
     length = sinkPtr->mark - sinkPtr->lastMark;
     sinkPtr->lastMark = sinkPtr->mark;
     if (length > 0) {
-	if ((!(sinkPtr->flags & SINK_KEEP_NL)) && 
+	if ((!(sinkPtr->flags & SINK_KEEP_NL)) &&
 	    (string[length - 1] == '\n')) {
 	    length--;
 	}
@@ -565,7 +565,7 @@
 	for (i = 0; i < newBytes; i++) {
 	    if (string[i] == '\n') {
 		int length;
-		
+
 		length = i + 1;
 		sinkPtr->lastMark += length;
 		if (!(sinkPtr->flags & SINK_KEEP_NL)) {
@@ -594,13 +594,13 @@
  *	keeping all the data collected from the channel (no -output
  *	flag and the process is detached).
  *
- *---------------------------------------------------------------------- 
+ *----------------------------------------------------------------------
  */
 static void
 ResetSink(sinkPtr)
     Sink *sinkPtr;
-{ 
-    if ((sinkPtr->flags & SINK_BUFFERED) && 
+{
+    if ((sinkPtr->flags & SINK_BUFFERED) &&
 	(sinkPtr->fill > sinkPtr->lastMark)) {
 	register size_t i, j;
 
@@ -645,7 +645,7 @@
     sinkPtr->name = name;
     sinkPtr->echo = FALSE;
     sinkPtr->fd = -1;
-    sinkPtr->file = (Tcl_File)NULL;
+    sinkPtr->file = (Tcl_File)(uintptr_t)NULL;
     sinkPtr->byteArr = sinkPtr->staticSpace;
     sinkPtr->size = DEF_BUFFER_SIZE;
     sinkPtr->encoding = encoding;
@@ -654,8 +654,8 @@
     }
     if (bgPtr->lineBuffered) {
 	sinkPtr->flags |= SINK_BUFFERED;
-    }	
-    if ((sinkPtr->updateCmd != NULL) || 
+    }
+    if ((sinkPtr->updateCmd != NULL) ||
 	(sinkPtr->updateVar != NULL) ||
 	(sinkPtr->echo)) {
 	sinkPtr->flags |= SINK_NOTIFY;
@@ -703,7 +703,7 @@
 	Blt_Free(sinkPtr->byteArr);
     }
     sinkPtr->fd = -1;
-    sinkPtr->file = (Tcl_File)NULL;
+    sinkPtr->file = (Tcl_File)(uintptr_t)NULL;
 #if (TCL_MAJOR_VERSION >= 8)
     if (sinkPtr->objv != NULL) {
 	register int i;
@@ -843,7 +843,7 @@
 #define IsOpenSink(sinkPtr)  ((sinkPtr)->fd != -1)
 
 static void
-CloseSink(interp, sinkPtr) 
+CloseSink(interp, sinkPtr)
     Tcl_Interp *interp;
     Sink *sinkPtr;
 {
@@ -855,7 +855,7 @@
 #else
 	Tcl_DeleteFileHandler(sinkPtr->fd);
 #endif
-	sinkPtr->file = (Tcl_File)NULL;
+	sinkPtr->file = (Tcl_File)(uintptr_t)NULL;
 	sinkPtr->fd = -1;
 
 #if WINDEBUG
@@ -864,19 +864,19 @@
 	if (sinkPtr->doneVar != NULL) {
 	    unsigned char *data;
 	    size_t length;
-	    /* 
+	    /*
 	     * If data is to be collected, set the "done" variable
-	     * with the contents of the buffer.  
+	     * with the contents of the buffer.
 	     */
 	    GetSinkData(sinkPtr, &data, &length);
-#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0))
 	    data[length] = '\0';
-	    if (Tcl_SetVar(interp, sinkPtr->doneVar, data, 
+	    if (Tcl_SetVar(interp, sinkPtr->doneVar, data,
 			   TCL_GLOBAL_ONLY) == NULL) {
 		Tcl_BackgroundError(interp);
 	    }
 #else
-	    if (Tcl_SetVar2Ex(interp, sinkPtr->doneVar, NULL, 
+	    if (Tcl_SetVar2Ex(interp, sinkPtr->doneVar, NULL,
 			      Tcl_NewByteArrayObj(data, length),
 			      (TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG)) == NULL) {
 		Tcl_BackgroundError(interp);
@@ -917,9 +917,9 @@
 #endif
     if (sinkPtr->encoding == ENCODING_BINARY) { /* binary */
 	/* No translation needed. */
-	sinkPtr->mark = sinkPtr->fill; 
+	sinkPtr->mark = sinkPtr->fill;
     } else if (sinkPtr->encoding == ENCODING_ASCII) { /* ascii */
-#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0))
 	/* Convert NUL bytes to question marks. */
 	srcPtr = sinkPtr->byteArr + sinkPtr->mark;
 	endPtr = sinkPtr->byteArr + sinkPtr->fill;
@@ -932,7 +932,7 @@
 #endif /* < 8.1.0 */
 	/* One-to-one translation. mark == fill. */
 	sinkPtr->mark = sinkPtr->fill;
-#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0))
     } else { /* unicode. */
 	int nSrcCooked, nCooked;
 	int result;
@@ -941,41 +941,41 @@
 	unsigned char *destPtr;
 	unsigned char *raw, *cooked;
 	unsigned char leftover[100];
-	
+
 	raw = sinkPtr->byteArr + sinkPtr->mark;
 	nRaw = sinkPtr->fill - sinkPtr->mark;
 	/* Ideally, the cooked buffer size should be smaller */
 	cookedSize = nRaw * TCL_UTF_MAX + 1;
 	cooked = Blt_Malloc(cookedSize);
-	result = Tcl_ExternalToUtf(interp, sinkPtr->encoding, 
-			(char *)raw, nRaw, 0, NULL, (char *)cooked, 
+	result = Tcl_ExternalToUtf(interp, sinkPtr->encoding,
+			(char *)raw, nRaw, 0, NULL, (char *)cooked,
 			cookedSize, &nSrcCooked, &nCooked, NULL);
 	nLeftOver = 0;
 	if (result == TCL_CONVERT_MULTIBYTE) {
-	    /* 
+	    /*
 	     * Last multibyte sequence wasn't completed.  Save the
-	     * extra characters in a temporary buffer.  
+	     * extra characters in a temporary buffer.
 	     */
 	    nLeftOver = (nRaw - nSrcCooked);
-	    srcPtr = sinkPtr->byteArr + (sinkPtr->mark + nSrcCooked); 
+	    srcPtr = sinkPtr->byteArr + (sinkPtr->mark + nSrcCooked);
 	    endPtr = srcPtr + nLeftOver;
 	    destPtr = leftover;
 	    while (srcPtr < endPtr) {
 		*destPtr++ = *srcPtr++;
 	    }
-	} 
+	}
 	/*
-	 * Create a bigger 
+	 * Create a bigger
 	 */
-						 
+
 	needed = nLeftOver + nCooked;
 	spaceLeft = sinkPtr->size - sinkPtr->mark;
 	if (spaceLeft >= needed) {
 	    spaceLeft = ExtendSinkBuffer(sinkPtr);
 	}
 	assert(spaceLeft > needed);
-	/* 
-	 * Replace the characters from the mark with the translated 
+	/*
+	 * Replace the characters from the mark with the translated
 	 * characters.
 	 */
 	srcPtr = cooked;
@@ -986,7 +986,7 @@
 	}
 	/* Add the number of newly translated characters to the mark */
 	sinkPtr->mark += nCooked;
-	
+
 	srcPtr = leftover;
 	endPtr = leftover + nLeftOver;
 	while (srcPtr < endPtr) {
@@ -996,7 +996,7 @@
 #endif /* >= 8.1.0  */
     }
 #ifdef WIN32
-    /* 
+    /*
      * Translate CRLF character sequences to LF characters.  We have to
      * do this after converting the string to UTF from UNICODE.
      */
@@ -1072,7 +1072,7 @@
 #endif
     timeout = (flags & WNOHANG) ? 0 : INFINITE;
     status = WaitForSingleObject(child.hProcess, timeout);
-				 
+
 #if WINDEBUG
     PurifyPrintf("WAITPID: wait status is %d\n", status);
 #endif
@@ -1147,9 +1147,9 @@
 
     EnumWindows(EnumWindowsProc, (LPARAM)&proc);
 
-    /* 
+    /*
      * Wait on the handle. If it signals, great. If it times out,
-     * then call TerminateProcess on it.  
+     * then call TerminateProcess on it.
      *
      * On Windows 95/98 this also has the added benefit of stopping
      * KERNEL32.dll from dumping.  The 2 second number is arbitrary.
@@ -1171,7 +1171,7 @@
 
 #endif /* WIN32 */
 
-#if (TCL_VERSION_NUMBER < _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER < _VERSION(8,1,0))
 
 static void
 NotifyOnUpdate(interp, sinkPtr, data, nBytes)
@@ -1192,7 +1192,7 @@
     data[nBytes] = '\0';
     if (sinkPtr->echo) {
 	Tcl_Channel channel;
-	
+
 	channel = Tcl_GetStdChannel(TCL_STDERR);
 	if (channel == NULL) {
 	    Tcl_AppendResult(interp, "can't get stderr channel", (char *)NULL);
@@ -1235,7 +1235,7 @@
     data[nBytes] = save;
 }
 
-#else 
+#else
 
 static void
 NotifyOnUpdate(interp, sinkPtr, data, nBytes)
@@ -1254,7 +1254,7 @@
     }
     if (sinkPtr->echo) {
 	Tcl_Channel channel;
-	
+
 	channel = Tcl_GetStdChannel(TCL_STDERR);
 	if (channel == NULL) {
 	    Tcl_AppendResult(interp, "can't get stderr channel", (char *)NULL);
@@ -1285,7 +1285,7 @@
     if (sinkPtr->updateVar != NULL) {
 	Tcl_Obj *result;
 
-	result = Tcl_SetVar2Ex(interp, sinkPtr->updateVar, NULL, objPtr, 
+	result = Tcl_SetVar2Ex(interp, sinkPtr->updateVar, NULL, objPtr,
 	       (TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG));
 	if (result == NULL) {
 	    Tcl_BackgroundError(interp);
@@ -1306,7 +1306,7 @@
     }
     ReadBytes(sinkPtr);
     CookSink(bgPtr->interp, sinkPtr);
-    if ((sinkPtr->mark > sinkPtr->lastMark) && 
+    if ((sinkPtr->mark > sinkPtr->lastMark) &&
 	(sinkPtr->flags & SINK_NOTIFY)) {
 	unsigned char *data;
 	int length;
@@ -1390,7 +1390,7 @@
 {
 
     if (bgPtr->traced) {
-	Tcl_UntraceVar(bgPtr->interp, bgPtr->statVar, TRACE_FLAGS, 
+	Tcl_UntraceVar(bgPtr->interp, bgPtr->statVar, TRACE_FLAGS,
 		VariableProc, bgPtr);
 	bgPtr->traced = FALSE;
     }
@@ -1471,7 +1471,7 @@
 #if (TCL_MAJOR_VERSION == 7)
 	    Tcl_DetachPids(1, &bgPtr->procArr[i]);
 #else
-	    Tcl_DetachPids(1, (Tcl_Pid *)bgPtr->procArr[i]);
+	    Tcl_DetachPids(1, (Tcl_Pid *)(uintptr_t)bgPtr->procArr[i]);
 #endif /* TCL_MAJOR_VERSION == 7 */
 #endif /* WIN32 */
 	}
@@ -1558,7 +1558,7 @@
     register int i;
     unsigned int lastPid;
     int pid;
-    enum PROCESS_STATUS { 
+    enum PROCESS_STATUS {
 	PROCESS_EXITED, PROCESS_STOPPED, PROCESS_KILLED, PROCESS_UNKNOWN
     } pcode;
     WAIT_STATUS_TYPE waitStatus, lastStatus;
@@ -1595,7 +1595,7 @@
     }
     bgPtr->nProcs = nLeft;
 
-    if ((nLeft > 0) || (IsOpenSink(&bgPtr->sink1)) || 
+    if ((nLeft > 0) || (IsOpenSink(&bgPtr->sink1)) ||
 	(IsOpenSink(&bgPtr->sink2))) {
 	/* Keep polling for the status of the children that are left */
 	bgPtr->timerToken = Tcl_CreateTimerHandler(bgPtr->interval, TimerProc,
@@ -1641,11 +1641,11 @@
 	Tcl_DStringAppendElement(&dString, "child completed normally");
 	break;
     case PROCESS_KILLED:
-	Tcl_DStringAppendElement(&dString, 
+	Tcl_DStringAppendElement(&dString,
 				Tcl_SignalMsg((int)(WTERMSIG(lastStatus))));
 	break;
     case PROCESS_STOPPED:
-	Tcl_DStringAppendElement(&dString, 
+	Tcl_DStringAppendElement(&dString,
 		 Tcl_SignalMsg((int)(WSTOPSIG(lastStatus))));
 	break;
     case PROCESS_UNKNOWN:
@@ -1658,8 +1658,8 @@
 	*bgPtr->exitCodePtr = code;
     }
     DisableTriggers(bgPtr);
-    result = Tcl_SetVar(bgPtr->interp, bgPtr->statVar, 
-	Tcl_DStringValue(&dString), TCL_GLOBAL_ONLY);
+    result = Tcl_SetVar(bgPtr->interp, bgPtr->statVar,
+	Tcl_DStringValue(&dString), TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG);
     Tcl_DStringFree(&dString);
     if (result == NULL) {
 	Tcl_BackgroundError(bgPtr->interp);
@@ -1712,7 +1712,7 @@
      * timer handler to periodically poll for the exit status of each
      * process.  Initially check at the next idle interval.
      */
-    if (!IsOpenSink(&bgPtr->sink2)) {
+    if (!IsOpenSink(&bgPtr->sink2) && bgPtr->timerToken == 0) {
 	bgPtr->timerToken = Tcl_CreateTimerHandler(0, TimerProc, clientData);
     }
 }
@@ -1760,7 +1760,7 @@
      * timer handler to periodically poll for the exit status of each
      * process.  Initially check at the next idle interval.
      */
-    if (!IsOpenSink(&bgPtr->sink1)) {
+    if (!IsOpenSink(&bgPtr->sink1) && bgPtr->timerToken == 0) {
 	bgPtr->timerToken = Tcl_CreateTimerHandler(0, TimerProc, clientData);
     }
 }
@@ -1827,7 +1827,7 @@
     /* Try to clean up any detached processes */
     Tcl_ReapDetachedProcs();
 
-    i = Blt_ProcessSwitches(interp, switchSpecs, argc - 2, argv + 2, 
+    i = Blt_ProcessSwitches(interp, switchSpecs, argc - 2, argv + 2,
 	(char *)bgPtr, BLT_SWITCH_ARGV_PARTIAL);
     if (i < 0) {
 	FreeBackgroundInfo(bgPtr);
@@ -1853,7 +1853,7 @@
 	if (strcmp(bgPtr->outputEncodingName, "binary") == 0) {
 	    encoding = ENCODING_BINARY;
 	} else {
-#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0))
 	    encoding = Tcl_GetEncoding(interp, bgPtr->outputEncodingName);
 	    if (encoding == NULL) {
 		goto error;
@@ -1866,7 +1866,7 @@
 	if (strcmp(bgPtr->errorEncodingName, "binary") == 0) {
 	    encoding = ENCODING_BINARY;
 	} else {
-#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0))
 	    encoding = Tcl_GetEncoding(interp, bgPtr->errorEncodingName);
 	    if (encoding == NULL) {
 		goto error;
@@ -1878,18 +1878,18 @@
 
     outFdPtr = errFdPtr = (int *)NULL;
 #ifdef WIN32
-    if ((!bgPtr->detached) || 
-	(bgPtr->sink1.doneVar != NULL) || 
-	(bgPtr->sink1.updateVar != NULL) || 
+    if ((!bgPtr->detached) ||
+	(bgPtr->sink1.doneVar != NULL) ||
+	(bgPtr->sink1.updateVar != NULL) ||
 	(bgPtr->sink1.updateCmd != NULL)) {
 	outFdPtr = &bgPtr->sink1.fd;
     }
 #else
     outFdPtr = &bgPtr->sink1.fd;
 #endif
-    if ((bgPtr->sink2.doneVar != NULL) || 
+    if ((bgPtr->sink2.doneVar != NULL) ||
 	(bgPtr->sink2.updateVar != NULL) ||
-	(bgPtr->sink2.updateCmd != NULL) || 
+	(bgPtr->sink2.updateCmd != NULL) ||
 	(bgPtr->sink2.echo)) {
 	errFdPtr = &bgPtr->sink2.fd;
     }
@@ -1900,6 +1900,7 @@
     }
     bgPtr->procArr = pidPtr;
     bgPtr->nProcs = nProcs;
+    bgPtr->timerToken = 0;
 
     if (bgPtr->sink1.fd == -1) {
 
@@ -1919,7 +1920,7 @@
 	(CreateSinkHandler(bgPtr, &bgPtr->sink2, StderrProc) != TCL_OK)) {
  	goto error;
     }
-    if (bgPtr->detached) {	
+    if (bgPtr->detached) {
 	char string[200];
 
 	/* If detached, return a list of the child process ids instead
@@ -1927,7 +1928,7 @@
 	for (i = 0; i < nProcs; i++) {
 #ifdef WIN32
 	    sprintf(string, "%u", (unsigned int)bgPtr->procArr[i].pid);
-#else 
+#else
 	    sprintf(string, "%d", bgPtr->procArr[i]);
 #endif
 	    Tcl_AppendElement(interp, string);
@@ -1950,7 +1951,7 @@
 
 	    /* Return the output of the pipeline. */
 	    GetSinkData(&bgPtr->sink1, &data, &length);
-#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0)) 
+#if (TCL_VERSION_NUMBER <  _VERSION(8,1,0))
 	    data[length] = '\0';
 	    Tcl_SetResult(interp, data, TCL_VOLATILE);
 #else
diff -uNr blt2.4z.orig/src/bltBitmap.c blt2.4z/src/bltBitmap.c
--- blt2.4z.orig/src/bltBitmap.c	2002-08-13 15:45:18.000000000 -0400
+++ blt2.4z/src/bltBitmap.c	2013-07-15 11:15:51.000000000 -0400
@@ -917,7 +917,7 @@
     info.padLeft = info.padRight = 0;
     info.padTop = info.padBottom = 0;
     info.font = (Tk_Font)NULL;	/* Initialized by Tk_ConfigureWidget */
-    if (Tk_ConfigureWidget(interp, tkwin, composeConfigSpecs,
+    if (Blt_ConfigureWidget(interp, tkwin, composeConfigSpecs,
 	    argc - 4, argv + 4, (char *)&info, 0) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1027,7 +1027,7 @@
     /* Initialize info and then process flags */
     info.rotate = 0.0;		/* No rotation by default */
     info.scale = 1.0;		/* No scaling by default */
-    if (Tk_ConfigureWidget(interp, dataPtr->tkwin, defineConfigSpecs,
+    if (Blt_ConfigureWidget(interp, dataPtr->tkwin, defineConfigSpecs,
 	    argc - 4, argv + 4, (char *)&info, 0) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltBusy.c blt2.4z/src/bltBusy.c
--- blt2.4z.orig/src/bltBusy.c	2002-07-12 18:29:28.000000000 -0400
+++ blt2.4z/src/bltBusy.c	2013-07-15 11:15:51.000000000 -0400
@@ -418,7 +418,7 @@
     Tk_Cursor oldCursor;
 
     oldCursor = busyPtr->cursor;
-    if (Tk_ConfigureWidget(interp, busyPtr->tkRef, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, busyPtr->tkRef, configSpecs, argc, argv,
 	    (char *)busyPtr, 0) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltCanvEps.c blt2.4z/src/bltCanvEps.c
--- blt2.4z.orig/src/bltCanvEps.c	2002-08-15 01:22:10.000000000 -0400
+++ blt2.4z/src/bltCanvEps.c	2013-07-15 11:15:51.000000000 -0400
@@ -1054,7 +1054,7 @@
     int width, height;
 
     tkwin = Tk_CanvasTkwin(canvas);
-    if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc,
+    if (Blt_ConfigureWidget(interp, tkwin, configSpecs, argc,
 	    argv, (char *)epsPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1686,10 +1686,10 @@
 {
     "eps",			/* name */
     sizeof(EpsItem),		/* itemSize */
-    CreateEps,			/* createProc */
+    (Tk_ItemCreateProc *)CreateEps,			/* createProc */
     configSpecs,		/* configSpecs */
-    ConfigureEps,		/* configureProc */
-    EpsCoords,			/* coordProc */
+    (Tk_ItemConfigureProc *)ConfigureEps,		/* configureProc */
+    (Tk_ItemCoordProc *)EpsCoords,			/* coordProc */
     DeleteEps,			/* deleteProc */
     DisplayEps,			/* displayProc */
     0,				/* alwaysRedraw */
@@ -1713,6 +1713,6 @@
 {
     Tk_CreateItemType(&epsItemType);
     /* Initialize custom canvas option routines. */
-    tagsOption.parseProc = Tk_CanvasTagsParseProc;
-    tagsOption.printProc = Tk_CanvasTagsPrintProc;
+    tagsOption.parseProc = (Tk_OptionParseProc *) Tk_CanvasTagsParseProc;
+    tagsOption.printProc = (Tk_OptionPrintProc *) Tk_CanvasTagsPrintProc;
 }
diff -uNr blt2.4z.orig/src/bltColor.c blt2.4z/src/bltColor.c
--- blt2.4z.orig/src/bltColor.c	2002-08-09 21:29:33.000000000 -0400
+++ blt2.4z/src/bltColor.c	2013-07-15 11:15:51.000000000 -0400
@@ -535,15 +535,15 @@
     for (i = 0; i < nPixels; i++, pixelPtr++) {
 	color.value = pixelPtr->value;
 	color.Alpha = 0xFF;	/* Ignore alpha-channel values */
-	hPtr = Blt_CreateHashEntry(&colorTable, (char *)color.value, &isNew);
+	hPtr = Blt_CreateHashEntry(&colorTable, (char *)(uintptr_t)color.value, &isNew);
 	if (isNew) {
 	    refCount = 1;
 	    nColors++;
 	} else {
-	    refCount = (int)Blt_GetHashValue(hPtr);
+	    refCount = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 	    refCount++;
 	}
-	Blt_SetHashValue(hPtr, (ClientData)refCount);
+	Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)refCount);
     }
     Blt_DeleteHashTable(&colorTable);
     return nColors;
diff -uNr blt2.4z.orig/src/bltConfig.c blt2.4z/src/bltConfig.c
--- blt2.4z.orig/src/bltConfig.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltConfig.c	2013-07-15 11:15:51.000000000 -0400
@@ -275,7 +275,7 @@
     char *widgRec;		/* Cubicle structure record */
     int offset;			/* Offset of style in record */
 {
-    unsigned int mask = (unsigned int)clientData;	/* Bit to be tested */
+    unsigned int mask = (unsigned int)(uintptr_t)clientData;	/* Bit to be tested */
     int *flagPtr = (int *)(widgRec + offset);
     int bool;
 
@@ -311,7 +311,7 @@
     int offset;			/* Offset of fill in widget record */
     Tcl_FreeProc **freeProcPtr;	/* Not Used. */
 {
-    unsigned int mask = (unsigned int)clientData;	/* Bit to be tested */
+    unsigned int mask = (unsigned int)(uintptr_t)clientData;	/* Bit to be tested */
     unsigned int bool = *(unsigned int *)(widgRec + offset);
 
     return (bool & mask) ? "1" : "0";
@@ -392,7 +392,7 @@
     int offset;			/* Offset of pixel size in record */
 {
     int *valuePtr = (int *)(widgRec + offset);
-    return Blt_GetPixels(interp, tkwin, string, (int)clientData, valuePtr);
+    return Blt_GetPixels(interp, tkwin, string, (int)(uintptr_t)clientData, valuePtr);
 }
 
 /*
@@ -481,7 +481,7 @@
     int offset;			/* Offset of pixel size in record */
 {
     int *valuePtr = (int *)(widgRec + offset);
-    return Blt_GetInt(interp, string, (int)clientData, valuePtr);
+    return Blt_GetInt(interp, string, (int)(uintptr_t)clientData, valuePtr);
 }
 
 /*
@@ -1206,6 +1206,65 @@
 }
 
 /*
+ * Tk_ConfigureWidget nolonger sets the TK_CONFIG_OPTION_SPECIFIED bit.
+ * Rather than convert all the BLT widgets to Tk_SetOptions,
+ * Blt_ConfigureWidget will serve as a wrapper for Tk_ConfigureWidget.
+ */
+int
+Blt_ConfigureWidget(interp, tkwin, specs, argc, argv, widgRec, flags)
+    Tcl_Interp *interp;
+    Tk_Window tkwin;		/* Window to associate with component */
+    Tk_ConfigSpec *specs;
+    int argc;
+    char **argv;
+    char *widgRec;
+    int flags;
+{
+  int i, nspec;
+  char *value;
+  char **valuesIn;
+  Tk_ConfigSpec *specPtr;
+
+  /* before configure get all the config values */
+  nspec = 0 ;
+  for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) nspec++;
+  valuesIn = (char**) Tcl_Alloc(nspec*sizeof(char*));
+
+  for (i=0, specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++, i++) {
+    if (Tk_ConfigureValue(interp, tkwin, specs, widgRec,
+			  specPtr->argvName, 0) != TCL_OK) {
+      return TCL_ERROR;
+    }
+    value = Tcl_GetStringResult(interp);
+    valuesIn[i] = (char*) Tcl_Alloc((strlen(value)+1)*sizeof(char));
+    strcpy(valuesIn[i], value);
+  }
+  /* configure */
+  if (Tk_ConfigureWidget(interp, tkwin, specs, argc, argv, widgRec, flags) !=
+      TCL_OK ) { return TCL_ERROR; }
+  /*
+    read back the new values and compare with inputs
+    set the TK_CONFIG_OPTION_SPECIFIED if value changed
+    clear that bit if the value didnt change
+  */
+  for (i=0, specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++, i++) {
+    if (Tk_ConfigureValue(interp, tkwin, specs, widgRec,
+			  specPtr->argvName, 0) != TCL_OK) {
+      return TCL_ERROR;
+    }
+    value = Tcl_GetStringResult(interp);
+    if ( strcmp(value, valuesIn[i]) ) {
+      specPtr->specFlags |= TK_CONFIG_OPTION_SPECIFIED;
+    } else {
+      specPtr->specFlags &= ~TK_CONFIG_OPTION_SPECIFIED;
+    }
+    Tcl_Free((char*)valuesIn[i]);
+  }
+  Tcl_Free((char*)valuesIn);
+  return TCL_OK;
+}
+
+/*
  *----------------------------------------------------------------------
  *
  * Blt_ConfigureWidgetComponent --
@@ -1275,7 +1334,7 @@
     Blt_Free(tempName);
 
     Tk_SetClass(tkwin, className);
-    result = Tk_ConfigureWidget(interp, tkwin, specsPtr, argc, argv, widgRec,
+    result = Blt_ConfigureWidget(interp, tkwin, specsPtr, argc, argv, widgRec,
 	flags);
     if (isTemporary) {
 	Tk_DestroyWindow(tkwin);
diff -uNr blt2.4z.orig/src/bltContainer.c blt2.4z/src/bltContainer.c
--- blt2.4z.orig/src/bltContainer.c	2002-07-14 19:33:24.000000000 -0400
+++ blt2.4z/src/bltContainer.c	2013-07-15 11:15:51.000000000 -0400
@@ -389,7 +389,7 @@
     Tcl_Interp *interp;
     Container *cntrPtr;
 {
-    int x, y, width, height, borderWidth, depth;
+    int x= 0, y= 0, width, height, borderWidth, depth;
     int xOffset, yOffset;
     Window root, dummy;
     Tk_ErrorHandler handler;
@@ -822,7 +822,7 @@
     char *widgRec;		/* Widget record */
     int offset;			/* Offset to field in structure */
 {
-    unsigned int flags = (int)clientData;
+    unsigned int flags = (int)(uintptr_t)clientData;
     Container *cntrPtr = (Container *)widgRec;
     Window *winPtr = (Window *) (widgRec + offset);
     Tk_Window tkAdopted;
@@ -1169,7 +1169,7 @@
     GC newGC;
     int width, height;
 
-    if (Tk_ConfigureWidget(interp, cntrPtr->tkwin, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, cntrPtr->tkwin, configSpecs, argc, argv,
 	    (char *)cntrPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltDragdrop.c blt2.4z/src/bltDragdrop.c
--- blt2.4z.orig/src/bltDragdrop.c	2002-07-18 02:35:32.000000000 -0400
+++ blt2.4z/src/bltDragdrop.c	2013-07-15 11:15:51.000000000 -0400
@@ -1065,7 +1065,7 @@
     Token *tokenPtr;
 
     tokenPtr = &(srcPtr->token);
-    if (Tk_ConfigureWidget(interp, srcPtr->tkwin, tokenConfigSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, srcPtr->tkwin, tokenConfigSpecs, argc, argv,
 	    (char *)tokenPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1293,7 +1293,7 @@
     /*
      *  Handle the bulk of the options...
      */
-    if (Tk_ConfigureWidget(interp, srcPtr->tkwin, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, srcPtr->tkwin, configSpecs, argc, argv,
 	    (char *)srcPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltGrAxis.c blt2.4z/src/bltGrAxis.c
--- blt2.4z.orig/src/bltGrAxis.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrAxis.c	2013-07-15 11:15:51.000000000 -0400
@@ -669,7 +669,7 @@
     char *widgRec;		/* Pointer to structure record. */
     int offset;			/* Offset of field in structure. */
 {
-    unsigned int mask = (unsigned int)clientData;
+    unsigned int mask = (unsigned int)(uintptr_t)clientData;
     Axis *axisPtr = (Axis *)widgRec;
     Ticks **ticksPtrPtr = (Ticks **) (widgRec + offset);
     int nTicks;
@@ -1268,39 +1268,39 @@
  * ----------------------------------------------------------------------
  */
 static double
-NiceNum(x, round)
+NiceNum(x, iround)
     double x;
-    int round;			/* If non-zero, round. Otherwise take ceiling
+    int iround;			/* If non-zero, round. Otherwise take ceiling
 				 * of value. */
 {
     double expt;		/* Exponent of x */
     double frac;		/* Fractional part of x */
-    double nice;		/* Nice, rounded fraction */
+    double dnice;		/* Nice, rounded fraction */
 
     expt = floor(log10(x));
     frac = x / EXP10(expt);	/* between 1 and 10 */
-    if (round) {
+    if (iround) {
 	if (frac < 1.5) {
-	    nice = 1.0;
+	    dnice = 1.0;
 	} else if (frac < 3.0) {
-	    nice = 2.0;
+	    dnice = 2.0;
 	} else if (frac < 7.0) {
-	    nice = 5.0;
+	    dnice = 5.0;
 	} else {
-	    nice = 10.0;
+	    dnice = 10.0;
 	}
     } else {
 	if (frac <= 1.0) {
-	    nice = 1.0;
+	    dnice = 1.0;
 	} else if (frac <= 2.0) {
-	    nice = 2.0;
+	    dnice = 2.0;
 	} else if (frac <= 5.0) {
-	    nice = 5.0;
+	    dnice = 5.0;
 	} else {
-	    nice = 10.0;
+	    dnice = 10.0;
 	}
     }
-    return nice * EXP10(expt);
+    return dnice * EXP10(expt);
 }
 
 static Ticks *
@@ -1420,63 +1420,66 @@
     double min, max;
 {
     double range;
-    double tickMin, tickMax;
+    double tickMin= 0, tickMax= 0;
     double majorStep, minorStep;
     int nMajor, nMinor;
 
-    min = (min != 0.0) ? log10(FABS(min)) : 0.0;
-    max = (max != 0.0) ? log10(FABS(max)) : 1.0;
-
-    tickMin = floor(min);
-    tickMax = ceil(max);
-    range = tickMax - tickMin;
-
-    if (range > 10) {
-	/* There are too many decades to display a major tick at every
-	 * decade.  Instead, treat the axis as a linear scale.  */
-	range = NiceNum(range, 0);
-	majorStep = NiceNum(range / DEF_NUM_TICKS, 1);
-	tickMin = UFLOOR(tickMin, majorStep);
-	tickMax = UCEIL(tickMax, majorStep);
-	nMajor = (int)((tickMax - tickMin) / majorStep) + 1;
-	minorStep = EXP10(floor(log10(majorStep)));
-	if (minorStep == majorStep) {
-	    nMinor = 4, minorStep = 0.2;
+    nMajor = nMinor = 0;
+    majorStep = minorStep = 0.0;
+    if (min < max) {
+	min = (min != 0.0) ? log10(FABS(min)) : 0.0;
+	max = (max != 0.0) ? log10(FABS(max)) : 1.0;
+	
+	tickMin = floor(min);
+	tickMax = ceil(max);
+	range = tickMax - tickMin;
+	
+	if (range > 10) {
+	    /* There are too many decades to display a major tick at every
+	     * decade.  Instead, treat the axis as a linear scale.  */
+	    range = NiceNum(range, 0);
+	    majorStep = NiceNum(range / DEF_NUM_TICKS, 1);
+	    tickMin = UFLOOR(tickMin, majorStep);
+	    tickMax = UCEIL(tickMax, majorStep);
+	    nMajor = (int)((tickMax - tickMin) / majorStep) + 1;
+	    minorStep = EXP10(floor(log10(majorStep)));
+	    if (minorStep == majorStep) {
+		nMinor = 4, minorStep = 0.2;
+	    } else {
+		nMinor = Round(majorStep / minorStep) - 1;
+	    }
 	} else {
-	    nMinor = Round(majorStep / minorStep) - 1;
-	}
-    } else {
-	if (tickMin == tickMax) {
-	    tickMax++;
-	}
-	majorStep = 1.0;
-	nMajor = (int)(tickMax - tickMin + 1); /* FIXME: Check this. */
-
-	minorStep = 0.0;	/* This is a special hack to pass
+	    if (tickMin == tickMax) {
+		tickMax++;
+	    }
+	    majorStep = 1.0;
+	    nMajor = (int)(tickMax - tickMin + 1); /* FIXME: Check this. */
+	    
+	    minorStep = 0.0;	/* This is a special hack to pass
 				 * information to the GenerateTicks
 				 * routine. An interval of 0.0 tells
 				 *	1) this is a minor sweep and 
 				 *	2) the axis is log scale.  
 				 */
-	nMinor = 10;
-    }
-    if ((axisPtr->looseMin == TICK_RANGE_TIGHT) ||
-	((axisPtr->looseMin == TICK_RANGE_LOOSE) && 
-	 (DEFINED(axisPtr->reqMin)))) {
-	tickMin = min;
-	nMajor++;
-    }
-    if ((axisPtr->looseMax == TICK_RANGE_TIGHT) ||
-	((axisPtr->looseMax == TICK_RANGE_LOOSE) &&
-	 (DEFINED(axisPtr->reqMax)))) {
-	tickMax = max;
+	    nMinor = 10;
+	}
+	if ((axisPtr->looseMin == TICK_RANGE_TIGHT) ||
+	    ((axisPtr->looseMin == TICK_RANGE_LOOSE) && 
+	     (DEFINED(axisPtr->reqMin)))) {
+	    tickMin = min;
+	    nMajor++;
+	}
+	if ((axisPtr->looseMax == TICK_RANGE_TIGHT) ||
+	    ((axisPtr->looseMax == TICK_RANGE_LOOSE) &&
+	     (DEFINED(axisPtr->reqMax)))) {
+	    tickMax = max;
+	}
     }
     axisPtr->majorSweep.step = majorStep;
     axisPtr->majorSweep.initial = floor(tickMin);
     axisPtr->majorSweep.nSteps = nMajor;
     axisPtr->minorSweep.initial = axisPtr->minorSweep.step = minorStep;
     axisPtr->minorSweep.nSteps = nMinor;
-
     SetAxisRange(&axisPtr->axisRange, tickMin, tickMax);
 }
 
@@ -1546,36 +1549,40 @@
     Axis *axisPtr;
     double min, max;
 {
-    double range, step;
+    double range, step= 0;
     double tickMin, tickMax;
     double axisMin, axisMax;
     int nTicks;
 
-    range = max - min;
-
-    /* Calculate the major tick stepping. */
-    if (axisPtr->reqStep > 0.0) {
-	/* An interval was designated by the user.  Keep scaling it
-	 * until it fits comfortably within the current range of the
-	 * axis.  */
-	step = axisPtr->reqStep;
-	while ((2 * step) >= range) {
-	    step *= 0.5;
+    nTicks = 0;
+    tickMin = tickMax = 0.0;
+    if (min < max) {
+	range = max - min;
+	
+	/* Calculate the major tick stepping. */
+	if (axisPtr->reqStep > 0.0) {
+	    /* An interval was designated by the user.  Keep scaling it
+	     * until it fits comfortably within the current range of the
+	     * axis.  */
+	    step = axisPtr->reqStep;
+	    while ((2 * step) >= range) {
+		step *= 0.5;
+	    }
+	} else {
+	    range = NiceNum(range, 0);
+	    step = NiceNum(range / DEF_NUM_TICKS, 1);
 	}
-    } else {
-	range = NiceNum(range, 0);
-	step = NiceNum(range / DEF_NUM_TICKS, 1);
+	
+	/* Find the outer tick values. Add 0.0 to prevent getting -0.0. */
+	axisMin = tickMin = floor(min / step) * step + 0.0;
+	axisMax = tickMax = ceil(max / step) * step + 0.0;
+	
+	nTicks = Round((tickMax - tickMin) / step) + 1;
     }
-
-    /* Find the outer tick values. Add 0.0 to prevent getting -0.0. */
-    axisMin = tickMin = floor(min / step) * step + 0.0;
-    axisMax = tickMax = ceil(max / step) * step + 0.0;
-
-    nTicks = Round((tickMax - tickMin) / step) + 1;
     axisPtr->majorSweep.step = step;
     axisPtr->majorSweep.initial = tickMin;
     axisPtr->majorSweep.nSteps = nTicks;
-
+    
     /*
      * The limits of the axis are either the range of the data
      * ("tight") or at the next outer tick interval ("loose").  The
@@ -1596,9 +1603,9 @@
 	axisMax = max;
     }
     SetAxisRange(&axisPtr->axisRange, axisMin, axisMax);
-
+    
     /* Now calculate the minor tick step and number. */
-
+    
     if ((axisPtr->reqNumMinorTicks > 0) && 
 	((axisPtr->flags & AXIS_CONFIG_MAJOR) == 0)) {
 	nTicks = axisPtr->reqNumMinorTicks - 1;
@@ -1614,7 +1621,6 @@
     axisPtr->minorSweep.nSteps = nTicks;
 }
 
-
 static void
 SweepTicks(axisPtr)
     Axis *axisPtr;
@@ -1684,9 +1690,11 @@
     for (linkPtr = Blt_ChainFirstLink(graphPtr->elements.displayList);
 	linkPtr != NULL; linkPtr = Blt_ChainNextLink(linkPtr)) {
 	elemPtr = Blt_ChainGetValue(linkPtr);
-	(*elemPtr->procsPtr->extentsProc) (elemPtr, &exts);
-	GetDataLimits(elemPtr->axes.x, exts.left, exts.right);
-	GetDataLimits(elemPtr->axes.y, exts.top, exts.bottom);
+	if (!elemPtr->hidden) {
+	    (*elemPtr->procsPtr->extentsProc) (elemPtr, &exts);
+	    GetDataLimits(elemPtr->axes.x, exts.left, exts.right);
+	    GetDataLimits(elemPtr->axes.y, exts.top, exts.bottom);
+	}
     }
     /*
      * Step 3:  Now that we know the range of data values for each axis,
@@ -3417,7 +3425,7 @@
 	return Tk_ConfigureInfo(graphPtr->interp, graphPtr->tkwin, configSpecs,
 	    (char *)axisPtr, argv[0], flags);
     }
-    if (Tk_ConfigureWidget(graphPtr->interp, graphPtr->tkwin, configSpecs,
+    if (Blt_ConfigureWidget(graphPtr->interp, graphPtr->tkwin, configSpecs,
 	    argc, argv, (char *)axisPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -3639,7 +3647,7 @@
     Blt_Uid classUid;
     int margin;
 
-    margin = (int)argv[-1];
+    margin = (int)(uintptr_t)argv[-1];
     chainPtr = graphPtr->margins[margin].axes;
     if (argc == 0) {
 	for (linkPtr = Blt_ChainFirstLink(chainPtr); linkPtr!= NULL;
@@ -4182,7 +4190,7 @@
     if (proc == NULL) {
 	return TCL_ERROR;
     }
-    argv[2] = (char *)margin; /* Hack. Slide a reference to the margin in 
+    argv[2] = (char *)(uintptr_t)margin; /* Hack. Slide a reference to the margin in 
 			       * the argument list. Needed only for UseOp.
 			       */
     axisPtr = Blt_GetFirstAxis(graphPtr->margins[margin].axes);
diff -uNr blt2.4z.orig/src/bltGrBar.c blt2.4z/src/bltGrBar.c
--- blt2.4z.orig/src/bltGrBar.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrBar.c	2013-07-15 11:15:51.000000000 -0400
@@ -2197,13 +2197,13 @@
 	    if (isNew) {
 		count = 1;
 	    } else {
-		count = (int)Blt_GetHashValue(hPtr);
+		count = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 		if (count == 1) {
 		    nStacks++;
 		}
 		count++;
 	    }
-	    Blt_SetHashValue(hPtr, (ClientData)count);
+	    Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)count);
 	}
     }
     if (nSegs == 0) {
@@ -2219,12 +2219,12 @@
 	infoPtr = graphPtr->freqArr;
 	for (hPtr = Blt_FirstHashEntry(&freqTable, &cursor); hPtr != NULL;
 	    hPtr = Blt_NextHashEntry(&cursor)) {
-	    count = (int)Blt_GetHashValue(hPtr);
+	    count = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 	    keyPtr = (FreqKey *)Blt_GetHashKey(&freqTable, hPtr);
 	    if (count > 1) {
 		h2Ptr = Blt_CreateHashEntry(&(graphPtr->freqTable),
 		    (char *)keyPtr, &isNew);
-		count = (int)Blt_GetHashValue(hPtr);
+		count = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 		infoPtr->freq = count;
 		infoPtr->axes = keyPtr->axes;
 		Blt_SetHashValue(h2Ptr, infoPtr);
diff -uNr blt2.4z.orig/src/bltGrElem.c blt2.4z/src/bltGrElem.c
--- blt2.4z.orig/src/bltGrElem.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrElem.c	2013-07-15 11:15:51.000000000 -0400
@@ -1215,9 +1215,7 @@
 {
     int nNames;			/* Number of names found in Tcl name list */
     char **nameArr;		/* Broken out array of element names */
-    Blt_HashSearch cursor;
     register int i;
-    register Blt_HashEntry *hPtr;
     Element *elemPtr;		/* Element information record */
 
     if (Tcl_SplitList(graphPtr->interp, newList, &nNames, &nameArr) != TCL_OK) {
@@ -1227,17 +1225,11 @@
     }
     /* Clear the display list and mark all elements as hidden.  */
     Blt_ChainReset(graphPtr->elements.displayList);
-    for (hPtr = Blt_FirstHashEntry(&graphPtr->elements.table, &cursor);
-	hPtr != NULL; hPtr = Blt_NextHashEntry(&cursor)) {
-	elemPtr = (Element *)Blt_GetHashValue(hPtr);
-	elemPtr->hidden = TRUE;
-    }
 
     /* Rebuild the display list, checking that each name it exists
      * (currently ignoring invalid element names).  */
     for (i = 0; i < nNames; i++) {
 	if (NameToElement(graphPtr, nameArr[i], &elemPtr) == TCL_OK) {
-	    elemPtr->hidden = FALSE;
 	    Blt_ChainAppend(graphPtr->elements.displayList, elemPtr);
 	}
     }
@@ -1399,8 +1391,7 @@
 	    /* Comment the PostScript to indicate the start of the element */
 	    Blt_FormatToPostScript(psToken, "\n%% Element \"%s\"\n\n", 
 		elemPtr->name);
-	    (*elemPtr->procsPtr->printNormalProc) (graphPtr, psToken, 
-		elemPtr);
+	    (*elemPtr->procsPtr->printNormalProc) (graphPtr, psToken, elemPtr);
 	}
     }
 }
@@ -1426,8 +1417,7 @@
 	if ((!elemPtr->hidden) && (elemPtr->flags & ELEM_ACTIVE)) {
 	    Blt_FormatToPostScript(psToken, "\n%% Active Element \"%s\"\n\n",
 		elemPtr->name);
-	    (*elemPtr->procsPtr->printActiveProc) (graphPtr, psToken, 
-						   elemPtr);
+	    (*elemPtr->procsPtr->printActiveProc) (graphPtr, psToken, elemPtr);
 	}
     }
 }
@@ -1671,6 +1661,7 @@
     ClosestSearch search;
     int i, x, y;
     int flags = TCL_LEAVE_ERR_MSG;
+    int found;
 
     if (graphPtr->flags & RESET_AXES) {
 	Blt_ResetAxes(graphPtr);
@@ -1705,7 +1696,7 @@
     search.x = x;
     search.y = y;
 
-    if (Tk_ConfigureWidget(interp, graphPtr->tkwin, closestSpecs, i - 6,
+    if (Blt_ConfigureWidget(interp, graphPtr->tkwin, closestSpecs, i - 6,
 	    argv + 6, (char *)&search, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;	/* Error occurred processing an option. */
     }
@@ -1715,13 +1706,23 @@
     search.dist = (double)(search.halo + 1);
 
     if (i < argc) {
+	Blt_ChainLink *linkPtr;
+
 	for ( /* empty */ ; i < argc; i++) {
 	    if (NameToElement(graphPtr, argv[i], &elemPtr) != TCL_OK) {
 		return TCL_ERROR;	/* Can't find named element */
 	    }
-	    if (elemPtr->hidden) {
+	    found = FALSE;
+	    for (linkPtr = Blt_ChainFirstLink(graphPtr->elements.displayList);
+		 linkPtr == NULL; linkPtr = Blt_ChainNextLink(linkPtr)) {
+		if (elemPtr == Blt_ChainGetValue(linkPtr)) {
+		    found = TRUE;
+		    break;
+		}
+	    }
+	    if ((!found) || (elemPtr->hidden)) {
 		Tcl_AppendResult(interp, "element \"", argv[i], "\" is hidden",
-		    (char *)NULL);
+			(char *)NULL);
 		return TCL_ERROR;	/* Element isn't visible */
 	    }
 	    /* Check if the X or Y vectors have notifications pending */
@@ -1744,16 +1745,14 @@
 	for (linkPtr = Blt_ChainLastLink(graphPtr->elements.displayList);
 	    linkPtr != NULL; linkPtr = Blt_ChainPrevLink(linkPtr)) {
 	    elemPtr = Blt_ChainGetValue(linkPtr);
-
 	    /* Check if the X or Y vectors have notifications pending */
-	    if ((elemPtr->flags & MAP_ITEM) ||
+	    if ((elemPtr->hidden) || 
+		(elemPtr->flags & MAP_ITEM) ||
 		(Blt_VectorNotifyPending(elemPtr->x.clientId)) ||
 		(Blt_VectorNotifyPending(elemPtr->y.clientId))) {
 		continue;
 	    }
-	    if (!elemPtr->hidden) {
-		(*elemPtr->procsPtr->closestProc) (graphPtr, elemPtr, &search);
-	    }
+	    (*elemPtr->procsPtr->closestProc)(graphPtr, elemPtr, &search);
 	}
 
     }
@@ -1851,7 +1850,7 @@
 	    return Tk_ConfigureInfo(interp, graphPtr->tkwin, 
 		elemPtr->specsPtr, (char *)elemPtr, options[0], flags);
 	}
-	if (Tk_ConfigureWidget(interp, graphPtr->tkwin, elemPtr->specsPtr, 
+	if (Blt_ConfigureWidget(interp, graphPtr->tkwin, elemPtr->specsPtr, 
 		numOpts, options, (char *)elemPtr, flags) != TCL_OK) {
 	    return TCL_ERROR;
 	}
@@ -1859,30 +1858,6 @@
 	    return TCL_ERROR;	/* Failed to configure element */
 	}
 	if (Blt_ConfigModified(elemPtr->specsPtr, "-hide", (char *)NULL)) {
-	    Blt_ChainLink *linkPtr;
-
-	    for (linkPtr = Blt_ChainFirstLink(graphPtr->elements.displayList);
-		linkPtr != NULL; linkPtr = Blt_ChainNextLink(linkPtr)) {
-		if (elemPtr == Blt_ChainGetValue(linkPtr)) {
-		    break;
-		}
-	    }
-	    if ((elemPtr->hidden) != (linkPtr == NULL)) {
-
-		/* The element's "hidden" variable is out of sync with
-		 * the display list. [That's what you get for having
-		 * two ways to do the same thing.]  This affects what
-		 * elements are considered for axis ranges and
-		 * displayed in the legend. Update the display list by
-		 * either by adding or removing the element.  */
-
-		if (linkPtr == NULL) {
-		    Blt_ChainPrepend(graphPtr->elements.displayList, elemPtr);
-		} else {
-		    Blt_ChainDeleteLink(graphPtr->elements.displayList, 
-					linkPtr);
-		}
-	    }
 	    graphPtr->flags |= RESET_AXES;
 	    elemPtr->flags |= MAP_ITEM;
 	}
diff -uNr blt2.4z.orig/src/bltGrGrid.c blt2.4z/src/bltGrGrid.c
--- blt2.4z.orig/src/bltGrGrid.c	2002-06-11 03:13:55.000000000 -0400
+++ blt2.4z/src/bltGrGrid.c	2013-07-15 11:15:51.000000000 -0400
@@ -365,7 +365,7 @@
 	return Tk_ConfigureInfo(interp, graphPtr->tkwin, configSpecs,
 	    (char *)gridPtr, argv[3], flags);
     }
-    if (Tk_ConfigureWidget(graphPtr->interp, graphPtr->tkwin, configSpecs,
+    if (Blt_ConfigureWidget(graphPtr->interp, graphPtr->tkwin, configSpecs,
 	    argc - 3, argv + 3, (char *)gridPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltGrHairs.c blt2.4z/src/bltGrHairs.c
--- blt2.4z.orig/src/bltGrHairs.c	2002-06-17 19:07:19.000000000 -0400
+++ blt2.4z/src/bltGrHairs.c	2013-07-15 11:15:51.000000000 -0400
@@ -390,7 +390,7 @@
 	return Tk_ConfigureInfo(interp, graphPtr->tkwin, configSpecs,
 		(char *)chPtr, argv[3], 0);
     }
-    if (Tk_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
+    if (Blt_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
 	    argv + 3, (char *)chPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltGrLegd.c blt2.4z/src/bltGrLegd.c
--- blt2.4z.orig/src/bltGrLegd.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrLegd.c	2013-07-15 11:15:51.000000000 -0400
@@ -1406,7 +1406,7 @@
 	return Tk_ConfigureInfo(interp, graphPtr->tkwin, configSpecs,
 		(char *)legendPtr, argv[3], flags);
     }
-    if (Tk_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
+    if (Blt_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
 	    argv + 3, (char *)legendPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltGrLine.c blt2.4z/src/bltGrLine.c
--- blt2.4z.orig/src/bltGrLine.c	2002-10-14 19:31:24.000000000 -0400
+++ blt2.4z/src/bltGrLine.c	2013-07-15 11:15:51.000000000 -0400
@@ -1211,7 +1211,7 @@
 NameOfSmooth(value)
     Smoothing value;
 {
-    if ((value < 0) || (value >= PEN_SMOOTH_LAST)) {
+    if (value >= PEN_SMOOTH_LAST) {
 	return "unknown smooth value";
     }
     return smoothingInfo[value].name;
diff -uNr blt2.4z.orig/src/bltGrMarker.c blt2.4z/src/bltGrMarker.c
--- blt2.4z.orig/src/bltGrMarker.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrMarker.c	2013-07-15 11:15:51.000000000 -0400
@@ -29,6 +29,9 @@
 #include "bltChain.h"
 #include "bltGrElem.h"
 
+#define GETBITMAP(b) \
+	(((b)->destBitmap == None) ? (b)->srcBitmap : (b)->destBitmap)
+
 #define MAX_OUTLINE_POINTS	12
 
 /* Map graph coordinates to normalized coordinates [0..1] */
@@ -812,7 +815,13 @@
 
     /* Polygon specific attributes and fields */
 
-    Point2D *screenPts;
+    Point2D *screenPts;		/* Array of points representing the
+				 * polygon in screen coordinates. It's
+				 * not used for drawing, but to
+				 * generate the outlinePts and fillPts
+				 * arrays that are the coordinates of
+				 * the possibly clipped outline and
+				 * filled polygon. */
 
     ColorPair outline;
     ColorPair fill;
@@ -1061,10 +1070,12 @@
     Graph *graphPtr;
     Extents2D *extsPtr;
 {
+/*
     assert(extsPtr->right >= extsPtr->left);
     assert(extsPtr->bottom >= extsPtr->top);
     assert(graphPtr->right >= graphPtr->left);
     assert(graphPtr->bottom >= graphPtr->top);
+*/
 
     return (((double)graphPtr->right < extsPtr->left) ||
 	    ((double)graphPtr->bottom < extsPtr->top) ||
@@ -1563,9 +1574,6 @@
     if (bmPtr->srcBitmap == None) {
 	return TCL_OK;
     }
-    if (bmPtr->destBitmap == None) {
-	bmPtr->destBitmap = bmPtr->srcBitmap;
-    }
     bmPtr->theta = FMOD(bmPtr->rotate, 360.0);
     if (bmPtr->theta < 0.0) {
 	bmPtr->theta += 360.0;
@@ -1650,9 +1658,9 @@
     if (bmPtr->srcBitmap == None) {
 	return;
     }
-    if (bmPtr->destBitmap != bmPtr->srcBitmap) {
+    if (bmPtr->destBitmap != None) {
 	Tk_FreePixmap(graphPtr->display, bmPtr->destBitmap);
-	bmPtr->destBitmap = bmPtr->srcBitmap;
+	bmPtr->destBitmap = None;
     }
     /* 
      * Collect the coordinates.  The number of coordinates will determine
@@ -1752,7 +1760,7 @@
     } else {
 	bmPtr->destWidth = srcWidth;
 	bmPtr->destHeight = srcHeight;
-	bmPtr->destBitmap = bmPtr->srcBitmap;
+	bmPtr->destBitmap = None;
     }
     bmPtr->anchorPos = anchorPos;
     {
@@ -1909,9 +1917,10 @@
     Graph *graphPtr = markerPtr->graphPtr;
     BitmapMarker *bmPtr = (BitmapMarker *)markerPtr;
     double theta;
+    Pixmap bitmap;
 
-    if ((bmPtr->destBitmap == None) || (bmPtr->destWidth < 1) || 
-	(bmPtr->destHeight < 1)) {
+    bitmap = GETBITMAP(bmPtr);
+    if ((bitmap == None) || (bmPtr->destWidth < 1) || (bmPtr->destHeight < 1)) {
 	return;
     }
     theta = FMOD(bmPtr->theta, (double)90.0);
@@ -1934,14 +1943,14 @@
 	    XFillPolygon(graphPtr->display, drawable, bmPtr->fillGC,
 		 polygon, bmPtr->nOutlinePts, Convex, CoordModeOrigin);
 	}
-	XSetClipMask(graphPtr->display, bmPtr->gc, bmPtr->destBitmap);
+	XSetClipMask(graphPtr->display, bmPtr->gc, bitmap);
 	XSetClipOrigin(graphPtr->display, bmPtr->gc, (int)bmPtr->anchorPos.x, 
 	       (int)bmPtr->anchorPos.y);
     } else {
 	XSetClipMask(graphPtr->display, bmPtr->gc, None);
 	XSetClipOrigin(graphPtr->display, bmPtr->gc, 0, 0);
     }
-    XCopyPlane(graphPtr->display, bmPtr->destBitmap, drawable, bmPtr->gc, 0, 0,
+    XCopyPlane(graphPtr->display, bitmap, drawable, bmPtr->gc, 0, 0,
 	bmPtr->destWidth, bmPtr->destHeight, (int)bmPtr->anchorPos.x, 
 	(int)bmPtr->anchorPos.y, 1);
 }
@@ -1965,8 +1974,10 @@
 {
     Graph *graphPtr = markerPtr->graphPtr;
     BitmapMarker *bmPtr = (BitmapMarker *)markerPtr;
+    Pixmap bitmap;
 
-    if (bmPtr->destBitmap == None) {
+    bitmap = GETBITMAP(bmPtr);
+    if (bitmap == None) {
 	return;
     }
     if (bmPtr->fillColor != NULL) {
@@ -1982,7 +1993,7 @@
     Blt_FormatToPostScript(psToken, "    %d %d true [%d 0 0 %d 0 %d] {",
 	bmPtr->destWidth, bmPtr->destHeight, bmPtr->destWidth, 
 	-bmPtr->destHeight, bmPtr->destHeight);
-    Blt_BitmapDataToPostScript(psToken, graphPtr->display, bmPtr->destBitmap,
+    Blt_BitmapDataToPostScript(psToken, graphPtr->display, bitmap,
 	bmPtr->destWidth, bmPtr->destHeight);
     Blt_AppendToPostScript(psToken, "    } imagemask\n",
 	"grestore\n", (char *)NULL);
@@ -2018,7 +2029,7 @@
     if (bmPtr->fillGC != NULL) {
 	Tk_FreeGC(graphPtr->display, bmPtr->fillGC);
     }
-    if (bmPtr->destBitmap != bmPtr->srcBitmap) {
+    if (bmPtr->destBitmap != None) {
 	Tk_FreePixmap(graphPtr->display, bmPtr->destBitmap);
     }
 }
@@ -2127,8 +2138,6 @@
 	    imPtr->tkImage = Tk_GetImage(interp, graphPtr->tkwin,
 		imPtr->imageName, ImageChangedProc, imPtr);
 	    if (imPtr->tkImage == NULL) {
-		Tcl_AppendResult(interp, "can't find an image \"", 
-			imPtr->imageName, "\"", (char *)NULL);
 		Blt_Free(imPtr->imageName);
 		imPtr->imageName = NULL;
 		return TCL_ERROR;
@@ -2494,6 +2503,9 @@
     if (imPtr->srcImage != NULL) {
 	Blt_FreeColorImage(imPtr->srcImage);
     }
+    if (imPtr->gc != NULL) {
+	Tk_FreeGC(graphPtr->display, imPtr->gc);
+    }
 }
 
 /*
@@ -3747,11 +3759,11 @@
 {
     PolygonMarker *pmPtr = (PolygonMarker *)markerPtr;
 
-    if (pmPtr->nWorldPts < 2) {
-	return FALSE;
+    if ((pmPtr->nWorldPts >= 3) && (pmPtr->screenPts != NULL)) {
+	return Blt_PointInPolygon(samplePtr, pmPtr->screenPts, 
+		  pmPtr->nWorldPts + 1);
     }
-    return Blt_PointInPolygon(samplePtr, pmPtr->screenPts, 
-	pmPtr->nWorldPts + 1);
+    return FALSE;
 }
 
 /*
@@ -3769,7 +3781,7 @@
 {
     PolygonMarker *pmPtr = (PolygonMarker *)markerPtr;
     
-    if (pmPtr->nWorldPts >= 3) {
+    if ((pmPtr->nWorldPts >= 3) && (pmPtr->screenPts != NULL)) {
 	return Blt_RegionInPolygon(extsPtr, pmPtr->screenPts, pmPtr->nWorldPts,
 	       enclosed);
     }
@@ -4036,6 +4048,9 @@
     if (pmPtr->outlinePts != NULL) {
 	Blt_Free(pmPtr->outlinePts);
     }
+    if (pmPtr->screenPts != NULL) {
+	Blt_Free(pmPtr->screenPts);
+    }
     Blt_FreeColorPair(&pmPtr->outline);
     Blt_FreeColorPair(&pmPtr->fill);
 }
@@ -4260,6 +4275,7 @@
     int nNames, nOpts;
     char **options;
     register int i;
+    int under;
 
     /* Figure out where the option value pairs begin */
     argc -= 3;
@@ -4289,7 +4305,8 @@
 	}
 	/* Save the old marker. */
 	oldName = markerPtr->name;
-	if (Tk_ConfigureWidget(interp, graphPtr->tkwin, 
+	under = markerPtr->drawUnder;
+	if (Blt_ConfigureWidget(interp, graphPtr->tkwin, 
 		markerPtr->classPtr->configSpecs, nOpts, options, 
 		(char *)markerPtr, flags) != TCL_OK) {
 	    return TCL_ERROR;
@@ -4304,6 +4321,9 @@
 	if ((*markerPtr->classPtr->configProc) (markerPtr) != TCL_OK) {
 	    return TCL_ERROR;
 	}
+	if (markerPtr->drawUnder != under) {
+	    graphPtr->flags |= REDRAW_BACKING_STORE;
+	}
     }
     return TCL_OK;
 }
@@ -4942,7 +4962,14 @@
     for (linkPtr = Blt_ChainLastLink(graphPtr->markers.displayList);
 	linkPtr != NULL; linkPtr = Blt_ChainPrevLink(linkPtr)) {
 	markerPtr = Blt_ChainGetValue(linkPtr);
+	/* 
+	 * Don't consider markers that are pending to be mapped. Even
+	 * if the marker has already been mapped, the coordinates
+	 * could be invalid now.  Better to pick no marker than the
+	 * wrong marker.
+	 */
 	if ((markerPtr->drawUnder == under) && (markerPtr->nWorldPts > 0) && 
+	    ((markerPtr->flags & MAP_ITEM) == 0) && 
 	    (!markerPtr->hidden) && (markerPtr->state == STATE_NORMAL)) {
 	    if ((*markerPtr->classPtr->pointProc) (markerPtr, &point)) {
 		return markerPtr;
diff -uNr blt2.4z.orig/src/bltGrMisc.c blt2.4z/src/bltGrMisc.c
--- blt2.4z.orig/src/bltGrMisc.c	2002-07-17 05:56:00.000000000 -0400
+++ blt2.4z/src/bltGrMisc.c	2013-07-15 11:15:51.000000000 -0400
@@ -260,7 +260,7 @@
 {
     ColorPair *pairPtr = (ColorPair *)(widgRec + offset);
     ColorPair sample;
-    int allowDefault = (int)clientData;
+    int allowDefault = (int)(uintptr_t)clientData;
 
     sample.fgColor = sample.bgColor = NULL;
     if ((string != NULL) && (*string != '\0')) {
diff -uNr blt2.4z.orig/src/bltGrPen.c blt2.4z/src/bltGrPen.c
--- blt2.4z.orig/src/bltGrPen.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGrPen.c	2013-07-15 11:15:51.000000000 -0400
@@ -215,7 +215,7 @@
     Tcl_FreeProc **freeProcPtr;	/* Not used. */
 {
     Pen *penPtr = *(Pen **)(widgRec + offset);
-
+    if ( ! penPtr ) return NULL;
     return penPtr->name;
 }
 
@@ -510,7 +510,7 @@
 	    return Tk_ConfigureInfo(interp, graphPtr->tkwin, 
 		    penPtr->configSpecs, (char *)penPtr, options[0], flags);
 	}
-	if (Tk_ConfigureWidget(interp, graphPtr->tkwin, penPtr->configSpecs,
+	if (Blt_ConfigureWidget(interp, graphPtr->tkwin, penPtr->configSpecs,
 		nOpts, options, (char *)penPtr, flags) != TCL_OK) {
 	    break;
 	}
diff -uNr blt2.4z.orig/src/bltGrPs.c blt2.4z/src/bltGrPs.c
--- blt2.4z.orig/src/bltGrPs.c	2002-08-09 21:29:33.000000000 -0400
+++ blt2.4z/src/bltGrPs.c	2013-07-15 11:15:51.000000000 -0400
@@ -418,7 +418,7 @@
 	return Tk_ConfigureInfo(interp, graphPtr->tkwin, configSpecs,
 		(char *)psPtr, argv[3], flags);
     }
-    if (Tk_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
+    if (Blt_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
 	    argv + 3, (char *)psPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1124,7 +1124,7 @@
 	    fileName = argv[3];	/* First argument is the file name. */
 	    argv++, argc--;
 	}
-	if (Tk_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
+	if (Blt_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 3,
 		argv + 3, (char *)psPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	    return TCL_ERROR;
 	}
diff -uNr blt2.4z.orig/src/bltGraph.c blt2.4z/src/bltGraph.c
--- blt2.4z.orig/src/bltGraph.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltGraph.c	2013-07-15 11:15:51.000000000 -0400
@@ -926,7 +926,7 @@
     if (InitPens(graphPtr) != TCL_OK) {
 	goto error;
     }
-    if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc - 2, argv + 2,
+    if (Blt_ConfigureWidget(interp, tkwin, configSpecs, argc - 2, argv + 2,
 	    (char *)graphPtr, 0) != TCL_OK) {
 	goto error;
     }
@@ -1074,7 +1074,7 @@
 	return Tk_ConfigureInfo(interp, graphPtr->tkwin, configSpecs,
 	    (char *)graphPtr, argv[2], flags);
     } else {
-	if (Tk_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 2,
+	if (Blt_ConfigureWidget(interp, graphPtr->tkwin, configSpecs, argc - 2,
 		argv + 2, (char *)graphPtr, flags) != TCL_OK) {
 	    return TCL_ERROR;
 	}
diff -uNr blt2.4z.orig/src/bltHash.c blt2.4z/src/bltHash.c
--- blt2.4z.orig/src/bltHash.c	2002-08-09 03:15:18.000000000 -0400
+++ blt2.4z/src/bltHash.c	2013-07-15 11:15:51.000000000 -0400
@@ -1302,7 +1302,7 @@
     sprintf(result, "%ld entries in table, %ld buckets\n",
 	    tablePtr->numEntries, tablePtr->numBuckets);
 #else 
-    sprintf(result, "%d entries in table, %d buckets\n",
+    sprintf(result, "%zd entries in table, %zd buckets\n",
 	    tablePtr->numEntries, tablePtr->numBuckets);
 #endif
     p = result + strlen(result);
@@ -1311,7 +1311,7 @@
 	sprintf(p, "number of buckets with %ld entries: %ld\n",
 		i, count[i]);
 #else 
-	sprintf(p, "number of buckets with %d entries: %d\n",
+	sprintf(p, "number of buckets with %zd entries: %zd\n",
 		i, count[i]);
 #endif
 	p += strlen(p);
@@ -1320,7 +1320,7 @@
     sprintf(p, "number of buckets with %d or more entries: %ld\n",
 	    NUM_COUNTERS, overflow);
 #else 
-    sprintf(p, "number of buckets with %d or more entries: %d\n",
+    sprintf(p, "number of buckets with %d or more entries: %zd\n",
 	    NUM_COUNTERS, overflow);
 #endif
     p += strlen(p);
@@ -1329,7 +1329,7 @@
 #if SIZEOF_VOID_P == 8
     sprintf(p, "maximum search distance for entry: %ld", max);
 #else
-    sprintf(p, "maximum search distance for entry: %d", max);
+    sprintf(p, "maximum search distance for entry: %zd", max);
 #endif
     return result;
 }
diff -uNr blt2.4z.orig/src/bltHash.h.in blt2.4z/src/bltHash.h.in
--- blt2.4z.orig/src/bltHash.h.in	2002-07-13 20:08:13.000000000 -0400
+++ blt2.4z/src/bltHash.h.in	2013-07-15 11:15:51.000000000 -0400
@@ -88,7 +88,7 @@
  * Acceptable key types for hash tables:
  */
 #define BLT_STRING_KEYS		0
-#define BLT_ONE_WORD_KEYS	((size_t)-1)
+#define BLT_ONE_WORD_KEYS	(unsigned int)((size_t)-1)
 
 /*
  * Forward declaration of Blt_HashTable.  Needed by some C++ compilers
diff -uNr blt2.4z.orig/src/bltHierbox.c blt2.4z/src/bltHierbox.c
--- blt2.4z.orig/src/bltHierbox.c	2002-09-18 23:02:09.000000000 -0400
+++ blt2.4z/src/bltHierbox.c	2013-07-15 11:15:51.000000000 -0400
@@ -2077,7 +2077,7 @@
     /* Generate a unique node serial number. */
     do {
 	serial = hboxPtr->nextSerial++;
-	hPtr = Blt_CreateHashEntry(&(hboxPtr->nodeTable), (char *)serial,
+	hPtr = Blt_CreateHashEntry(&(hboxPtr->nodeTable), (char *)(uintptr_t)serial,
 	    &isNew);
     } while (!isNew);
     Blt_SetHashValue(hPtr, treePtr);
@@ -2372,7 +2372,7 @@
 	if (Tcl_GetInt(NULL, string, &serial) == TCL_OK) {
 	    Blt_HashEntry *hPtr;
 
-	    hPtr = Blt_FindHashEntry(&(hboxPtr->nodeTable), (char *)serial);
+	    hPtr = Blt_FindHashEntry(&(hboxPtr->nodeTable), (char *)(uintptr_t)serial);
 	    if (hPtr != NULL) {
 		return (Tree *) Blt_GetHashValue(hPtr);
 	    }
@@ -2406,7 +2406,7 @@
     int serial;
 
     /* Node table keys are integers.  Convert them to strings. */
-    serial = (int)Blt_GetHashKey(&(hboxPtr->nodeTable),
+    serial = (int)(uintptr_t)Blt_GetHashKey(&(hboxPtr->nodeTable),
 	nodePtr->entryPtr->hashPtr);
     sprintf(string, "%d", serial);
 
@@ -3321,7 +3321,7 @@
     XColor *colorPtr;
 
     hierBox = hboxPtr;
-    if (Tk_ConfigureWidget(hboxPtr->interp, hboxPtr->tkwin, entryConfigSpecs,
+    if (Blt_ConfigureWidget(hboxPtr->interp, hboxPtr->tkwin, entryConfigSpecs,
 	    argc, argv, (char *)entryPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -3935,7 +3935,7 @@
     Tk_Uid nameId;
     Pixmap bitmap;
     hierBox = hboxPtr;
-    if (Tk_ConfigureWidget(interp, hboxPtr->tkwin, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, hboxPtr->tkwin, configSpecs, argc, argv,
 	    (char *)hboxPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -4443,7 +4443,7 @@
     Drawable drawable;		/* Pixmap or window to draw into. */
 {
     Entry *entryPtr;		/* Entry to be drawn. */
-    int x1, y1, x2, y2;
+    int x1, y1i, x2, y2;
     int height;
     int x, y;
 
@@ -4463,22 +4463,22 @@
 	y += (height - hboxPtr->button.height) / 2;
 	x1 = x2 = x + LEVELWIDTH(treePtr->level) +
 	    LEVELWIDTH(treePtr->level + 1) / 2;
-	y1 = y + hboxPtr->button.height / 2;
-	y2 = y1 + entryPtr->lineHeight;
+	y1i = y + hboxPtr->button.height / 2;
+	y2 = y1i + entryPtr->lineHeight;
 	if ((treePtr == hboxPtr->rootPtr) && (hboxPtr->hideRoot)) {
-	    y1 += entryPtr->height;
+	    y1i += entryPtr->height;
 	}
 	/*
 	 * Clip the line's Y-coordinates at the window border.
 	 */
-	if (y1 < 0) {
-	    y1 = 0;
+	if (y1i < 0) {
+	    y1i = 0;
 	}
 	if (y2 > Tk_Height(hboxPtr->tkwin)) {
 	    y2 = Tk_Height(hboxPtr->tkwin);
 	}
-	if ((y1 < Tk_Height(hboxPtr->tkwin)) && (y2 > 0)) {
-	    XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x1, y1, 
+	if ((y1i < Tk_Height(hboxPtr->tkwin)) && (y2 > 0)) {
+	    XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x1, y1i, 
 		      x2, y2);
 	}
     }
@@ -4787,17 +4787,17 @@
 	    x, y);
     }
     if ((isFocused) && (hboxPtr->focusEdit) && (editPtr->cursorOn)) {
-	int x1, y1, x2, y2;
+	int x1, y1i, x2, y2;
 
 	GetCursorLocation(hboxPtr, treePtr);
 	x1 = x + editPtr->x;
 	x2 = x1 + 3;
-	y1 = y + editPtr->y - 1;
-	y2 = y1 + editPtr->height - 1;
+	y1i = y + editPtr->y - 1;
+	y2 = y1i + editPtr->height - 1;
 	XDrawLine(hboxPtr->display, drawable, entryPtr->labelGC,
-	    x1, y1, x1, y2);
+	    x1, y1i, x1, y2);
 	XDrawLine(hboxPtr->display, drawable, entryPtr->labelGC,
-	    x1 - 2, y1, x2, y1);
+	    x1 - 2, y1i, x2, y1i);
 	XDrawLine(hboxPtr->display, drawable, entryPtr->labelGC,
 	    x1 - 2, y2, x2, y2);
     }
@@ -4858,7 +4858,7 @@
     int width, height;
     int entryHeight;
     int buttonY;
-    int x1, y1, x2, y2;
+    int x1, y1i, x2, y2;
     Entry *entryPtr;
 
     entryPtr = treePtr->entryPtr;
@@ -4874,7 +4874,7 @@
     buttonY = y + entryPtr->buttonY;
 
     x1 = x + (width / 2);
-    y1 = y2 = buttonY + (buttonPtr->height / 2);
+    y1i = y2 = buttonY + (buttonPtr->height / 2);
     x2 = x1 + (LEVELWIDTH(treePtr->level) + LEVELWIDTH(treePtr->level + 1)) / 2;
 
     if ((treePtr->parentPtr != NULL) && (hboxPtr->lineWidth > 0)) {
@@ -4882,17 +4882,17 @@
 	 * For every node except root, draw a horizontal line from
 	 * the vertical bar to the middle of the icon.
 	 */
-	XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x1, y1, x2, y2);
+	XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x1, y1i, x2, y2);
     }
     if ((entryPtr->flags & ENTRY_OPEN) && (hboxPtr->lineWidth > 0)) {
 	/*
 	 * Entry is open, draw vertical line.
 	 */
-	y2 = y1 + entryPtr->lineHeight;
+	y2 = y1i + entryPtr->lineHeight;
 	if (y2 > Tk_Height(hboxPtr->tkwin)) {
 	    y2 = Tk_Height(hboxPtr->tkwin);	/* Clip line at window border. */
 	}
-	XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x2, y1, x2, y2);
+	XDrawLine(hboxPtr->display, drawable, hboxPtr->lineGC, x2, y1i, x2, y2);
     }
     if ((entryPtr->flags & ENTRY_BUTTON) && (treePtr->parentPtr != NULL)) {
 	/*
@@ -5505,7 +5505,7 @@
 	return Tk_ConfigureInfo(interp, hboxPtr->tkwin, buttonConfigSpecs,
 	    (char *)hboxPtr, argv[0], 0);
     }
-    if (Tk_ConfigureWidget(hboxPtr->interp, hboxPtr->tkwin, buttonConfigSpecs,
+    if (Blt_ConfigureWidget(hboxPtr->interp, hboxPtr->tkwin, buttonConfigSpecs,
 	    argc, argv, (char *)hboxPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltHtext.c blt2.4z/src/bltHtext.c
--- blt2.4z.orig/src/bltHtext.c	2002-07-17 05:56:00.000000000 -0400
+++ blt2.4z/src/bltHtext.c	2013-07-15 11:15:51.000000000 -0400
@@ -40,6 +40,13 @@
  *    of the virtual text.
  */
 
+/*
+ * the htext widget is broken in tk8.5.6 as
+ * Tk_ConfigureWidget no longer supports
+ * queries of changed options. Need to migrate to Tk_SetOptions
+ * instead hack a wrapper Blt_ConfigureWidget
+ */
+
 #include "bltInt.h"
 
 #ifndef NO_HTEXT
@@ -338,7 +345,7 @@
 	TK_CONFIG_DONT_SET_DEFAULT, &heightOption},
     {TK_CONFIG_CUSTOM, "-linespacing", "lineSpacing", "LineSpacing",
 	DEF_HTEXT_LINE_SPACING, Tk_Offset(HText, leader),
-	TK_CONFIG_DONT_SET_DEFAULT, &bltDistanceOption},
+ 	TK_CONFIG_DONT_SET_DEFAULT, &bltDistanceOption},
     {TK_CONFIG_CUSTOM, "-maxheight", "maxHeight", "MaxHeight",
 	DEF_HTEXT_MAX_HEIGHT, Tk_Offset(HText, maxHeight),
 	TK_CONFIG_DONT_SET_DEFAULT, &bltDistanceOption},
@@ -2824,9 +2831,15 @@
     Tk_GetFontMetrics(htPtr->font, &fontMetrics);
     if ((segPtr->textEnd < htPtr->selFirst) ||
 	(segPtr->textStart > htPtr->selLast)) {	/* No selected text */
+#ifdef TK_DRAWCHARS_ANLGE
+	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
+	    htPtr->charArr + segPtr->textStart, textLength - 1,
+		     x, y + linePtr->baseline, 0.);
+#else
 	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
 	    htPtr->charArr + segPtr->textStart, textLength - 1,
 	    x, y + linePtr->baseline);
+#endif
 	return;
     }
     /*
@@ -2855,9 +2868,15 @@
 	Tk_MeasureChars(htPtr->font, htPtr->charArr + segPtr->textStart,
 	    nChars, 10000, DEF_TEXT_FLAGS, &lastX);
 	lastX += x;
+#ifdef TK_DRAWCHARS_ANGLE
+	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
+	    htPtr->charArr + segPtr->textStart, nChars, x,
+		     y + linePtr->baseline, 0.);
+#else
 	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
 	    htPtr->charArr + segPtr->textStart, nChars, x,
 	    y + linePtr->baseline);
+#endif
 	curPos = selStart;
     }
     if (selLength > 0) {	/* The selection itself */
@@ -2873,16 +2892,28 @@
 	    lastX, y + linePtr->baseline - fontMetrics.ascent,
 	    width, fontMetrics.linespace, htPtr->selBorderWidth,
 	    TK_RELIEF_RAISED);
+#ifdef TK_DRAWCHARS_ANGLE
+	Tk_DrawChars(htPtr->display, draw, htPtr->selectGC,
+	    htPtr->font, htPtr->charArr + selStart, selLength,
+		     lastX, y + linePtr->baseline, 0.);
+#else
 	Tk_DrawChars(htPtr->display, draw, htPtr->selectGC,
 	    htPtr->font, htPtr->charArr + selStart, selLength,
 	    lastX, y + linePtr->baseline);
+#endif
 	lastX = nextX;
 	curPos = selStart + selLength;
     }
     nChars = segPtr->textEnd - curPos;
     if (nChars > 0) {		/* Text following the selection */
+#ifdef TK_DRAWCHARS_ANGLE
+	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
+		     htPtr->charArr + curPos, nChars - 1,
+		     lastX, y + linePtr->baseline, 0.);
+#else
 	Tk_DrawChars(htPtr->display, draw, htPtr->drawGC, htPtr->font,
 	    htPtr->charArr + curPos, nChars - 1, lastX, y + linePtr->baseline);
+#endif
     }
 }
 
@@ -3038,17 +3069,21 @@
 	XFillRectangle(display, pixmap, htPtr->fillGC, 0, 0, width, height);
     }
 
-
-    if (deltaY >= 0) {
+    /* handle null lineArr */
+    if (htPtr->arraySize > 0 && htPtr->nLines > 0) {
+      if (deltaY >= 0) {
 	y += htPtr->lineArr[htPtr->first].offset;
 	lineNum = htPtr->first;
 	lastY = 0;
-    } else {
+      } else {
 	y += htPtr->lineArr[htPtr->last].offset;
 	lineNum = htPtr->last;
 	lastY = height;
+      }
+      forceCopy = 0;
+    } else {
+      htPtr->last = htPtr->first - 1;
     }
-    forceCopy = 0;
 
     /* Draw each line */
     for (i = htPtr->first; i <= htPtr->last; i++) {
@@ -3347,7 +3382,8 @@
      * The page is always draw at full width and the viewport will clip
      * the text.
      */
-    if ((htPtr->first != oldFirst) || (htPtr->last != oldLast)) {
+    if ((htPtr->first != oldFirst) || (htPtr->last != oldLast)
+	|| htPtr->flags & TEXT_DIRTY ) {
 	int offset;
 	int i;
 	int first, last;
@@ -3364,23 +3400,26 @@
 	    first = oldFirst, last = oldLast;
 	}
 
-	for (i = first; i <= last; i++) {
+
+	if (htPtr->arraySize > 0 && htPtr->nLines > 0) {
+	  for (i = first; i <= last; i++) {
 	    offset = htPtr->lineArr[i].offset;
 	    for (linkPtr = Blt_ChainFirstLink(htPtr->lineArr[i].chainPtr);
-		linkPtr != NULL; linkPtr = Blt_ChainNextLink(linkPtr)) {
-		winPtr = Blt_ChainGetValue(linkPtr);
-		if (winPtr->tkwin != NULL) {
-		    MoveEmbeddedWidget(winPtr, offset);
-		    winPtr->flags &= ~WIDGET_VISIBLE;
-		}
+		 linkPtr != NULL; linkPtr = Blt_ChainNextLink(linkPtr)) {
+	      winPtr = Blt_ChainGetValue(linkPtr);
+	      if (winPtr->tkwin != NULL) {
+		MoveEmbeddedWidget(winPtr, offset);
+		winPtr->flags &= ~WIDGET_VISIBLE;
+	      }
 	    }
+	  }
 	}
-    }
-    DrawPage(htPtr, deltaY);
-    SendBogusEvent(tkwin);
+	DrawPage(htPtr, deltaY);
+	SendBogusEvent(tkwin);
 
-    /* Reset flags */
-    htPtr->flags &= ~TEXT_DIRTY;
+	/* Reset flags */
+	htPtr->flags &= ~TEXT_DIRTY;
+    }
 }
 
 /* Selection Procedures */
@@ -3900,7 +3939,7 @@
     if (winPtr == NULL) {
 	return TCL_ERROR;
     }
-    if (Tk_ConfigureWidget(interp, htPtr->tkwin, widgetConfigSpecs,
+    if (Blt_ConfigureWidget(interp, htPtr->tkwin, widgetConfigSpecs,
 	    argc - 3, argv + 3, (char *)winPtr, 0) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -4070,8 +4109,13 @@
 	return Tk_ConfigureInfo(interp, htPtr->tkwin, specsPtr, itemPtr,
 		argv[2], 0);
     }
-    if (Tk_ConfigureWidget(interp, htPtr->tkwin, specsPtr, argc - 2,
-	    argv + 2, itemPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
+    if (Blt_ConfigureWidget(interp, htPtr->tkwin, specsPtr, argc - 2,
+    	    argv + 2, itemPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
+
+      /*
+       * in 8.5 cant tell if in option was modified
+       * supposed to convert to Tk_SetOptions
+       */
 	return TCL_ERROR;
     }
     if (itemPtr == (char *)htPtr) {
@@ -4468,7 +4512,7 @@
 #ifdef ITCL_NAMESPACES
     Itk_SetWidgetCommand(htPtr->tkwin, htPtr->cmdToken);
 #endif
-    if ((Tk_ConfigureWidget(interp, htPtr->tkwin, configSpecs, argc - 2,
+    if ((Blt_ConfigureWidget(interp, htPtr->tkwin, configSpecs, argc - 2,
 		argv + 2, (char *)htPtr, 0) != TCL_OK) ||
 	(ConfigureText(interp, htPtr) != TCL_OK)) {
 	Tk_DestroyWindow(htPtr->tkwin);
diff -uNr blt2.4z.orig/src/bltImage.c blt2.4z/src/bltImage.c
--- blt2.4z.orig/src/bltImage.c	2002-08-15 01:22:10.000000000 -0400
+++ blt2.4z/src/bltImage.c	2013-07-15 11:15:51.000000000 -0400
@@ -2448,7 +2448,7 @@
 	color.Red = red >> 8;
 	color.Green = green >> 8;
 	color.Blue = blue >> 8;
-	Mark(cubePtr, color.value, lut);
+	Mark(cubePtr, color.value, (unsigned int (*)[33][33])lut);
     }
     return lut;
 }
@@ -2530,7 +2530,7 @@
     lut = CreateColorLookupTable(statistics, cubes, nColors);
     Blt_Free(statistics);
     Blt_Free(cubes);
-    MapColors(src, dest, lut);
+    MapColors(src, dest, (unsigned int (*)[33][33])lut);
     Blt_Free(lut);
     return TCL_OK;
 }
diff -uNr blt2.4z.orig/src/bltInit.c blt2.4z/src/bltInit.c
--- blt2.4z.orig/src/bltInit.c	2002-09-10 01:12:33.000000000 -0400
+++ blt2.4z/src/bltInit.c	2013-07-15 11:15:51.000000000 -0400
@@ -28,7 +28,7 @@
 
 #include <bltInt.h>
 
-#define EXACT 1
+#define EXACT 0
 
 #ifndef BLT_LIBRARY
 #ifdef WIN32
@@ -38,17 +38,16 @@
 #endif
 #endif
 
+#define BLT_THREAD_KEY		"BLT Initialized"
+#define BLT_TCL_CMDS		(1<<0)
+#define BLT_TK_CMDS		(1<<1)
+
 double bltNaN;
 #if (TCL_MAJOR_VERSION > 7)
 Tcl_Obj *bltEmptyStringObjPtr;
 #endif
 
 static Tcl_MathProc MinMathProc, MaxMathProc;
-static int tclLoaded = FALSE;
-#ifndef TCL_ONLY
-static int tkLoaded = FALSE;
-#endif
-
 static char libPath[1024] =
 {
     BLT_LIBRARY
@@ -404,7 +403,10 @@
 Blt_Init(interp)
     Tcl_Interp *interp;		/* Interpreter to add extra commands */
 {
-    if (!tclLoaded) {
+    int flags;
+
+    flags = (int)Tcl_GetAssocData(interp, BLT_THREAD_KEY, NULL);
+    if ((flags & BLT_TCL_CMDS) == 0) {
 	register Tcl_AppInitProc **p;
 	Tcl_Namespace *nsPtr;
 	Tcl_ValueType args[2];
@@ -413,7 +415,7 @@
 	 * Check that the versions of Tcl that have been loaded are
 	 * the same ones that BLT was compiled against.
 	 */
-	if (Tcl_PkgRequire(interp, "Tcl", TCL_VERSION, EXACT) == NULL) {
+	if (Tcl_InitStubs(interp, TCL_VERSION, 1) == NULL) {
 	    return TCL_ERROR;
 	}
 	/* Set the "blt_version", "blt_patchLevel", and "blt_libPath" Tcl
@@ -451,23 +453,31 @@
 	if (Tcl_PkgProvide(interp, "BLT", BLT_VERSION) != TCL_OK) {
 	    return TCL_ERROR;
 	}
-	tclLoaded = TRUE;
+	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
+		(ClientData)(flags | BLT_TCL_CMDS));
     }
 #ifndef TCL_ONLY
-    if (!tkLoaded) {
+    if ((flags & BLT_TK_CMDS) == 0) {
 	register Tcl_AppInitProc **p;
 	Tcl_Namespace *nsPtr;
 
+	if (Tk_InitStubs(interp, TK_VERSION, 1) == NULL) {
+		return TCL_OK;
+	}
+
+#if 0
 #if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
 	if (Tcl_PkgPresent(interp, "Tk", TK_VERSION, EXACT) == NULL) {
 	    return TCL_OK;
-	} 
+	}
 #else
 	if (Tcl_PkgRequire(interp, "Tk", TK_VERSION, EXACT) == NULL) {
 	    Tcl_ResetResult(interp);
 	    return TCL_OK;
 	} 
 #endif
+#endif
+
 	nsPtr = Tcl_CreateNamespace(interp, "blt::tile", NULL, 
 			    (Tcl_NamespaceDeleteProc *) NULL);
 	if (nsPtr == NULL) {
@@ -486,7 +496,8 @@
 	    }
 	}
 	Blt_InitEpsCanvasItem(interp);
-	tkLoaded = TRUE;
+	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
+		(ClientData)(flags | BLT_TK_CMDS));
     }
 #endif
     return TCL_OK;
@@ -499,7 +510,10 @@
 Blt_Init(interp)
     Tcl_Interp *interp;		/* Interpreter to add extra commands */
 {
-    if (!tclLoaded) {
+    int flags;
+
+    flags = (int)Tcl_GetAssocData(interp, BLT_THREAD_KEY, NULL);
+    if ((flags & BLT_TCL_CMDS) == 0) {
 	register Tcl_AppInitProc **p;
 	Tcl_ValueType args[2];
 
@@ -507,7 +521,7 @@
 	 * Check that the versions of Tcl that have been loaded are
 	 * the same ones that BLT was compiled against.
 	 */
-	if (Tcl_PkgRequire(interp, "Tcl", TCL_VERSION, EXACT) == NULL) {
+	if (Tcl_InitStubs(interp, TCL_VERSION, EXACT) == NULL) {
 	    return TCL_ERROR;
 	}
 	/* Set the "blt_version", "blt_patchLevel", and "blt_libPath" Tcl
@@ -537,12 +551,18 @@
 	if (Tcl_PkgProvide(interp, "BLT", BLT_VERSION) != TCL_OK) {
 	    return TCL_ERROR;
 	}
-	tclLoaded = TRUE;
+	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
+		(ClientData)(flags | BLT_TCL_CMDS));
     }
 #ifndef TCL_ONLY
-    if (!tkLoaded) {
+    if ((flags & BLT_TK_CMDS) == 0) {
 	register Tcl_AppInitProc **p;
 
+	if (Tk_InitStubs(interp, TK_VERSION, 1) == NULL) {
+		return TCL_OK;
+	}
+
+#if 0
 #if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
 	if (Tcl_PkgPresent(interp, "Tk", TK_VERSION, EXACT) == NULL) {
 	    return TCL_OK;
@@ -553,6 +573,8 @@
 	    return TCL_OK;
 	} 
 #endif
+#endif
+
 	/* Initialize the BLT commands that use Tk too. */
 	for (p = tkCmds; *p != NULL; p++) {
 	    if ((**p) (interp) != TCL_OK) {
@@ -560,7 +582,8 @@
 	    }
 	}
 	Blt_InitEpsCanvasItem(interp);
-	tkLoaded = TRUE;
+	Tcl_SetAssocData(interp, BLT_THREAD_KEY, NULL, 
+		(ClientData)(flags | BLT_TK_CMDS));
     }
 #endif
     return TCL_OK;
diff -uNr blt2.4z.orig/src/bltInt.h blt2.4z/src/bltInt.h
--- blt2.4z.orig/src/bltInt.h	2002-08-21 16:13:12.000000000 -0400
+++ blt2.4z/src/bltInt.h	2013-07-15 11:15:51.000000000 -0400
@@ -724,6 +724,10 @@
 extern Tk_OptionParseProc Blt_StringToEnum;
 extern Tk_OptionPrintProc Blt_EnumToString;
 
+extern int Blt_ConfigureWidget _ANSI_ARGS_((Tcl_Interp *interp,
+       Tk_Window tkwin, Tk_ConfigSpec *specs, int argc, char **argv,
+       char *widgRec, int flags));
+
 extern int Blt_ConfigModified _ANSI_ARGS_(TCL_VARARGS(Tk_ConfigSpec *, specs));
 
 extern void Blt_DStringAppendElements _ANSI_ARGS_(TCL_VARARGS(Tcl_DString *, args));
diff -uNr blt2.4z.orig/src/bltNsUtil.c blt2.4z/src/bltNsUtil.c
--- blt2.4z.orig/src/bltNsUtil.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltNsUtil.c	2013-07-15 11:15:51.000000000 -0400
@@ -286,7 +286,7 @@
 				 * this "real" command. */
 } Command;
 
-
+/*
 struct VarTrace;
 struct ArraySearch;
 
@@ -341,19 +341,32 @@
     return varPtr->value.tablePtr;
 }
 
+*/
+
+/*
+* Yes ever dangerous not to use public API. Private Var has changed
+* rewrite using namespace which -variable command
+*/
+
 Tcl_Namespace *
 Blt_GetVariableNamespace(interp, name)
     Tcl_Interp *interp;
     CONST char *name;
 {
-    Var *varPtr;
+  Tcl_Namespace *nsPtr ;
+  const char *qualName, *nsName ;
+  static char nswhich[] = "namespace which -variable " ;
+
+  if ( name == NULL ) { return NULL ; }
+  if ( Tcl_VarEval(interp, nswhich, name, (char*)NULL) != TCL_OK ) 
+    { return NULL ; }
+  if ( (qualName = Tcl_GetStringResult(interp)) == NULL ||
+       strlen(qualName) < 1 ) { return NULL ; }
 
-    varPtr = (Var *)Tcl_FindNamespaceVar(interp, (char *)name, 
-	(Tcl_Namespace *)NULL, 0);
-    if (varPtr == NULL) {
-	return NULL;
-    }
-    return varPtr->nsPtr;
+  if ( Blt_ParseQualifiedName(interp, qualName, &nsPtr, &nsName) != TCL_OK )
+    { return NULL ; }
+
+  return nsPtr;
 }
 
 /*ARGSUSED*/
diff -uNr blt2.4z.orig/src/bltNsUtil.h blt2.4z/src/bltNsUtil.h
--- blt2.4z.orig/src/bltNsUtil.h	2002-07-18 02:35:32.000000000 -0400
+++ blt2.4z/src/bltNsUtil.h	2013-07-15 11:15:51.000000000 -0400
@@ -48,7 +48,7 @@
 
 
 EXTERN Tcl_Command Tcl_FindCommand _ANSI_ARGS_((Tcl_Interp *interp,
-	char *name, Tcl_Namespace *nsPtr, int flags));
+	CONST char *name, Tcl_Namespace *nsPtr, int flags));
 
 #define NS_SEARCH_NONE		(0)
 #define NS_SEARCH_CURRENT	(1<<0)
@@ -65,15 +65,15 @@
 
 #if (TCL_MAJOR_VERSION >= 8)
 EXTERN Tcl_Namespace *Tcl_CreateNamespace _ANSI_ARGS_((Tcl_Interp *interp,
-	char *name, ClientData clientData, Tcl_NamespaceDeleteProc *nsDelProc));
+	CONST char *name, ClientData clientData, Tcl_NamespaceDeleteProc *nsDelProc));
 
 EXTERN void Tcl_DeleteNamespace _ANSI_ARGS_((Tcl_Namespace *nsPtr));
 
 EXTERN Tcl_Namespace *Tcl_FindNamespace _ANSI_ARGS_((Tcl_Interp *interp,
-	char *name, Tcl_Namespace *context, int flags));
+	CONST char *name, Tcl_Namespace *context, int flags));
 
 EXTERN int Tcl_Export _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Namespace *nsPtr,
-	char *name, int resetFlag));
+	CONST char *name, int resetFlag));
 
 EXTERN Tcl_Var Tcl_FindNamespaceVar _ANSI_ARGS_((Tcl_Interp *interp, char *name,
 	Tcl_Namespace *contextNsPtr, int flags));
diff -uNr blt2.4z.orig/src/bltObjConfig.c blt2.4z/src/bltObjConfig.c
--- blt2.4z.orig/src/bltObjConfig.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltObjConfig.c	2013-07-15 11:15:51.000000000 -0400
@@ -1225,7 +1225,7 @@
 		if (Tcl_GetBooleanFromObj(interp, objPtr, &bool) != TCL_OK) {
 		    return TCL_ERROR;
 		}
-		flag = (unsigned int)specPtr->customPtr;
+		flag = (unsigned int)(uintptr_t)specPtr->customPtr;
 		*(int *)ptr &= ~flag;
 		if (bool) {
 		    *(int *)ptr |= flag;
@@ -1500,7 +1500,7 @@
 	{
 	    unsigned int flag;
 
-	    flag = (*(int *)ptr) & (unsigned int)specPtr->customPtr;
+	    flag = (*(int *)ptr) & (unsigned int)(uintptr_t)specPtr->customPtr;
 	    return Tcl_NewBooleanObj((flag != 0));
 	}
 
diff -uNr blt2.4z.orig/src/bltScrollbar.c blt2.4z/src/bltScrollbar.c
--- blt2.4z.orig/src/bltScrollbar.c	2002-07-17 18:38:54.000000000 -0400
+++ blt2.4z/src/bltScrollbar.c	2013-07-15 11:15:51.000000000 -0400
@@ -22,6 +22,12 @@
 
 #include "bltTile.h"
 
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
+#define Tcl_GetStringResult(x) x->result
+#define Tcl_GetErrorLine(x) x->errorLine
+#define Tcl_SetResult(x, y, z) x->result = y
+#endif
+
 extern Tk_CustomOption bltTileOption;
 
 #define NORMAL_BG	"#d9d9d9"
@@ -534,7 +540,7 @@
 	} else {
 	    fraction = ((double)pixels / (double)barWidth);
 	}
-	sprintf(interp->result, "%g", fraction);
+	sprintf(Tcl_GetStringResult(interp), "%g", fraction);
     } else if ((c == 'f') && (strncmp(argv[1], "fraction", length) == 0)) {
 	int x, y, pos, barWidth;
 	double fraction;
@@ -814,7 +820,7 @@
     XGCValues gcValues;
     GC new;
 
-    if (Tk_ConfigureWidget(interp, scrollPtr->tkwin, configSpecs,
+    if (Blt_ConfigureWidget(interp, scrollPtr->tkwin, configSpecs,
 	    argc, argv, (char *)scrollPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltSpline.c blt2.4z/src/bltSpline.c
--- blt2.4z.orig/src/bltSpline.c	2002-07-17 05:56:01.000000000 -0400
+++ blt2.4z/src/bltSpline.c	2013-07-15 11:15:51.000000000 -0400
@@ -228,14 +228,14 @@
     int which;
 {
     if ((which == 3) || (which == 4)) {	/* Parameters used in both 3 and 4 */
-	double mbar1, mbar2, mbar3, c1, d1, h1, j1, k1;
+	double mbar1, mbar2, mbar3, c1, d1, h1, j1d, k1;
 
 	c1 = p->x + (q->y - p->y) / m1;
 	d1 = q->x + (p->y - q->y) / m2;
 	h1 = c1 * 2.0 - p->x;
-	j1 = d1 * 2.0 - q->x;
+	j1d = d1 * 2.0 - q->x;
 	mbar1 = (q->y - p->y) / (h1 - p->x);
-	mbar2 = (p->y - q->y) / (j1 - q->x);
+	mbar2 = (p->y - q->y) / (j1d - q->x);
 
 	if (which == 4) {	/* Case 4. */
 	    Y1 = (p->x + c1) / 2.0;
diff -uNr blt2.4z.orig/src/bltTable.c blt2.4z/src/bltTable.c
--- blt2.4z.orig/src/bltTable.c	2002-10-14 19:31:24.000000000 -0400
+++ blt2.4z/src/bltTable.c	2013-07-15 11:15:51.000000000 -0400
@@ -1201,7 +1201,7 @@
     oldRowSpan = entryPtr->row.span;
     oldColSpan = entryPtr->column.span;
 
-    if (Tk_ConfigureWidget(interp, entryPtr->tkwin, entryConfigSpecs,
+    if (Blt_ConfigureWidget(interp, entryPtr->tkwin, entryConfigSpecs,
 	    argc, argv, (char *)entryPtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1553,7 +1553,7 @@
 		return Tk_ConfigureInfo(tablePtr->interp, tablePtr->tkwin,
 		    infoPtr->configSpecs, (char *)rcPtr, argv[0], 0);
 	    } else {
-		if (Tk_ConfigureWidget(tablePtr->interp, tablePtr->tkwin,
+		if (Blt_ConfigureWidget(tablePtr->interp, tablePtr->tkwin,
 			infoPtr->configSpecs, argc, argv, (char *)rcPtr,
 			TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 		    return TCL_ERROR;
@@ -1578,7 +1578,7 @@
 	}
 	rcPtr = GetRowColumn(infoPtr, n);
 	assert(rcPtr);
-	if (Tk_ConfigureWidget(tablePtr->interp, tablePtr->tkwin,
+	if (Blt_ConfigureWidget(tablePtr->interp, tablePtr->tkwin,
 	       infoPtr->configSpecs, argc, argv, (char *)rcPtr,
 	       TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	    return TCL_ERROR;
@@ -1861,7 +1861,7 @@
 	return Tk_ConfigureInfo(interp, tablePtr->tkwin, tableConfigSpecs,
 	    (char *)tablePtr, argv[0], 0);
     }
-    if (Tk_ConfigureWidget(interp, tablePtr->tkwin, tableConfigSpecs,
+    if (Blt_ConfigureWidget(interp, tablePtr->tkwin, tableConfigSpecs,
 	    argc, argv, (char *)tablePtr, TK_CONFIG_ARGV_ONLY) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -2034,7 +2034,7 @@
     key = 0;			/* Initialize key to bogus span */
     for (node = Blt_ListFirstNode(list); node != NULL;
 	node = Blt_ListNextNode(node)) {
-	key = (int)Blt_ListGetKey(node);
+	key = (int)(uintptr_t)Blt_ListGetKey(node);
 	if (entryPtr->row.span <= key) {
 	    break;
 	}
@@ -2046,7 +2046,7 @@
 	 * Create a new list (bucket) to hold entries of that size
 	 * span and and link it into the list of buckets.
 	 */
-	newNode = Blt_ListCreateNode(list, (char *)entryPtr->row.span);
+	newNode = Blt_ListCreateNode(list, (char *)(uintptr_t)entryPtr->row.span);
 	Blt_ListSetValue(newNode, (char *)Blt_ChainCreate());
 	Blt_ListLinkBefore(list, newNode, node);
 	node = newNode;
@@ -2063,7 +2063,7 @@
     key = 0;
     for (node = Blt_ListFirstNode(list); node != NULL;
 	node = Blt_ListNextNode(node)) {
-	key = (int)Blt_ListGetKey(node);
+	key = (int)(uintptr_t)Blt_ListGetKey(node);
 	if (entryPtr->column.span <= key) {
 	    break;
 	}
@@ -2075,7 +2075,7 @@
 	 * Create a new list (bucket) to hold entries of that size
 	 * span and and link it into the list of buckets.
 	 */
-	newNode = Blt_ListCreateNode(list, (char *)entryPtr->column.span);
+	newNode = Blt_ListCreateNode(list, (char *)(uintptr_t)entryPtr->column.span);
 	Blt_ListSetValue(newNode, (char *)Blt_ChainCreate());
 	Blt_ListLinkBefore(list, newNode, node);
 	node = newNode;
@@ -2198,7 +2198,7 @@
 	}
     }
     if (argc > 0) {
-	result = Tk_ConfigureWidget(tablePtr->interp, entryPtr->tkwin,
+	result = Blt_ConfigureWidget(tablePtr->interp, entryPtr->tkwin,
 	    entryConfigSpecs, argc, argv, (char *)entryPtr,
 	    TK_CONFIG_ARGV_ONLY);
     }
diff -uNr blt2.4z.orig/src/bltTabnotebook.c blt2.4z/src/bltTabnotebook.c
--- blt2.4z.orig/src/bltTabnotebook.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltTabnotebook.c	2013-07-15 11:15:51.000000000 -0400
@@ -2766,7 +2766,7 @@
     GC newGC;
 
     lastNotebookInstance = nbPtr;
-    if (Tk_ConfigureWidget(interp, nbPtr->tkwin, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, nbPtr->tkwin, configSpecs, argc, argv,
 	    (char *)nbPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -3691,7 +3691,7 @@
 	}
 	Tcl_Preserve(tabPtr);
 	lastNotebookInstance = nbPtr;
-	result = Tk_ConfigureWidget(interp, nbPtr->tkwin, tabConfigSpecs,
+	result = Blt_ConfigureWidget(interp, nbPtr->tkwin, tabConfigSpecs,
 	    nOpts, options, (char *)tabPtr, TK_CONFIG_ARGV_ONLY);
 	if (result == TCL_OK) {
 	    result = ConfigureTab(nbPtr, tabPtr);
diff -uNr blt2.4z.orig/src/bltTabset.c blt2.4z/src/bltTabset.c
--- blt2.4z.orig/src/bltTabset.c	2002-09-18 18:30:51.000000000 -0400
+++ blt2.4z/src/bltTabset.c	2013-07-15 11:15:51.000000000 -0400
@@ -2812,7 +2812,7 @@
     GC newGC;
 
     tabSet = setPtr;
-    if (Tk_ConfigureWidget(interp, setPtr->tkwin, configSpecs, argc, argv,
+    if (Blt_ConfigureWidget(interp, setPtr->tkwin, configSpecs, argc, argv,
 	    (char *)setPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -3818,7 +3818,7 @@
 	}
 	tabSet = setPtr;
 	Tcl_Preserve(tabPtr);
-	result = Tk_ConfigureWidget(interp, setPtr->tkwin, tabConfigSpecs,
+	result = Blt_ConfigureWidget(interp, setPtr->tkwin, tabConfigSpecs,
 	    nOpts, options, (char *)tabPtr, TK_CONFIG_ARGV_ONLY);
 	if (result == TCL_OK) {
 	    result = ConfigureTab(setPtr, tabPtr);
diff -uNr blt2.4z.orig/src/bltTed.c blt2.4z/src/bltTed.c
--- blt2.4z.orig/src/bltTed.c	2002-05-16 16:46:00.000000000 -0400
+++ blt2.4z/src/bltTed.c	2013-07-15 11:15:51.000000000 -0400
@@ -29,6 +29,12 @@
 
 #include "bltTable.h"
 
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
+#define Tcl_GetStringResult(x) x->result
+#define Tcl_GetErrorLine(x) x->errorLine
+#define Tcl_SetResult(x, y, z) x->result = y
+#endif
+
 extern Tk_CustomOption bltDistanceOption;
 extern Tk_CustomOption bltDashesOption;
 
@@ -826,7 +832,7 @@
     GC newGC;
     unsigned long gcMask;
 
-    if (Tk_ConfigureWidget(tedPtr->interp, tedPtr->tkwin, configSpecs,
+    if (Blt_ConfigureWidget(tedPtr->interp, tedPtr->tkwin, configSpecs,
 	    argc, argv, (char *)tedPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1504,7 +1510,7 @@
 	tablePtr->flags |= ARRANGE_PENDING;
 	Tcl_DoWhenIdle(tablePtr->arrangeProc, tablePtr);
     }
-    interp->result = Tk_PathName(tedPtr->tkwin);
+    Tcl_SetResult(interp, (char* )Tk_PathName(tedPtr->tkwin), TCL_VOLATILE);
     tedPtr->flags |= LAYOUT_PENDING;
     EventuallyRedraw(tedPtr);
     return TCL_OK;
@@ -1678,7 +1684,7 @@
 	    tedPtr->activeRectArr[4].width = grip - 1;
 	    tedPtr->activeRectArr[4].height = grip - 1;
 
-	    interp->result = Tk_PathName(entryPtr->tkwin);
+	    Tcl_SetResult (interp, (char *)Tk_PathName(entryPtr->tkwin), TCL_VOLATILE);
 	    active = 1;
 	    break;
 	}
@@ -1751,7 +1757,7 @@
 	tablePtr->flags |= ARRANGE_PENDING;
 	Tcl_DoWhenIdle(tablePtr->arrangeProc, tablePtr);
     }
-    interp->result = Tk_PathName(tedPtr->tkwin);
+    Tcl_SetResult (interp, (char *)Tk_PathName(tedPtr->tkwin), TCL_VOLATILE);
     tedPtr->flags |= LAYOUT_PENDING;
     EventuallyRedraw(tedPtr);
     return TCL_OK;
diff -uNr blt2.4z.orig/src/bltText.c blt2.4z/src/bltText.c
--- blt2.4z.orig/src/bltText.c	2002-08-13 15:45:20.000000000 -0400
+++ blt2.4z/src/bltText.c	2013-07-15 11:15:51.000000000 -0400
@@ -35,28 +35,196 @@
 static int initialized;
 
 static void
-DrawTextLayout(display, drawable, gc, font, x, y, textPtr)
+Blt_AverageImage(im, w, h, d)
+     XImage *im;
+     unsigned int w, h, d;
+{
+  /* the image will end up with 1 or 0 in the first plane, rest zero */
+  int i, j, k;
+  unsigned int d2;
+  unsigned long pixel, pixelave;
+
+  d2 = (3*d)/4;
+  for (i=0 ; i<w ; i++) {
+    for (j=0 ; j<h ; j++) {
+      pixel = XGetPixel(im, i, j);
+      pixelave = pixel & 1;
+      for (k=1 ; k<d ; k++) {
+	pixel >>= 1;
+	pixelave += pixel & 1;
+      }
+      pixelave = (pixelave + d2)/d;
+      XPutPixel(im, i, j, pixelave);
+    }
+  }
+  return;
+}
+
+static void
+Blt_DrawCharsBitmap(display, bitmap, w, width, height, gc, font, x, y, textPtr)
+    Display *display;
+    Drawable bitmap;
+    Window w;
+    unsigned int width, height;
+    GC gc;
+    Tk_Font font;
+    register int x, y;
+    TextLayout *textPtr;
+{
+  register TextFragment *fragPtr;
+  register int i, j;
+
+  XImage *bitmapimage, *pixmapimage;
+  GC gcsave, gcp;
+  Window winr;
+  int xr, yr;
+  unsigned int wr, hr, br, dr;
+  Pixmap pixmap;
+  unsigned long whitepixel;
+  XGCValues gcvalues ;
+  unsigned long valuemask, pixel ;
+
+  /* save the GC */
+  gcsave = XCreateGC(display, bitmap, 0, NULL);
+  XCopyGC(display, gc, 0, gcsave);
+  /* create a pixmap to draw chars to */
+  XGetGeometry(display, w, &winr, &xr, &yr, &wr, &hr, &br, &dr);
+  pixmap = Tk_GetPixmap(display, winr, width, height, dr);
+  /* get a GC for the pixmap, black(0) background, white(1) chars */
+  valuemask = (GCForeground|GCBackground) ;
+  gcvalues.foreground = gcvalues.background = 0 ;
+  gcp = XCreateGC(display, pixmap, valuemask, &gcvalues);
+  XSetForeground(display, gcp, 0) ;
+  XFillRectangle(display, pixmap, gcp, 0, 0, width, height);
+  whitepixel = XWhitePixel(display, 0);
+  XSetForeground(display, gcp, whitepixel) ;
+  /* draw white chars to the pixmap */
+  fragPtr = textPtr->fragArr;
+  for (i = 0; i < textPtr->nFrags; i++, fragPtr++) {
+#ifdef TK_DRAWCHARS_ANGLE
+    Tk_DrawChars(display, pixmap, gcp, font, fragPtr->text,
+		 fragPtr->count, x + fragPtr->x, y + fragPtr->y, 0);
+#else
+    Tk_DrawChars(display, pixmap, gcp, font, fragPtr->text,
+		 fragPtr->count, x + fragPtr->x, y + fragPtr->y);
+#endif
+  }
+  XFlush(display);
+  /* get the pixmap image */
+  pixmapimage = XGetImage(display, pixmap, 0, 0, width, height,
+			  AllPlanes, XYPixmap);
+  /* average the image to get the char in a single bit plane */
+  Blt_AverageImage(pixmapimage, width, height, dr);
+  /* get an image for the bitmap */
+  bitmapimage = XGetImage(display, bitmap, 0, 0, width, height,
+			  1, XYPixmap);
+  /* copy the first bit plane from the averaged pixmap to the bitmap */
+  for (i=0 ; i<width ; i++) {
+    for(j=0 ; j<height ; j++) {
+      pixel = XGetPixel(pixmapimage, i, j);
+      XPutPixel(bitmapimage, i, j, pixel);
+    }
+  }
+  /* but the bitmapimage into the bitmap with gc fg=1 bg=0 clipmask=None */
+  XSetForeground(display, gc, 1);
+  XSetBackground(display, gc, 0);
+  XSetClipMask(display, gc, None);
+  XPutImage(display, bitmap, gc, bitmapimage, 0, 0, 0, 0, width, height);
+  /* reset gc and clean up */
+  XCopyGC(display, gcsave, 0, gc);
+  XFreeGC(display, gcp);
+  XFreeGC(display, gcsave);
+  XDestroyImage(bitmapimage);
+  XDestroyImage(pixmapimage);
+  Tk_FreePixmap(display, pixmap);
+  return;
+}
+
+#ifdef TK_DRAWCHARS_ANGLE
+static void
+DrawTextLayout(display, drawable, gc, font, x, y, textPtr, angle)
     Display *display;
     Drawable drawable;
     GC gc;
     Tk_Font font;
     register int x, y;		/* Origin of text */
     TextLayout *textPtr;
+    double angle;
 {
     register TextFragment *fragPtr;
     register int i;
 
+#if HAVE_UTF
+    /*
+     * Tk_DrawChars no longer works on bitmaps for antialiased fonts
+     * Fix this by checking for a bitmap and calling code that
+     * DrawChars to bitmap
+     */
+    Window w;
+    int xd, yd;
+    unsigned int wd, hd, bd, dd;
+    XGetGeometry(display, drawable, &w, &xd, &yd, &wd, &hd, &bd, &dd);
+    if ( dd == 1 ) {
+      Blt_DrawCharsBitmap(display, drawable, w, wd, hd, gc, font,
+			  x, y, textPtr);
+      return;
+    }
     fragPtr = textPtr->fragArr;
     for (i = 0; i < textPtr->nFrags; i++, fragPtr++) {
+	Tk_DrawChars(display, drawable, gc, font, fragPtr->text,
+		     fragPtr->count, x + fragPtr->x, y + fragPtr->y, angle);
+    }
+#else
+    fragPtr = textPtr->fragArr;
+    for (i = 0; i < textPtr->nFrags; i++, fragPtr++) {
+	XDrawString(display, drawable, gc, x + fragPtr->x, y + fragPtr->y,
+	    fragPtr->text, fragPtr->count);
+    }
+#endif /*HAVE_UTF*/
+}
+
+#else  /* no angled drawing in Tk_DrawChars */
+static void
+DrawTextLayout(display, drawable, gc, font, x, y, textPtr)
+    Display *display;
+    Drawable drawable;
+    GC gc;
+    Tk_Font font;
+    register int x, y;		/* Origin of text */
+    TextLayout *textPtr;
+{
+    register TextFragment *fragPtr;
+    register int i;
+
 #if HAVE_UTF
+    /*
+     * Tk_DrawChars no longer works on bitmaps for antialiased fonts
+     * Fix this by checking for a bitmap and calling code that
+     * DrawChars to bitmap
+     */
+    Window w;
+    int xd, yd;
+    unsigned int wd, hd, bd, dd;
+    XGetGeometry(display, drawable, &w, &xd, &yd, &wd, &hd, &bd, &dd);
+    if ( dd == 1 ) {
+      Blt_DrawCharsBitmap(display, drawable, w, wd, hd, gc, font,
+			  x, y, textPtr);
+      return;
+    }
+    fragPtr = textPtr->fragArr;
+    for (i = 0; i < textPtr->nFrags; i++, fragPtr++) {
 	Tk_DrawChars(display, drawable, gc, font, fragPtr->text,
 	    fragPtr->count, x + fragPtr->x, y + fragPtr->y);
+    }
 #else
+    fragPtr = textPtr->fragArr;
+    for (i = 0; i < textPtr->nFrags; i++, fragPtr++) {
 	XDrawString(display, drawable, gc, x + fragPtr->x, y + fragPtr->y,
 	    fragPtr->text, fragPtr->count);
-#endif /*HAVE_UTF*/
     }
+#endif /*HAVE_UTF*/
 }
+#endif /* TK_DRAWCHARS_ANGLE */
 
 /*
  * -----------------------------------------------------------------
@@ -657,6 +825,8 @@
  *
  * -----------------------------------------------------------------
  */
+
+#ifdef TK_DRAWCHARS_ANGLE
 void
 Blt_DrawTextLayout(tkwin, drawable, textPtr, tsPtr, x, y)
     Tk_Window tkwin;
@@ -671,6 +841,90 @@
     Pixmap bitmap;
     int active;
 
+    if (!textPtr)
+	return;
+    
+    display = Tk_Display(tkwin);
+    theta = FMOD(tsPtr->theta, (double)360.0);
+    if (theta < 0.0) {
+	theta += 360.0;
+    }
+
+#ifdef WIN32
+    if ( theta > 0. ) {
+      if (Blt_DrawRotatedText(display, drawable, x, y, theta, tsPtr, textPtr)) {
+	return;
+      }
+    }
+#endif
+
+    active = tsPtr->state & STATE_ACTIVE;
+
+    width = textPtr->width, height = textPtr->height;
+    Blt_TranslateAnchor(x, y, width, height, tsPtr->anchor, &x, &y);
+    if (tsPtr->state & (STATE_DISABLED | STATE_EMPHASIS)) {
+      TkBorder *borderPtr = (TkBorder *) tsPtr->border;
+      XColor *color1, *color2;
+
+      color1 = borderPtr->lightColor, color2 = borderPtr->darkColor;
+      if (tsPtr->state & STATE_EMPHASIS) {
+	XColor *hold;
+	
+	hold = color1, color1 = color2, color2 = hold;
+      }
+      if (color1 != NULL) {
+	XSetForeground(display, tsPtr->gc, color1->pixel);
+      }
+      DrawTextLayout(display, drawable, tsPtr->gc, tsPtr->font, x + 1, 
+		     y + 1, textPtr, theta);
+      if (color2 != NULL) {
+	XSetForeground(display, tsPtr->gc, color2->pixel);
+      }
+      DrawTextLayout(display, drawable, tsPtr->gc, tsPtr->font, x, y, 
+		     textPtr, theta);
+      
+      /* Reset the foreground color back to its original setting,
+       * so not to invalidate the GC cache. */
+      XSetForeground(display, tsPtr->gc, tsPtr->color->pixel);
+      
+      return;		/* Done */
+    }
+    if ((tsPtr->shadow.offset > 0) && (tsPtr->shadow.color != NULL)) {
+      XSetForeground(display, tsPtr->gc, tsPtr->shadow.color->pixel);
+      DrawTextLayout(display, drawable, tsPtr->gc, tsPtr->font, 
+		     x + tsPtr->shadow.offset, y + tsPtr->shadow.offset,
+		     textPtr, theta);
+      XSetForeground(display, tsPtr->gc, tsPtr->color->pixel);
+    }
+    if (active) {
+      XSetForeground(display, tsPtr->gc, tsPtr->activeColor->pixel);
+    }
+    DrawTextLayout(display, drawable, tsPtr->gc, tsPtr->font, x, y, 
+		   textPtr, theta);
+    if (active) {
+      XSetForeground(display, tsPtr->gc, tsPtr->color->pixel);
+    }
+    return;			/* Done */
+}
+
+#else  /* NO TK_DRAWCHARS_ANGLE */
+void
+Blt_DrawTextLayout(tkwin, drawable, textPtr, tsPtr, x, y)
+    Tk_Window tkwin;
+    Drawable drawable;
+    TextLayout *textPtr;
+    TextStyle *tsPtr;		/* Text attribute information */
+    int x, y;			/* Window coordinates to draw text */
+{
+    int width, height;
+    double theta;
+    Display *display;
+    Pixmap bitmap;
+    int active;
+
+    if (!textPtr)
+	return;
+    
     display = Tk_Display(tkwin);
     theta = FMOD(tsPtr->theta, (double)360.0);
     if (theta < 0.0) {
@@ -795,6 +1049,7 @@
     XSetClipMask(display, tsPtr->gc, None);
     Tk_FreePixmap(display, bitmap);
 }
+#endif   /* TK_DRAWCHARS_ANGLE */
 
 void
 Blt_DrawText2(tkwin, drawable, string, tsPtr, x, y, areaPtr)
diff -uNr blt2.4z.orig/src/bltTree.c blt2.4z/src/bltTree.c
--- blt2.4z.orig/src/bltTree.c	2002-09-29 01:44:12.000000000 -0400
+++ blt2.4z/src/bltTree.c	2013-07-15 11:15:51.000000000 -0400
@@ -95,17 +95,16 @@
  */
 
 #define REBUILD_MULTIPLIER	3
+#define START_LOGSIZE		5 /* Initial hash table size is 32. */
+#define MAX_LIST_VALUES		20 /* Convert to hash table when node
+				    * value list gets bigger than this
+				    * many values. */
 
 #if (SIZEOF_VOID_P == 8)
 #define RANDOM_INDEX(i)		HashOneWord(mask, downshift, i)
 #define BITSPERWORD		64
 #else 
 
-#define START_LOGSIZE		5 /* Initial hash table size is 32. */
-#define MAX_LIST_VALUES		20 /* Convert to hash table when node
-				    * value list gets bigger than this
-				    * many values. */
-
 /*
  * The following macro takes a preliminary integer hash value and
  * produces an index into a hash tables bucket list.  The idea is
@@ -403,7 +402,7 @@
     TreeDestroyValues(nodePtr);
     UnlinkNode(nodePtr);
     treeObjPtr->nNodes--;
-    hPtr = Blt_FindHashEntry(&treeObjPtr->nodeTable, (char *)nodePtr->inode);
+    hPtr = Blt_FindHashEntry(&treeObjPtr->nodeTable, (char *)(uintptr_t)nodePtr->inode);
     assert(hPtr);
     Blt_DeleteHashEntry(&treeObjPtr->nodeTable, hPtr);
     Blt_PoolFreeItem(treeObjPtr->nodePool, (char *)nodePtr);
@@ -836,7 +835,7 @@
     /* Generate an unique serial number for this node.  */
     do {
 	inode = treeObjPtr->nextInode++;
-	hPtr = Blt_CreateHashEntry(&treeObjPtr->nodeTable,(char *)inode, 
+	hPtr = Blt_CreateHashEntry(&treeObjPtr->nodeTable,(char *)(uintptr_t)inode, 
 		   &isNew);
     } while (!isNew);
     nodePtr = NewNode(treeObjPtr, name, inode);
@@ -891,7 +890,7 @@
     int isNew;
 
     treeObjPtr = parentPtr->treeObject;
-    hPtr = Blt_CreateHashEntry(&treeObjPtr->nodeTable,(char *)inode, &isNew);
+    hPtr = Blt_CreateHashEntry(&treeObjPtr->nodeTable,(char *)(uintptr_t)inode, &isNew);
     if (!isNew) {
 	return NULL;
     }
@@ -997,7 +996,7 @@
     TreeObject *treeObjPtr = clientPtr->treeObject;
     Blt_HashEntry *hPtr;
 
-    hPtr = Blt_FindHashEntry(&treeObjPtr->nodeTable, (char *)inode);
+    hPtr = Blt_FindHashEntry(&treeObjPtr->nodeTable, (char *)(uintptr_t)inode);
     if (hPtr != NULL) {
 	return (Blt_TreeNode)Blt_GetHashValue(hPtr);
     }
diff -uNr blt2.4z.orig/src/bltTreeCmd.c blt2.4z/src/bltTreeCmd.c
--- blt2.4z.orig/src/bltTreeCmd.c	2002-09-27 18:23:01.000000000 -0400
+++ blt2.4z/src/bltTreeCmd.c	2013-07-15 11:15:51.000000000 -0400
@@ -950,7 +950,7 @@
     Tcl_Interp *interp = cmdPtr->interp;
     Blt_Tree tree = cmdPtr->tree;
     char c;
-    Blt_TreeNode node;
+    Blt_TreeNode node=NULL;
     char *string;
     char *p;
 
@@ -1283,7 +1283,7 @@
     if (parentId == -1) {	/* Dump marks root's parent as -1. */
 	node = dataPtr->root;
 	/* Create a mapping between the old id and the new node */
-	hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)nodeId, 
+	hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)(uintptr_t)nodeId, 
 		   &isNew);
 	Blt_SetHashValue(hPtr, node);
 	Blt_TreeRelabelNode(cmdPtr->tree, node, names[0]);
@@ -1293,7 +1293,7 @@
 	 * This can happen when there's a id collision with an
 	 * existing node. 
 	 */
-	hPtr = Blt_FindHashEntry(&dataPtr->idTable, (char *)parentId);
+	hPtr = Blt_FindHashEntry(&dataPtr->idTable, (char *)(uintptr_t)parentId);
 	if (hPtr != NULL) {
 	    parent = Blt_GetHashValue(hPtr);
 	} else {
@@ -1330,7 +1330,7 @@
 	if (dataPtr->flags & RESTORE_OVERWRITE) {
 	    node = Blt_TreeFindChild(parent, names[nNames - 1]);
 	    /* Create a mapping between the old id and the new node */
-	    hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)nodeId, 
+	    hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)(uintptr_t)nodeId, 
 				       &isNew);
 	    Blt_SetHashValue(hPtr, node);
 	}
@@ -1340,7 +1340,7 @@
 		node = Blt_TreeCreateNode(cmdPtr->tree, parent, 
 					  names[nNames - 1], -1);
 		/* Create a mapping between the old id and the new node */
-		hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)nodeId,
+		hPtr = Blt_CreateHashEntry(&dataPtr->idTable, (char *)(uintptr_t)nodeId,
 					   &isNew);
 		Blt_SetHashValue(hPtr, node);
 	    } else {
@@ -1667,7 +1667,7 @@
     for (node = Blt_ListFirstNode(patternList); node != NULL; 
 	node = Blt_ListNextNode(node)) {
 		
-	type = (int)Blt_ListGetValue(node);
+	type = (int)(uintptr_t)Blt_ListGetValue(node);
 	pattern = (char *)Blt_ListGetKey(node);
 	switch (type) {
 	case PATTERN_EXACT:
@@ -2602,7 +2602,7 @@
 	    for (hPtr = Blt_FirstHashEntry(tablePtr, &cursor); 
 		hPtr != NULL; hPtr = Blt_NextHashEntry(&cursor)) {
 		node = Blt_GetHashValue(hPtr);
-		Blt_ChainAppend(chainPtr, (ClientData)Blt_TreeNodeId(node));
+		Blt_ChainAppend(chainPtr, (ClientData)(uintptr_t)Blt_TreeNodeId(node));
 	    }   
 	    /*  
 	     * Iterate through this list to delete the nodes.  By
@@ -2612,7 +2612,7 @@
 	    for (linkPtr = Blt_ChainFirstLink(chainPtr); linkPtr != NULL;
 		 linkPtr = nextPtr) {
 		nextPtr = Blt_ChainNextLink(linkPtr);
-		inode = (int)Blt_ChainGetValue(linkPtr);
+		inode = (int)(uintptr_t)Blt_ChainGetValue(linkPtr);
 		node = Blt_TreeGetNode(cmdPtr->tree, inode);
 		if (node != NULL) {
 		    DeleteNode(cmdPtr, node);
diff -uNr blt2.4z.orig/src/bltTreeView.c blt2.4z/src/bltTreeView.c
--- blt2.4z.orig/src/bltTreeView.c	2002-08-16 00:15:04.000000000 -0400
+++ blt2.4z/src/bltTreeView.c	2013-07-15 11:15:51.000000000 -0400
@@ -1055,10 +1055,10 @@
     if (isNew) {
 	refCount = 1;
     } else {
-	refCount = (int)Blt_GetHashValue(hPtr);
+	refCount = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 	refCount++;
     }
-    Blt_SetHashValue(hPtr, (ClientData)refCount);
+    Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)refCount);
     return Blt_GetHashKey(&tvPtr->uidTable, hPtr);
 }
 
@@ -1084,10 +1084,10 @@
 
     hPtr = Blt_FindHashEntry(&tvPtr->uidTable, uid);
     assert(hPtr != NULL);
-    refCount = (int)Blt_GetHashValue(hPtr);
+    refCount = (int)(uintptr_t)Blt_GetHashValue(hPtr);
     refCount--;
     if (refCount > 0) {
-	Blt_SetHashValue(hPtr, (ClientData)refCount);
+	Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)refCount);
     } else {
 	Blt_DeleteHashEntry(&tvPtr->uidTable, hPtr);
     }
@@ -3866,6 +3866,7 @@
 	assert(tvPtr->visibleArr);
     }
     tvPtr->nVisible = 0;
+    tvPtr->visibleArr[0] = NULL;
 
     if (tvPtr->rootPtr->flags & ENTRY_HIDDEN) {
 	return TCL_OK;		/* Root node is hidden. */
@@ -4022,7 +4023,7 @@
 {
     int height, level;
     int x, y;
-    int x1, y1, x2, y2;
+    int x1, y1i, x2, y2;
 
     while (entryPtr != tvPtr->rootPtr) {
 	entryPtr = Blt_TreeViewParentEntry(entryPtr);
@@ -4042,24 +4043,24 @@
 		tvPtr->button.height);
 	y += (height - tvPtr->button.height) / 2;
 	x1 = x2 = x + ICONWIDTH(level) + ICONWIDTH(level + 1) / 2;
-	y1 = y + tvPtr->button.height / 2;
-	y2 = y1 + entryPtr->vertLineLength;
+	y1i = y + tvPtr->button.height / 2;
+	y2 = y1i + entryPtr->vertLineLength;
 	if ((entryPtr == tvPtr->rootPtr) && (tvPtr->flags & TV_HIDE_ROOT)) {
-	    y1 += entryPtr->height;
+	    y1i += entryPtr->height;
 	}
 	/*
 	 * Clip the line's Y-coordinates at the viewport borders.
 	 */
-	if (y1 < 0) {
-	    y1 = (y1 & 0x1);	/* Make sure the dotted line starts on 
+	if (y1i < 0) {
+	    y1i = (y1i & 0x1);	/* Make sure the dotted line starts on 
 				 * the same even/odd pixel. */
 	}
 	if (y2 > Tk_Height(tvPtr->tkwin)) {
 	    y2 = Tk_Height(tvPtr->tkwin);
 	}
-	if ((y1 < Tk_Height(tvPtr->tkwin)) && (y2 > 0)) {
+	if ((y1i < Tk_Height(tvPtr->tkwin)) && (y2 > 0)) {
 	    XDrawLine(tvPtr->display, drawable, tvPtr->lineGC, 
-	      x1, y1, x2, y2);
+	      x1, y1i, x2, y2);
 	}
     }
 }
@@ -4071,14 +4072,14 @@
     TreeViewColumn *columnPtr,
     Drawable drawable)		/* Pixmap or window to draw into. */
 {
-    int x, y1, y2;
+    int x, y1i, y2;
 
     x = SCREENX(tvPtr, columnPtr->worldX) + 
 	columnPtr->width + tvPtr->ruleMark - tvPtr->ruleAnchor - 1;
 
-    y1 = tvPtr->titleHeight + tvPtr->inset;
+    y1i = tvPtr->titleHeight + tvPtr->inset;
     y2 = Tk_Height(tvPtr->tkwin) - tvPtr->inset;
-    XDrawLine(tvPtr->display, drawable, columnPtr->ruleGC, x, y1, x, y2);
+    XDrawLine(tvPtr->display, drawable, columnPtr->ruleGC, x, y1i, x, y2);
     tvPtr->flags = TOGGLE(tvPtr->flags, TV_RULE_ACTIVE);
 }
 
@@ -4526,7 +4527,7 @@
     int level;
     int width, height;
     int x, y;
-    int x1, y1, x2, y2;
+    int x1, y1i, x2, y2;
 
     entryPtr->flags &= ~ENTRY_REDRAW;
 
@@ -4544,7 +4545,7 @@
     buttonY = y + entryPtr->buttonY;
 
     x1 = x + (width / 2);
-    y1 = y2 = buttonY + (buttonPtr->height / 2);
+    y1i = y2 = buttonY + (buttonPtr->height / 2);
     x2 = x1 + (ICONWIDTH(level) + ICONWIDTH(level + 1)) / 2;
 
     if ((Blt_TreeNodeParent(entryPtr->node) != NULL) && 
@@ -4553,17 +4554,17 @@
 	 * For every node except root, draw a horizontal line from
 	 * the vertical bar to the middle of the icon.
 	 */
-	XDrawLine(tvPtr->display, drawable, tvPtr->lineGC, x1, y1, x2, y2);
+	XDrawLine(tvPtr->display, drawable, tvPtr->lineGC, x1, y1i, x2, y2);
     }
     if (((entryPtr->flags & ENTRY_CLOSED) == 0) && (tvPtr->lineWidth > 0)) {
 	/*
 	 * Entry is open, draw vertical line.
 	 */
-	y2 = y1 + entryPtr->vertLineLength;
+	y2 = y1i + entryPtr->vertLineLength;
 	if (y2 > Tk_Height(tvPtr->tkwin)) {
 	    y2 = Tk_Height(tvPtr->tkwin); /* Clip line at window border. */
 	}
-	XDrawLine(tvPtr->display, drawable, tvPtr->lineGC, x2, y1, x2, y2);
+	XDrawLine(tvPtr->display, drawable, tvPtr->lineGC, x2, y1i, x2, y2);
     }
     if ((entryPtr->flags & ENTRY_HAS_BUTTON) && (entryPtr != tvPtr->rootPtr)) {
 	/*
@@ -4631,6 +4632,9 @@
     int width;
     int x0, cx, xOffset;
 
+    if (tvPtr->titleHeight < 1) {
+	return;
+    }
     columnWidth = columnPtr->width;
     cx = x;
     if (columnPtr->position == Blt_ChainGetLength(tvPtr->colChainPtr)) {
diff -uNr blt2.4z.orig/src/bltTreeViewEdit.c blt2.4z/src/bltTreeViewEdit.c
--- blt2.4z.orig/src/bltTreeViewEdit.c	2002-09-14 16:07:43.000000000 -0400
+++ blt2.4z/src/bltTreeViewEdit.c	2013-07-15 11:15:51.000000000 -0400
@@ -1177,9 +1177,15 @@
 	rightPos = count;
 	if ((rightPos < tbPtr->selFirst) || (leftPos > tbPtr->selLast)) {
 	    /* No part of the text fragment is selected. */
+#ifdef TK_DRAWCHARS_ANGLE
+	    Tk_DrawChars(tbPtr->display, drawable, tbPtr->gc, 
+			 tbPtr->font, fragPtr->text, fragPtr->count, 
+			 x + fragPtr->x, y + fragPtr->y, 0.);
+#else
 	    Tk_DrawChars(tbPtr->display, drawable, tbPtr->gc, 
 			 tbPtr->font, fragPtr->text, fragPtr->count, 
 			 x + fragPtr->x, y + fragPtr->y);
+#endif
 	    continue;
 	}
 
@@ -1221,9 +1227,15 @@
 	        width, fontMetrics.linespace,
 		tbPtr->selBorderWidth, tbPtr->selRelief);
 	}
+#ifdef TK_DRAWCHARS_ANGLE
+	Tk_DrawChars(Tk_Display(tbPtr->tkwin), drawable, tbPtr->gc, 
+	     tbPtr->font, fragPtr->text, fragPtr->count, 
+		     fragPtr->x + x, fragPtr->y + y, 0.);
+#else
 	Tk_DrawChars(Tk_Display(tbPtr->tkwin), drawable, tbPtr->gc, 
 	     tbPtr->font, fragPtr->text, fragPtr->count, 
 	     fragPtr->x + x, fragPtr->y + y);
+#endif
     }
     if ((tbPtr->flags & TEXTBOX_FOCUS) && (tbPtr->cursorOn)) {
 	int left, top, right, bottom;
diff -uNr blt2.4z.orig/src/bltTreeViewStyle.c blt2.4z/src/bltTreeViewStyle.c
--- blt2.4z.orig/src/bltTreeViewStyle.c	2002-07-22 18:18:40.000000000 -0400
+++ blt2.4z/src/bltTreeViewStyle.c	2013-07-15 11:15:51.000000000 -0400
@@ -846,6 +846,11 @@
  *----------------------------------------------------------------------
  */
 /*ARGSUSED*/
+
+int
+Blt_TreeViewTextbox(TreeView *tvPtr,
+		    TreeViewEntry *entryPtr,
+		    TreeViewColumn *columnPtr);
 static int
 EditTextBox(tvPtr, entryPtr, valuePtr, stylePtr)
     TreeView *tvPtr;
diff -uNr blt2.4z.orig/src/bltUnixDnd.c blt2.4z/src/bltUnixDnd.c
--- blt2.4z.orig/src/bltUnixDnd.c	2002-07-13 20:08:56.000000000 -0400
+++ blt2.4z/src/bltUnixDnd.c	2013-07-15 11:15:51.000000000 -0400
@@ -1834,7 +1834,7 @@
     unsigned long gcMask;
 
     Tk_MakeWindowExist(tokenPtr->tkwin);
-    if (Tk_ConfigureWidget(interp, tokenPtr->tkwin, tokenConfigSpecs, argc, 
+    if (Blt_ConfigureWidget(interp, tokenPtr->tkwin, tokenConfigSpecs, argc, 
 		argv, (char *)tokenPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -3777,7 +3777,7 @@
 	return Tk_ConfigureInfo(interp, dndPtr->tkwin, configSpecs,
 	    (char *)dndPtr, argv[3], flags);
     } 
-    if (Tk_ConfigureWidget(interp, dndPtr->tkwin, configSpecs, argc - 3,
+    if (Blt_ConfigureWidget(interp, dndPtr->tkwin, configSpecs, argc - 3,
 		   argv + 3, (char *)dndPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -4440,7 +4440,7 @@
     dndPtr->hashPtr = hPtr;
     dndPtr->dataPtr = dataPtr;
     Blt_SetHashValue(hPtr, dndPtr);
-    if (Tk_ConfigureWidget(interp, dndPtr->tkwin, configSpecs, argc - 3,
+    if (Blt_ConfigureWidget(interp, dndPtr->tkwin, configSpecs, argc - 3,
 	   argv + 3, (char *)dndPtr, 0) != TCL_OK) {
 	return TCL_ERROR;
     }
diff -uNr blt2.4z.orig/src/bltUnixImage.c blt2.4z/src/bltUnixImage.c
--- blt2.4z.orig/src/bltUnixImage.c	2002-08-16 00:15:04.000000000 -0400
+++ blt2.4z/src/bltUnixImage.c	2013-07-15 11:15:51.000000000 -0400
@@ -574,7 +574,7 @@
 	destPtr = Blt_ColorImageBits(image);
 	endPtr = destPtr + nPixels;
 	for (/* empty */; destPtr < endPtr; destPtr++) {
-	    hPtr = Blt_FindHashEntry(&pixelTable, (char *)destPtr->value);
+	    hPtr = Blt_FindHashEntry(&pixelTable, (char *)(uintptr_t)destPtr->value);
 	    colorPtr = (XColor *)Blt_GetHashValue(hPtr);
 	    destPtr->Red = lut[colorPtr->red >> 8];
 	    destPtr->Green = lut[colorPtr->green >> 8];
diff -uNr blt2.4z.orig/src/bltUnixPipe.c blt2.4z/src/bltUnixPipe.c
--- blt2.4z.orig/src/bltUnixPipe.c	2002-06-22 15:21:05.000000000 -0400
+++ blt2.4z/src/bltUnixPipe.c	2013-07-15 11:15:51.000000000 -0400
@@ -477,7 +477,7 @@
 	 * Reap the child process now if an error occurred during its
 	 * startup.
 	 */
-	Tcl_WaitPid((Tcl_Pid)pid, &status, WNOHANG);
+	Tcl_WaitPid((Tcl_Pid)(uintptr_t)pid, &status, WNOHANG);
     }
     if (errPipeIn >= 0) {
 	CloseFile(errPipeIn);
diff -uNr blt2.4z.orig/src/bltUtil.c blt2.4z/src/bltUtil.c
--- blt2.4z.orig/src/bltUtil.c	2002-08-21 16:13:12.000000000 -0400
+++ blt2.4z/src/bltUtil.c	2013-07-15 11:15:51.000000000 -0400
@@ -793,10 +793,10 @@
     if (isNew) {
 	refCount = 0;
     } else {
-	refCount = (int)Blt_GetHashValue(hPtr);
+	refCount = (int)(uintptr_t)Blt_GetHashValue(hPtr);
     }
     refCount++;
-    Blt_SetHashValue(hPtr, (ClientData)refCount);
+    Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)refCount);
     return (Blt_Uid)Blt_GetHashKey(&uidTable, hPtr);
 }
 
@@ -830,12 +830,12 @@
     if (hPtr) {
 	int refCount;
 
-	refCount = (int)Blt_GetHashValue(hPtr);
+	refCount = (int)(uintptr_t)Blt_GetHashValue(hPtr);
 	refCount--;
 	if (refCount == 0) {
 	    Blt_DeleteHashEntry(&uidTable, hPtr);
 	} else {
-	    Blt_SetHashValue(hPtr, (ClientData)refCount);
+	    Blt_SetHashValue(hPtr, (ClientData)(uintptr_t)refCount);
 	}
     } else {
 	fprintf(stderr, "tried to release unknown identifier \"%s\"\n", uid);
diff -uNr blt2.4z.orig/src/bltVecMath.c blt2.4z/src/bltVecMath.c
--- blt2.4z.orig/src/bltVecMath.c	2002-09-10 01:12:33.000000000 -0400
+++ blt2.4z/src/bltVecMath.c	2013-07-15 11:15:51.000000000 -0400
@@ -28,6 +28,12 @@
 
 #include "bltVecInt.h"
 
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
+#define Tcl_GetStringResult(x) x->result
+#define Tcl_GetErrorLine(x) x->errorLine
+#define Tcl_SetResult(x, y, z) x->result = y
+#endif
+
 /*
  * Three types of math functions:
  *
@@ -764,20 +770,20 @@
     if ((errno == EDOM) || (value != value)) {
 	Tcl_AppendResult(interp, "domain error: argument not in valid range",
 	    (char *)NULL);
-	Tcl_SetErrorCode(interp, "ARITH", "DOMAIN", interp->result,
+	Tcl_SetErrorCode(interp, "ARITH", "DOMAIN", Tcl_GetStringResult(interp),
 	    (char *)NULL);
     } else if ((errno == ERANGE) || IS_INF(value)) {
 	if (value == 0.0) {
 	    Tcl_AppendResult(interp, 
 			     "floating-point value too small to represent",
 		(char *)NULL);
-	    Tcl_SetErrorCode(interp, "ARITH", "UNDERFLOW", interp->result,
+	    Tcl_SetErrorCode(interp, "ARITH", "UNDERFLOW", Tcl_GetStringResult(interp),
 		(char *)NULL);
 	} else {
 	    Tcl_AppendResult(interp, 
 			     "floating-point value too large to represent",
 		(char *)NULL);
-	    Tcl_SetErrorCode(interp, "ARITH", "OVERFLOW", interp->result,
+	    Tcl_SetErrorCode(interp, "ARITH", "OVERFLOW", Tcl_GetStringResult(interp),
 		(char *)NULL);
 	}
     } else {
@@ -786,7 +792,7 @@
 	sprintf(buf, "%d", errno);
 	Tcl_AppendResult(interp, "unknown floating-point error, ",
 	    "errno = ", buf, (char *)NULL);
-	Tcl_SetErrorCode(interp, "ARITH", "UNKNOWN", interp->result,
+	Tcl_SetErrorCode(interp, "ARITH", "UNKNOWN", Tcl_GetStringResult(interp),
 	    (char *)NULL);
     }
 }
diff -uNr blt2.4z.orig/src/bltWinDraw.c blt2.4z/src/bltWinDraw.c
--- blt2.4z.orig/src/bltWinDraw.c	2002-09-07 16:38:08.000000000 -0400
+++ blt2.4z/src/bltWinDraw.c	2013-07-15 11:15:51.000000000 -0400
@@ -1647,8 +1647,13 @@
     if (drawable == None) {
 	return;
     }
+#ifdef TK_DRAWCHARS_ANGLE
+    Tk_DrawChars(display, drawable, gc, (Tk_Font)gc->font, string, length, 
+		 x, y, 0.);
+#else
     Tk_DrawChars(display, drawable, gc, (Tk_Font)gc->font, string, length, 
 	x, y);
+#endif
 }
 
 static void
diff -uNr blt2.4z.orig/src/bltWindow.c blt2.4z/src/bltWindow.c
--- blt2.4z.orig/src/bltWindow.c	2002-09-18 23:02:09.000000000 -0400
+++ blt2.4z/src/bltWindow.c	2013-07-15 11:15:51.000000000 -0400
@@ -89,9 +89,9 @@
 
 typedef struct TkDisplayStruct {
     Display *display;		/* Xlib's info about display. */
-    struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
-    char *name;			/* Name of display (with any screen
-				 * identifier removed).  Malloc-ed. */
+    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
+    char *name;			/* Name of display (with any screen identifier
+				 * removed). Malloc-ed. */
     Time lastEventTime;		/* Time of last event received for this
 				 * display. */
 
@@ -107,8 +107,8 @@
      * Information used by tkAtom.c only:
      */
 
-    int atomInit;		/* 0 means stuff below hasn't been
-				 * initialized yet. */
+    int atomInit;		/* 0 means stuff below hasn't been initialized
+				 * yet. */
     Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
     Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
 
@@ -116,27 +116,26 @@
      * Information used primarily by tkBind.c:
      */
 
-    int bindInfoStale;		/* Non-zero means the variables in this
-				 * part of the structure are potentially
-				 * incorrect and should be recomputed. */
+    int bindInfoStale;		/* Non-zero means the variables in this part
+				 * of the structure are potentially incorrect
+				 * and should be recomputed. */
     unsigned int modeModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to "mode shift".  If no
-				 * such modifier, than this is zero. */
+				 * corresponding to "mode shift". If no such
+				 * modifier, than this is zero. */
     unsigned int metaModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
     unsigned int altModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    enum {
-	LU_IGNORE, LU_CAPS, LU_SHIFT
-    } lockUsage;		/* Indicates how to interpret lock modifier. */
+				 * corresponding to the "Meta" key. If no such
+				 * modifier, then this is zero. */
+    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
+				/* Indicates how to interpret lock
+				 * modifier. */
     int numModKeyCodes;		/* Number of entries in modKeyCodes array
 				 * below. */
-    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
-				 * all of the keys that have modifiers
-				 * associated with them.  Malloc'ed, but
-				 * may be NULL. */
+    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
+				 * of the keys that have modifiers associated
+				 * with them. Malloc'ed, but may be NULL. */
 
     /*
      * Information used by tkBitmap.c only:
@@ -150,10 +149,10 @@
     Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
 				 * structure for the bitmap. */
     Tcl_HashTable bitmapDataTable;
-				/* Used by Tk_GetBitmapFromData to map from
-				 * a collection of in-core data about a
-				 * bitmap to a reference giving an auto-
-				 * matically-generated name for the bitmap. */
+				/* Used by Tk_GetBitmapFromData to map from a
+				 * collection of in-core data about a bitmap
+				 * to a reference giving an automatically-
+				 * generated name for the bitmap. */
 
     /*
      * Information used by tkCanvas.c only:
@@ -167,9 +166,9 @@
      */
 
     int colorInit;		/* 0 means color module needs initializing. */
-    TkStressedCmap *stressPtr;	/* First in list of colormaps that have
-				 * filled up, so we have to pick an
-				 * approximate color. */
+    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
+				 * up, so we have to pick an approximate
+				 * color. */
     Tcl_HashTable colorNameTable;
 				/* Maps from color name to TkColor structure
 				 * for that color. */
@@ -192,34 +191,33 @@
 				/* Maps from a cursor id to the TkCursor
 				 * structure for the cursor. */
     char cursorString[20];	/* Used to store a cursor id string. */
-    Font cursorFont;		/* Font to use for standard cursors.
-				 * None means font not loaded yet. */
+    Font cursorFont;		/* Font to use for standard cursors. None
+				 * means font not loaded yet. */
 
     /*
      * Information used by tkError.c only:
      */
 
     struct TkErrorHandler *errorPtr;
-				/* First in list of error handlers
-				 * for this display.  NULL means
-				 * no handlers exist at present. */
-    int deleteCount;		/* Counts # of handlers deleted since
-				 * last time inactive handlers were
-				 * garbage-collected.  When this number
-				 * gets big, handlers get cleaned up. */
+				/* First in list of error handlers for this
+				 * display. NULL means no handlers exist at
+				 * present. */
+    int deleteCount;		/* Counts # of handlers deleted since last
+				 * time inactive handlers were garbage-
+				 * collected. When this number gets big,
+				 * handlers get cleaned up. */
 
     /*
      * Used by tkEvent.c only:
      */
 
     struct TkWindowEvent *delayedMotionPtr;
-				/* Points to a malloc-ed motion event
-				 * whose processing has been delayed in
-				 * the hopes that another motion event
-				 * will come along right away and we can
-				 * merge the two of them together.  NULL
-				 * means that there is no delayed motion
-				 * event. */
+				/* Points to a malloc-ed motion event whose
+				 * processing has been delayed in the hopes
+				 * that another motion event will come along
+				 * right away and we can merge the two of them
+				 * together. NULL means that there is no
+				 * delayed motion event. */
 
     /*
      * Information used by tkFocus.c only:
@@ -229,26 +227,24 @@
 				 * statistics. */
     struct TkWindow *implicitWinPtr;
 				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
+				 * implicitly via an Enter event (rather than
+				 * via a FocusIn event), this points to the
+				 * toplevel window. Otherwise it is NULL. */
     struct TkWindow *focusPtr;	/* Points to the window on this display that
-				 * should be receiving keyboard events.  When
+				 * should be receiving keyboard events. When
 				 * multiple applications on the display have
-				 * the focus, this will refer to the
-				 * innermost window in the innermost
-				 * application.  This information isn't used
-				 * under Unix or Windows, but it's needed on
-				 * the Macintosh. */
+				 * the focus, this will refer to the innermost
+				 * window in the innermost application. This
+				 * information isn't used under Unix or
+				 * Windows, but it's needed on the Mac. */
 
     /*
      * Information used by tkGC.c only:
      */
 
-    Tcl_HashTable gcValueTable;	/* Maps from a GC's values to a TkGC structure
+    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
 				 * describing a GC with those values. */
-    Tcl_HashTable gcIdTable;	/* Maps from a GC to a TkGC. */
+    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
     int gcInit;			/* 0 means the tables below need
 				 * initializing. */
 
@@ -258,23 +254,22 @@
 
     Tcl_HashTable maintainHashTable;
 				/* Hash table that maps from a master's
-				 * Tk_Window token to a list of slaves
-				 * managed by that master. */
+				 * Tk_Window token to a list of slaves managed
+				 * by that master. */
     int geomInit;
 
     /*
      * Information used by tkGet.c only:
      */
 
-    Tcl_HashTable uidTable;	/* Stores all Tk_Uids used in a thread. */
+    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
     int uidInit;		/* 0 means uidTable needs initializing. */
 
     /*
      * Information used by tkGrab.c only:
      */
 
-    struct TkWindow *grabWinPtr;
-				/* Window in which the pointer is currently
+    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
 				 * grabbed, or NULL if none. */
     struct TkWindow *eventualGrabWinPtr;
 				/* Value that grabWinPtr will have once the
@@ -286,22 +281,22 @@
 				 * if no such press in effect. */
     struct TkWindow *serverWinPtr;
 				/* If no application contains the pointer then
-				 * this is NULL.  Otherwise it contains the
-				 * last window for which we've gotten an
-				 * Enter or Leave event from the server (i.e.
-				 * the last window known to have contained
-				 * the pointer).  Doesn't reflect events
-				 * that were synthesized in tkGrab.c. */
+				 * this is NULL. Otherwise it contains the
+				 * last window for which we've gotten an Enter
+				 * or Leave event from the server (i.e. the
+				 * last window known to have contained the
+				 * pointer). Doesn't reflect events that were
+				 * synthesized in tkGrab.c. */
     TkGrabEvent *firstGrabEventPtr;
 				/* First in list of enter/leave events
-				 * synthesized by grab code.  These events
-				 * must be processed in order before any other
-				 * events are processed.  NULL means no such
+				 * synthesized by grab code. These events must
+				 * be processed in order before any other
+				 * events are processed. NULL means no such
 				 * events. */
     TkGrabEvent *lastGrabEventPtr;
 				/* Last in list of synthesized events, or NULL
 				 * if list is empty. */
-    int grabFlags;		/* Miscellaneous flag values.  See definitions
+    int grabFlags;		/* Miscellaneous flag values. See definitions
 				 * in tkGrab.c. */
 
     /*
@@ -309,8 +304,8 @@
      */
 
     int gridInit;		/* 0 means table below needs initializing. */
-    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to
-				 * corresponding Grid structures. */
+    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
+				 * Grid structures. */
 
     /*
      * Information used by tkImage.c only:
@@ -328,17 +323,14 @@
      * Information used by tkOption.c only.
      */
 
-
-
     /*
      * Information used by tkPack.c only.
      */
 
     int packInit;		/* 0 means table below needs initializing. */
     Tcl_HashTable packerHashTable;
-				/* Maps from Tk_Window tokens to
-				 * corresponding Packer structures. */
-
+				/* Maps from Tk_Window tokens to corresponding
+				 * Packer structures. */
 
     /*
      * Information used by tkPlace.c only.
@@ -354,14 +346,13 @@
      * Information used by tkSelect.c and tkClipboard.c only:
      */
 
-
     struct TkSelectionInfo *selectionInfoPtr;
-    /* First in list of selection information
-				 * records.  Each entry contains information
+				/* First in list of selection information
+				 * records. Each entry contains information
 				 * about the current owner of a particular
 				 * selection on this display. */
-    Atom multipleAtom;		/* Atom for MULTIPLE.  None means
-				 * selection stuff isn't initialized. */
+    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
+				 * stuff isn't initialized. */
     Atom incrAtom;		/* Atom for INCR. */
     Atom targetsAtom;		/* Atom for TARGETS. */
     Atom timestampAtom;		/* Atom for TIMESTAMP. */
@@ -370,9 +361,8 @@
     Atom applicationAtom;	/* Atom for TK_APPLICATION. */
     Atom windowAtom;		/* Atom for TK_WINDOW. */
     Atom clipboardAtom;		/* Atom for CLIPBOARD. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
-    Atom utf8Atom;
-#endif
+    Atom utf8Atom;		/* Atom for UTF8_STRING. */
+
     Tk_Window clipWindow;	/* Window used for clipboard ownership and to
 				 * retrieve selections between processes. NULL
 				 * means clipboard info hasn't been
@@ -383,7 +373,7 @@
 				/* Last application that owned clipboard. */
     struct TkClipboardTarget *clipTargetPtr;
 				/* First in list of clipboard type information
-				 * records.  Each entry contains information
+				 * records. Each entry contains information
 				 * about the buffers for a given selection
 				 * target. */
 
@@ -391,13 +381,13 @@
      * Information used by tkSend.c only:
      */
 
-    Tk_Window commTkwin;	/* Window used for communication
-				 * between interpreters during "send"
-				 * commands.  NULL means send info hasn't
-				 * been initialized yet. */
+    Tk_Window commTkwin;	/* Window used for communication between
+				 * interpreters during "send" commands. NULL
+				 * means send info hasn't been initialized
+				 * yet. */
     Atom commProperty;		/* X's name for comm property. */
-    Atom registryProperty;	/* X's name for property containing
-				 * registry of interpreter names. */
+    Atom registryProperty;	/* X's name for property containing registry
+				 * of interpreter names. */
     Atom appNameProperty;	/* X's name for property used to hold the
 				 * application name on each comm window. */
 
@@ -409,34 +399,21 @@
 				/* First in list of chunks of free resource
 				 * identifiers, or NULL if there are no free
 				 * resources. */
-    XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
+    XID (*defaultAllocProc) (Display *display);
 				/* Default resource allocator for display. */
     struct TkIdStack *windowStackPtr;
-				/* First in list of chunks of window
-				 * identifers that can't be reused right
-				 * now. */
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
-				 * already been scheduled, 0 means it
-				 * hasn't. */
-#else
+				/* First in list of chunks of window ids that
+				 * can't be reused right now. */
     Tcl_TimerToken idCleanupScheduled;
 				/* If set, it means a call to WindowIdCleanup
 				 * has already been scheduled, 0 means it
 				 * hasn't. */
-#endif
+
     /*
      * Information used by tkUnixWm.c and tkWinWm.c only:
      */
 
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int wmTracing;		/* Used to enable or disable tracing in
-				 * this module.  If tracing is enabled,
-				 * then information is printed on
-				 * standard output about interesting
-				 * interactions with the window manager. */
-#endif
-    struct TkWmInfo *firstWmPtr; /* Points to first top-level window. */
+    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
     struct TkWmInfo *foregroundWmPtr;
 				/* Points to the foreground window. */
 
@@ -444,9 +421,8 @@
      * Information maintained by tkWindow.c for use later on by tkXId.c:
      */
 
-
-    int destroyCount;		/* Number of Tk_DestroyWindow operations
-				 * in progress. */
+    int destroyCount;		/* Number of Tk_DestroyWindow operations in
+				 * progress. */
     unsigned long lastDestroyRequest;
 				/* Id of most recent XDestroyWindow request;
 				 * can re-use ids in windowStackPtr when
@@ -465,42 +441,41 @@
      */
 
 #ifdef TK_USE_INPUT_METHODS
-    XIM inputMethod;		/* Input method for this display */
-#if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
-#if TK_XIM_SPOT
+    XIM inputMethod;		/* Input method for this display. */
+    XIMStyle inputStyle;	/* Input style selected for this display. */
     XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
-#endif /* TK_XIM_SPOT */
-#endif /* TK_VERSION_NUMBER >= 8.4 */
 #endif /* TK_USE_INPUT_METHODS */
     Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
+
     int refCount;		/* Reference count of how many Tk applications
-                                 * are using this display. Used to clean up
-                                 * the display when we no longer have any
-                                 * Tk applications using it.
-                                 */
+				 * are using this display. Used to clean up
+				 * the display when we no longer have any Tk
+				 * applications using it. */
+
     /*
      * The following field were all added for Tk8.3
      */
-    int mouseButtonState;       /* current mouse button state for this
-                                 * display */
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int warpInProgress;
-#endif
+
+    int mouseButtonState;	/* Current mouse button state for this
+				 * display. */
+    Window mouseButtonWindow;	/* Window the button state was set in, added
+				 * in Tk 8.4. */
     Window warpWindow;
     int warpX;
     int warpY;
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int useInputMethods;        /* Whether to use input methods */
-#else
+
     /*
      * The following field(s) were all added for Tk8.4
      */
-    long deletionEpoch;		/* Incremented by window deletions */
-    unsigned int flags;		/* Various flag values:  these are all
-				 * defined in below. */
-    TkCaret caret;		/* information about the caret for this
-				 * display.  This is not a pointer. */
-#endif
+
+    unsigned int flags;		/* Various flag values: these are all defined
+				 * in below. */
+    TkCaret caret;		/* Information about the caret for this
+				 * display. This is not a pointer. */
+
+    int iconDataSize;		/* Size of default iconphoto image data. */
+    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
+
 } TkDisplay;
 
 #else
diff -uNr blt2.4z.orig/src/shared/Makefile.in blt2.4z/src/shared/Makefile.in
--- blt2.4z.orig/src/shared/Makefile.in	2002-05-14 17:37:19.000000000 -0400
+++ blt2.4z/src/shared/Makefile.in	2013-07-15 11:15:51.000000000 -0400
@@ -120,8 +120,8 @@
 LN_S =		@LN_S@
 bltwish =	bltwish$(version)
 bltsh =		bltsh$(version)
-lib_so =	libBLT$(version)$(SHLIB_SUFFIX)
-tcl_only_lib_so = libBLTlite$(version)$(SHLIB_SUFFIX)
+lib_so =	libBLT.2$(SHLIB_SUFFIX)
+tcl_only_lib_so = libBLTlite.2$(SHLIB_SUFFIX)
 
 all: build_lib build_demo
 
@@ -144,19 +144,19 @@
 	$(CC) -c $(CC_SWITCHES) -DBLT_LIBRARY=\"$(scriptdir)\" \
 		$(srcdir)/bltInit.c
 	$(RM) $@
-	$(SHLIB_LD) $(SHLIB_LD_FLAGS) -o $@ bltInit.o $(OBJS) \
-		$(SHLIB_LIB_SPECS)
+	$(SHLIB_LD) $(SHLIB_LD_FLAGS) -o $@ -install_name $(libdir)/$@ -compatibility_version 2.0 -current_version 2.4 bltInit.o $(OBJS) \
+		$(SHLIB_LIB_SPECS) $(LIBS)
 
 $(tcl_only_lib_so): $(TCL_ONLY_OBJS)
 	$(CC) -c $(CC_SWITCHES) -DTCL_ONLY -DBLT_LIBRARY=\"$(scriptdir)\" \
 		$(srcdir)/bltInit.c
 	$(RM) $@
-	$(SHLIB_LD) $(SHLIB_LD_FLAGS) -o $@ bltInit.o $(TCL_ONLY_OBJS) \
-		$(SHLIB_TCL_ONLY_LIB_SPECS)
+	$(SHLIB_LD) $(SHLIB_LD_FLAGS) -o $@ -install_name $(libdir)/$@ -compatibility_version 2.0 -current_version 2.4 bltInit.o $(TCL_ONLY_OBJS) \
+		$(SHLIB_TCL_ONLY_LIB_SPECS) $(TCL_ONLY_LIB_SPECS)
 
 install: mkdirs install-lib install-demo
 
-install-demo: $(bltwish)
+install-demo: $(bltwish) $(bltsh)
 	$(INSTALL) -m 0755 bltwish$(version) $(INSTALL_ROOT)$(bindir)
 	$(INSTALL) -m 0755 bltsh$(version) $(INSTALL_ROOT)$(bindir)
 
@@ -175,10 +175,10 @@
         done
 clean:
 	$(RM) $(OBJS) $(lib_so) $(tcl_only_lib_so) $(bltwish) $(bltsh) \
-		*pure* .pure* 
+		*pure* .pure* bltInit.o
 
 distclean: clean
-	$(RM) $(srcdir)/*.bak $(srcdir)/*\~ $(srcdir)/"#"* 
+	$(RM) Makefile $(srcdir)/*.bak $(srcdir)/*\~ $(srcdir)/"#"* 
 
 # ------------------------------------------------------------------------
 # 	in lieu of viewpath-ing...
diff -uNr blt2.4z.orig/src/tkButton.c blt2.4z/src/tkButton.c
--- blt2.4z.orig/src/tkButton.c	2002-09-23 03:19:01.000000000 -0400
+++ blt2.4z/src/tkButton.c	2013-07-15 11:18:47.000000000 -0400
@@ -526,7 +526,9 @@
 static Blt_TileChangedProc TileChangedProc;
 static Tcl_CmdProc ButtonCmd, LabelCmd, CheckbuttonCmd, RadiobuttonCmd;
 
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
 EXTERN int TkCopyAndGlobalEval _ANSI_ARGS_((Tcl_Interp *interp, char *script));
+#endif
 
 #if (TK_MAJOR_VERSION > 4)
 EXTERN void TkComputeAnchor _ANSI_ARGS_((Tk_Anchor anchor, Tk_Window tkwin, 
@@ -1104,7 +1106,7 @@
 	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
 	    ButtonVarProc, (ClientData)butPtr);
     }
-    if (Tk_ConfigureWidget(interp, butPtr->tkwin, configSpecs,
+    if (Blt_ConfigureWidget(interp, butPtr->tkwin, configSpecs,
 	    argc, argv, (char *)butPtr, flags) != TCL_OK) {
 	return TCL_ERROR;
     }
@@ -1890,7 +1892,11 @@
 	}
     }
     if ((butPtr->type != TYPE_LABEL) && (butPtr->command != NULL)) {
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
 	return TkCopyAndGlobalEval(butPtr->interp, butPtr->command);
+#else
+	return Tcl_EvalObjEx(butPtr->interp, butPtr->command, TCL_EVAL_GLOBAL);
+#endif
     }
     return TCL_OK;
 }
diff -uNr blt2.4z.orig/src/tkScrollbar.c blt2.4z/src/tkScrollbar.c
--- blt2.4z.orig/src/tkScrollbar.c	2002-05-16 16:46:01.000000000 -0400
+++ blt2.4z/src/tkScrollbar.c	2013-07-15 11:15:51.000000000 -0400
@@ -22,6 +22,12 @@
 
 #include "bltTile.h"
 
+#if TCL_MAJOR_VERSION <=8 && TCL_MINOR_VERSION < 6
+#define Tcl_GetStringResult(x) x->result
+#define Tcl_GetErrorLine(x) x->errorLine
+#define Tcl_SetResult(x, y, z) x->result = y
+#endif
+
 extern Tk_CustomOption bltTileOption;
 
 #define NORMAL_BG	"#d9d9d9"
@@ -533,7 +539,7 @@
 	} else {
 	    fraction = ((double)pixels / (double)barWidth);
 	}
-	sprintf(interp->result, "%g", fraction);
+	sprintf(Tcl_GetStringResult(interp), "%g", fraction);
     } else if ((c == 'f') && (strncmp(argv[1], "fraction", length) == 0)) {
 	int x, y, pos, barWidth;
 	double fraction;
diff -uNr blt2.4z.orig/win/makedefs blt2.4z/win/makedefs
--- blt2.4z.orig/win/makedefs	2002-10-16 01:33:53.000000000 -0400
+++ blt2.4z/win/makedefs	2013-07-15 11:15:51.000000000 -0400
@@ -3,33 +3,13 @@
 
 v1 = 8.4
 v2 = 84
-v3 = 8.4.0
-
-#v1 = 8.3
-#v2 = 83
-#v3 = 8.3.4
-
-#v1 = 8.3
-#v2 = 83
-#v3 = 8.3.2
-
-#v1 = 8.2
-#v2 = 82
-#v3 = 8.2.3
-
-#v1 = 8.1
-#v2 = 81
-#v3 = 8.1.1
-
-#v1 = 8.0
-#v2 = 80
-#v3 = 8.0.5
+v3 = 8.4.12
 
 #Use Independent JPEG Group (IJG) library or Intel JPEG Library (IJL)
 # 0 = None.
 # 1 = IJG
 # 2 = IJL
-WITH_JPEG=2
+WITH_JPEG=0
 
 # ------------------------------------------------------------------------
 #       You shouldn't need to edit anything beyond this point
@@ -39,7 +19,7 @@
 BLT_MINOR_VERSION = 	4
 BLT_VERSION =		2.4
 
-prefix =		C:/Program\ Files/Tcl
+prefix =		x:/target/staff/koen/install/tcltk8.4.12/WIN
 exec_prefix =		$(prefix)
 includedir =		$(prefix)/include
 bindir =		$(prefix)/bin
@@ -48,7 +28,7 @@
 BLT_LIBRARY =		$(libdir)/blt$(BLT_VERSION)
 TCLLIBPATH =		$(libdir)/tcl$(v1)
 
-AUX_LIBS = 
+AUX_LIBS =
 SHLIB_SUFFIX =		.dll
 
 INSTALL =		install -m 0755
