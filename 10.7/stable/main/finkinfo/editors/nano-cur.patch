diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/ChangeLog nano/ChangeLog
--- nano_2_3_1/ChangeLog	2011-12-18 22:20:12.000000000 +0100
+++ nano/ChangeLog	2013-01-10 19:47:33.000000000 +0100
@@ -0,0 +1,33 @@
+2013-01-02 Mike Frysinger <vapier@gentoo.org>
+        * configure.ac: Check for ncursesw5-config and base $CPPFLAGS based on it.
+
+2013-01-09 Fabian Groffen <grobian@Savannah>
+        * configure.ac, src/nano.h: Make search for ncursesw more generalized.
+
+2013-01-02 David Benjamin <davidben@Savannah>
+        * src/search.c (parse_syntax): Fix blatantly and dangerously incorrect  code for 
+          deleting old syntaxes.
+
+2013-01-02 Mike Frysinger <vapier@gentoo.org>
+        * src/files.c (cwd_tab_completion): Remove unnecessary variables
+        * src/search.c (search_init): Fix gcc complaints on certain versions
+
+2013-01-02 Eitan Adler <lists@eitanadler.com>
+        * configure.ac: Remove unnecessary checks
+        * src/nano.h, NEWS: Fix redundant wording
+
+2012-12-31 Chris Allegretta <chrisa@asty.org>
+        * src/*: Introduce (basic) vim-style file locks.  Does not allow vim to recover
+          our changes, and just lets a vim user know we're editing a file.  Commands line "-G" 
+          or "--locking", nanorc option "locking".  New functions 
+          src/files.c:do_lockfile(), write_lockfile(), and delete_lockfile().
+
+2012-02-05 Chris Allegretta <chrisa@asty.org>
+	* src/*: Fix overlapping strings highlighting each other.  new variables in edit_draw 
+	  (slmatcharray, pbegin, paintok), new logic (with repeated setting od values in the 
+	  array but its BFI after all).  FIXME: Need to create a new 'overlap'
+	* src/*: Fix a silly issue with the argument to nregcomp, as it's confusing to the caller
+	* src/nano.h: Change the color types to a compiler macro (COLORWIDTH), may not actually 
+	  even be worth doing, but someday who knows how wide a color curses implementation might 
+	  be, and maybe we'll even start checking for it in autoconf!
+
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/NEWS nano/NEWS
--- nano_2_3_1/NEWS	2011-12-18 22:20:12.000000000 +0100
+++ nano/NEWS	2013-01-10 19:47:33.000000000 +0100
@@ -748 +748 @@
-			Fixes are included included for justification,
+		Fixes are included for justification,
@@ -751 +751 @@
-		updated, and the the --quotestr and --regexp really work
+		updated, and the --quotestr and --regexp really work
@@ -1076 +1076 @@
-		a fix for the the nasty bug in -k mode that could create
+		a fix for the nasty bug in -k mode that could create
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/configure.ac nano/configure.ac
--- nano_2_3_1/configure.ac	2011-12-18 22:20:12.000000000 +0100
+++ nano/configure.ac	2013-01-10 19:47:33.000000000 +0100
@@ -23 +23 @@
-AC_INIT([GNU nano], [2.3.1], [nano-devel@gnu.org], [nano])
+AC_INIT([GNU nano], [2.3.1-svn], [nano-devel@gnu.org], [nano])
@@ -25 +25 @@
-AC_CANONICAL_TARGET([])
+AC_CANONICAL_HOST
@@ -52 +51,0 @@
-AC_HEADER_STDC
@@ -445 +444,10 @@
-	AC_CHECK_LIB(ncursesw, get_wch, [CURSES_LIB="-lncursesw" CPPFLAGS="-I/usr/include/ncursesw $CPPFLAGS" CURSES_LIB_NAME=ncursesw CURSES_LIB_WIDE=yes])
+	AC_CHECK_HEADERS(ncursesw/ncurses.h)
+        AC_CHECK_TOOL(NCURSESW_CONFIG, ncursesw5-config, no)
+        if test "x$NCURSESW_CONFIG" != xno; then
+            CURSES_LIB=`$NCURSESW_CONFIG --libs`
+            CPPFLAGS="`$NCURSESW_CONFIG --cflags` $CPPFLAGS"
+            CURSES_LIB_NAME=ncursesw
+            CURSES_LIB_WIDE=yes
+        else
+            AC_CHECK_LIB(ncursesw, get_wch, [CURSES_LIB="-lncursesw" CURSES_LIB_NAME=ncursesw CURSES_LIB_WIDE=yes])
+        fi
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/doc/man/nano.1 nano/doc/man/nano.1
--- nano_2_3_1/doc/man/nano.1	2011-12-18 22:20:10.000000000 +0100
+++ nano/doc/man/nano.1	2013-01-10 19:47:32.000000000 +0100
@@ -21 +21 @@
-.\" $Id: nano.1 4502 2010-04-14 21:55:39Z astyanax $
+.\" $Id: nano.1 4549 2013-01-01 03:24:39Z astyanax $
@@ -79,0 +80,3 @@
+.B \-G (\-\-locking)
+Enable vim-style file locking when editing files.
+.TP
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/doc/man/nanorc.5 nano/doc/man/nanorc.5
--- nano_2_3_1/doc/man/nanorc.5	2011-12-18 22:20:10.000000000 +0100
+++ nano/doc/man/nanorc.5	2013-01-10 19:47:32.000000000 +0100
@@ -21 +21 @@
-.\" $Id: nanorc.5 4533 2011-02-24 02:14:30Z astyanax $
+.\" $Id: nanorc.5 4549 2013-01-01 03:24:39Z astyanax $
@@ -104,0 +105,3 @@
+.B set/unset locking
+Enable vim-style lock-files for when editing files.
+.TP
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/doc/nanorc.sample.in nano/doc/nanorc.sample.in
--- nano_2_3_1/doc/nanorc.sample.in	2011-12-18 22:20:10.000000000 +0100
+++ nano/doc/nanorc.sample.in	2013-01-10 19:47:32.000000000 +0100
@@ -58,0 +59,5 @@
+## Enable vim-style lock-files.  This is just to let a vim user know you
+## are editing a file [s]he is trying to edit and vice versa. There are
+## no plans to implement vim-style undo state in these files
+# set locking
+
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/doc/syntax/nanorc.nanorc nano/doc/syntax/nanorc.nanorc
--- nano_2_3_1/doc/syntax/nanorc.nanorc	2011-12-18 22:20:10.000000000 +0100
+++ nano/doc/syntax/nanorc.nanorc	2013-01-10 19:47:32.000000000 +0100
@@ -7 +7 @@
-icolor brightgreen "^[[:space:]]*(set|unset)[[:space:]]+(allow_insecure_backup|autoindent|backup|backupdir|backwards|boldtext|brackets|casesensitive|const|cut|fill|historylog|matchbrackets|morespace|mouse|multibuffer|noconvert|nofollow|nohelp|nonewlines|nowrap|operatingdir|poslog|preserve|punct)\>" "^[[:space:]]*(set|unset)[[:space:]]+(quickblank|quotestr|rebinddelete|rebindkeypad|regexp|smarthome|smooth|softwrap|speller|suspend|suspendenable|tabsize|tabstospaces|tempfile|undo|view|whitespace|wordbounds)\>"
+icolor brightgreen "^[[:space:]]*(set|unset)[[:space:]]+(allow_insecure_backup|autoindent|backup|backupdir|backwards|boldtext|brackets|casesensitive|const|cut|fill|historylog|matchbrackets|morespace|mouse|multibuffer|noconvert|nofollow|nohelp|nonewlines|nowrap|operatingdir|poslog|preserve|punct)\>" "^[[:space:]]*(set|unset)[[:space:]]+(quickblank|quotestr|rebinddelete|rebindkeypad|regexp|smarthome|smooth|softwrap|speller|suspend|suspendenable|tabsize|tabstospaces|tempfile|undo|view|whitespace|wordbounds|locking)\>"
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/browser.c nano/src/browser.c
--- nano_2_3_1/src/browser.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/browser.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: browser.c 4527 2011-02-07 14:45:56Z astyanax $ */
+/* $Id: browser.c 4548 2012-12-30 19:20:10Z astyanax $ */
@@ -797 +797 @@
-	&meta_key, &func_key, 
+	&meta_key, &func_key,
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/chars.c nano/src/chars.c
--- nano_2_3_1/src/chars.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/chars.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: chars.c 4534 2011-02-24 02:47:25Z astyanax $ */
+/* $Id: chars.c 4555 2013-01-03 04:23:10Z astyanax $ */
@@ -82 +82 @@
-static void mbtowc_reset(void)
+void mbtowc_reset(void)
@@ -87 +87 @@
-static void wctomb_reset(void)
+void wctomb_reset(void)
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/files.c nano/src/files.c
--- nano_2_3_1/src/files.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/files.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: files.c 4534 2011-02-24 02:47:25Z astyanax $ */
+/* $Id: files.c 4558 2013-01-03 04:50:49Z astyanax $ */
@@ -33,0 +34 @@
+#include <libgen.h>
@@ -79,0 +81 @@
+    openfile->lock_filename = NULL;
@@ -105,0 +108,201 @@
+
+#ifndef NANO_TINY
+/* Actyally write the lock file.  This function will
+   ALWAYS annihilate any previous version of the file.
+   We'll borrow INSECURE_BACKUP here to decide about lock file
+   paranoia here as well...
+   Args:
+       lockfilename: file name for lock
+       origfilename: name of the file the lock is for
+       modified: whether to set the modified bit in the file
+
+   Returns: 1 on success, 0 on failure (but continue loading), -1 on failure and abort
+ */
+int write_lockfile(const char *lockfilename, const char *origfilename, bool modified)
+{
+    int cflags, fd;
+    FILE *filestream;
+    pid_t mypid;
+    uid_t myuid;
+    struct passwd *mypwuid;
+    char *lockdata = charalloc(1024);
+    char myhostname[32];
+    ssize_t lockdatalen = 1024;
+    ssize_t wroteamt;
+
+    /* Run things which might fail first before we try and blow away
+       the old state */
+    myuid = geteuid();
+    if ((mypwuid = getpwuid(myuid)) == NULL) {
+        statusbar(_("Couldn't determine my identity for lock file (getpwuid() failed)"));
+        return -1;
+    }
+    mypid = getpid();
+
+    if (gethostname(myhostname, 31) < 0) {
+       statusbar(_("Couldn't determine hosttname for lock file: %s"), strerror(errno));
+       return -1;
+    }
+
+    if (delete_lockfile(lockfilename) < 0)
+        return -1;
+
+    if (ISSET(INSECURE_BACKUP))
+        cflags = O_WRONLY | O_CREAT | O_APPEND;
+    else
+        cflags = O_WRONLY | O_CREAT | O_EXCL | O_APPEND;
+
+    fd = open(lockfilename, cflags,
+	    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
+
+    /* Maybe we just don't have write access, don't stop us from
+       opening the file at all, just don't set the lock_filename
+       and return success */
+    if (fd < 0 && errno == EACCES)
+        return 1;
+
+    /* Now we've got a safe file stream.  If the previous open()
+    call failed, this will return NULL. */
+    filestream = fdopen(fd, "wb");
+
+    if (fd < 0 || filestream == NULL) {
+        statusbar(_("Error writing lock file %s: %s"), lockfilename,
+		    strerror(errno));
+        return -1;
+    }
+
+
+    /* Okay. so at the moment we're following this state for how
+       to store the lock data:
+       byte 0        - 0x62
+       byte 1        - 0x30
+       bytes 2-12    - program name which created the lock
+       bytes 24,25   - little endian store of creator program's PID
+                       (b24 = 256^0 column, b25 = 256^1 column)
+       bytes 28-44   - username of who created the lock
+       bytes 68-100  - hostname of where the lock was created
+       bytes 108-876 - filename the lock is for
+       byte 1007     - 0x55 if file is modified
+
+       Looks like VIM also stores undo state in this file so we're
+       gonna have to figure out how to slap a 'OMG don't use recover
+       on our lockfile' message in here...
+
+       This is likely very wrong, so this is a WIP
+     */
+    null_at(&lockdata, lockdatalen);
+    lockdata[0] = 0x62;
+    lockdata[1] = 0x30;
+    lockdata[24] = mypid % 256;
+    lockdata[25] = mypid / 256;
+    snprintf(&lockdata[2], 10, "nano %s", VERSION);
+    strncpy(&lockdata[28], mypwuid->pw_name, 16);
+    strncpy(&lockdata[68], myhostname, 31);
+    strncpy(&lockdata[108], origfilename, 768);
+    if (modified == TRUE)
+        lockdata[1007] = 0x55;
+
+    wroteamt = fwrite(lockdata, sizeof(char), lockdatalen, filestream);
+    if (wroteamt < lockdatalen) {
+        statusbar(_("Error writing lock file %s: %s"),
+                  lockfilename, ferror(filestream));
+        return -1;
+    }
+
+#ifdef DEBUG
+    fprintf(stderr, "In write_lockfile(), write successful (wrote %d bytes)\n", wroteamt);
+#endif /* DEBUG */
+
+    if (fclose(filestream) == EOF) {
+        statusbar(_("Error writing lock file %s: %s"),
+                  lockfilename, strerror(errno));
+        return -1;
+    }
+
+    openfile->lock_filename = lockfilename;
+
+    return 1;
+}
+
+
+/* Less exciting, delete the lock file.
+   Return -1 if successful and complain on the statusbar, 1 otherwite
+ */
+int delete_lockfile(const char *lockfilename)
+{
+    if (unlink(lockfilename) < 0 && errno != ENOENT) {
+        statusbar(_("Error deleting lock file %s: %s"), lockfilename,
+		    strerror(errno));
+        return -1;
+    }
+    return 1;
+}
+
+
+/* Deal with lockfiles.  Return -1 on refusing to override
+   the lock file, and 1 on successfully created the lockfile, 0 means
+   we were not successful on creating the lockfile but we should
+   continue to load the file and complain to the user.
+ */
+int do_lockfile(const char *filename)
+{
+    char *lockdir = dirname((char *) mallocstrcpy(NULL, filename));
+    char *lockbase = basename((char *) mallocstrcpy(NULL, filename));
+    ssize_t lockfilesize = (sizeof (char *) * (strlen(filename)
+                   + strlen(locking_prefix) + strlen(locking_suffix) + 3));
+    char *lockfilename = (char *) nmalloc(lockfilesize);
+    char lockprog[12], lockuser[16];
+    struct stat fileinfo;
+    int lockfd, lockpid;
+
+
+    snprintf(lockfilename, lockfilesize, "%s/%s%s%s", lockdir,
+             locking_prefix, lockbase, locking_suffix);
+#ifdef DEBUG
+    fprintf(stderr, "lock file name is %s\n", lockfilename);
+#endif /* DEBUG */
+    if (stat(lockfilename, &fileinfo) != -1) {
+        ssize_t readtot = 0;
+        ssize_t readamt = 0;
+        char *lockbuf = (char *) nmalloc(8192);
+        char *promptstr = (char *) nmalloc(128);
+        int ans;
+        if ((lockfd = open(lockfilename, O_RDONLY)) < 0) {
+            statusbar(_("Error opening lockfile %s: %s"),
+                      lockfilename, strerror(errno));
+            return -1;
+        }
+        do {
+            readamt = read(lockfd, &lockbuf[readtot], BUFSIZ);
+            readtot += readamt;
+        } while (readtot < 8192 && readamt > 0);
+
+        if (readtot < 48) {
+            statusbar(_("Error reading lockfile %s: Not enough data read"),
+                      lockfilename);
+            return -1;
+        }
+        strncpy(lockprog, &lockbuf[2], 10);
+        lockpid = lockbuf[25] * 256 + lockbuf[24];
+        strncpy(lockuser, &lockbuf[28], 16);
+#ifdef DEBUG
+        fprintf(stderr, "lockpid = %d\n", lockpid);
+        fprintf(stderr, "program name which created this lock file should be %s\n",
+                lockprog);
+        fprintf(stderr, "user which created this lock file should be %s\n",
+                lockuser);
+#endif /* DEBUG */
+        sprintf(promptstr, "File being edited (by %s, PID %d, user %s), continue?",
+                              lockprog, lockpid, lockuser);
+        ans = do_yesno_prompt(FALSE, promptstr);
+        if (ans < 1) {
+            blank_statusbar();
+            return -1;
+        }
+    }
+
+    return write_lockfile(lockfilename, filename, FALSE);
+}
+#endif /* NANO_TINY */
+
+
@@ -131,5 +333,0 @@
-    /* If the filename isn't blank, open the file.  Otherwise, treat it
-     * as a new file. */
-    rc = (filename[0] != '\0') ? open_file(filename, new_buffer, &f) :
-	-2;
-
@@ -140,0 +339,5 @@
+    /* If the filename isn't blank, open the file.  Otherwise, treat it
+     * as a new file. */
+    rc = (filename[0] != '\0') ? open_file(filename, new_buffer, &f) :
+	-2;
+
@@ -681 +884 @@
- * fd opened otherwise.  The file might still have an error while reading 
+ * fd opened otherwise.  The file might still have an error while reading
@@ -696 +899 @@
-    if (full_filename == NULL 
+    if (full_filename == NULL
@@ -699,0 +903,7 @@
+
+#ifndef NANO_TINY
+    if (ISSET(LOCKING))
+        if (do_lockfile(full_filename) < 0)
+            return -1;
+#endif
+
@@ -1488 +1697,0 @@
-    int backup_cflags;
@@ -1550,0 +1760 @@
+	int backup_cflags;
@@ -1992,0 +2203 @@
+
@@ -2405,3 +2615,0 @@
-#ifndef DISABLE_OPERATINGDIR
-    size_t dirnamelen;
-#endif
@@ -2446,3 +2653,0 @@
-#ifndef DISABLE_OPERATINGDIR
-    dirnamelen = strlen(dirname);
-#endif
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/global.c nano/src/global.c
--- nano_2_3_1/src/global.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/global.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: global.c 4535 2011-02-26 14:22:37Z astyanax $ */
+/* $Id: global.c 4556 2013-01-03 04:36:39Z astyanax $ */
@@ -132,0 +133,5 @@
+
+const char *locking_prefix = ".";
+        /* Prefix of how to store the vim-style lock file */
+const char *locking_suffix = ".swp";
+        /* Suffix of the vim-style lock file */
@@ -156 +161 @@
-	/* Did a command mangle enough of the buffer refresh that we 
+	/* Did a command mangle enough of the buffer refresh that we
@@ -377 +382 @@
-int sc_seq_or (void (*func)(void), int defaultval) 
+int sc_seq_or (void (*func)(void), int defaultval)
@@ -388 +393 @@
-/* Assign the info to the shortcut struct 
+/* Assign the info to the shortcut struct
@@ -817 +822 @@
-    add_to_funcs(do_mark, MMAIN, N_("Mark Text"), 
+    add_to_funcs(do_mark, MMAIN, N_("Mark Text"),
@@ -956 +961 @@
-    add_to_funcs(total_refresh, (MMAIN|MHELP), refresh_msg, 
+    add_to_funcs(total_refresh, (MMAIN|MHELP), refresh_msg,
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/move.c nano/src/move.c
--- nano_2_3_1/src/move.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/move.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: move.c 4486 2010-03-21 04:56:37Z astyanax $ */
+/* $Id: move.c 4548 2012-12-30 19:20:10Z astyanax $ */
@@ -82 +82 @@
-    fprintf(stderr, "do_page_up: i = %d, skipped = %d based on line %ld len %d\n", i, (unsigned long) skipped, 
+    fprintf(stderr, "do_page_up: i = %d, skipped = %d based on line %ld len %d\n", i, (unsigned long) skipped,
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/nano.c nano/src/nano.c
--- nano_2_3_1/src/nano.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/nano.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: nano.c 4530 2011-02-18 07:30:57Z astyanax $ */ 
+/* $Id: nano.c 4549 2013-01-01 03:24:39Z astyanax $ */
@@ -522,0 +523 @@
+    newnode->lock_filename = NULL;
@@ -847,0 +849,2 @@
+    print_opt("-G", "--locking",
+	N_("Use (vim-style) lock files"));
@@ -1060,0 +1064,6 @@
+
+#ifndef NANO_TINY
+        if (ISSET(LOCKING) && openfile->lock_filename)
+            delete_lockfile(openfile->lock_filename);
+#endif /* NANO_TINY */
+
@@ -2013 +2022 @@
-    /* Well we might also need a full refresh if we've changed the 
+    /* Well we might also need a full refresh if we've changed the
@@ -2100,0 +2110 @@
+	{"locking", 0, NULL, 'G'},
@@ -2149 +2159 @@
-		"h?ABC:DEFHIKLNOPQ:RST:UVWY:abcdefgijklmo:pqr:s:tuvwxz$",
+		"h?ABC:DEFGHIKLNOPQ:RST:UVWY:abcdefgijklmo:pqr:s:tuvwxz$",
@@ -2153 +2163 @@
-		"h?ABC:DEFHIKLNOPQ:RST:UVWY:abcdefgijklmo:pqr:s:tuvwxz$")
+		"h?ABC:DEFGHIKLNOPQ:RST:UVWY:abcdefgijklmo:pqr:s:tuvwxz$")
@@ -2190,0 +2201,3 @@
+	    case 'G':
+		SET(LOCKING);
+		break;
@@ -2452 +2465 @@
-       if a --fill option was given on the command line. */ 
+       if a --fill option was given on the command line. */
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/nano.h nano/src/nano.h
--- nano_2_3_1/src/nano.h	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/nano.h	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: nano.h 4535 2011-02-26 14:22:37Z astyanax $ */
+/* $Id: nano.h 4561 2013-01-10 03:29:59Z astyanax $ */
@@ -87,0 +88,2 @@
+#elif defined(HAVE_NCURSESW_NCURSES_H)
+#include <ncursesw/ncurses.h>
@@ -192,0 +195 @@
+#define COLORWIDTH short
@@ -194 +197 @@
-    short fg;
+    COLORWIDTH fg;
@@ -196 +199 @@
-    short bg;
+    COLORWIDTH bg;
@@ -215 +218,3 @@
-     int id;
+    bool overlap;
+	/* Is it acceptable for other regexes to overlap this one? */
+    int id;
@@ -374,0 +380,2 @@
+    const char *lock_filename;
+        /* The path of the lockfile, if we created one */
@@ -433 +440 @@
-        /* The actual sequence to check on the the type is determined */
+        /* The actual sequence to check on the type is determined */
@@ -470 +477 @@
-/* Enumeration to be used in flags table. See FLAGBIT and FLAGOFF 
+/* Enumeration to be used in flags table. See FLAGBIT and FLAGOFF
@@ -510 +517,2 @@
-    POS_HISTORY
+    POS_HISTORY,
+    LOCKING
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/proto.h nano/src/proto.h
--- nano_2_3_1/src/proto.h	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/proto.h	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: proto.h 4530 2011-02-18 07:30:57Z astyanax $ */
+/* $Id: proto.h 4556 2013-01-03 04:36:39Z astyanax $ */
@@ -87,0 +88,2 @@
+extern const char *locking_prefix;
+extern const char *locking_suffix;
@@ -255,0 +258 @@
+
@@ -295,0 +299,2 @@
+int delete_lockfile(const char *lockfilename);
+int write_lockfile(const char *lockfilename, const char *origfilename, bool modified);
@@ -554 +559 @@
-bool nregcomp(const char *regex, int eflags);
+bool nregcomp(const char *regex, int cflags);
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/rcfile.c nano/src/rcfile.c
--- nano_2_3_1/src/rcfile.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/rcfile.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: rcfile.c 4530 2011-02-18 07:30:57Z astyanax $ */
+/* $Id: rcfile.c 4560 2013-01-03 05:17:36Z astyanax $ */
@@ -43,0 +44,3 @@
+#ifndef NANO_TINY
+    {"locking", LOCKING},
+#endif
@@ -228 +231 @@
-bool nregcomp(const char *regex, int eflags)
+bool nregcomp(const char *regex, int cflags)
@@ -232 +235 @@
-    int rc = regcomp(&preg, r, REG_EXTENDED | eflags);
+    int rc = regcomp(&preg, r, REG_EXTENDED | cflags);
@@ -252 +255 @@
-    syntaxtype *tmpsyntax;
+    syntaxtype *tmpsyntax, *prev_syntax;
@@ -278,0 +282 @@
+    prev_syntax = NULL;
@@ -282 +286,4 @@
-	    syntaxtype *prev_syntax = tmpsyntax;
+	    syntaxtype *old_syntax = tmpsyntax;
+
+	    if (endsyntax == tmpsyntax)
+		endsyntax = prev_syntax;
@@ -285 +292,7 @@
-	    free(prev_syntax);
+	    if (prev_syntax != NULL)
+		prev_syntax->next = tmpsyntax;
+	    else
+		syntaxes = tmpsyntax;
+
+	    free(old_syntax->desc);
+	    free(old_syntax);
@@ -287,0 +301 @@
+	prev_syntax = tmpsyntax;
@@ -669 +683 @@
-short color_to_short(const char *colorname, bool *bright)
+COLORWIDTH color_to_short(const char *colorname, bool *bright)
@@ -671 +685 @@
-    short mcolor = -1;
+    COLORWIDTH mcolor = -1;
@@ -711 +725 @@
-    short fg, bg;
+    COLORWIDTH fg, bg;
@@ -861 +875 @@
-            newcolor->id = endsyntax->nmultis;
+	    newcolor->id = endsyntax->nmultis;
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/search.c nano/src/search.c
--- nano_2_3_1/src/search.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/search.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: search.c 4527 2011-02-07 14:45:56Z astyanax $ */
+/* $Id: search.c 4559 2013-01-03 05:00:34Z astyanax $ */
@@ -141 +140,0 @@
-    void (*func)(void);
@@ -222,0 +222,2 @@
+	void (*func)(void);
+
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/text.c nano/src/text.c
--- nano_2_3_1/src/text.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/text.c	2013-01-10 19:47:31.000000000 +0100
@@ -858 +858 @@
-    if (current_action == CUT && u && u->type == CUT 
+    if (current_action == CUT && u && u->type == CUT
diff --unidirectional-new-file -U 0 -rx .svn nano_2_3_1/src/winio.c nano/src/winio.c
--- nano_2_3_1/src/winio.c	2011-12-18 22:20:10.000000000 +0100
+++ nano/src/winio.c	2013-01-10 19:47:31.000000000 +0100
@@ -1 +1 @@
-/* $Id: winio.c 4527 2011-02-07 14:45:56Z astyanax $ */
+/* $Id: winio.c 4555 2013-01-03 04:23:10Z astyanax $ */
@@ -1803 +1803 @@
-   functions to need to create function_key meta_key blah blah 
+   functions to need to create function_key meta_key blah blah
@@ -2260,0 +2261,11 @@
+#ifndef NANO_TINY
+	if (ISSET(LOCKING)) {
+	    if (openfile->lock_filename == NULL) {
+                /* Translators: Try to keep this at most 80 characters. */
+                statusbar(_("Warning: Modifying a file which is not locked, check directory permission?"));
+	    } else {
+		write_lockfile(openfile->lock_filename,
+                               get_full_path(openfile->filename), TRUE);
+            }
+	}
+#endif
@@ -2492,0 +2504,15 @@
+ 	int i, coloruid = 0; /* We need a unique color ID now */
+	static filestruct *lastptr = NULL;
+	static COLORWIDTH *slmatcharray = NULL;
+	    /* Array to track how much we've painted of the line for single line matches */
+
+	if (lastptr != fileptr || start == 0) {
+	    if (slmatcharray != NULL)
+		free(slmatcharray);
+	    slmatcharray = (COLORWIDTH *)nmalloc(strlenpt(fileptr->data) * sizeof(COLORWIDTH));
+
+	    /* Init slmatcharray */
+	    for (i = 0; i < strlenpt(fileptr->data); i++)
+		slmatcharray[i] = -1;
+	}
+
@@ -2497 +2522,0 @@
- 	    int i;
@@ -2499 +2524 @@
-            for (i = 0; i < openfile->syntax->nmultis; i++)
+	    for (i = 0; i < openfile->syntax->nmultis; i++)
@@ -2500,0 +2526 @@
+
@@ -2514,0 +2541 @@
+	    coloruid++;
@@ -2522 +2549 @@
-	    /* First case, tmpcolor is a single-line expression. */
+	    /* First case,tmpcolor is a single-line expression. */
@@ -2530,0 +2558,2 @@
+		    bool paintok = TRUE;
+
@@ -2539,0 +2569,2 @@
+
+
@@ -2549,0 +2581,2 @@
+			size_t pbegin = strnlenpt(fileptr->data, startmatch.rm_so);
+
@@ -2562 +2595,9 @@
-			mvwaddnstr(edit, line, x_start, converted +
+			/* Check that the match is not preceeded by another previous
+			   (single line) match before proceeding to paint it */
+			if (slmatcharray[pbegin] != -1 && slmatcharray[pbegin] != coloruid)
+			    paintok = FALSE;
+
+			if (paintok == TRUE) {
+			    int p;
+
+			    mvwaddnstr(edit, line, x_start, converted +
@@ -2563,0 +2605,4 @@
+			    for (p = pbegin; p < pbegin + (startmatch.rm_eo - startmatch.rm_so); p++) {
+				slmatcharray[p] = coloruid;  /* Add to our match array for the proper length */
+			    }
+			}
@@ -2565 +2610,4 @@
-		    k = startmatch.rm_eo;
+		    if (paintok)
+			k = startmatch.rm_eo;
+		    else
+			k = startmatch.rm_so + 1;
@@ -2751,0 +2800 @@
+	lastptr = fileptr;
@@ -3127 +3175,0 @@
-	filestruct *old_edittop = openfile->edittop;
@@ -3134,0 +3183 @@
+	    filestruct *old_edittop = openfile->edittop;
