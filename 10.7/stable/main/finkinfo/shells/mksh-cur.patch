Index: src/bin/mksh/Build.sh
diff -u src/bin/mksh/Build.sh:1.590.2.1 src/bin/mksh/Build.sh:1.612
--- src/bin/mksh/Build.sh:1.590.2.1	Fri Nov 30 20:49:10 2012
+++ src/bin/mksh/Build.sh	Tue Jan  1 21:19:36 2013
@@ -1,5 +1,5 @@
 #!/bin/sh
-srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.590.2.1 2012/11/30 20:49:10 tg Exp $'
+srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.612 2013/01/01 21:19:36 tg Exp $'
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012
@@ -270,7 +270,21 @@
 	echo "/* NeXTstep bug workaround */" >x
 	for i
 	do
-		echo "#include <$i>" >>x
+		case $i in
+		_time)
+			echo '#if HAVE_BOTH_TIME_H' >>x
+			echo '#include <sys/time.h>' >>x
+			echo '#include <time.h>' >>x
+			echo '#elif HAVE_SYS_TIME_H' >>x
+			echo '#include <sys/time.h>' >>x
+			echo '#elif HAVE_TIME_H' >>x
+			echo '#include <time.h>' >>x
+			echo '#endif' >>x
+			;;
+		*)
+			echo "#include <$i>" >>x
+			;;
+		esac
 	done
 	echo "#include <$hf>" >>x
 	echo 'int main(void) { return (0); }' >>x
@@ -594,7 +608,6 @@
 Linux)
 	case $CC in
 	*tendracc*) ;;
-	*/musl-gcc*) add_cppflags -D_GNU_SOURCE -D_BSD_SOURCE ;;
 	*) add_cppflags -D_GNU_SOURCE ;;
 	esac
 	add_cppflags -DSETUID_CAN_FAIL_WITH_EAGAIN
@@ -605,6 +618,14 @@
 	;;
 MidnightBSD)
 	;;
+Minix-vmd)
+	add_cppflags -DMKSH__NO_SETEUGID
+	add_cppflags -DMKSH_UNEMPLOYED
+	add_cppflags -DMKSH_CONSERVATIVE_FDS
+	add_cppflags -D_MINIX_SOURCE
+	oldish_ed=no-stderr-ed		# no /bin/ed, maybe see below
+	: ${HAVE_SETLOCALE_CTYPE=0}
+	;;
 Minix3)
 	add_cppflags -DMKSH_UNEMPLOYED
 	add_cppflags -DMKSH_CONSERVATIVE_FDS
@@ -675,6 +696,7 @@
 	;;
 QNX)
 	add_cppflags -D__NO_EXT_QNX
+	add_cppflags -D__EXT_UNIX_MISC
 	case $TARGET_OSREV in
 	[012345].*|6.[0123].*|6.4.[01])
 		oldish_ed=no-stderr-ed		# oldish /bin/ed is broken
@@ -869,7 +891,7 @@
 ct=untested
 et=untested
 vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c | \
-    sed -n '/^[ce]t *= */s/\([ce]t\) *= */\1=/p' | tr -d \\\\015 >x"
+    sed -n '/^ *[ce]t *= */s/^ *\([ce]t\) *= */\1=/p' | tr -d \\\\015 >x"
 sed 's/^/[ /' x
 eval `cat x`
 rmf x vv.out
@@ -1003,9 +1025,7 @@
 	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
 	;;
 watcom)
-	echo >&2 'Warning: Watcom C Compiler detected. This compiler has not yet
-    been tested for compatibility with mksh. Continue at your
-    own risk, please report success/failure to the developers.'
+	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
 	;;
 xlc)
 	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -qversion"
@@ -1110,6 +1130,9 @@
 elif test $ct = ucode; then
 	save_NOWARN=
 	DOWARN=-w2
+elif test $ct = watcom; then
+	save_NOWARN=
+	DOWARN=-Wc,-we
 else
 	test x"$save_NOWARN" = x"" && save_NOWARN=-Wno-error
 	ac_flags 0 wnoerror "$save_NOWARN"
@@ -1155,6 +1178,8 @@
 	# The following tests run with -Werror (gcc only) if possible
 	NOWARN=$DOWARN; phase=u
 	ac_flags 0 wnooverflow -Wno-overflow
+	# mksh is not written in CFrustFrust!
+	ac_flags 1 no_eh_frame -fno-asynchronous-unwind-tables
 	ac_flags 1 fnostrictaliasing -fno-strict-aliasing
 	ac_flags 1 fstackprotectorall -fstack-protector-all
 	test $cm = dragonegg && case " $CC $CFLAGS $LDFLAGS " in
@@ -1276,6 +1301,10 @@
 	    __attribute__((__bounded__ (__buffer__, 2, 3)));
 	int main(int ac, char *av[]) { return (xcopy(av[0], av[--ac], 1)); }
 	int xcopy(const void *s, void *d, size_t n) {
+		/*
+		 * if memmove does not exist, we are not on a system
+		 * with GCC with __bounded__ attribute either so poo
+		 */
 		memmove(d, s, n); return ((int)n);
 	}
 	#endif
@@ -1294,20 +1323,6 @@
 	int main(int ac, char **av) { return (fprintf(stderr, "%s%d", *av, ac)); }
 	#endif
 EOF
-ac_test attribute_nonnull '' 'for __attribute__((__nonnull__))' <<-'EOF'
-	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
-	/* force a failure: TenDRA and gcc 1.42 have false positive here */
-	int main(void) { return (thiswillneverbedefinedIhope()); }
-	#else
-	int foo(char *s1, char *s2) __attribute__((__nonnull__));
-	int bar(char *s1, char *s2) __attribute__((__nonnull__ (1, 2)));
-	int baz(char *s) __attribute__((__nonnull__ (1)));
-	int foo(char *s1, char *s2) { return (bar(s2, s1)); }
-	int bar(char *s1, char *s2) { return (baz(s1) - baz(s2)); }
-	int baz(char *s) { return (*s); }
-	int main(int ac, char **av) { return (ac == foo(av[0], av[ac-1])); }
-	#endif
-EOF
 ac_test attribute_noreturn '' 'for __attribute__((__noreturn__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1370,18 +1385,28 @@
 #ac_ifcpp 'ifdef MKSH_DISABLE_DEPRECATED' isset_MKSH_DISABLE_DEPRECATED '' \
 #    "if deprecated features are to be omitted" && \
 #    check_categories="$check_categories nodeprecated"
-ac_ifcpp 'ifdef MKSH_DISABLE_EXPERIMENTAL' isset_MKSH_DISABLE_EXPERIMENTAL '' \
-    "if experimental features are to be omitted" && \
-    check_categories="$check_categories noexperimental"
+#ac_ifcpp 'ifdef MKSH_DISABLE_EXPERIMENTAL' isset_MKSH_DISABLE_EXPERIMENTAL '' \
+#    "if experimental features are to be omitted" && \
+#    check_categories="$check_categories noexperimental"
 
 #
 # Environment: headers
 #
+ac_header sys/time.h sys/types.h
+ac_header time.h sys/types.h
+test "11" = "$HAVE_SYS_TIME_H$HAVE_TIME_H" || HAVE_BOTH_TIME_H=0
+ac_test both_time_h '' 'whether <sys/time.h> and <time.h> can both be included' <<-'EOF'
+	#include <sys/types.h>
+	#include <sys/time.h>
+	#include <time.h>
+	int main(void) { struct tm tm; return ((int)sizeof(tm)); }
+EOF
 ac_header sys/bsdtypes.h
 ac_header sys/file.h sys/types.h
 ac_header sys/mkdev.h sys/types.h
 ac_header sys/mman.h sys/types.h
 ac_header sys/param.h
+ac_header sys/resource.h sys/types.h _time
 ac_header sys/select.h sys/types.h
 ac_header sys/sysmacros.h
 ac_header bstring.h
@@ -1443,8 +1468,17 @@
 
 ac_test rlim_t <<-'EOF'
 	#include <sys/types.h>
+	#if HAVE_BOTH_TIME_H
 	#include <sys/time.h>
+	#include <time.h>
+	#elif HAVE_SYS_TIME_H
+	#include <sys/time.h>
+	#elif HAVE_TIME_H
+	#include <time.h>
+	#endif
+	#if HAVE_SYS_RESOURCE_H
 	#include <sys/resource.h>
+	#endif
 	#include <unistd.h>
 	int main(void) { return ((int)(rlim_t)0); }
 EOF
@@ -1495,7 +1529,7 @@
 		#define EXTERN
 		#define MKSH_INCLUDES_ONLY
 		#include "sh.h"
-		__RCSID("$MirOS: src/bin/mksh/Build.sh,v 1.590.2.1 2012/11/30 20:49:10 tg Exp $");
+		__RCSID("$MirOS: src/bin/mksh/Build.sh,v 1.612 2013/01/01 21:19:36 tg Exp $");
 		int main(void) { printf("Hello, World!\n"); return (0); }
 EOF
 	case $cm in
@@ -1528,18 +1562,35 @@
 fi
 
 #
-# Environment: signals
+# Environment: errors and signals
 #
 test x"NetBSD" = x"$TARGET_OS" && $e Ignore the compatibility warning.
 
+ac_testn sys_errlist '' "the sys_errlist[] array and sys_nerr" <<-'EOF'
+	extern const int sys_nerr;
+	extern const char * const sys_errlist[];
+	int main(void) { return (*sys_errlist[sys_nerr - 1]); }
+EOF
+ac_testn _sys_errlist '!' sys_errlist 0 "the _sys_errlist[] array and _sys_nerr" <<-'EOF'
+	extern const int _sys_nerr;
+	extern const char * const _sys_errlist[];
+	int main(void) { return (*_sys_errlist[_sys_nerr - 1]); }
+EOF
+if test 1 = "$HAVE__SYS_ERRLIST"; then
+	add_cppflags -Dsys_nerr=_sys_nerr
+	add_cppflags -Dsys_errlist=_sys_errlist
+	HAVE_SYS_ERRLIST=1
+fi
+ac_cppflags SYS_ERRLIST
+
 for what in name list; do
 	uwhat=`upper $what`
 	ac_testn sys_sig$what '' "the sys_sig${what}[] array" <<-EOF
-		extern const char *const sys_sig${what}[];
+		extern const char * const sys_sig${what}[];
 		int main(void) { return (sys_sig${what}[0][0]); }
 	EOF
 	ac_testn _sys_sig$what '!' sys_sig$what 0 "the _sys_sig${what}[] array" <<-EOF
-		extern const char *const _sys_sig${what}[];
+		extern const char * const _sys_sig${what}[];
 		int main(void) { return (_sys_sig${what}[0][0]); }
 	EOF
 	eval uwhat_v=\$HAVE__SYS_SIG$uwhat
@@ -1550,12 +1601,6 @@
 	ac_cppflags SYS_SIG$uwhat
 done
 
-ac_test strsignal '!' sys_siglist 0 <<-'EOF'
-	#include <string.h>
-	#include <signal.h>
-	int main(void) { return (strsignal(1)[0]); }
-EOF
-
 #
 # Environment: library functions
 #
@@ -1592,7 +1637,7 @@
 ac_test gettimeofday <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
-	int main(void) { return (gettimeofday(NULL, NULL)); }
+	int main(void) { struct timeval tv; return (gettimeofday(&tv, NULL)); }
 EOF
 
 ac_test killpg <<-'EOF'
@@ -1600,6 +1645,18 @@
 	int main(int ac, char *av[]) { return (av[0][killpg(123, ac)]); }
 EOF
 
+ac_test memmove <<-'EOF'
+	#include <sys/types.h>
+	#include <stddef.h>
+	#include <string.h>
+	#if HAVE_STRINGS_H
+	#include <strings.h>
+	#endif
+	int main(int ac, char *av[]) {
+		return (*(int *)(void *)memmove(av[0], av[1], ac));
+	}
+EOF
+
 ac_test mknod '' 'if to use mknod(), makedev() and friends' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
@@ -1654,7 +1711,14 @@
 
 ac_test select <<-'EOF'
 	#include <sys/types.h>
+	#if HAVE_BOTH_TIME_H
 	#include <sys/time.h>
+	#include <time.h>
+	#elif HAVE_SYS_TIME_H
+	#include <sys/time.h>
+	#elif HAVE_TIME_H
+	#include <time.h>
+	#endif
 	#if HAVE_SYS_BSDTYPES_H
 	#include <sys/bsdtypes.h>
 	#endif
@@ -1725,6 +1789,17 @@
 	fi
 fi
 
+ac_test strerror '!' sys_errlist 0 <<-'EOF'
+	extern char *strerror(int);
+	int main(int ac, char *av[]) { return (*strerror(*av[ac])); }
+EOF
+
+ac_test strsignal '!' sys_siglist 0 <<-'EOF'
+	#include <string.h>
+	#include <signal.h>
+	int main(void) { return (strsignal(1)[0]); }
+EOF
+
 ac_test strlcpy <<-'EOF'
 	#include <string.h>
 	int main(int ac, char *av[]) { return (strlcpy(*av, av[1],
@@ -1734,8 +1809,8 @@
 #
 # check headers for declarations
 #
-save_CC=$CC; save_LDFLAGS=$LDFLAGS; save_LIBS=$LIBS
-CC="$CC -c -o $tcfn"; LDFLAGS=; LIBS=
+save_tcfn=$tcfn; save_CC=$CC; save_LDFLAGS=$LDFLAGS; save_LIBS=$LIBS
+tcfn=conftest.o; CC="$CC -c -o $tcfn"; LDFLAGS=; LIBS=
 ac_test '!' flock_decl flock 1 'if flock() does not need to be declared' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
@@ -1751,13 +1826,17 @@
 	long revoke(void);		/* this clashes if defined before */
 	int main(void) { return ((int)revoke()); }
 EOF
-ac_test '!' sys_siglist_decl sys_siglist 1 'if sys_siglist[] does not need to be declared' <<-'EOF'
+ac_test sys_errlist_decl sys_errlist 0 "for declaration of sys_errlist[] and sys_nerr" <<-'EOF'
+	#define MKSH_INCLUDES_ONLY
+	#include "sh.h"
+	int main(void) { return (*sys_errlist[sys_nerr - 1]); }
+EOF
+ac_test sys_siglist_decl sys_siglist 0 'for declaration of sys_siglist[]' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
-	extern int sys_siglist[5][5][5][5][5];	/* this clashes happily */
-	int main(void) { return (sys_siglist[0][0][0][0][0]); }
+	int main(void) { return (sys_siglist[0][0]); }
 EOF
-CC=$save_CC; LDFLAGS=$save_LDFLAGS; LIBS=$save_LIBS
+tcfn=$save_tcfn; CC=$save_CC; LDFLAGS=$save_LDFLAGS; LIBS=$save_LIBS
 
 #
 # other checks
@@ -1982,6 +2061,8 @@
 #define NSIG _NSIG
 #elif defined(SIGMAX)
 #define NSIG (SIGMAX+1)
+#elif defined(_SIGMAX)
+#define NSIG (_SIGMAX+1)
 #endif
 #endif
 int
@@ -1989,14 +2070,15 @@
 ;' >conftest.c
 	# GNU sed 2.03 segfaults when optimising this to sed -n
 	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
-	    grep '^mksh_cfg *=' | \
-	    sed 's/^mksh_cfg *=[	 ]*\([()0-9x+-][()0-9x+	 -]*\).*$/\1/'`
+	    grep '^ *mksh_cfg *=' | \
+	    sed 's/^ *mksh_cfg *=[	 ]*\([()0-9x+-][()0-9x+	 -]*\).*$/\1/'`
 	case $NSIG in
 	*mksh_cfg*) $e "Error: NSIG='$NSIG'"; NSIG=0 ;;
 	*[\ \(\)+-]*) NSIG=`"$AWK" "BEGIN { print $NSIG }" </dev/null` ;;
 	esac
 	printf=printf
 	(printf hallo) >/dev/null 2>&1 || printf=echo
+	test $printf = echo || test "`printf %d 42`" = 42 || printf=echo
 	test $printf = echo || NSIG=`printf %d "$NSIG" 2>/dev/null`
 	$printf "NSIG=$NSIG ... "
 	sigs="INT SEGV ABRT KILL ALRM BUS CHLD CLD CONT DIL EMT FPE HUP ILL"
@@ -2018,8 +2100,8 @@
 		echo ';' >>conftest.c
 		# GNU sed 2.03 croaks on optimising this, too
 		vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
-		    grep '^mksh_cfg *=' | \
-		    sed 's/^mksh_cfg *=[	 ]*\([0-9][0-9x]*\).*$/:\1 '$name/
+		    grep '^ *mksh_cfg *=' | \
+		    sed 's/^ *mksh_cfg *=[	 ]*\([0-9][0-9x]*\).*$/:\1 '$name/
 	done | sed -n '/^:[^ ]/s/^://p' | while read nr name; do
 		test $printf = echo || nr=`printf %d "$nr" 2>/dev/null`
 		test $nr -gt 0 && test $nr -le $NSIG || continue
@@ -2040,7 +2122,7 @@
 test 1 = "$USE_PRINTF_BUILTIN" && add_cppflags -DMKSH_PRINTF_BUILTIN
 test 1 = "$HAVE_CAN_VERB" && CFLAGS="$CFLAGS -verbose"
 test -n "$LDSTATIC" && add_cppflags -DMKSH_OPTSTATIC
-add_cppflags -DMKSH_BUILD_R=411
+add_cppflags -DMKSH_BUILD_R=419
 
 $e $bi$me: Finished configuration testing, now producing output.$ao
 
@@ -2312,6 +2394,7 @@
 MKSH_DISABLE_EXPERIMENTAL	disable code not yet comfy for (LTS) snapshots
 MKSH_DISABLE_TTY_WARNING	shut up warning about ctty if OS cant be fixed
 MKSH_DONT_EMIT_IDSTRING		omit RCS IDs from binary
+MKSH_GCC55009			DANGER! see http://www.mirbsd.org/mksh.htm#p41
 MKSH_MIDNIGHTBSD01ASH_COMPAT	set -o sh: additional compatibility quirk
 MKSH_NOPROSPECTOFWORK		disable jobs, co-processes, etc. (do not use)
 MKSH_NOPWNAM			skip PAM calls, for -static on eglibc, Solaris
Index: src/bin/mksh/check.t
diff -u src/bin/mksh/check.t:1.569 src/bin/mksh/check.t:1.586
--- src/bin/mksh/check.t:1.569	Fri Nov 30 19:25:01 2012
+++ src/bin/mksh/check.t	Sun Jan  6 18:51:39 2013
@@ -1,10 +1,10 @@
-# $MirOS: src/bin/mksh/check.t,v 1.569 2012/11/30 19:25:01 tg Exp $
+# $MirOS: src/bin/mksh/check.t,v 1.586 2013/01/06 18:51:39 tg Exp $
 # $OpenBSD: bksl-nl.t,v 1.2 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: history.t,v 1.5 2001/01/28 23:04:56 niklas Exp $
 # $OpenBSD: read.t,v 1.3 2003/03/10 03:48:16 david Exp $
 #-
 # Copyright Â© 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#	      2011, 2012
+#	      2011, 2012, 2013
 #	Thorsten Glaser <tg@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -29,7 +29,7 @@
 # http://www.freebsd.org/cgi/cvsweb.cgi/src/tools/regression/bin/test/regress.sh?rev=HEAD
 
 expected-stdout:
-	@(#)MIRBSD KSH R41 2012/11/30
+	@(#)MIRBSD KSH R41 2013/01/06
 description:
 	Check version of shell.
 stdin:
@@ -38,7 +38,7 @@
 category: shell:legacy-no
 ---
 expected-stdout:
-	@(#)LEGACY KSH R41 2012/11/30
+	@(#)LEGACY KSH R41 2013/01/06
 description:
 	Check version of legacy shell.
 stdin:
@@ -217,14 +217,21 @@
 	the time-limit clause (e.g. to 7) if this occurs.
 time-limit: 3
 stdin:
-	echo -n >tf
-	alias ls=ls
-	ls
-	echo $(ls)
+	print '#!'"$__progname"'\necho tf' >lq
+	chmod +x lq
+	PATH=$PWD:$PATH
+	alias lq=lq
+	lq
+	echo = now
+	i=`lq`
+	print -r -- $i
+	echo = out
 	exit 0
 expected-stdout:
 	tf
+	= now
 	tf
+	= out
 ---
 name: alias-10
 description:
@@ -1141,7 +1148,8 @@
 need-pass: no
 # the mv command fails on Cygwin
 # Hurd aborts the testsuite (permission denied)
-category: !os:cygwin,!os:gnu,!os:msys,!nosymlink
+# QNX does not find subdir to cd into
+category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!nosymlink
 file-setup: file 644 "x"
 	mkdir noread noread/target noread/target/subdir
 	ln -s noread link
@@ -2060,7 +2068,9 @@
 	Check that globbing matches the right things...
 # breaks on Mac OSX (HFS+ non-standard Unicode canonical decomposition)
 # breaks on Cygwin 1.7 (files are now UTF-16 or something)
-category: !os:cygwin,!os:darwin,!os:msys
+# breaks on QNX 6.4.1 (says RT)
+category: !os:cygwin,!os:darwin,!os:msys,!os:nto
+need-pass: no
 file-setup: file 644 "aÂc"
 stdin:
 	echo a[Á-Ú]*
@@ -5811,6 +5821,140 @@
 	hi
 expected-exit: 9
 ---
+name: exit-trap-2
+description:
+	Check that ERR and EXIT traps are run just like ksh93 does.
+	GNU bash does not run ERtrap in Â±e eval-undef but runs it
+	twice (bug?) in +e eval-false, so does ksh93 (bug?), which
+	also has a bug to continue execution (echoing "and out" and
+	returning 0) in +e eval-undef.
+file-setup: file 644 "x"
+	v=; unset v
+	trap 'echo EXtrap' EXIT
+	trap 'echo ERtrap' ERR
+	set $1
+	echo "and run $2"
+	eval $2
+	echo and out
+file-setup: file 644 "xt"
+	v=; unset v
+	trap 'echo EXtrap' EXIT
+	trap 'echo ERtrap' ERR
+	set $1
+	echo 'and run true'
+	true
+	echo and out
+file-setup: file 644 "xf"
+	v=; unset v
+	trap 'echo EXtrap' EXIT
+	trap 'echo ERtrap' ERR
+	set $1
+	echo 'and run false'
+	false
+	echo and out
+file-setup: file 644 "xu"
+	v=; unset v
+	trap 'echo EXtrap' EXIT
+	trap 'echo ERtrap' ERR
+	set $1
+	echo 'and run ${v?}'
+	${v?}
+	echo and out
+stdin:
+	runtest() {
+		rm -f rc
+		(
+			"$__progname" "$@"
+			echo $? >rc
+		) 2>&1 | sed \
+		    -e 's/parameter not set/parameter null or not set/' \
+		    -e 's/[[]6]//' -e 's/: eval: line 1//' -e 's/: line 6//' \
+		    -e "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
+	}
+	xe=-e
+	echo : $xe
+	runtest x $xe true
+	echo = eval-true $(<rc) .
+	runtest x $xe false
+	echo = eval-false $(<rc) .
+	runtest x $xe '${v?}'
+	echo = eval-undef $(<rc) .
+	runtest xt $xe
+	echo = noeval-true $(<rc) .
+	runtest xf $xe
+	echo = noeval-false $(<rc) .
+	runtest xu $xe
+	echo = noeval-undef $(<rc) .
+	xe=+e
+	echo : $xe
+	runtest x $xe true
+	echo = eval-true $(<rc) .
+	runtest x $xe false
+	echo = eval-false $(<rc) .
+	runtest x $xe '${v?}'
+	echo = eval-undef $(<rc) .
+	runtest xt $xe
+	echo = noeval-true $(<rc) .
+	runtest xf $xe
+	echo = noeval-false $(<rc) .
+	runtest xu $xe
+	echo = noeval-undef $(<rc) .
+expected-stdout:
+	: -e
+	and run true
+	and out
+	EXtrap
+	= eval-true 0 .
+	and run false
+	ERtrap
+	EXtrap
+	= eval-false 1 .
+	and run ${v?}
+	x: v: parameter null or not set
+	ERtrap
+	EXtrap
+	= eval-undef 1 .
+	and run true
+	and out
+	EXtrap
+	= noeval-true 0 .
+	and run false
+	ERtrap
+	EXtrap
+	= noeval-false 1 .
+	and run ${v?}
+	xu: v: parameter null or not set
+	EXtrap
+	= noeval-undef 1 .
+	: +e
+	and run true
+	and out
+	EXtrap
+	= eval-true 0 .
+	and run false
+	ERtrap
+	and out
+	EXtrap
+	= eval-false 0 .
+	and run ${v?}
+	x: v: parameter null or not set
+	ERtrap
+	EXtrap
+	= eval-undef 1 .
+	and run true
+	and out
+	EXtrap
+	= noeval-true 0 .
+	and run false
+	ERtrap
+	and out
+	EXtrap
+	= noeval-false 0 .
+	and run ${v?}
+	xu: v: parameter null or not set
+	EXtrap
+	= noeval-undef 1 .
+---
 name: test-stlt-1
 description:
 	Check that test also can handle string1 < string2 etc.
@@ -7593,11 +7737,13 @@
 	mk 'foo ()' >f-dash
 	mk 'function foo ()' >f-bash
 	mk 'function stop ()' stop >f-stop
+	print '#!'"$__progname"'\nprint -r -- "${0%/f-argh}"' >f-argh
 	chmod +x f-*
-	echo "korn: $(./f-korn)"
-	echo "dash: $(./f-dash)"
-	echo "bash: $(./f-bash)"
-	echo "stop: $(./f-stop)"
+	u=$(./f-argh)
+	x="korn: $(./f-korn)"; echo "${x/@("$u")/.}"
+	x="dash: $(./f-dash)"; echo "${x/@("$u")/.}"
+	x="bash: $(./f-bash)"; echo "${x/@("$u")/.}"
+	x="stop: $(./f-stop)"; echo "${x/@("$u")/.}"
 expected-stdout:
 	korn: bar='foo'
 	dash: bar='./f-dash'
@@ -8134,6 +8280,36 @@
 expected-stdout:
 	okay
 ---
+name: redir-1
+description:
+	Check some of the most basic invariants of I/O redirection
+stdin:
+	i=0
+	function d {
+		print o$i.
+		print -u2 e$((i++)).
+	}
+	d >a 2>b
+	echo =1=
+	cat a
+	echo =2=
+	cat b
+	echo =3=
+	d 2>&1 >c
+	echo =4=
+	cat c
+	echo =5=
+expected-stdout:
+	=1=
+	o0.
+	=2=
+	e0.
+	=3=
+	e1.
+	=4=
+	o1.
+	=5=
+---
 name: bashiop-1
 description:
 	Check if GNU bash-like I/O redirection works
@@ -10390,6 +10566,34 @@
 	5(esac)bourne no
 	6(esac)korn esac
 ---
+name: command-shift
+description:
+	Check that 'command shift' works
+stdin:
+	function snc {
+		echo "before	0='$0' 1='$1' 2='$2'"
+		shift
+		echo "after	0='$0' 1='$1' 2='$2'"
+	}
+	function swc {
+		echo "before	0='$0' 1='$1' 2='$2'"
+		command shift
+		echo "after	0='$0' 1='$1' 2='$2'"
+	}
+	echo = without command
+	snc ä¸€ äºŒ
+	echo = with command
+	swc ä¸€ äºŒ
+	echo = done
+expected-stdout:
+	= without command
+	before	0='snc' 1='ä¸€' 2='äºŒ'
+	after	0='snc' 1='äºŒ' 2=''
+	= with command
+	before	0='swc' 1='ä¸€' 2='äºŒ'
+	after	0='swc' 1='äºŒ' 2=''
+	= done
+---
 name: stateptr-underflow
 description:
 	This check overflows an Xrestpos stored in a short in R40
Index: src/bin/mksh/dot.mkshrc
diff -u src/bin/mksh/dot.mkshrc:1.72 src/bin/mksh/dot.mkshrc:1.73
--- src/bin/mksh/dot.mkshrc:1.72	Tue Oct 30 21:04:56 2012
+++ src/bin/mksh/dot.mkshrc	Fri Nov 30 20:19:10 2012
@@ -1,5 +1,5 @@
 # $Id$
-# $MirOS: src/bin/mksh/dot.mkshrc,v 1.72 2012/10/30 21:04:56 tg Exp $
+# $MirOS: src/bin/mksh/dot.mkshrc,v 1.73 2012/11/30 20:19:10 tg Exp $
 #-
 # Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012
@@ -30,7 +30,7 @@
 
 	(( e )) && print -n "$e|"
 }
-PS1=$'\001\r''$(precmd)${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
+PS1=$'\001\r''${ precmd;}${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
 	)}@${HOSTNAME%%.*}:$(local d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || \
 	d=${d/#$p/~}; local m=${%d} n p=...; (( m > 0 )) || m=${#d}
 	(( m > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && d=${d:(-n)} || \
Index: src/bin/mksh/edit.c
diff -u src/bin/mksh/edit.c:1.256 src/bin/mksh/edit.c:1.260
--- src/bin/mksh/edit.c:1.256	Mon Nov 26 22:39:14 2012
+++ src/bin/mksh/edit.c	Fri Dec 28 02:28:33 2012
@@ -28,7 +28,7 @@
 
 #ifndef MKSH_NO_CMDLINE_EDITING
 
-__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.256 2012/11/26 22:39:14 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.260 2012/12/28 02:28:33 tg Exp $");
 
 /*
  * in later versions we might use libtermcap for this, but since external
@@ -73,9 +73,9 @@
 static void x_modified(void);
 static void x_mode(bool);
 static int x_do_comment(char *, ssize_t, ssize_t *);
-static void x_print_expansions(int, char *const *, bool);
+static void x_print_expansions(int, char * const *, bool);
 static int x_cf_glob(int *, const char *, int, int, int *, int *, char ***);
-static size_t x_longest_prefix(int, char *const *);
+static size_t x_longest_prefix(int, char * const *);
 static void x_glob_hlp_add_qchar(char *);
 static char *x_glob_hlp_tilde_and_rem_qchar(char *, bool);
 static int x_basename(const char *, const char *);
@@ -607,6 +607,8 @@
 	char **words = NULL;
 	bool is_command;
 
+	mkssert(buf != NULL);
+
 	len = x_locate_word(buf, buflen, pos, startp, &is_command);
 	if (!((*flagsp) & XCF_COMMAND))
 		is_command = false;
@@ -990,8 +992,7 @@
 static int x_match(char *, char *);
 static void x_redraw(int);
 static void x_push(int);
-static char *x_mapin(const char *, Area *)
-    MKSH_A_NONNULL((__nonnull__ (1)));
+static char *x_mapin(const char *, Area *);
 static char *x_mapout(int);
 static void x_mapout2(int, char **);
 static void x_print(int, int);
@@ -2274,6 +2275,7 @@
 {
 	char *cp;
 
+	mkssert(xcp != NULL);
 	strndupx(cp, xcp, nchars, AEDIT);
 	if (killstack[killsp])
 		afree(killstack[killsp], AEDIT);
@@ -2395,9 +2397,6 @@
 {
 	char *news, *op;
 
-	/* for clang's static analyser, the nonnull attribute isn't enough */
-	mkssert(cp != NULL);
-
 	strdupx(news, cp, ap);
 	op = news;
 	while (*cp) {
Index: src/bin/mksh/eval.c
diff -u src/bin/mksh/eval.c:1.129 src/bin/mksh/eval.c:1.132
--- src/bin/mksh/eval.c:1.129	Mon Oct 22 20:19:12 2012
+++ src/bin/mksh/eval.c	Mon Dec 17 23:18:03 2012
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.129 2012/10/22 20:19:12 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.132 2012/12/17 23:18:03 tg Exp $");
 
 /*
  * string expansion
@@ -277,30 +277,24 @@
 				quote = st->quotew;
 				continue;
 			case COMSUB:
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 			case FUNSUB:
-#endif
 				tilde_ok = 0;
 				if (f & DONTRUNCOMMAND) {
 					word = IFS_WORD;
 					*dp++ = '$';
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 					if (c == FUNSUB) {
 						*dp++ = '{';
 						*dp++ = ' ';
 					} else
-#endif
 						*dp++ = '(';
 					while (*sp != '\0') {
 						Xcheck(ds, dp);
 						*dp++ = *sp++;
 					}
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 					if (c == FUNSUB) {
 						*dp++ = ';';
 						*dp++ = '}';
 					} else
-#endif
 						*dp++ = ')';
 				} else {
 					type = comsub(&x, sp, c);
@@ -522,6 +516,7 @@
 
 						/* check for special cases */
 						d = str_val(st->var);
+						mkssert(d != NULL);
 						switch (*pat) {
 						case '#':
 							/* anchor at begin */
@@ -1322,7 +1317,6 @@
 			SHF_MAPHI|SHF_CLEXEC);
 		if (shf == NULL)
 			errorf("%s: %s %s", name, "can't open", "$() input");
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 	} else if (fn == FUNSUB) {
 		int ofd1;
 		struct temp *tf = NULL;
@@ -1331,7 +1325,7 @@
 		maketemp(ATEMP, TT_FUNSUB, &tf);
 		if (!tf->shf) {
 			errorf("can't %s temporary file %s: %s",
-			    "create", tf->tffn, strerror(errno));
+			    "create", tf->tffn, cstrerror(errno));
 		}
 		/* save stdout and make the temporary file it */
 		ofd1 = savefd(1);
@@ -1345,7 +1339,6 @@
 		shf = shf_open(tf->tffn, O_RDONLY, 0, SHF_MAPHI | SHF_CLEXEC);
 		unlink(tf->tffn);
 		afree(tf, ATEMP);
-#endif
 	} else {
 		int ofd1, pv[2];
 
Index: src/bin/mksh/exec.c
diff -u src/bin/mksh/exec.c:1.106 src/bin/mksh/exec.c:1.112
--- src/bin/mksh/exec.c:1.106	Fri Nov 30 19:02:06 2012
+++ src/bin/mksh/exec.c	Sun Jan  6 18:51:42 2013
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012
+ *		 2011, 2012, 2013
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106 2012/11/30 19:02:06 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.112 2013/01/06 18:51:42 tg Exp $");
 
 #ifndef MKSH_DEFAULT_EXECSHELL
 #define MKSH_DEFAULT_EXECSHELL	"/bin/sh"
@@ -32,7 +32,7 @@
 static int comexec(struct op *, struct tbl * volatile, const char **,
     int volatile, volatile int *);
 static void scriptexec(struct op *, const char **) MKSH_A_NORETURN;
-static int call_builtin(struct tbl *, const char **);
+static int call_builtin(struct tbl *, const char **, const char *);
 static int iosetup(struct ioword *, struct tbl *);
 static int herein(const char *, int, char **);
 static const char *do_selectargs(const char **, bool);
@@ -461,7 +461,7 @@
 		if (rv == ENOEXEC)
 			scriptexec(t, (const char **)up);
 		else
-			errorf("%s: %s", s, strerror(rv));
+			errorf("%s: %s", s, cstrerror(rv));
 	}
  Break:
 	exstat = rv & 0xFF;
@@ -479,9 +479,14 @@
 		unwind(LEXIT);
 	if (rv != 0 && !(flags & XERROK) &&
 	    (xerrok == NULL || !*xerrok)) {
-		trapsig(ksh_SIGERR);
-		if (Flag(FERREXIT))
-			unwind(LERROR);
+		if (Flag(FERREXIT) & 0x80) {
+			/* inside eval */
+			Flag(FERREXIT) = 0;
+		} else {
+			trapsig(ksh_SIGERR);
+			if (Flag(FERREXIT))
+				unwind(LERROR);
+		}
 	}
 	return (rv);
 }
@@ -501,7 +506,7 @@
 	/* Must be static (XXX but why?) */
 	static struct op texec;
 	int type_flags;
-	int keepasn_ok;
+	bool keepasn_ok;
 	int fcflags = FC_BI|FC_FUNC|FC_PATH;
 	bool bourne_function_call = false;
 	struct block *l_expand, *l_assign;
@@ -533,7 +538,7 @@
 	 *	FOO=bar command			FOO is neither kept nor exported
 	 *	PATH=... foobar			use new PATH in foobar search
 	 */
-	keepasn_ok = 1;
+	keepasn_ok = true;
 	while (tp && tp->type == CSHELL) {
 		/* undo effects of command */
 		fcflags = FC_BI|FC_FUNC|FC_PATH;
@@ -580,7 +585,7 @@
 			 * POSIX says special builtins lose their status
 			 * if accessed using command.
 			 */
-			keepasn_ok = 0;
+			keepasn_ok = false;
 			if (!ap[0]) {
 				/* ensure command with no args exits with 0 */
 				subst_exstat = 0;
@@ -605,7 +610,7 @@
 				/* go on, use the builtin */
 				break;
 #endif
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 		} else if (tp->val.f == c_trap) {
 			t->u.evalflags &= ~DOTCOMEXEC;
 			break;
@@ -614,7 +619,7 @@
 			break;
 		tp = findcom(ap[0], fcflags & (FC_BI|FC_FUNC));
 	}
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 	if (t->u.evalflags & DOTCOMEXEC)
 		flags |= XEXEC;
 #endif
@@ -672,7 +677,11 @@
 
 	/* shell built-in */
 	case CSHELL:
-		rv = call_builtin(tp, (const char **)ap);
+		rv = call_builtin(tp, (const char **)ap, null);
+		if (!keepasn_ok && tp->val.f == c_shift) {
+			l_expand->argc = l_assign->argc;
+			l_expand->argv = l_assign->argv;
+		}
 		break;
 
 	/* function call */
@@ -688,14 +697,14 @@
 				rv = (tp->u2.errnov == ENOENT) ? 127 : 126;
 				warningf(true, "%s: %s %s: %s", cp,
 				    "can't find", "function definition file",
-				    strerror(tp->u2.errnov));
+				    cstrerror(tp->u2.errnov));
 				break;
 			}
 			if (include(tp->u.fpath, 0, NULL, false) < 0) {
 				rv = errno;
 				warningf(true, "%s: %s %s %s: %s", cp,
 				    "can't open", "function definition file",
-				    tp->u.fpath, strerror(rv));
+				    tp->u.fpath, cstrerror(rv));
 				rv = 127;
 				break;
 			}
@@ -789,7 +798,7 @@
 			} else {
 				rv = 126;
 				warningf(true, "%s: %s: %s", cp, "can't execute",
-				    strerror(tp->u2.errnov));
+				    cstrerror(tp->u2.errnov));
 			}
 			break;
 		}
@@ -924,7 +933,7 @@
 	execve(args.rw[0], args.rw, cap.rw);
 
 	/* report both the programme that was run and the bogus interpreter */
-	errorf("%s: %s: %s", tp->str, sh, strerror(errno));
+	errorf("%s: %s: %s", tp->str, sh, cstrerror(errno));
 }
 
 int
@@ -933,9 +942,7 @@
 	struct tbl *tp;
 
 	tp = ktsearch(&builtins, *wp, hash(*wp));
-	if (tp == NULL)
-		internal_errorf("%s: %s", "shcomexec", *wp);
-	return (call_builtin(tp, wp));
+	return (call_builtin(tp, wp, "shcomexec"));
 }
 
 /*
@@ -984,6 +991,8 @@
 
 	while (/* CONSTCOND */ 1) {
 		tp = findfunc(name, nhash, true);
+		/* because findfunc:create=true */
+		mkssert(tp != NULL);
 
 		if (tp->flag & ISSET)
 			was_set = true;
@@ -1250,10 +1259,12 @@
 }
 
 static int
-call_builtin(struct tbl *tp, const char **wp)
+call_builtin(struct tbl *tp, const char **wp, const char *where)
 {
 	int rv;
 
+	if (!tp)
+		internal_errorf("%s: %s", where, wp[0]);
 	builtin_argv0 = wp[0];
 	builtin_flag = tp->flag;
 	shf_reopen(1, SHF_WR, shl_stdout);
@@ -1361,7 +1372,7 @@
 			warningf(true, "can't %s %s: %s",
 			    iotype == IODUP ? "dup" :
 			    (iotype == IOREAD || iotype == IOHERE) ?
-			    "open" : "create", cp, strerror(u));
+			    "open" : "create", cp, cstrerror(u));
 		}
 		return (-1);
 	}
@@ -1391,7 +1402,7 @@
 			warningf(true, "%s %s %s",
 			    "can't finish (dup) redirection",
 			    snptreef(NULL, 32, "%R", &iotmp),
-			    strerror(eno));
+			    cstrerror(eno));
 			if (iotype != IODUP)
 				close(u);
 			return (-1);
@@ -1425,7 +1436,7 @@
 static int
 hereinval(const char *content, int sub, char **resbuf, struct shf *shf)
 {
-	const char *ccp;
+	const char * volatile ccp = content;
 	struct source *s, *osource;
 
 	osource = source;
@@ -1439,14 +1450,13 @@
 	if (sub) {
 		/* do substitutions on the content of heredoc */
 		s = pushs(SSTRING, ATEMP);
-		s->start = s->str = content;
+		s->start = s->str = ccp;
 		source = s;
 		if (yylex(ONEWORD|HEREDOC) != LWORD)
 			internal_errorf("%s: %s", "herein", "yylex");
 		source = osource;
 		ccp = evalstr(yylval.cp, 0);
-	} else
-		ccp = content;
+	}
 
 	if (resbuf == NULL)
 		shf_puts(ccp, shf);
@@ -1484,7 +1494,7 @@
 	if (!(shf = h->shf) || (fd = open(h->tffn, O_RDONLY, 0)) < 0) {
 		i = errno;
 		warningf(true, "can't %s temporary file %s: %s",
-		    !shf ? "create" : "open", h->tffn, strerror(i));
+		    !shf ? "create" : "open", h->tffn, cstrerror(i));
 		if (shf)
 			shf_close(shf);
 		/* special to iosetup(): don't print error */
@@ -1501,7 +1511,7 @@
 		i = errno;
 		close(fd);
 		warningf(true, "can't %s temporary file %s: %s",
-		    "write", h->tffn, strerror(i));
+		    "write", h->tffn, cstrerror(i));
 		/* special to iosetup(): don't print error */
 		return (-2);
 	}
@@ -1534,7 +1544,7 @@
 		if (print_menu || !*str_val(global("REPLY")))
 			pr_menu(ap);
 		shellf("%s", str_val(global("PS3")));
-		if (call_builtin(findcom("read", FC_BI), read_args))
+		if (call_builtin(findcom("read", FC_BI), read_args, Tselect))
 			return (NULL);
 		s = str_val(global("REPLY"));
 		if (*s) {
Index: src/bin/mksh/funcs.c
diff -u src/bin/mksh/funcs.c:1.230 src/bin/mksh/funcs.c:1.237
--- src/bin/mksh/funcs.c:1.230	Tue Oct 30 20:13:18 2012
+++ src/bin/mksh/funcs.c	Tue Jan  1 20:45:02 2013
@@ -5,7 +5,7 @@
 
 /*-
  * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
- *		 2010, 2011, 2012
+ *		 2010, 2011, 2012, 2013
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -38,7 +38,7 @@
 #endif
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.230 2012/10/30 20:13:18 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.237 2013/01/01 20:45:02 tg Exp $");
 
 #if HAVE_KILLPG
 /*
@@ -220,8 +220,7 @@
 static void ptest_error(Test_env *, int, const char *);
 static char *kill_fmt_entry(char *, size_t, unsigned int, const void *);
 static void p_time(struct shf *, bool, long, int, int,
-    const char *, const char *)
-    MKSH_A_NONNULL((__nonnull__ (6, 7)));
+    const char *, const char *);
 
 int
 c_pwd(const char **wp)
@@ -254,7 +253,7 @@
 		p = NULL;
 	if (!p && !(p = allocd = ksh_get_wd())) {
 		bi_errorf("%s: %s", "can't determine current directory",
-		    strerror(errno));
+		    cstrerror(errno));
 		return (1);
 	}
 	shprintf("%s\n", p);
@@ -853,8 +852,6 @@
 	} else if (wp[builtin_opt.optind]) {
 		for (i = builtin_opt.optind; wp[i]; i++) {
 			varsearch(e->loc, &vp, wp[i], hash(wp[i]));
-			if (!vp)
-				continue;
 			c_typeset_vardump(vp, flag, thing, pflag, istset);
 		}
 	} else
@@ -884,6 +881,9 @@
 	int any_set = 0;
 	char *s;
 
+	if (!vp)
+		return;
+
 	/*
 	 * See if the parameter is set (for arrays, if any
 	 * element is set).
@@ -1379,7 +1379,7 @@
 			rv = 1;
 		} else {
 			if (mksh_kill(n, sig) < 0) {
-				bi_errorf("%s: %s", p, strerror(errno));
+				bi_errorf("%s: %s", p, cstrerror(errno));
 				rv = 1;
 			}
 		}
@@ -1726,7 +1726,7 @@
 		return (1);
 	}
 	if ((file = search_path(cp, path, R_OK, &errcode)) == NULL) {
-		bi_errorf("%s: %s", cp, strerror(errcode));
+		bi_errorf("%s: %s", cp, cstrerror(errcode));
 		return (1);
 	}
 
@@ -1743,7 +1743,7 @@
 	}
 	if ((i = include(file, argc, argv, false)) < 0) {
 		/* should not happen */
-		bi_errorf("%s: %s", cp, strerror(errno));
+		bi_errorf("%s: %s", cp, cstrerror(errno));
 		return (1);
 	}
 	return (i);
@@ -1834,7 +1834,7 @@
 #if HAVE_SELECT
 	case 't':
 		if (parse_usec(builtin_opt.optarg, &tv)) {
-			bi_errorf("%s: %s '%s'", Tsynerr, strerror(errno),
+			bi_errorf("%s: %s '%s'", Tsynerr, cstrerror(errno),
 			    builtin_opt.optarg);
 			return (2);
 		}
@@ -1916,7 +1916,7 @@
 			rv = 1;
 			goto c_read_out;
 		default:
-			bi_errorf("%s: %s", Tselect, strerror(errno));
+			bi_errorf("%s: %s", Tselect, cstrerror(errno));
 			rv = 2;
 			goto c_read_out;
 		}
@@ -2216,7 +2216,7 @@
 	exstat |= 0x4000;
 
 	savef = Flag(FERREXIT);
-	Flag(FERREXIT) = 0;
+	Flag(FERREXIT) |= 0x80;
 	rv = shell(s, false);
 	Flag(FERREXIT) = savef;
 	source = saves;
@@ -2710,7 +2710,7 @@
 			goto c_mknod_failed;
 	} else if (mkfifo(argv[0], mode)) {
  c_mknod_failed:
-		bi_errorf("%s: %s", argv[0], strerror(errno));
+		bi_errorf("%s: %s", argv[0], cstrerror(errno));
  c_mknod_err:
 		rv = 1;
 	}
@@ -2766,6 +2766,8 @@
 
 	for (argc = 0; wp[argc]; argc++)
 		;
+	mkssert(argc > 0);
+	mkssert(wp[0] != NULL);
 
 	if (strcmp(wp[0], "[") == 0) {
 		if (strcmp(wp[--argc], "]") != 0) {
@@ -2895,6 +2897,34 @@
 	if (!do_eval)
 		return (0);
 
+#ifdef DEBUG
+	switch (op) {
+	/* Binary operators */
+	case TO_STEQL:
+	case TO_STNEQ:
+	case TO_STLT:
+	case TO_STGT:
+	case TO_INTEQ:
+	case TO_INTNE:
+	case TO_INTGT:
+	case TO_INTGE:
+	case TO_INTLT:
+	case TO_INTLE:
+	case TO_FILEQ:
+	case TO_FILNT:
+	case TO_FILOT:
+		/* consistency check, but does not happen in practice */
+		if (!opnd2) {
+			te->flags |= TEF_ERROR;
+			return (1);
+		}
+		break;
+	default:
+		/* for completeness of switch */
+		break;
+	}
+#endif
+
 	switch (op) {
 
 	/*
@@ -3242,7 +3272,7 @@
 ptest_isa(Test_env *te, Test_meta meta)
 {
 	/* Order important - indexed by Test_meta values */
-	static const char *const tokens[] = {
+	static const char * const tokens[] = {
 		"-o", "-a", "!", "(", ")"
 	};
 	Test_op rv;
@@ -3580,7 +3610,7 @@
 	if (errno == EPERM)
 		bi_errorf("%s exceeds allowable %s limit", v, l->name);
 	else
-		bi_errorf("bad %s limit: %s", l->name, strerror(errno));
+		bi_errorf("bad %s limit: %s", l->name, cstrerror(errno));
 	return (1);
 }
 
@@ -3623,7 +3653,7 @@
 		bi_errorf(Tsynerr);
 	else if ((rv = rename(wp[0], wp[1])) != 0) {
 		rv = errno;
-		bi_errorf("%s: %s", "failed", strerror(rv));
+		bi_errorf("%s: %s", "failed", cstrerror(rv));
 	}
 
 	return (rv);
@@ -3646,7 +3676,7 @@
 		bi_errorf(Tsynerr);
 	else if ((buf = do_realpath(wp[0])) == NULL) {
 		rv = errno;
-		bi_errorf("%s: %s", wp[0], strerror(rv));
+		bi_errorf("%s: %s", wp[0], cstrerror(rv));
 		if ((unsigned int)rv > 255)
 			rv = 255;
 	} else {
@@ -3693,7 +3723,7 @@
 				fd = STDIN_FILENO;
 			else if ((fd = open(fn, O_RDONLY)) < 0) {
 				eno = errno;
-				bi_errorf("%s: %s", fn, strerror(eno));
+				bi_errorf("%s: %s", fn, cstrerror(eno));
 				rv = 1;
 				continue;
 			}
@@ -3709,7 +3739,7 @@
 					continue;
 				}
 				/* an error occured during reading */
-				bi_errorf("%s: %s", fn, strerror(eno));
+				bi_errorf("%s: %s", fn, cstrerror(eno));
 				rv = 1;
 				break;
 			} else if (n == 0)
@@ -3724,7 +3754,7 @@
 					/* an error occured during writing */
 					eno = errno;
 					bi_errorf("%s: %s", "<stdout>",
-					    strerror(eno));
+					    cstrerror(eno));
 					rv = 1;
 					if (fd != STDIN_FILENO)
 						close(fd);
@@ -3759,7 +3789,7 @@
 	if (!wp[0] || wp[1])
 		bi_errorf(Tsynerr);
 	else if (parse_usec(wp[0], &tv))
-		bi_errorf("%s: %s '%s'", Tsynerr, strerror(errno), wp[0]);
+		bi_errorf("%s: %s '%s'", Tsynerr, cstrerror(errno), wp[0]);
 	else {
 #ifndef MKSH_NOPROSPECTOFWORK
 		sigset_t omask, bmask;
@@ -3789,7 +3819,7 @@
 			 */
 			rv = 0;
 		else
-			bi_errorf("%s: %s", Tselect, strerror(errno));
+			bi_errorf("%s: %s", Tselect, cstrerror(errno));
 #ifndef MKSH_NOPROSPECTOFWORK
 		/* this will re-schedule signal delivery */
 		sigprocmask(SIG_SETMASK, &omask, NULL);
Index: src/bin/mksh/histrap.c
diff -u src/bin/mksh/histrap.c:1.128 src/bin/mksh/histrap.c:1.131
--- src/bin/mksh/histrap.c:1.128	Fri Nov 30 19:02:07 2012
+++ src/bin/mksh/histrap.c	Fri Dec 28 02:28:35 2012
@@ -27,7 +27,7 @@
 #include <sys/file.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.128 2012/11/30 19:02:07 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.131 2012/12/28 02:28:35 tg Exp $");
 
 Trap sigtraps[NSIG + 1];
 static struct sigaction Sigact_ign;
@@ -297,7 +297,7 @@
 	tf = maketemp(ATEMP, TT_HIST_EDIT, &e->temps);
 	if (!(shf = tf->shf)) {
 		bi_errorf("can't %s temporary file %s: %s",
-		    "create", tf->tffn, strerror(errno));
+		    "create", tf->tffn, cstrerror(errno));
 		return (1);
 	}
 	for (hp = rflag ? hlast : hfirst;
@@ -305,7 +305,7 @@
 		shf_fprintf(shf, "%s\n", *hp);
 	if (shf_close(shf) == EOF) {
 		bi_errorf("can't %s temporary file %s: %s",
-		    "write", tf->tffn, strerror(errno));
+		    "write", tf->tffn, cstrerror(errno));
 		return (1);
 	}
 
@@ -331,7 +331,7 @@
 
 		if (!(shf = shf_open(tf->tffn, O_RDONLY, 0, 0))) {
 			bi_errorf("can't %s temporary file %s: %s",
-			    "open", tf->tffn, strerror(errno));
+			    "open", tf->tffn, cstrerror(errno));
 			return (1);
 		}
 
@@ -351,7 +351,7 @@
 		}
 		if (n < 0) {
 			bi_errorf("can't %s temporary file %s: %s",
-			    "read", tf->tffn, strerror(shf_errno(shf)));
+			    "read", tf->tffn, cstrerror(shf_errno(shf)));
  errout:
 			shf_close(shf);
 			return (1);
@@ -634,6 +634,7 @@
 	char **hp;
 	char *c, *cp;
 
+	mkssert(cmd != NULL);
 	strdupx(c, cmd, APERM);
 	if ((cp = strchr(c, '\n')) != NULL)
 		*cp = '\0';
@@ -806,7 +807,7 @@
 		}
 		if (hs != hist_init_retry)
 			bi_errorf("can't %s %s: %s",
-			    "unlink HISTFILE", hname, strerror(errno));
+			    "unlink HISTFILE", hname, cstrerror(errno));
 		histfsize = 0;
 		return;
 	} else {
@@ -952,7 +953,7 @@
 
 #if !HAVE_SYS_SIGNAME
 static const struct mksh_sigpair {
-	const char *const name;
+	const char * const name;
 	int nr;
 } mksh_sigpairs[] = {
 #include "signames.inc"
@@ -960,6 +961,12 @@
 };
 #endif
 
+#if HAVE_SYS_SIGLIST
+#if !HAVE_SYS_SIGLIST_DECL
+extern const char * const sys_siglist[];
+#endif
+#endif
+
 void
 inittraps(void)
 {
Index: src/bin/mksh/jobs.c
diff -u src/bin/mksh/jobs.c:1.91 src/bin/mksh/jobs.c:1.94
--- src/bin/mksh/jobs.c:1.91	Fri Nov 30 19:25:03 2012
+++ src/bin/mksh/jobs.c	Fri Dec 28 02:28:36 2012
@@ -22,7 +22,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.91 2012/11/30 19:25:03 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.94 2012/12/28 02:28:36 tg Exp $");
 
 #if HAVE_KILLPG
 #define mksh_killpg		killpg
@@ -107,7 +107,7 @@
 #define JL_AMBIG	2	/* %foo or %?foo is ambiguous */
 #define JL_INVALID	3	/* non-pid, non-% job id */
 
-static const char *const lookup_msgs[] = {
+static const char * const lookup_msgs[] = {
 	null,
 	"no such job",
 	"ambiguous",
@@ -306,7 +306,7 @@
 				if ((ttypgrp = tcgetpgrp(tty_fd)) < 0) {
 					warningf(false, "%s: %s %s: %s",
 					    "j_init", "tcgetpgrp", "failed",
-					    strerror(errno));
+					    cstrerror(errno));
 					ttypgrp_ok = false;
 					break;
 				}
@@ -321,13 +321,13 @@
 		if (ttypgrp_ok && kshpgrp != kshpid) {
 			if (setpgid(0, kshpid) < 0) {
 				warningf(false, "%s: %s %s: %s", "j_init",
-				    "setpgid", "failed", strerror(errno));
+				    "setpgid", "failed", cstrerror(errno));
 				ttypgrp_ok = false;
 			} else {
 				if (tcsetpgrp(tty_fd, kshpid) < 0) {
 					warningf(false, "%s: %s %s: %s",
 					    "j_init", "tcsetpgrp", "failed",
-					    strerror(errno));
+					    cstrerror(errno));
 					ttypgrp_ok = false;
 				} else
 					restore_ttypgrp = kshpgrp;
@@ -370,7 +370,7 @@
 	errno = 0;
 	/* this is gonna annoy users; complain to your distro, people! */
 	if (nice(ness) == -1 && (eno = errno) != 0)
-		warningf(false, "%s: %s", "bgnice", strerror(eno));
+		warningf(false, "%s: %s", "bgnice", cstrerror(eno));
 #else
 	(void)nice(ness);
 #endif
@@ -735,7 +735,7 @@
 	if (j->pgrp == 0) {
 		/* started when !Flag(FMONITOR) */
 		if (kill_job(j, sig) < 0) {
-			bi_errorf("%s: %s", cp, strerror(errno));
+			bi_errorf("%s: %s", cp, cstrerror(errno));
 			rv = 1;
 		}
 	} else {
@@ -744,7 +744,7 @@
 			mksh_killpg(j->pgrp, SIGCONT);
 #endif
 		if (mksh_killpg(j->pgrp, sig) < 0) {
-			bi_errorf("%s: %s", cp, strerror(errno));
+			bi_errorf("%s: %s", cp, cstrerror(errno));
 			rv = 1;
 		}
 	}
@@ -820,7 +820,7 @@
 				    "1st", "tcsetpgrp", tty_fd,
 				    (long)((j->flags & JF_SAVEDTTYPGRP) ?
 				    j->saved_ttypgrp : j->pgrp), "failed",
-				    strerror(rv));
+				    cstrerror(rv));
 				return (1);
 			}
 		}
@@ -840,11 +840,11 @@
 			if (ttypgrp_ok && tcsetpgrp(tty_fd, kshpgrp) < 0)
 				warningf(true, "%s %s(%d, %ld) %s: %s",
 				    "fg: 2nd", "tcsetpgrp", tty_fd,
-				    (long)kshpgrp, "failed", strerror(errno));
+				    (long)kshpgrp, "failed", cstrerror(errno));
 		}
 		sigprocmask(SIG_SETMASK, &omask, NULL);
 		bi_errorf("%s %s %s", "can't continue job",
-		    cp, strerror(eno));
+		    cp, cstrerror(eno));
 		return (1);
 	}
 	if (!bg) {
@@ -1131,7 +1131,7 @@
 			if (tcsetpgrp(tty_fd, kshpgrp) < 0)
 				warningf(true, "%s %s(%d, %ld) %s: %s",
 				    "j_waitj:", "tcsetpgrp", tty_fd,
-				    (long)kshpgrp, "failed", strerror(errno));
+				    (long)kshpgrp, "failed", cstrerror(errno));
 			if (j->state == PSTOPPED) {
 				j->flags |= JF_SAVEDTTY;
 				mksh_tcget(tty_fd, &j->ttystat);
@@ -1722,10 +1722,13 @@
 	Proc	*p, *tmp;
 	Job	**prev, *curr;
 
+	mkssert(j != NULL);
 	prev = &job_list;
-	curr = *prev;
-	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
-		;
+	curr = job_list;
+	while (curr && curr != j) {
+		prev = &curr->next;
+		curr = *prev;
+	}
 	if (curr != j) {
 		internal_warningf("remove_job: job %s (%s)", "not found", where);
 		return;
@@ -1762,11 +1765,14 @@
 {
 	Job	**prev, *curr;
 
+	mkssert(j != NULL);
 	/* Remove job from list (if there) */
 	prev = &job_list;
 	curr = job_list;
-	for (; curr && curr != j; prev = &curr->next, curr = *prev)
-		;
+	while (curr && curr != j) {
+		prev = &curr->next;
+		curr = *prev;
+	}
 	if (curr == j)
 		*prev = curr->next;
 
@@ -1816,21 +1822,21 @@
 #ifndef MKSH_DISABLE_TTY_WARNING
 		warningf(false, "%s: %s %s: %s",
 		    "No controlling tty", "open", "/dev/tty",
-		    strerror(errno));
+		    cstrerror(errno));
 #endif
 		break;
 	case 2:
 #ifndef MKSH_DISABLE_TTY_WARNING
-		warningf(false, "%s: %s", "can't find tty fd", strerror(errno));
+		warningf(false, "%s: %s", "can't find tty fd", cstrerror(errno));
 #endif
 		break;
 	case 3:
 		warningf(false, "%s: %s %s: %s", "j_ttyinit",
-		    "dup of tty fd", "failed", strerror(errno));
+		    "dup of tty fd", "failed", cstrerror(errno));
 		break;
 	case 4:
 		warningf(false, "%s: %s: %s", "j_ttyinit",
-		    "can't set close-on-exec flag", strerror(errno));
+		    "can't set close-on-exec flag", cstrerror(errno));
 		break;
 	}
 }
Index: src/bin/mksh/lex.c
diff -u src/bin/mksh/lex.c:1.171 src/bin/mksh/lex.c:1.174
--- src/bin/mksh/lex.c:1.171	Fri Nov 30 19:02:08 2012
+++ src/bin/mksh/lex.c	Wed Dec  5 19:38:20 2012
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.171 2012/11/30 19:02:08 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.174 2012/12/05 19:38:20 tg Exp $");
 
 /*
  * states while lexing word
@@ -104,12 +104,9 @@
 static Lex_state *pop_state_i(State_info *, Lex_state *);
 
 static int dopprompt(const char *, int, bool);
-void yyskiputf8bom(void);
 
 static int backslash_skip;
 static int ignore_backslash_newline;
-struct sretrace_info *retrace_info = NULL;
-int subshell_nesting_type = 0;
 
 /* optimised getsc_bn() */
 #define o_getsc()	(*source->str != '\0' && *source->str != '\\' && \
@@ -262,13 +259,11 @@
 	while (!((c = getsc()) == 0 ||
 	    ((state == SBASE || state == SHEREDELIM || state == SHERESTRING) &&
 	    ctype(c, C_LEX1)))) {
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 		if (state == SBASE &&
 		    subshell_nesting_type == /*{*/ '}' &&
 		    c == /*{*/ '}')
 			/* possibly end ${ :;} */
 			break;
-#endif
  accept_nonword:
 		Xcheck(ws, wp);
 		switch (state) {
@@ -277,8 +272,8 @@
 				statep->nparen++;
 			else if (c == ')')
 				statep->nparen--;
-			else if (statep->nparen == 0 &&
-			    (c == /*{*/ '}' || c == statep->ls_adelim.delimiter)) {
+			else if (statep->nparen == 0 && (c == /*{*/ '}' ||
+			    c == (int)statep->ls_adelim.delimiter)) {
 				*wp++ = ADELIM;
 				*wp++ = c;
 				if (c == /*{*/ '}' || --statep->ls_adelim.num == 0)
@@ -403,9 +398,7 @@
 						ungetsc(c);
  subst_command:
 						c = COMSUB;
-#ifndef MKSH_DISABLE_EXPERIMENTAL
  subst_command2:
-#endif
 						sp = yyrecursive(c);
 						cz = strlen(sp) + 1;
 						XcheckN(ws, wp, cz);
@@ -414,7 +407,6 @@
 						wp += cz;
 					}
 				} else if (c == '{') /*}*/ {
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 					c = getsc();
 					if (ctype(c, C_IFSWS)) {
 						/*
@@ -425,7 +417,6 @@
 						goto subst_command2;
 					}
 					ungetsc(c);
-#endif
 					*wp++ = OSUBST;
 					*wp++ = '{'; /*}*/
 					wp = get_brace_var(&ws, wp);
Index: src/bin/mksh/main.c
diff -u src/bin/mksh/main.c:1.245 src/bin/mksh/main.c:1.252
--- src/bin/mksh/main.c:1.245	Fri Nov 30 19:58:47 2012
+++ src/bin/mksh/main.c	Sun Jan  6 18:44:07 2013
@@ -5,7 +5,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012
+ *		 2011, 2012, 2013
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -34,7 +34,7 @@
 #include <locale.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/main.c,v 1.245 2012/11/30 19:58:47 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/main.c,v 1.252 2013/01/06 18:44:07 tg Exp $");
 
 extern char **environ;
 
@@ -254,7 +254,7 @@
 #ifdef MKSH_BINSHREDUCED
 		/* set FSH if we're called as -sh or /bin/sh or so */
 		if (!strcmp(ccp, "sh"))
-			change_flag(FSH, OF_FIRSTTIME, 1);
+			change_flag(FSH, OF_FIRSTTIME, true);
 #endif
 	}
 
@@ -329,7 +329,7 @@
 	 * by the environment or the user. Also, we want tab completion
 	 * on in vi by default.
 	 */
-	change_flag(FEMACS, OF_SPECIAL, 1);
+	change_flag(FEMACS, OF_SPECIAL, true);
 #if !MKSH_S_NOVI
 	Flag(FVITABCOMPLETE) = 1;
 #endif
@@ -460,7 +460,7 @@
 		s = pushs(SSTRINGCMDLINE, ATEMP);
 		if (!(s->start = s->str = argv[argi++]))
 			errorf("%s %s", "-c", "requires an argument");
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 		while (*s->str) {
 			if (*s->str != ' ' && ctype(*s->str, C_QUOTE))
 				break;
@@ -484,7 +484,7 @@
 		    SHF_MAPHI | SHF_CLEXEC);
 		if (s->u.shf == NULL) {
 			shl_stdout_ok = false;
-			warningf(true, "%s: %s", s->file, strerror(errno));
+			warningf(true, "%s: %s", s->file, cstrerror(errno));
 			/* mandated by SUSv4 */
 			exstat = 127;
 			unwind(LERROR);
@@ -849,7 +849,7 @@
 				break;
 			}
 		}
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 		  else if ((s->flags & SF_MAYEXEC) && t->type == TCOM)
 			t->u.evalflags |= DOTCOMEXEC;
 #endif
@@ -872,19 +872,36 @@
 void
 unwind(int i)
 {
+	/*
+	 * This is a kludge. We need to restore everything that was
+	 * changed in the new environment, see cid 1005090337C7A669439
+	 * and 10050903386452ACBF1, but fail to even save things most of
+	 * the time. funcs.c:c_eval() changes FERREXIT temporarily to 0,
+	 * which needs to be restored thus (related to Debian #696823).
+	 * We did not save the shell flags, so we use a special or'd
+	 * value here... this is mostly to clean up behind *other*
+	 * callers of unwind(LERROR) here; exec.c has the regular case.
+	 */
+	if (Flag(FERREXIT) & 0x80) {
+		/* GNU bash does not run this trapsig */
+		trapsig(ksh_SIGERR);
+		Flag(FERREXIT) &= ~0x80;
+	}
+
 	/* ordering for EXIT vs ERR is a bit odd (this is what AT&T ksh does) */
-	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR) &&
-	    sigtraps[ksh_SIGEXIT].trap)) {
+	if (i == LEXIT ||
+	    ((i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
 		++trap_nested;
 		runtrap(&sigtraps[ksh_SIGEXIT], trap_nested == 1);
 		--trap_nested;
 		i = LLEAVE;
-	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
+	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
 		++trap_nested;
 		runtrap(&sigtraps[ksh_SIGERR], trap_nested == 1);
 		--trap_nested;
 		i = LLEAVE;
 	}
+
 	while (/* CONSTCOND */ 1) {
 		switch (e->type) {
 		case E_PARSE:
@@ -1319,8 +1336,11 @@
 	shf_fdopen(2, SHF_WR, shl_out);
 	shf_fdopen(2, SHF_WR, shl_spare);
 #ifdef DF
-	if ((lfp = getenv("SDMKSH_PATH")) == NULL)
-		lfp = "/tmp/mksh-dbg.txt";
+	if ((lfp = getenv("SDMKSH_PATH")) == NULL) {
+		if ((lfp = getenv("HOME")) == NULL || *lfp != '/')
+			errorf("cannot get home directory");
+		lfp = shf_smprintf("%s/mksh-dbg.txt", lfp);
+	}
 
 	if ((shl_dbg_fd = open(lfp, O_WRONLY | O_APPEND | O_CREAT, 0600)) < 0)
 		errorf("cannot open debug output file %s", lfp);
@@ -1593,7 +1613,6 @@
 		/* do another cycle */
 	}
 
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 	if (type == TT_FUNSUB) {
 		int nfd;
 
@@ -1603,7 +1622,6 @@
 			i = nfd;
 		}
 	}
-#endif
 
 	/* shf_fdopen cannot fail, so no fd leak */
 	tp->shf = shf_fdopen(i, SHF_WR, NULL);
@@ -1656,7 +1674,7 @@
 		if ((tblp = otblp[i]) != NULL) {
 			if ((tblp->flag & DEFINED)) {
 				/* search for free hash table slot */
-				j = (perturb = tblp->ua.hval) & mask;
+				j = perturb = tblp->ua.hval;
 				goto find_first_empty_slot;
  find_next_empty_slot:
 				j = (j << 2) + j + perturb + 1;
@@ -1694,7 +1712,7 @@
 
 	mask = ((size_t)1 << (tp->tshift)) - 1;
 	/* search for hash table slot matching name */
-	j = (perturb = h) & mask;
+	j = perturb = h;
 	goto find_first_slot;
  find_next_slot:
 	j = (j << 2) + j + perturb + 1;
Index: src/bin/mksh/misc.c
diff -u src/bin/mksh/misc.c:1.201 src/bin/mksh/misc.c:1.205
--- src/bin/mksh/misc.c:1.201	Fri Nov 30 17:34:46 2012
+++ src/bin/mksh/misc.c	Mon Dec 17 23:18:08 2012
@@ -30,7 +30,7 @@
 #include <grp.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.201 2012/11/30 17:34:46 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.205 2012/12/17 23:18:08 tg Exp $");
 
 #define KSH_CHVT_FLAG
 #ifdef MKSH_SMALL
@@ -52,7 +52,7 @@
     const unsigned char *, bool);
 static int do_gmatch(const unsigned char *, const unsigned char *,
     const unsigned char *, const unsigned char *);
-static const unsigned char *cclass(const unsigned char *, int);
+static const unsigned char *cclass(const unsigned char *, unsigned char);
 #ifdef KSH_CHVT_CODE
 static void chvt(const char *);
 #endif
@@ -226,13 +226,13 @@
 
 /* change a Flag(*) value; takes care of special actions */
 void
-change_flag(enum sh_flag f, int what, unsigned int newval)
+change_flag(enum sh_flag f, int what, bool newset)
 {
 	unsigned char oldval;
+	unsigned char newval;
 
 	oldval = Flag(f);
-	/* needed for tristates */
-	Flag(f) = newval ? 1 : 0;
+	Flag(f) = newval = (newset ? 1 : 0);
 #ifndef MKSH_UNEMPLOYED
 	if (f == FMONITOR) {
 		if (what != OF_CMDLINE && newval != oldval)
@@ -249,7 +249,7 @@
 		Flag(FVI) =
 #endif
 		    Flag(FEMACS) = Flag(FGMACS) = 0;
-		Flag(f) = (unsigned char)newval;
+		Flag(f) = newval;
 	} else
 #endif
 	  if (f == FPRIVILEGED && oldval && !newval) {
@@ -278,12 +278,12 @@
 #endif
 	} else if ((f == FPOSIX || f == FSH) && newval) {
 		Flag(FPOSIX) = Flag(FSH) = Flag(FBRACEEXPAND) = 0;
-		Flag(f) = (unsigned char)newval;
+		Flag(f) = newval;
 	}
 	/* Changing interactive flag? */
 	if (f == FTALKING) {
 		if ((what == OF_CMDLINE || what == OF_SET) && procpid == kshpid)
-			Flag(FTALKING_I) = (unsigned char)newval;
+			Flag(FTALKING_I) = newval;
 	}
 }
 
@@ -299,7 +299,8 @@
 {
 	static char cmd_opts[NELEM(options) + 5]; /* o:T:\0 */
 	static char set_opts[NELEM(options) + 6]; /* A:o;s\0 */
-	char set, *opts;
+	bool set;
+	char *opts;
 	const char *array = NULL;
 	Getopt go;
 	size_t i;
@@ -354,7 +355,7 @@
 		opts = set_opts;
 	ksh_getopt_reset(&go, GF_ERROR|GF_PLUSOPT);
 	while ((optc = ksh_getopt(argv, &go, opts)) != -1) {
-		set = (go.info & GI_PLUS) ? 0 : 1;
+		set = tobool(!(go.info & GI_PLUS));
 		switch (optc) {
 		case 'A':
 			if (what == OF_FIRSTTIME)
@@ -378,7 +379,7 @@
 				break;
 			}
 			i = option(go.optarg);
-			if ((i != (size_t)-1) && set == Flag(i))
+			if ((i != (size_t)-1) && (set ? 1U : 0U) == Flag(i))
 				/*
 				 * Don't check the context if the flag
 				 * isn't changing - makes "set -o interactive"
@@ -401,7 +402,7 @@
 #ifndef KSH_CHVT_CODE
 			errorf("no TIOCSCTTY ioctl");
 #else
-			change_flag(FTALKING, OF_CMDLINE, 1);
+			change_flag(FTALKING, OF_CMDLINE, true);
 			chvt(go.optarg);
 			break;
 #endif
@@ -445,6 +446,7 @@
 	if (arrayset) {
 		const char *ccp = NULL;
 
+		mkssert(array != NULL);
 		if (*array)
 			ccp = skip_varname(array, false);
 		if (!ccp || !(!ccp[0] || (ccp[0] == '+' && !ccp[1]))) {
@@ -469,33 +471,40 @@
 int
 getn(const char *s, int *ai)
 {
-	int c;
-	unsigned int i, j, k;
+	char c;
+	unsigned int i = 0;
 	bool neg = false;
-	int rv = 0;
 
 	do {
 		c = *s++;
 	} while (ksh_isspace(c));
-	if (c == '-') {
+
+	switch (c) {
+	case '-':
 		neg = true;
+		/* FALLTHROUGH */
+	case '+':
 		c = *s++;
-	} else if (c == '+')
-		c = *s++;
-	k = neg ? 2147483648U : 2147483647U;
-	j = i = 0;
+		break;
+	}
+
 	do {
 		if (!ksh_isdigit(c))
-			goto getn_out;
-		if ((j = i * 10 + c - '0') > k)
-			goto getn_out;
-		i = j;
+			/* not numeric */
+			return (0);
+		if (i > 214748364U)
+			/* overflow on multiplication */
+			return (0);
+		i = i * 10U + (unsigned int)(c - '0');
+		/* now: i <= 2147483649U */
 	} while ((c = *s++));
-	rv = 1;
 
- getn_out:
-	*ai = i == 2147483648U ? (int)i : neg ? -(int)i : (int)i;
-	return (rv);
+	if (i > (neg ? 2147483648U : 2147483647U))
+		/* overflow for signed 32-bit int */
+		return (0);
+
+	*ai = neg ? -(int)i : (int)i;
+	return (1);
 }
 
 /**
@@ -698,7 +707,7 @@
 do_gmatch(const unsigned char *s, const unsigned char *se,
     const unsigned char *p, const unsigned char *pe)
 {
-	int sc, pc;
+	unsigned char sc, pc;
 	const unsigned char *prest, *psub, *pnext;
 	const unsigned char *srest;
 
@@ -828,12 +837,13 @@
 }
 
 static const unsigned char *
-cclass(const unsigned char *p, int sub)
+cclass(const unsigned char *p, unsigned char sub)
 {
-	int c, d, notp, found = 0;
+	unsigned char c, d;
+	bool notp, found = false;
 	const unsigned char *orig_p = p;
 
-	if ((notp = (ISMAGIC(*p) && *++p == '!')))
+	if ((notp = tobool(ISMAGIC(*p) && *++p == '!')))
 		p++;
 	do {
 		c = *p++;
@@ -867,7 +877,7 @@
 		} else
 			d = c;
 		if (c == sub || (c <= sub && sub <= d))
-			found = 1;
+			found = true;
 	} while (!(ISMAGIC(p[0]) && p[1] == ']'));
 
 	return ((found != notp) ? p+2 : NULL);
@@ -1843,7 +1853,7 @@
 		if (cdnode)
 			bi_errorf("%s: %s", dir, "bad directory");
 		else
-			bi_errorf("%s: %s", tryp, strerror(errno));
+			bi_errorf("%s: %s", tryp, cstrerror(errno));
 		afree(allocd, ATEMP);
 		Xfree(xs, xp);
 		return (2);
Index: src/bin/mksh/sh.h
diff -u src/bin/mksh/sh.h:1.608.2.1 src/bin/mksh/sh.h:1.627
--- src/bin/mksh/sh.h:1.608.2.1	Fri Nov 30 20:49:13 2012
+++ src/bin/mksh/sh.h	Sun Jan  6 18:51:43 2013
@@ -10,7 +10,7 @@
 
 /*-
  * Copyright Â© 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *	       2011, 2012
+ *	       2011, 2012, 2013
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -38,7 +38,14 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
+#if HAVE_BOTH_TIME_H
 #include <sys/time.h>
+#include <time.h>
+#elif HAVE_SYS_TIME_H
+#include <sys/time.h>
+#elif HAVE_TIME_H
+#include <time.h>
+#endif
 #include <sys/ioctl.h>
 #if HAVE_SYS_SYSMACROS_H
 #include <sys/sysmacros.h>
@@ -49,7 +56,9 @@
 #if HAVE_SYS_MMAN_H
 #include <sys/mman.h>
 #endif
+#if HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
+#endif
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <dirent.h>
@@ -85,7 +94,10 @@
 /* shudderâ€¦ */
 #include <termio.h>
 #endif
-#include <time.h>
+#ifdef _ISC_UNIX
+/* XXX imake style */
+#include <sys/sioctl.h>
+#endif
 #if HAVE_ULIMIT_H
 #include <ulimit.h>
 #endif
@@ -105,11 +117,6 @@
 #else
 #define MKSH_A_FORMAT(x,y,z)	/* nothing */
 #endif
-#if HAVE_ATTRIBUTE_NONNULL
-#define MKSH_A_NONNULL(a)	__attribute__(a)
-#else
-#define MKSH_A_NONNULL(a)	/* nothing */
-#endif
 #if HAVE_ATTRIBUTE_NORETURN
 #define MKSH_A_NORETURN		__attribute__((__noreturn__))
 #else
@@ -157,9 +164,9 @@
 #endif
 
 #ifdef EXTERN
-__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.1 2012/11/30 20:49:13 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.627 2013/01/06 18:51:43 tg Exp $");
 #endif
-#define MKSH_VERSION "R41 2012/11/30"
+#define MKSH_VERSION "R41 2013/01/06"
 
 /* arithmetic types: C implementation */
 #if !HAVE_CAN_INTTYPES
@@ -328,6 +335,8 @@
 #define NSIG		_NSIG
 #elif defined(SIGMAX)
 #define NSIG		(SIGMAX+1)
+#elif defined(_SIGMAX)
+#define NSIG		(_SIGMAX+1)
 #endif
 #endif
 
@@ -351,16 +360,25 @@
 extern int getrusage(int, struct rusage *);
 #endif
 
+#if !HAVE_MEMMOVE
+/* we assume either memmove or bcopy exist, at the moment */
+#define memmove(dst, src, len)	bcopy((src), (dst), (len))
+#endif
+
 #if !HAVE_REVOKE_DECL
 extern int revoke(const char *);
 #endif
 
-#if !HAVE_STRLCPY
-size_t strlcpy(char *, const char *, size_t);
+#if defined(DEBUG) || !HAVE_STRERROR
+#define strerror		/* poisoned */ dontuse_strerror
+#define cstrerror		/* replaced */ cstrerror
+extern const char *cstrerror(int);
+#else
+#define cstrerror(errnum)	((const char *)strerror(errnum))
 #endif
 
-#if !HAVE_SYS_SIGLIST_DECL
-extern const char *const sys_siglist[];
+#if !HAVE_STRLCPY
+size_t strlcpy(char *, const char *, size_t);
 #endif
 
 #ifdef __INTERIX
@@ -477,16 +495,20 @@
 })
 #define vstrchr(s,c)	(cstrchr((s), (c)) != NULL)
 #define vstrstr(b,l)	(cstrstr((b), (l)) != NULL)
-#define mkssert(e)	((e) ? (void)0 : exit(255))
 #else /* !DEBUG, !gcc */
 #define cstrchr(s,c)	((const char *)strchr((s), (c)))
 #define cstrstr(s,c)	((const char *)strstr((s), (c)))
 #define vstrchr(s,c)	(strchr((s), (c)) != NULL)
 #define vstrstr(b,l)	(strstr((b), (l)) != NULL)
-#define mkssert(e)	((void)0)
 #endif
 
-#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 411)
+#if defined(DEBUG) || defined(__COVERITY__)
+#define mkssert(e)	do { if (!(e)) exit(255); } while (/* CONSTCOND */ 0)
+#else
+#define mkssert(e)	do { } while (/* CONSTCOND */ 0)
+#endif
+
+#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 419)
 #error Must run Build.sh to compile this.
 int
 im_sorry_dave(void)
@@ -652,7 +674,8 @@
 struct sretrace_info;
 struct yyrecursive_state;
 
-extern struct sretrace_info *retrace_info;
+EXTERN struct sretrace_info *retrace_info E_INIT(NULL);
+EXTERN int subshell_nesting_type E_INIT(0);
 
 extern struct env {
 	ALLOC_ITEM alloc_INT;	/* internal, do not touch */
@@ -785,10 +808,8 @@
 #define TT_HEREDOC_EXP	0
 /* temporary file used for history editing (fc -e) */
 #define TT_HIST_EDIT	1
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 /* temporary file used during in-situ command substitution */
 #define TT_FUNSUB	2
-#endif
 
 /* temp/heredoc files. The file is removed when the struct is freed. */
 struct temp {
@@ -1300,9 +1321,7 @@
 #define SPAT	10	/* separate pattern: | */
 #define CPAT	11	/* close pattern: ) */
 #define ADELIM	12	/* arbitrary delimiter: ${foo:2:3} ${foo/bar/baz} */
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 #define FUNSUB	14	/* ${ foo;} substitution (NUL terminated) */
-#endif
 
 /*
  * IO redirection
@@ -1361,7 +1380,7 @@
 #define DOTEMP	BIT(8)		/* dito: in word part of ${..[%#=?]..} */
 #define DOVACHECK BIT(9)	/* var assign check (for typeset, set, etc) */
 #define DOMARKDIRS BIT(10)	/* force markdirs behaviour */
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 #define DOTCOMEXEC BIT(11)	/* not an eval flag, used by sh -c hack */
 #endif
 
@@ -1507,7 +1526,7 @@
 #define SF_ALIASEND	BIT(2)	/* faking space at end of alias */
 #define SF_TTY		BIT(3)	/* type == SSTDIN & it is a tty */
 #define SF_HASALIAS	BIT(4)	/* u.tblp valid (SALIAS, SEOF) */
-#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
+#if !defined(MKSH_SMALL)
 #define SF_MAYEXEC	BIT(5)	/* special sh -c optimisation hack */
 #endif
 
@@ -1802,6 +1821,7 @@
 int j_stopped_running(void);
 /* lex.c */
 int yylex(int);
+void yyskiputf8bom(void);
 void yyerror(const char *, ...)
     MKSH_A_NORETURN
     MKSH_A_FORMAT(__printf__, 1, 2);
@@ -1875,7 +1895,7 @@
 void initctypes(void);
 size_t option(const char *);
 char *getoptions(void);
-void change_flag(enum sh_flag, int, unsigned int);
+void change_flag(enum sh_flag, int, bool);
 int parse_args(const char **, int, bool *);
 int getn(const char *, int *);
 int gmatchx(const char *, const char *, bool);
@@ -1970,8 +1990,7 @@
 struct tbl *setint_v(struct tbl *, struct tbl *, bool);
 void setint(struct tbl *, mksh_ari_t);
 void setint_n(struct tbl *, mksh_ari_t, int);
-struct tbl *typeset(const char *, uint32_t, uint32_t, int, int)
-    MKSH_A_NONNULL((__nonnull__ (1)));
+struct tbl *typeset(const char *, uint32_t, uint32_t, int, int);
 void unset(struct tbl *, int);
 const char *skip_varname(const char *, int);
 const char *skip_wdvarname(const char *, bool);
@@ -2034,7 +2053,7 @@
 	int flags;			/* TEF_* */
 } Test_env;
 
-extern const char *const dbtest_tokens[];
+extern const char * const dbtest_tokens[];
 
 Test_op	test_isop(Test_meta, const char *);
 int test_eval(Test_env *, Test_op, const char *, const char *, bool);
Index: src/bin/mksh/shf.c
diff -u src/bin/mksh/shf.c:1.47 src/bin/mksh/shf.c:1.56
--- src/bin/mksh/shf.c:1.47	Wed Oct  3 16:16:15 2012
+++ src/bin/mksh/shf.c	Tue Jan  1 03:32:44 2013
@@ -1,7 +1,7 @@
 /*	$OpenBSD: shf.c,v 1.15 2006/04/02 00:48:33 deraadt Exp $	*/
 
 /*-
- * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
+ * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
  *	Thorsten Glaser <tg@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -24,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47 2012/10/03 16:16:15 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.56 2013/01/01 03:32:44 tg Exp $");
 
 /* flags to shf_emptybuf() */
 #define EB_READSW	0x01	/* about to switch to reading */
@@ -490,7 +490,7 @@
 		return (NULL);
 
 	/* save room for NUL */
-	--bsize;	
+	--bsize;
 	do {
 		if (shf->rnleft == 0) {
 			if (shf_fillbuf(shf) == EOF)
@@ -552,7 +552,7 @@
 		 * Can unget what was read, but not something different;
 		 * we don't want to modify a string.
 		 */
-		if (shf->rp[-1] != c)
+		if ((int)(shf->rp[-1]) != c)
 			return (EOF);
 		shf->flags &= ~SHF_EOF;
 		shf->rp--;
@@ -722,7 +722,7 @@
 	n = shf_vfprintf(&shf, fmt, args);
 	va_end(args);
 	/* NUL terminates */
-	shf_sclose(&shf); 
+	shf_sclose(&shf);
 	return (n);
 }
 
@@ -764,7 +764,12 @@
 	ssize_t field, precision, len;
 	unsigned long lnum;
 	/* %#o produces the longest output */
-	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
+	char numbuf[(8 * sizeof(long) + 2) / 3 + 1
+#ifdef DEBUG
+		/* a NUL for LLVM/Clang scan-build */
+		+ 1
+#endif
+	    ];
 	/* this stuff for dealing with the buffer */
 	ssize_t nwritten = 0;
 
@@ -902,6 +907,16 @@
  integral:
 			flags |= FL_NUMBER;
 			cp = numbuf + sizeof(numbuf);
+#ifdef DEBUG
+			/*
+			 * this is necessary so Clang 3.2 realises
+			 * utf_skipcols/shf_putc in the output loop
+			 * terminate; these values are always ASCII
+			 * so an out-of-bounds access cannot happen
+			 * but Clang doesn't know that
+			 */
+			*--cp = '\0';
+#endif
 
 			switch (c) {
 			case 'd':
@@ -953,6 +968,10 @@
 			}
 			}
 			len = numbuf + sizeof(numbuf) - (s = cp);
+#ifdef DEBUG
+			/* see above comment for Clang 3.2 */
+			--len;
+#endif
 			if (flags & FL_DOT) {
 				if (precision > len) {
 					field = precision;
@@ -971,14 +990,13 @@
 
 		case 'c':
 			flags &= ~FL_DOT;
-			numbuf[0] = (char)(VA(int));
-			s = numbuf;
-			len = 1;
-			break;
+			c = (char)(VA(int));
+			/* FALLTHROUGH */
 
 		case '%':
 		default:
 			numbuf[0] = c;
+			numbuf[1] = 0;
 			s = numbuf;
 			len = 1;
 			break;
@@ -1059,3 +1077,82 @@
 	return (shf_putc_i(c, shf));
 }
 #endif
+
+#ifdef DEBUG
+const char *
+cstrerror(int errnum)
+{
+#undef strerror
+	return (strerror(errnum));
+#define strerror dontuse_strerror /* poisoned */
+}
+#elif !HAVE_STRERROR
+
+#if HAVE_SYS_ERRLIST
+#if !HAVE_SYS_ERRLIST_DECL
+extern const int sys_nerr;
+extern const char * const sys_errlist[];
+#endif
+#endif
+
+const char *
+cstrerror(int errnum)
+{
+	/* "Unknown error: " + sign + rough estimate + NUL */
+	static char errbuf[15 + 1 + (8 * sizeof(int) + 2) / 3 + 1];
+
+#if HAVE_SYS_ERRLIST
+	if (errnum > 0 && errnum < sys_nerr && sys_errlist[errnum])
+		return (sys_errlist[errnum]);
+#endif
+
+	switch (errnum) {
+	case 0:
+		return ("Undefined error: 0");
+#ifdef EPERM
+	case EPERM:
+		return ("Operation not permitted");
+#endif
+#ifdef ENOENT
+	case ENOENT:
+		return ("No such file or directory");
+#endif
+#ifdef ESRCH
+	case ESRCH:
+		return ("No such process");
+#endif
+#ifdef E2BIG
+	case E2BIG:
+		return ("Argument list too long");
+#endif
+#ifdef ENOEXEC
+	case ENOEXEC:
+		return ("Exec format error");
+#endif
+#ifdef ENOMEM
+	case ENOMEM:
+		return ("Cannot allocate memory");
+#endif
+#ifdef EACCES
+	case EACCES:
+		return ("Permission denied");
+#endif
+#ifdef ENOTDIR
+	case ENOTDIR:
+		return ("Not a directory");
+#endif
+#ifdef EINVAL
+	case EINVAL:
+		return ("Invalid argument");
+#endif
+#ifdef ELOOP
+	case ELOOP:
+		return ("Too many levels of symbolic links");
+#endif
+	default:
+		shf_snprintf(errbuf, sizeof(errbuf),
+		    "Unknown error: %d", errnum);
+		return (errbuf);
+	}
+}
+#endif
Index: src/bin/mksh/syn.c
diff -u src/bin/mksh/syn.c:1.84 src/bin/mksh/syn.c:1.88
--- src/bin/mksh/syn.c:1.84	Tue Oct 30 20:49:44 2012
+++ src/bin/mksh/syn.c	Fri Dec 28 02:28:39 2012
@@ -23,10 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.84 2012/10/30 20:49:44 tg Exp $");
-
-extern int subshell_nesting_type;
-extern void yyskiputf8bom(void);
+__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.88 2012/12/28 02:28:39 tg Exp $");
 
 struct nesting_state {
 	int start_token;	/* token than began nesting (eg, FOR) */
@@ -771,7 +768,7 @@
 	return (t);
 }
 
-const struct tokeninfo {
+static const struct tokeninfo {
 	const char *name;
 	short val;
 	short reserved;
@@ -969,13 +966,13 @@
 static const char dbtest_not[] = { CHAR, '!', EOS };
 static const char dbtest_oparen[] = { CHAR, '(', EOS };
 static const char dbtest_cparen[] = { CHAR, ')', EOS };
-const char *const dbtest_tokens[] = {
+const char * const dbtest_tokens[] = {
 	dbtest_or, dbtest_and, dbtest_not,
 	dbtest_oparen, dbtest_cparen
 };
-const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
-const char db_lthan[] = { CHAR, '<', EOS };
-const char db_gthan[] = { CHAR, '>', EOS };
+static const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
+static const char db_lthan[] = { CHAR, '<', EOS };
+static const char db_gthan[] = { CHAR, '>', EOS };
 
 /*
  * Test if the current token is a whatever. Accepts the current token if
@@ -1018,7 +1015,7 @@
 		    db_close)) ? TO_NONNULL : TO_NONOP;
 	if (ret != TO_NONOP) {
 		ACCEPT;
-		if (meta < NELEM(dbtest_tokens))
+		if ((unsigned int)meta < NELEM(dbtest_tokens))
 			save = wdcopy(dbtest_tokens[(int)meta], ATEMP);
 		if (save)
 			XPput(*te->pos.av, save);
@@ -1134,13 +1131,10 @@
 	struct yyrecursive_state *ys;
 	int stok, etok;
 
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 	if (subtype == FUNSUB) {
 		stok = '{';
 		etok = '}';
-	} else
-#endif
-	  {
+	} else {
 		stok = '(';
 		etok = ')';
 	}
Index: src/bin/mksh/tree.c
diff -u src/bin/mksh/tree.c:1.65 src/bin/mksh/tree.c:1.67
--- src/bin/mksh/tree.c:1.65	Mon Oct 22 20:19:18 2012
+++ src/bin/mksh/tree.c	Tue Dec  4 01:10:35 2012
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.65 2012/10/22 20:19:18 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.67 2012/12/04 01:10:35 tg Exp $");
 
 #define INDENT	8
 
@@ -37,6 +37,8 @@
 /* "foo& ; bar" and "foo |& ; bar" are invalid */
 static bool prevent_semicolon;
 
+static const char Telif_pT[] = "elif %T";
+
 /*
  * print a command tree
  */
@@ -160,7 +162,7 @@
 			fptreef(shf, indent, "%;");
  process_TIF:
 			/* 5 == strlen("elif ") */
-			fptreef(shf, indent + 5 - i, "elif %T" + i, t1->left);
+			fptreef(shf, indent + 5 - i, Telif_pT + i, t1->left);
 			t1 = t1->right;
 			if (t1->left != NULL) {
 				fptreef(shf, indent, "%;");
@@ -177,7 +179,7 @@
 		break;
 	case TWHILE:
 	case TUNTIL:
-		/* 6 == strlen("while"/"until") */
+		/* 6 == strlen("while "/"until ") */
 		fptreef(shf, indent + 6, "%s %T",
 		    (t->type == TWHILE) ? "while" : "until",
 		    t->left);
@@ -342,12 +344,10 @@
 				shf_putc(c, shf);
 			shf_puts(cs, shf);
 			break;
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 		case FUNSUB:
 			shf_puts("${ ", shf);
 			cs = ";}";
 			goto pSUB;
-#endif
 		case EXPRSUB:
 			shf_puts("$((", shf);
 			cs = "))";
@@ -587,9 +587,7 @@
 			wp++;
 			break;
 		case COMSUB:
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 		case FUNSUB:
-#endif
 		case EXPRSUB:
 			while (*wp++ != 0)
 				;
@@ -829,11 +827,9 @@
  closeandout:
 			shf_putc('>', shf);
 			break;
-#ifndef MKSH_DISABLE_EXPERIMENTAL
 		case FUNSUB:
 			shf_puts("FUNSUB<", shf);
 			goto dumpsub;
-#endif
 		case EXPRSUB:
 			shf_puts("EXPRSUB<", shf);
 			goto dumpsub;
Index: src/bin/mksh/var.c
diff -u src/bin/mksh/var.c:1.161 src/bin/mksh/var.c:1.165
--- src/bin/mksh/var.c:1.161	Fri Nov 30 19:25:08 2012
+++ src/bin/mksh/var.c	Sat Dec  8 18:30:31 2012
@@ -27,7 +27,7 @@
 #include <sys/sysctl.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/var.c,v 1.161 2012/11/30 19:25:08 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/var.c,v 1.165 2012/12/08 18:30:31 tg Exp $");
 
 /*-
  * Variables
@@ -299,6 +299,7 @@
 
 	/* check to see if this is an array */
 	n = array_index_calc(n, &array, &val);
+	mkssert(n != NULL);
 	h = hash(n);
 	if (!ksh_isalphx(*n)) {
 		vp = &vtemp;
@@ -615,10 +616,13 @@
 				--slen;
 			}
 			if (vp->flag & ZEROFIL && vp->flag & INTEGER) {
+				if (!s[0] || !s[1])
+					goto uhm_no;
 				if (s[1] == '#')
 					n = 2;
 				else if (s[2] == '#')
 					n = 3;
+ uhm_no:
 				if (vp->u2.field <= n)
 					n = 0;
 			}
@@ -669,6 +673,8 @@
 	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
 	size_t namelen, vallen;
 
+	mkssert(val != NULL);
+
 	namelen = strlen(vp->name);
 	vallen = strlen(val) + 1;
 
@@ -704,7 +710,6 @@
 	val = skip_varname(var, false);
 	if (val == var)
 		return (NULL);
-	mkssert(var != NULL);
 	if (*val == '[') {
 		if (set_refflag != SRF_NOP)
 			errorf("%s: %s", var,
