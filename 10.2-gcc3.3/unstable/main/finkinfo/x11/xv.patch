
Name: FINK_xv-3.10a-3.superpatch
Data: Sun Aug 31 23:57:07 CEST 2003 (Sun Aug 31 22:57:07 GMT 2003)
Me  : Peter Dyballa, Germany (Peter_Dyballa@Web.DE)

========================================================================
* What is this patch?

 This patch is for xv-3.10a. Pekoe <pekoe@lair.net> made the patches
 which came out so far as one. My sole addition was to add Fink's own
 xv-3.10a-2.patch. My aim was to have a 21st Century Schizoid xv capable
 of handling the graphics formats that evolved since John Bradley
 stopped to keep pace with progress. Of course should be able to run
 under Darwin/Mac OS X! Now xv understands:
 PNG, GIF, JPEG, TIFF, PBM, PGM, PPM, XPM, X11 bitmap, Sun Rasterfile,
 Targa, RLE, RGB, BMP, PCX, FITS, PM, (E)PS, PDF (both through converting
 them in ppm raw format), PCD (Kodak PhotoCD), and the Japanese file
 formats MAG, MAKI, PIC, PIC2, Pi. Support for scanner, drawing board and
 camera file formats like Cannon View Station, XLD4(Q4), ML1, TIM (Sony
 PlayStation), CASIO QV-10, DB-Z, SAURUS Freehand Meme, PV-F1 Action
 Board, Wiz Quick Memo is provided. (Someone/Something forgotten?!) Specific
 extra support might be needed from xbm2free (version 1.10 or later).

 Even if you are in a hurry don't forget to take a look into the
 subdirectories this patch creates:

    XV+FLmask.v2.1
    xv-jp-extension/contrib/{cam,free,q4,tim,unchc}

 In bits new bitmaps have resublimated ...


 This super patch included before all patches as given by the
 following list (the rest of this descriptionis taken from Pekoe):

[http://www.airlab.cs.ritsumei.ac.jp/~ikeyan/xv-jp-extension/]
xv310a-jp-extension-rev5.3.3.tar.gz

[http://www.lb.u-tokai.ac.jp/%7Ematsu/flmask/]
XV+FLmask.v2.1.tar.gz

[ftp://ftp.trilon.com/pub/xv/]
xv-3.10a.JPEG-patch
xv-3.10a.TIFF-patch

[ftp://ftp.trilon.com/pub/xv/patches/]
bmp32.patch
croppad.patch
deepcolor.patch
epsfpatch
exceed_grab.patch
gifpatch
grabpatch
gssafer.patch
longname.patch
mp-tiff-patch
pdf.patch
tiff1200.patch
vispatch
windowid.patch
xpm.patch

[ftp://ring.crl.go.jp/pub/FreeBSD/distfiles/xv/]
xv-png-1.2d.patch
xvpng-1.2d-fix3.patch
jp-ext-bzip2.patch

[?]
xv-3.10a.Q0-patch


========================================================================
* How to use?

% cd /usr/local/src
% tar xzvf /tmp/xv-3.10a.tar.gz
% cd xv-3.10a/
% zcat /tmp/xv-3.10a+jp-extension-rev5.3.3+FLmask.v2.1+png+misc.patch.gz | patch -p1
% make
% su
# make install
# exit
% make clean


========================================================================
* The site of this patch

 ftp://ftp.lair.net/pub/unix/graphics/xv/

 Have fun :)


 --------
 Pekoe <pekoe@lair.net>

========================================================================
========================================================================

diff -Naur xv-3.10a.old/Imakefile xv-3.10a/Imakefile
--- xv-3.10a.old/Imakefile	Sat Jan 14 05:24:01 1995
+++ xv-3.10a/Imakefile	Tue Apr 24 09:37:06 2001
@@ -14,6 +14,8 @@
  */
 #define HaveTiff
 
+#define UseInstalledPng
+
 
 /* if, for whatever reason, you're unable to get the PDS/VICAR support
  * to compile (xvpds.c, and vdcomp.c), *COMMENT OUT* the following line
@@ -104,6 +106,11 @@
 SGI = -Dsgi
 #endif
 
+/* install directory of xv_mgcsfx.sample. */
+MGCSFXDIR = $(LIBDIR)
+/* Directory of default configuration file. */
+MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
+
 
 
 
@@ -129,6 +136,18 @@
 TIFFINCLUDE = -I$(TIFFDIR)
 #endif
 
+#ifdef UseInstalledPng
+#define UseInstalledZlib
+PNG = -DDOPNG
+LIBPNG = -L/usr/local/lib -lpng
+PNGINCLUDE = -I/usr/local/include
+#endif
+
+#ifdef UseInstalledZlib
+LIBZLIB = -L/usr/lib -lz
+ZLIBINCLUDE = -I/usr/include
+#endif
+
 #ifdef HavePDS
 PDS = -DDOPDS
 #endif
@@ -137,35 +156,43 @@
 #if defined(SCOArchitecture)
 SCO= -Dsco -DPOSIX -DNO_RANDOM 
 SYS_LIBRARIES=        -lm -lc -lx 
+#elif defined(HPArchitecture)
+SYS_LIBRARIES=        -lm -lV3
 #else
 SYS_LIBRARIES=        -lm
 #endif
 
 
 DEPLIBS = $(LIBJPEG) $(LIBTIFF)
-LOCAL_LIBRARIES = $(XLIB) $(DEPLIBS)
+LOCAL_LIBRARIES = $(XLIB) $(DEPLIBS) $(LIBPNG) $(LIBZLIB)
 
 DEFINES= $(SCO) $(UNIX) $(NODIRENT) $(VPRINTF) $(TIMERS) \
 	$(HPUX7) $(JPEG) $(TIFF) $(PDS) $(DXWM) $(RAND) \
-	$(BACKING_STORE) $(BSDTYPES) $(SGI)
+	$(BACKING_STORE) $(BSDTYPES) $(SGI) $(MGCSFX) $(PNG)
 
-INCLUDES = $(JPEGINCLUDE) $(TIFFINCLUDE)
+INCLUDES = $(JPEGINCLUDE) $(TIFFINCLUDE) $(PNGINCLUDE) $(ZLIBINCLUDE)
 
 SRCS1 =	xv.c xvevent.c xvroot.c xvmisc.c xvimage.c xvcolor.c xvsmooth.c \
 	xv24to8.c xvgif.c xvpm.c xvinfo.c xvctrl.c xvscrl.c xvalg.c \
+	xvmask.c xvcpmask.c xvmeko.c \
 	xvgifwr.c xvdir.c xvbutt.c xvpbm.c xvxbm.c xvgam.c xvbmp.c \
 	xvdial.c xvgraf.c xvsunras.c xvjpeg.c xvps.c xvpopup.c xvdflt.c \
 	xvtiff.c xvtiffwr.c xvpds.c xvrle.c xviris.c xvgrab.c vprintf.c \
 	xvbrowse.c xvtext.c xvpcx.c xviff.c xvtarga.c xvxpm.c xvcut.c \
-	xvxwd.c xvfits.c
+	xvxwd.c xvfits.c xvpng.c \
+	xvmag.c xvpic.c xvmaki.c xvpi.c xvpic2.c xvpcd.c xvvd.c xvmgcsfx.c \
+	xvml.c
 
 OBJS1 =	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
+	xvmask.o xvcpmask.o xvmeko.o \
 	xvgifwr.o xvdir.o xvbutt.o xvpbm.o xvxbm.o xvgam.o xvbmp.o \
 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
-	xvxwd.o xvfits.o
+	xvxwd.o xvfits.o xvpng.o \
+	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
+	xvml.o
 
 SRCS2=	bggen.c
 OBJS2=	bggen.o
@@ -265,6 +292,8 @@
 InstallManPageLong(docs/xcmap,$(MANDIR),xcmap)
 InstallManPageLong(docs/xvp2p,$(MANDIR),xvpictoppm)
 InstallManPageLong(docs/vdcomp,$(MANDIR),vdcomp)
+
+InstallNonExecFile(xv_mgcsfx.sample,$(MGCSFXDIR))
 
 tar:
 	tar cf xv.tar Makefile* Imakefile *.c *.h bits docs \
diff -Naur xv-3.10a.old/Makefile xv-3.10a/Makefile
--- xv-3.10a.old/Makefile	Tue Jan 24 05:20:54 1995
+++ xv-3.10a/Makefile	Tue Apr 24 09:37:06 2001
@@ -1,8 +1,8 @@
 # Makefile for xv
 
 # your C compiler (and options) of choice
-CC = cc
-# CC = gcc -ansi
+# CC = cc
+CC = gcc -ansi
 
 # use this if you're using 'cc' on a DEC Alpha (OSF/1) or MIPS (Ultrix) system:
 # CC = cc -std1 -Olimit 750
@@ -14,7 +14,7 @@
 #       -Wuninitialized -Wparentheses
 
 
-CCOPTS = -O 
+CCOPTS = -O2 -pipe -fomit-frame-pointer -IFINKINSTALLPREFIX/include -I/usr/X11R6/include -D_BSD_SOURCE
 
 
 ### NOTE: Sun running OpenWindows:
@@ -27,11 +27,11 @@
 ### '-I' options on the CCOPTS line to tell the compiler where said files are.
 
 
-### Installation locations
-BINDIR = /usr/local/bin
-MANDIR = /usr/local/man/man1
+###Installation locations
+BINDIR = FINKINSTALLPREFIX/bin
+MANDIR = FINKINSTALLPREFIX/share/man/man1
 MANSUF = 1
-LIBDIR = /usr/local/lib
+LIBDIR = FINKINSTALLPREFIX/lib
 
 
 buildit: all
@@ -46,13 +46,28 @@
 ### on your machine, *COMMENT OUT* the following lines
 ###
 JPEG    = -DDOJPEG
-JPEGDIR = jpeg
-JPEGINC = -I$(JPEGDIR)
-JPEGLIB = $(JPEGDIR)/libjpeg.a
-$(JPEGDIR)/jconfig.h:
-	cd $(JPEGDIR) ; ./configure CC='$(CC)'
-$(JPEGLIB):  $(JPEGDIR)/jconfig.h
-	cd $(JPEGDIR) ; make
+JPEGDIR = 
+JPEGINC = 
+JPEGLIB = -ljpeg
+
+
+###
+### if, for whatever reason, you're unable to get the PNG library to compile
+### on your machine, *COMMENT OUT* the following lines
+###
+PNG    = -DDOPNG
+PNGDIR = 
+PNGINC = 
+PNGLIB = -lpng
+
+
+###
+### if, for whatever reason, you're unable to get the PNG library to compile
+### on your machine, *COMMENT OUT* the following lines
+###
+ZLIBDIR = 
+ZLIBINC = 
+ZLIBLIB = -lz
 
 
 ###
@@ -60,11 +75,9 @@
 ### on your machine, *COMMENT OUT* the following lines
 ###
 TIFF    = -DDOTIFF
-TIFFDIR = tiff
-TIFFINC = -I$(TIFFDIR)
-TIFFLIB = $(TIFFDIR)/libtiff.a
-$(TIFFLIB):
-	( cd $(TIFFDIR) ; make CC='$(CC)' )
+TIFFDIR = 
+TIFFINC = 
+TIFFLIB = -ltiff
 
 
 ###
@@ -78,9 +91,11 @@
 #----------System V----------
 
 # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
-# Solaris, etc., uncomment the following line to get mostly there.  
-#UNIX = -DSVR4
-
+# Sikarusm etc, uncomment one of the following lines to get you *most* of
+# the way there.  SYSV means System V R3.
+# UNIX = -DSVR4
+# UNIX = -DSYSV
+
 
 #----------Machine Specific Configurations----------
 
@@ -99,6 +114,9 @@
 # note:  You may need to add '-I/usr/include/X11R5' (or R6, or whatever)
 # to whichever of those lines you used, as HP tends to store their X11
 # include files in a non-standard place...
+#
+# And, you probably have to add '-lV3' to the end of the LIBS def,
+# when use AUTO_EXPAND feauture.
 
 
 ### for LINUX, uncomment the following line
@@ -177,6 +195,16 @@
 #VPRINTF = -DNEED_VPRINTF -DLONGINT -DNOSTDHDRS
 
 
+# if your X Window System compiled with -DX_LOCALE, 
+# uncomment the following line:
+# TVL10N = -DX_LOCALE
+
+# Install directory of xv_mgcsfx.sample.
+MGCSFXDIR = $(LIBDIR)
+# Directory of default configuration file.
+MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
+
+
 
 
 ################ END OF CONFIGURATION OPTIONS #################
@@ -186,9 +214,9 @@
 
 CFLAGS = $(CCOPTS) $(JPEG) $(JPEGINC) $(TIFF) $(TIFFINC) $(PDS) \
 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
-	$(DXWM) $(MCHN)
+	$(DXWM) $(MCHN) $(TVL10N) $(MGCSFX) $(PNG) $(PNGINC) $(ZLIBINC)
 
-LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+LIBS = -LFINKINSTALLPREFIX/lib -L/usr/X11R6/lib -lX11 $(JPEGLIB) $(TIFFLIB) $(PNGLIB) $(ZLIBLIB) -lm
 
 OBJS = 	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
@@ -196,7 +224,9 @@
 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
-	xvxwd.o xvfits.o
+	xvxwd.o xvfits.o xvpng.o \
+	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
+	xvml.o xvcpmask.o xvmask.o xvmeko.o
 
 MISC = README INSTALL CHANGELOG IDEAS
 
@@ -206,10 +236,10 @@
 
 
 
-all: $(JPEGLIB) $(TIFFLIB) xv bggen vdcomp xcmap xvpictoppm
+all: xv bggen vdcomp xcmap xvpictoppm
 
 
-xv: $(OBJS) $(JPEGLIB) $(TIFFLIB)
+xv: $(OBJS)
 	$(CC) -o xv $(CFLAGS) $(OBJS) $(LIBS)
 
 bggen: bggen.c
@@ -237,13 +237,17 @@
 
 
 install: all
+	mkdir -p $(BINDIR)
+	mkdir -p $(MANDIR)
+	mkdir -p $(LIBDIR)
 	cp xv bggen vdcomp xcmap xvpictoppm $(BINDIR)
 	cp docs/xv.man     $(MANDIR)/xv.$(MANSUF)
 	cp docs/bggen.man  $(MANDIR)/bggen.$(MANSUF)
	cp docs/xcmap.man  $(MANDIR)/xcmap.$(MANSUF)
	cp docs/xvp2p.man  $(MANDIR)/xvpictoppm.$(MANSUF)
	cp docs/vdcomp.man $(MANDIR)/vdcomp.$(MANSUF)
	cp docs/xvdocs.ps* $(LIBDIR)
+	cp xv_mgcsfx.sample $(MGCSFXDIR)
 
 tar:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
@@ -267,7 +298,7 @@
 xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds 
 xvbrowse.o:	bits/br_ps bits/br_iff bits/br_targa bits/br_xpm
 xvbrowse.o:	bits/br_trash bits/fcurs bits/fccurs bits/fdcurs bits/fcursm
-xvbrowse.o:     bits/br_xwd
+xvbrowse.o:     bits/br_xwd bits/br_png bits/br_bzip2
 
 xvbutt.o:	bits/cboard50 bits/rb_frame bits/rb_frame1 bits/rb_top
 xvbutt.o:	bits/rb_bot bits/rb_dtop bits/rb_dbot bits/rb_body
diff -Naur xv-3.10a.old/Makefile.std xv-3.10a/Makefile.std
--- xv-3.10a.old/Makefile.std	Tue Jan 24 10:06:26 1995
+++ xv-3.10a/Makefile.std	Tue Apr 24 09:37:06 2001
@@ -56,6 +56,25 @@
 
 
 ###
+### if, for whatever reason, you're unable to get the PNG library to compile
+### on your machine, *COMMENT OUT* the following lines
+###
+PNG    = -DDOPNG
+PNGDIR = /usr/local/src/libpng
+PNGINC = -I$(PNGDIR)
+PNGLIB = -L$(PNGDIR) -lpng
+
+
+###
+### if, for whatever reason, you're unable to get the PNG library to compile
+### on your machine, *COMMENT OUT* the following lines
+###
+ZLIBDIR = /usr/local/src/zlib
+ZLIBINC = -I$(ZLIBDIR)
+ZLIBLIB = -L$(ZLIBDIR) -lz
+
+
+###
 ### if, for whatever reason, you're unable to get the TIFF library to compile
 ### on your machine, *COMMENT OUT* the following lines
 ###
@@ -78,9 +97,11 @@
 #----------System V----------
 
 # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
-# Solaris, etc., uncomment the following line to get mostly there.  
-#UNIX = -DSVR4
-
+# Sikarusm etc, uncomment one of the following lines to get you *most* of
+# the way there.  SYSV means System V R3.
+# UNIX = -DSVR4
+# UNIX = -DSYSV
+     
 
 #----------Machine Specific Configurations----------
 
@@ -99,6 +120,9 @@
 # note:  You may need to add '-I/usr/include/X11R5' (or R6, or whatever)
 # to whichever of those lines you used, as HP tends to store their X11
 # include files in a non-standard place...
+#
+# And, you probably have to add '-lV3' to the end of the LIBS def,
+# when use AUTO_EXPAND feauture.
 
 
 ### for LINUX, uncomment the following line
@@ -177,6 +201,16 @@
 #VPRINTF = -DNEED_VPRINTF -DLONGINT -DNOSTDHDRS
 
 
+# if your X Window System compiled with -DX_LOCALE, 
+# uncomment the following line:
+# TVL10N = -DX_LOCALE
+
+# Install directory of xv_mgcsfx.sample.
+MGCSFXDIR = $(LIBDIR)
+# Directory of default configuration file.
+MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
+
+
 
 
 ################ END OF CONFIGURATION OPTIONS #################
@@ -186,9 +220,9 @@
 
 CFLAGS = $(CCOPTS) $(JPEG) $(JPEGINC) $(TIFF) $(TIFFINC) $(PDS) \
 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
-	$(DXWM) $(MCHN)
+	$(DXWM) $(MCHN) $(TVL10N) $(MGCSFX) $(PNG) $(PNGINC) $(ZLIBINC)
 
-LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) $(PNGLIB) $(ZLIBLIB) -lm
 
 OBJS = 	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
@@ -196,7 +230,9 @@
 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
-	xvxwd.o xvfits.o
+	xvxwd.o xvfits.o xvpng.o \
+	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
+	xvml.o
 
 MISC = README INSTALL CHANGELOG IDEAS
 
@@ -244,6 +280,7 @@
 	cp docs/xvp2p.man  $(MANDIR)/xvpictoppm.$(MANSUF)
 	cp docs/vdcomp.man $(MANDIR)/vdcomp.$(MANSUF)
 	cp docs/xvdocs.ps* $(LIBDIR)
+	cp xv_mgcsfx.sample $(MGCSFXDIR)
 
 tar:
 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
@@ -267,7 +304,7 @@
 xvbrowse.o:	bits/br_pcx bits/br_jfif bits/br_tiff bits/br_pds 
 xvbrowse.o:	bits/br_ps bits/br_iff bits/br_targa bits/br_xpm
 xvbrowse.o:	bits/br_trash bits/fcurs bits/fccurs bits/fdcurs bits/fcursm
-xvbrowse.o:     bits/br_xwd
+xvbrowse.o:     bits/br_xwd bits/br_png bits/br_bzip2
 
 xvbutt.o:	bits/cboard50 bits/rb_frame bits/rb_frame1 bits/rb_top
 xvbutt.o:	bits/rb_bot bits/rb_dtop bits/rb_dbot bits/rb_body
diff -Naur xv-3.10a.old/README.PNG xv-3.10a/README.PNG
--- xv-3.10a.old/README.PNG	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/README.PNG	Tue Apr 24 09:37:06 2001
@@ -0,0 +1,33 @@
+This archive contains context diffs suitable for use with the GNU
+patch utility.  It adds the ability to read and write PNG format
+files with XV 3.10a.  This patch was written by Andreas Dilger
+<adilger@enel.ucalgary.ca> based on a patch written by Alexander
+Lehmann <lehmann@mathematik.th-darmstadt.de>.  No warranty, expressed
+or implied, of merchant-ability or fitness for a particular purpose
+is given with this patch.  It is also an unofficial patch, in the
+sense that the XV author had nothing to do with it.  Despite all that,
+it is reasonably reliable.
+
+The following files are required for adding PNG to XV 3.10a.
+xvpng.c
+xvpng.diff
+bits/br_png
+
+Move them into the same directory as the XV source code, and apply
+the patch via "patch -p1 < xvpng.diff".  You may need to edit your
+makefile to indicate the location of libpng and zlib, which are not
+included here.  Both are available at ftp.uu.net and various other
+locations on the internet.  This patch was created with libpng-0.89
+and zlib-1.0.2, but later versions should also work.
+
+The xvjpeg.diff and xvtiff.diff are not required for the PNG
+functionality, but were modifications I needed to make to get XV
+to compile with the latest versions of the respective libraries
+(libjpeg 6.0 and libtiff 3.4.beta027 respectively).  You do not
+need to apply them if you are using the libraries included with XV.
+
+The xcmap.diff file allows this program to work properly with a 1-bit
+X display.  It is not required for PNG functionality.  Why use xcmap
+for a 1-bit display?  Because I have an xcmap icon for fvwm, and it
+always starts regardless of the display, so it was easier to fix xcmap
+than to stop xcmap from starting based on the display depth.
diff -Naur xv-3.10a.old/XV+FLmask.v2.1/00_README xv-3.10a/XV+FLmask.v2.1/00_README
--- xv-3.10a.old/XV+FLmask.v2.1/00_README	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/XV+FLmask.v2.1/00_README	Mon Sep 15 20:21:08 1997
@@ -0,0 +1,101 @@
+
+	       XV+FLmask version 2.1.
+
+	   	     97.09.14.
+	     matu@alice.lb.u-tokai.ac.jp.
+                  まつむらしげる。。
+
+
+[このパッチは何?]
+	なんだろう。なにかしら。
+	きっと気まぐれで作られたものです。(^^)
+
+
+[このアーカイブが含むもの]
+	README 			このファイル。
+	XV+FLmask.v2.1.patch	パッチ。
+
+
+[作り方]
+	(1)まず、材料を集めましょう。
+		xv-3.10a.tar.gz
+		libjpeg-6a.tar.gz
+		xv310a-jp-extension-rev5.3.3.tar.gz
+
+	(2)これらに、
+		XV+FLmask.v2.1.patch
+	   を加えてぐつぐつ煮込みましょう。(jvim風。)
+
+	(3)以上。(これだけ）
+
+
+[使用にあたって]
+	FLmask menu と Mask button が増えているだけです。
+	難しいところは無いでしょう。
+	Mask button は上手に使うと便利です。
+
+
+[警告]
+	この patch はあなた自身の責任のもとに使用して下
+	さい。もし、この patch を使用する事によって、あ
+	なたの HDD の data が全部消えてしまったり、ハー
+	ドウェアがダメージを受けたり、あなたの犬が死んで
+	しまっても、当方は一切関知しません。(mgetty風。)
+
+
+[動作環境]
+	開発環境は Linux-2.0.30 ですが、たぶん original 
+	の xv が動く環境であれば問題無く動くでしょう。
+	(たぶん)
+
+
+[その他]
+	このパッチはシェアウエアです。
+	500円也。貧乏な学生なので、free にしませんでした。
+	同じく生活の苦しい方は、免除致します。。
+	その他、 software の自由な配付がうんたらかんたら
+	でどうとかこうとか言う人も払わなくても良いです。。
+	                                           (^^;;;
+
+	いつの日かうちにもPから始まるCPUを導入する事を夢
+	見て。。(Kでもよい。Dはもういや。。)
+
+	本当に支払ってくれる方は
+		E-mail: matu@alice.lb.u-tokai.ac.jp
+	まで Mail して下さい。(^^)
+
+
+	不具合や, 要求, 感想などなんでも, 上のアドレスまで
+	お願いします。
+	(v2.0 の時 mail 送って下さった沢山の方、有難うござ
+	います。御意見反映できるよう努力してみます。。)
+
+
+	また「XV+FLmask Home Page.」
+	http://www.lb.u-tokai.ac.jp/~matu/flmask/
+	にて Version UP のお知らせ等があるかも知れません。
+
+
+[謝辞]
+	このパッチキットを作成するにあたって、以下の方々
+	の御協力を得ました。 心より感謝致します。
+
+	  o Gmask の作者の古溝 剛 様。
+	  o あの人。
+	  o この人。
+	  o その他。
+
+
+--
+o `XV'は, X Window System上の画像表示プログラムです.
+   XV is Copyright 1989, 1994 by John Bradley.
+   X Window System is a trademark of X Consortium, Inc.
+o MEKOMASK は 五十嵐 洋二さん作のマスクツール。
+o WINMASK  は 外村 高章さん作のマスクツール。
+o FLMASK   は Ｇenesis さん作のマスクツール。
+o CPMASK   は 内野さんとＧenesis さん合作のマスク技法。
+o Gmask    は 古溝剛さんのマスクツール。
+
+(jp-extension風の README)
+
+
diff -Naur xv-3.10a.old/XV+FLmask.v2.1/CPMASK xv-3.10a/XV+FLmask.v2.1/CPMASK
--- xv-3.10a.old/XV+FLmask.v2.1/CPMASK	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/XV+FLmask.v2.1/CPMASK	Sun Sep 14 19:01:48 1997
@@ -0,0 +1,21 @@
+[CPMASKについて]
+	この patch によってかけられた CPmask は FLMASK プログラム等
+	でかけたものとは違いfile に passwd の情報を残しません。
+
+	xv は jpeg file を save する時に
+	「CREATOR: XV Version 3.10a Rev: 12/29/94 Quality = 75, 
+	  Smoothing = 0」
+	というような情報を加えます。
+
+	CPmask はこの部分にこっそりpasswd情報を書き込むのですが、こ
+	れが原因で CPmask のかけられた file を xv で読み込んでその
+	まま save しなおすと passwd を調べる tool とかで判定できない
+	file が出来上がるわけです。
+
+	そのために、前の version では CPmask がかけられていない file
+	の場合は error pop up するようにしていたのですが、不便である
+	との mail を沢山受けたので変えることにしました。
+
+	ですから、この patch では新しく CPmask をかけずに、はずすだ
+	けにして下さい。
+
diff -Naur xv-3.10a.old/XV+FLmask.v2.1/FTP_SITE xv-3.10a/XV+FLmask.v2.1/FTP_SITE
--- xv-3.10a.old/XV+FLmask.v2.1/FTP_SITE	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/XV+FLmask.v2.1/FTP_SITE	Mon Sep 15 00:25:52 1997
@@ -0,0 +1,40 @@
+xv-3.10a.tar.gz:
+
+ftp://ftp.chiba-u.ac.jp/pub/solaris/freeware/SOURCES/xv-3.10a.tar.gz
+ftp://ftp.ipc.chiba-u.ac.jp/pub/pub.yamaga/misc/src/xv-3.10a.tar.gz
+ftp://ftp.leo.chubu.ac.jp/pub/x/X-contrib/xv-3.10a.tar.gz
+ftp://ftp.huie.hokudai.ac.jp/pub/X11/contrib/xv-3.10a.tar.gz
+ftp://kipcftp.ipc.kanazawa-u.ac.jp/pub/X11/contrib/clients/xv/xv-3.10a.tar.gz
+ftp://ftp.kuis.kyoto-u.ac.jp/X11/contrib/clients/xv/xv-3.10a.tar.gz
+ftp://ftp.nuie.nagoya-u.ac.jp/packages/xv/xv-3.10a.tar.gz
+ftp://ftp.nuie.nagoya-u.ac.jp/pub/xv/xv-3.10a.tar.gz
+ftp://ftp.momo.it.okayama-u.ac.jp/pub/X/contrib/applications/xv/xv-3.10a.tar.gz
+ftp://ftp.st.ryukoku.ac.jp/pub/X11/utils/xv/xv-3.10a.tar.gz
+ftp://ftp.cs.titech.ac.jp/lab/kumazawa/ksw/xv-3.10a.tar.gz
+ftp://ftp.tohoku.ac.jp/pub/X/app/xv/xv-3.10a.tar.gz
+ftp://ftp.tut.ac.jp/.h3/X11/Contrib/Visual/xv/xv-3.10a.tar.gz
+ftp://ftp.iis.u-tokyo.ac.jp/pub1/X/misc/xv-3.10a.tar.gz
+ftp://ftp.uoeh-u.ac.jp/pub/tools/xv-3.10a.tar.gz
+ftp://ftp.kohnolab.dnj.ynu.ac.jp/pub/misc/xv/xv-3.10a.tar.gz
+ftp://ftp.kyoto.wide.ad.jp/pub/misc/xv-3.10a.tar.gz
+ftp://ftp.astec.co.jp/pub/X11/contrib/xv-3.10a.tar.gz
+ftp://ftp.lab.kdd.co.jp/Sun/freeware/sources/xv-3.10a.tar.gz
+ftp://ftp.mei.co.jp/free/X11/X/clients/images/xv/xv-3.10/xv-3.10a.tar.gz
+ftp://etlport.etl.go.jp/pub/xv-3.10a.tar.gz
+ftp://ftp.meshnet.or.jp/pub/48pub/Freeware96/src/X/xv/xv-3.10a.tar.gz
+ftp://ftp.win.or.jp/pub/graphics/xv/xv-3.10a.tar.gz
+
+
+libjpeg-6a.tar.gz:
+
+ftp://ftp.kuis.kyoto-u.ac.jp/Linux/sunsite/libs/graphics/libjpeg-6a.tar.gz
+ftp://ftp.csce.kyushu-u.ac.jp/pub/Linux/sunsite/libs/graphics/libjpeg-6a.tar.gz
+ftp://ftp.ics.es.osaka-u.ac.jp/pub/mirrors/KDE/unstable/devel/other_libs/libjpeg-6a.tar.gz
+
+
+xv310a-jp-extension-rev5.3.3.tar.gz:
+
+ftp://ftp.tohoku.ac.jp/pub/X/app/xv/xv310a-jp-extension-rev5.3.3.tar.gz
+ftp://ftp.mei.co.jp/free/X11/X/clients/images/xv/xv-3.10/working/xv310a-jp-extension-rev5.3.3.tar.gz
+ftp://ftp.win.or.jp/pub/graphics/xv/xv310a-jp-extension-rev5.3.3.tar.gz
+
diff -Naur xv-3.10a.old/XV+FLmask.v2.1/XV+FLmask.v2.1.patch xv-3.10a/XV+FLmask.v2.1/XV+FLmask.v2.1.patch
--- xv-3.10a.old/XV+FLmask.v2.1/XV+FLmask.v2.1.patch	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/XV+FLmask.v2.1/XV+FLmask.v2.1.patch	Sun Sep 14 17:04:07 1997
@@ -0,0 +1,2581 @@
+diff -c --new-file xv-3.10a.org/Imakefile xv+flmask/Imakefile
+*** xv-3.10a.org/Imakefile	Sun Sep 14 02:29:10 1997
+--- xv+flmask/Imakefile	Sun Sep 14 03:18:49 1997
+***************
+*** 160,165 ****
+--- 160,166 ----
+  
+  SRCS1 =	xv.c xvevent.c xvroot.c xvmisc.c xvimage.c xvcolor.c xvsmooth.c \
+  	xv24to8.c xvgif.c xvpm.c xvinfo.c xvctrl.c xvscrl.c xvalg.c \
++ 	xvmask.c xvcpmask.c xvmeko.c \
+  	xvgifwr.c xvdir.c xvbutt.c xvpbm.c xvxbm.c xvgam.c xvbmp.c \
+  	xvdial.c xvgraf.c xvsunras.c xvjpeg.c xvps.c xvpopup.c xvdflt.c \
+  	xvtiff.c xvtiffwr.c xvpds.c xvrle.c xviris.c xvgrab.c vprintf.c \
+***************
+*** 170,175 ****
+--- 171,177 ----
+  
+  OBJS1 =	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
+  	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
++ 	xvmask.o xvcpmask.o xvmeko.o \
+  	xvgifwr.o xvdir.o xvbutt.o xvpbm.o xvxbm.o xvgam.o xvbmp.o \
+  	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
+  	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
+diff -c --new-file xv-3.10a.org/xv.h xv+flmask/xv.h
+*** xv-3.10a.org/xv.h	Sun Sep 14 02:29:12 1997
+--- xv+flmask/xv.h	Sun Sep 14 06:50:03 1997
+***************
+*** 8,15 ****
+  #include "config.h"
+  
+  
+! #define REVDATE   "Version 3.10a+jp5.3.3  Rev: 12/29/94"
+! #define VERSTR    "3.10a+jp5.3.3"
+  
+  /*
+   * uncomment the following, and modify for your site, but only if you've
+--- 8,16 ----
+  #include "config.h"
+  
+  
+! #define REVDATE   "Version 3.10a+FLmask+jp5.3.3  Rev: 12/29/94"
+! #define VERSTR    "3.10a+FLmask+jp"
+! 
+  
+  /*
+   * uncomment the following, and modify for your site, but only if you've
+***************
+*** 415,424 ****
+  #define BCROP    19
+  #define BUNCROP  20
+  #define BACROP   21
+! #define BABOUT   22
+! #define BQUIT    23
+! #define BXV      24
+! #define NBUTTS   25    /* # of butts */
+  
+  
+  /* buttons in the load/save window */
+--- 416,426 ----
+  #define BCROP    19
+  #define BUNCROP  20
+  #define BACROP   21
+! #define BMASKS   22
+! #define BABOUT   23
+! #define BQUIT    24
+! #define BXV      25
+! #define NBUTTS   26    /* # of butts */
+  
+  
+  /* buttons in the load/save window */
+***************
+*** 719,740 ****
+  #define PIC24 CONV24_24BIT
+  
+  /* indicies into algMB */
+  #define ALG_NONE      0
+! #define ALG_SEP1      1  /* separator */
+! #define ALG_BLUR      2
+! #define ALG_SHARPEN   3
+! #define ALG_EDGE      4
+! #define ALG_TINF      5
+! #define ALG_OIL       6
+! #define ALG_BLEND     7
+! #define ALG_ROTATE    8
+! #define ALG_ROTATECLR 9
+  #define ALG_PIXEL     10
+  #define ALG_SPREAD    11
+  #define ALG_MEDIAN    12
+  #define ALG_MAX       13
+  
+- 
+  /* indicies into sizeMB */
+  #define SZMB_NORM     0
+  #define SZMB_MAXPIC   1
+--- 721,753 ----
+  #define PIC24 CONV24_24BIT
+  
+  /* indicies into algMB */
++ #define MSK_NONE      0
++ #define MSK_SEP1      1  /* separator */
++ #define MSK_FLMASK    2 
++ #define MSK_Q0MASK    3 
++ #define MSK_WIN	      4 
++ #define MSK_MEKO      5 
++ #define MSK_CPMASK    6 
++ #define MSK_RGB	      7 
++ #define MSK_BITREV    8 
++ #define MSK_COLREV    9 
++ #define MSK_MAX	      10
++                       
+  #define ALG_NONE      0
+! #define ALG_SEP1      1   /* separator */
+! #define ALG_BLUR      2 
+! #define ALG_SHARPEN   3 
+! #define ALG_EDGE      4 
+! #define ALG_TINF      5 
+! #define ALG_OIL       6 
+! #define ALG_BLEND     7 
+! #define ALG_ROTATE    8 
+! #define ALG_ROTATECLR 9 
+  #define ALG_PIXEL     10
+  #define ALG_SPREAD    11
+  #define ALG_MEDIAN    12
+  #define ALG_MAX       13
+  
+  /* indicies into sizeMB */
+  #define SZMB_NORM     0
+  #define SZMB_MAXPIC   1
+***************
+*** 1209,1214 ****
+--- 1222,1228 ----
+  WHERE MBUTT         dispMB;              /* display mode menu button */
+  WHERE MBUTT         conv24MB;            /* 24-to-8 conversion mode mbutt */
+  WHERE MBUTT         algMB;               /* Algorithms mbutt */
++ WHERE MBUTT         flmaskMB;            /* FLmask mbutt */
+  WHERE MBUTT         rootMB;
+  WHERE MBUTT         sizeMB;
+  WHERE MBUTT         windowMB;
+diff -c --new-file xv-3.10a.org/xvalg.c xv+flmask/xvalg.c
+*** xv-3.10a.org/xvalg.c	Fri Dec 23 04:12:20 1994
+--- xv+flmask/xvalg.c	Wed Sep  3 12:49:55 1997
+***************
+*** 26,32 ****
+  static void Pixelize       PARM((void));
+  static void Spread         PARM((void));
+  static void MedianFilter   PARM((void));
+! static void saveOrigPic    PARM((void));
+  
+  static void doBlurConvolv  PARM((byte *,int,int,byte *, int,int,int,int, int));
+  static void doSharpConvolv PARM((byte *,int,int,byte *, int,int,int,int, int));
+--- 26,33 ----
+  static void Pixelize       PARM((void));
+  static void Spread         PARM((void));
+  static void MedianFilter   PARM((void));
+! 
+! void saveOrigPic    PARM((void));
+  
+  static void doBlurConvolv  PARM((byte *,int,int,byte *, int,int,int,int, int));
+  static void doSharpConvolv PARM((byte *,int,int,byte *, int,int,int,int, int));
+***************
+*** 41,47 ****
+  static void doSpread       PARM((byte *,int,int,byte *, int,int,int,int, 
+  				 int, int));
+  static void doMedianFilter PARM((byte *,int,int,byte *, int,int,int,int, int));
+- 
+  static void add2bb         PARM((int *, int *, int *, int *, int, int));
+  static void rotXfer        PARM((int, int, double *,double *,
+  				 double,double, double));
+--- 42,47 ----
+***************
+*** 50,62 ****
+  static void intsort        PARM((int *, int));
+  #endif
+  
+! static int  start24bitAlg  PARM((byte **, byte **));
+! static void end24bitAlg    PARM((byte *, byte *));
+! 
+! static void printUTime     PARM((char *));
+  
+! static byte *origPic = (byte *) NULL;
+! static int  origPicType;
+  static byte origrmap[256], origgmap[256], origbmap[256];
+  
+  
+--- 50,61 ----
+  static void intsort        PARM((int *, int));
+  #endif
+  
+! int  start24bitAlg  PARM((byte **, byte **));
+! void end24bitAlg    PARM((byte *, byte *));
+! void printUTime     PARM((char *));
+  
+! byte *origPic = (byte *) NULL;
+! int  origPicType;
+  static byte origrmap[256], origgmap[256], origbmap[256];
+  
+  
+***************
+*** 69,75 ****
+  
+  
+  /***************************/
+! static void printUTime(str)
+       char *str;
+  {
+  #ifdef TIMING_TEST
+--- 68,74 ----
+  
+  
+  /***************************/
+! void printUTime(str)
+       char *str;
+  {
+  #ifdef TIMING_TEST
+***************
+*** 82,91 ****
+  }
+  
+  
+- 
+- 
+- 
+- 
+  /************************************************************/
+  void AlgInit()
+  {
+--- 81,86 ----
+***************
+*** 96,101 ****
+--- 91,97 ----
+    origPic = (byte *) NULL;
+  
+    algMB.dim[ALG_NONE] = 1;    /* can't undo when init'ed already */
++   flmaskMB.dim[MSK_NONE]=1;
+  }
+  
+  
+***************
+*** 107,127 ****
+       algorithm */
+  
+    switch (anum) {
+!   case ALG_NONE:      NoAlg();        break;
+!   case ALG_BLUR:      Blur();         break;
+!   case ALG_SHARPEN:   Sharpen();      break;
+!   case ALG_EDGE:      EdgeDetect();   break;
+!   case ALG_TINF:      TinFoil();      break;
+!   case ALG_OIL:       OilPaint();     break;
+!   case ALG_BLEND:     Blend();        break;
+!   case ALG_ROTATE:    FineRotate(0);  break;
+!   case ALG_ROTATECLR: FineRotate(1);  break;
+!   case ALG_PIXEL:     Pixelize();     break;
+!   case ALG_SPREAD:    Spread();       break;
+!   case ALG_MEDIAN:    MedianFilter(); break;
+    }
+  
+    algMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
+  }
+  
+  
+--- 103,124 ----
+       algorithm */
+  
+    switch (anum) {
+!   case ALG_NONE:      NoAlg();        	break;
+!   case ALG_BLUR:      Blur();         	break;
+!   case ALG_SHARPEN:   Sharpen();      	break;
+!   case ALG_EDGE:      EdgeDetect();   	break;
+!   case ALG_TINF:      TinFoil();      	break;
+!   case ALG_OIL:       OilPaint();     	break;
+!   case ALG_BLEND:     Blend();        	break;
+!   case ALG_ROTATE:    FineRotate(0);  	break;
+!   case ALG_ROTATECLR: FineRotate(1);  	break;
+!   case ALG_PIXEL:     Pixelize();     	break;
+!   case ALG_SPREAD:    Spread();       	break;
+!   case ALG_MEDIAN:    MedianFilter(); 	break;
+    }
+  
+    algMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
++   flmaskMB.dim[MSK_NONE] = (origPic == (byte *) NULL);
+  }
+  
+  
+***************
+*** 1567,1573 ****
+  
+  
+  /***********************************************/
+! static int start24bitAlg(pic24, tmpPic)
+       byte **pic24, **tmpPic;
+  {
+    /* generates a 24-bit version of 'pic', if neccessary, and also mallocs
+--- 1564,1570 ----
+  
+  
+  /***********************************************/
+! int start24bitAlg(pic24, tmpPic)
+       byte **pic24, **tmpPic;
+  {
+    /* generates a 24-bit version of 'pic', if neccessary, and also mallocs
+***************
+*** 1600,1606 ****
+  
+  
+  /***********************************************/
+! static void end24bitAlg(pic24, outPic)
+       byte *pic24, *outPic;
+  {
+    /* given pic24, and outPic, which has the new 24-bit image, installs it */
+--- 1597,1603 ----
+  
+  
+  /***********************************************/
+! void end24bitAlg(pic24, outPic)
+       byte *pic24, *outPic;
+  {
+    /* given pic24, and outPic, which has the new 24-bit image, installs it */
+***************
+*** 1629,1635 ****
+  
+  
+  /************************/
+! static void saveOrigPic()
+  {
+    /* saves original picture into origPic, if it hasn't already been done.
+       This allows us to undo algorithms...  
+--- 1626,1632 ----
+  
+  
+  /************************/
+! void saveOrigPic()
+  {
+    /* saves original picture into origPic, if it hasn't already been done.
+       This allows us to undo algorithms...  
+***************
+*** 1669,1674 ****
+      pic = NULL;
+    }
+  }
+- 
+- 
+  
+--- 1666,1669 ----
+diff -c --new-file xv-3.10a.org/xvcpmask.c xv+flmask/xvcpmask.c
+*** xv-3.10a.org/xvcpmask.c	Thu Jan  1 09:00:00 1970
+--- xv+flmask/xvcpmask.c	Sun Sep 14 07:17:54 1997
+***************
+*** 0 ****
+--- 1,108 ----
++ #include <sys/types.h>
++ #include <sys/stat.h>
++ #include <fcntl.h>
++ #include <stdio.h>
++ #include <stdlib.h>
++ #include <string.h>
++ 
++ #include "xv.h"
++ 
++ typedef struct { int n; char flg; } CPS;
++ 
++ static unsigned char CPTbl[] = {
++     0x10, 0x17, 0x13, 0x15, 0x09,
++     0x08, 0x0a, 0x14, 0x06, 0x05,
++     0x16, 0x02, 0x0d, 0x03, 0x01,
++     0x04, 0x19, 0x0c, 0x0f, 0x0e,
++     0x12, 0x07, 0x0b, 0x18, 0x11, 0x1a
++ };
++ 
++ void cpcode(char *filename,unsigned char *buff,int code_num)
++ {
++ 	int i,j,fd;
++   	unsigned char *wp, *cp;
++   	unsigned char *CP_KEY = "kIUCHIuCHINO";
++ 
++ 	if(code_num>=3) return;
++ 	if((fd=open(filename,O_RDONLY))==-1) return;
++ 
++ 	lseek(fd,20+16*code_num,SEEK_SET);
++ 	read(fd,buff,16);
++ 
++   	wp = buff;
++   	cp = CP_KEY;
++ 
++       	for ( i = 0; i < 16; i++ ) {
++           	*wp ^= *cp;
++           	if ( *wp & 0x80 ) *wp = '\0';
++ 		cp++;
++           	wp++;
++         	if ( *cp == '\0' ) cp = CP_KEY;
++    	}
++ 
++ 	for (i=0;i<16;i++) {
++ 		if (buff[i]<'A' || 'Z'<buff[i]){
++ 			buff[i]=0;
++ 			break;
++ 		}
++ 	}
++ 	close(fd);
++ }
++ 
++ 
++ static void GetCPTbl(int nTbl, char *CPcode, int *tbl, CPS *cps)
++ {
++     int i, k, vl1, vl2, len;
++ 
++     for(i = 0; i < nTbl; i++) {
++         tbl[i] = -1;
++         cps[i].n = i;
++         cps[i].flg = 0;
++     }
++     len = strlen(CPcode);
++     vl1 = nTbl - 1;
++     vl2 = len + nTbl % len;
++     for(k = 0; k < nTbl; k++) {
++         vl1 = CPTbl[CPcode[k % len] - 'A'] + vl1 + vl2;
++         if(vl1 >= nTbl) vl1 %= nTbl;
++          while(tbl[vl1] != -1) {
++             if(k & 01) {
++                 if(vl1 == 0) vl1 = nTbl;
++                 vl1--;
++             }
++             else {
++                 if(++vl1 >= nTbl) vl1 = 0;
++             }
++         }
++         tbl[vl1] = k;
++         vl2++;
++     }
++     for(i = 0, k = nTbl - 1; i < k; i++, k--) {
++         cps[tbl[i]].n = tbl[k];
++         cps[tbl[k]].n = tbl[i];
++         if((tbl[i] ^ tbl[k]) & 0x01)
++             cps[tbl[i]].flg = cps[tbl[k]].flg = 1;
++     }
++ }
++ 
++ 
++ CPS *calcCPmask(char *code, int ntbl)
++ {
++     int *tbl;
++     int len,i;
++     CPS *cps;
++ 
++     len = strlen(code);
++     tbl = (int *)malloc(sizeof(int) * ntbl);
++     cps = (CPS *)malloc(sizeof(CPS) * ntbl);
++     if(!tbl || !cps) {
++ 	ErrPopUp ("Error:  No memory!!", "\nOk");
++         if(tbl) free(tbl);
++         exit(1);
++     }
++     GetCPTbl(ntbl, code, tbl, cps);
++     
++     free(tbl);
++     return(cps);
++ }
++ 
+diff -c --new-file xv-3.10a.org/xvctrl.c xv+flmask/xvctrl.c
+*** xv-3.10a.org/xvctrl.c	Fri Dec 23 04:12:16 1994
+--- xv+flmask/xvctrl.c	Wed Sep  3 12:49:54 1997
+***************
+*** 112,117 ****
+--- 112,128 ----
+  			       "Slow 24->8",
+  			       "Best 24->8" };
+  
++ static char *mskMList[]    = { "Undo All\t\244u",
++ 			       MBSEP,
++ 			       "FLmask\t\244f",
++ 			       "Q0mask\t\244g",
++ 			       "WIN\t\244h",
++ 			       "MEKO\t\244i",
++ 			       "CPmask\t\244j",
++ 			       "RGB\t\244l",
++ 			       "BitRev.\t\244n",
++ 			       "ColRev.\t\244w"};
++ 
+  static char *algMList[]    = { "Undo All\t\244u",
+  			       MBSEP,
+   			       "Blur...\t\244b",
+***************
+*** 303,311 ****
+    BTCreate(&but[BPAD],    ctrlW,BX0,          BY1,BUTTW/2,BUTTH,"",BCLS);
+    BTCreate(&but[BANNOT],  ctrlW,BX0+BUTTW/2+1,BY1,BUTTW/2,BUTTH,"",BCLS);
+  
+!   BTCreate(&but[BCROP],   ctrlW,BX1,  BY1,BUTTW,BUTTH,"Crop",    BCLS);
+!   BTCreate(&but[BUNCROP], ctrlW,BX2,  BY1,BUTTW,BUTTH,"UnCrop",  BCLS);
+!   BTCreate(&but[BACROP],  ctrlW,BX3,  BY1,BUTTW,BUTTH,"AutoCrop",BCLS);
+    BTCreate(&but[BABOUT],  ctrlW,BX4,  BY1,BUTTW,BUTTH,"About XV",BCLS);
+    BTCreate(&but[BQUIT],   ctrlW,BX5,  BY1,BUTTW,BUTTH,"Quit",    BCLS);
+  
+--- 314,324 ----
+    BTCreate(&but[BPAD],    ctrlW,BX0,          BY1,BUTTW/2,BUTTH,"",BCLS);
+    BTCreate(&but[BANNOT],  ctrlW,BX0+BUTTW/2+1,BY1,BUTTW/2,BUTTH,"",BCLS);
+  
+! #define NEW_BUTW BUTTW*3/4
+!   BTCreate(&but[BCROP],   ctrlW,BX1            ,BY1,NEW_BUTW,BUTTH,"Crp",    BCLS);
+!   BTCreate(&but[BUNCROP], ctrlW,BX1+NEW_BUTW+1   ,BY1,NEW_BUTW,BUTTH,"UCrp",  BCLS);
+!   BTCreate(&but[BACROP],  ctrlW,BX1+NEW_BUTW*2+2,BY1,NEW_BUTW,BUTTH,"ACrp",BCLS);
+!   BTCreate(&but[BMASKS],  ctrlW,BX1+NEW_BUTW*3+3,BY1,NEW_BUTW,BUTTH,"Mask",BCLS);
+    BTCreate(&but[BABOUT],  ctrlW,BX4,  BY1,BUTTW,BUTTH,"About XV",BCLS);
+    BTCreate(&but[BQUIT],   ctrlW,BX5,  BY1,BUTTW,BUTTH,"Quit",    BCLS);
+  
+***************
+*** 341,356 ****
+    /* have to create menu buttons after XMapSubWindows, as we *don't* want 
+       the popup menus mapped */
+  
+!   MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5,112,19, 
+  	   "Display",    dispMList,   DMB_MAX,    BCLS);
+!   MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5,112,19, 
+  	   "24/8 Bit",   conv24MList, CONV24_MAX, BCLS);
+!   MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 112,             5,112,19, 
+! 	   "Algorithms", algMList,    ALG_MAX,    BCLS);
+  
+!   MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5+21,112,19, 
+  	   "Root",       rootMList,   RMB_MAX,    BCLS);
+!   MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5+21,112,19, 
+  	   "Windows",    windowMList, WMB_MAX,    BCLS);
+    MBCreate(&sizeMB,   ctrlW, CTRLWIDE - 8 - 112,             5+21,112,19, 
+  	   "Image Size", sizeMList,   SZMB_MAX,   BCLS);
+--- 354,371 ----
+    /* have to create menu buttons after XMapSubWindows, as we *don't* want 
+       the popup menus mapped */
+  
+!   MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 84 - 3*(84+2), 5,84,19, 
+  	   "Display",    dispMList,   DMB_MAX,    BCLS);
+!   MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 84 - 2*(84+2), 5,84,19, 
+  	   "24/8 Bit",   conv24MList, CONV24_MAX, BCLS);
+!   MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 84 - (84+2),   5,84,19, 
+! 	   "Algo.", algMList,    ALG_MAX,    BCLS);
+!   MBCreate(&flmaskMB, ctrlW, CTRLWIDE - 8 - 84,          5,84,19, 
+! 	   "FLmask", mskMList,    MSK_MAX,    BCLS);
+  
+!   MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+3), 5+21,112,19, 
+  	   "Root",       rootMList,   RMB_MAX,    BCLS);
+!   MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+3),   5+21,112,19, 
+  	   "Windows",    windowMList, WMB_MAX,    BCLS);
+    MBCreate(&sizeMB,   ctrlW, CTRLWIDE - 8 - 112,             5+21,112,19, 
+  	   "Image Size", sizeMList,   SZMB_MAX,   BCLS);
+***************
+*** 437,442 ****
+--- 452,458 ----
+    MBRedraw(&dispMB);
+    MBRedraw(&conv24MB);
+    MBRedraw(&algMB);
++   MBRedraw(&flmaskMB);
+    MBRedraw(&rootMB);
+    MBRedraw(&windowMB);
+    MBRedraw(&sizeMB);
+diff -c --new-file xv-3.10a.org/xvcut.c xv+flmask/xvcut.c
+*** xv-3.10a.org/xvcut.c	Fri Sep  5 21:12:32 1997
+--- xv+flmask/xvcut.c	Wed Sep  3 12:49:55 1997
+***************
+*** 101,107 ****
+  static Cursor cutcurs  = (Cursor) 0;
+  
+  
+! 
+  
+  /********************************************/
+  int CutAllowed()
+--- 101,108 ----
+  static Cursor cutcurs  = (Cursor) 0;
+  
+  
+! /* FLmask: Mask Select. */
+! void MaskSelect (int,int,int,int);
+  
+  /********************************************/
+  int CutAllowed()
+***************
+*** 1859,1862 ****
+--- 1860,1870 ----
+    CoordC2P(cx, cy, px_ret, py_ret);
+  }
+  
++ 
++ void MaskSelect (x1,x2,y1,y2)
++ int x1,x2,y1,y2;
++ {
++ 	selrx = x1;  selry = y1;  selrw = x2;  selrh = y2;
++ 	EnableSelection(1);
++ }
+  
+diff -c --new-file xv-3.10a.org/xvevent.c xv+flmask/xvevent.c
+*** xv-3.10a.org/xvevent.c	Sun Sep 14 02:29:13 1997
+--- xv+flmask/xvevent.c	Wed Sep  3 12:51:25 1997
+***************
+*** 1245,1250 ****
+--- 1245,1256 ----
+  	  if (i>=0) DoAlg(i);
+  	  break;
+  	}
++ 
++ 	else if (MBClick(&flmaskMB, x,y)) {
++ 	  i = MBTrack(&flmaskMB);
++ 	  if (i>=0) DoMask(i);
++ 	  break;
++ 	}
+  	
+  	i=ClickCtrl(x,y);
+  	
+***************
+*** 1271,1276 ****
+--- 1277,1283 ----
+  	case BCROP:   Crop();                       break;
+  	case BUNCROP: UnCrop();                     break;
+  	case BACROP:  AutoCrop();                   break;
++ 	case BMASKS:  MaskCr();			    break;	
+  	  
+  	case BPAD:
+  	  {
+***************
+*** 1587,1592 ****
+--- 1594,1609 ----
+        else if (ks==XK_d) FakeButtonPress(&but[BCLEAR]);
+  
+        else if (ks==XK_u) DoAlg(ALG_NONE);
++ 
++       else if (ks==XK_f) DoMask(MSK_FLMASK);
++       else if (ks==XK_g) DoMask(MSK_Q0MASK);
++       else if (ks==XK_h) DoMask(MSK_WIN);
++       else if (ks==XK_i) DoMask(MSK_MEKO);
++       else if (ks==XK_j) DoMask(MSK_CPMASK);
++       else if (ks==XK_l) DoMask(MSK_RGB);
++       else if (ks==XK_n) DoMask(MSK_BITREV);
++       else if (ks==XK_w) DoMask(MSK_COLREV);
++ 
+        else if (ks==XK_b) DoAlg(ALG_BLUR);
+        else if (ks==XK_s) DoAlg(ALG_SHARPEN);
+        else if (ks==XK_e) DoAlg(ALG_EDGE);
+***************
+*** 1625,1631 ****
+      }
+      else {                               /* commands valid in any window */
+        switch (buf[0]) {
+! 	
+  	/* things in dispMB */
+        case 'r':    SelectDispMB(DMB_RAW);           break;
+        case 'd':    SelectDispMB(DMB_DITH);          break;
+--- 1642,1648 ----
+      }
+      else {                               /* commands valid in any window */
+        switch (buf[0]) {
+! 
+  	/* things in dispMB */
+        case 'r':    SelectDispMB(DMB_RAW);           break;
+        case 'd':    SelectDispMB(DMB_DITH);          break;
+***************
+*** 1689,1694 ****
+--- 1706,1712 ----
+        case 'c':    FakeButtonPress(&but[BCROP]);    break;
+        case 'u':    FakeButtonPress(&but[BUNCROP]);  break;
+        case 'C':    FakeButtonPress(&but[BACROP]);   break;
++       case 'f':    FakeButtonPress(&but[BMASKS]);   break;
+        case 'P':    FakeButtonPress(&but[BPAD]);     break;
+        case 'A':    FakeButtonPress(&but[BANNOT]);   break;
+  	
+diff -c --new-file xv-3.10a.org/xvimage.c xv+flmask/xvimage.c
+*** xv-3.10a.org/xvimage.c	Fri Sep  5 21:12:33 1997
+--- xv+flmask/xvimage.c	Wed Sep  3 12:49:54 1997
+***************
+*** 45,51 ****
+  static int  doPadPaste        PARM((byte *, int, int, int, int));
+  static int  ReadImageFile1    PARM((char *, PICINFO *));
+  
+! 
+  
+  #define DO_CROP 0
+  #define DO_ZOOM 1
+--- 45,52 ----
+  static int  doPadPaste        PARM((byte *, int, int, int, int));
+  static int  ReadImageFile1    PARM((char *, PICINFO *));
+  
+! byte *origPic;
+! int  origPicType;
+  
+  #define DO_CROP 0
+  #define DO_ZOOM 1
+***************
+*** 910,915 ****
+--- 911,922 ----
+    /* dir=0: 90 degrees clockwise, else 90 degrees counter-clockwise */
+    WaitCursor();
+    
++   if (origPic!=NULL) {
++ 	  int tmp_pw,tmp_ph;
++ 	  tmp_pw=pWIDE;
++ 	  tmp_ph=pHIGH;
++ 	  RotatePic(origPic,origPicType,&tmp_pw,&tmp_ph,dir);
++   }
+    RotatePic(pic, picType, &pWIDE, &pHIGH, dir);
+    
+    /* rotate clipped version and modify 'clip' coords */
+diff -c --new-file xv-3.10a.org/xvmask.c xv+flmask/xvmask.c
+*** xv-3.10a.org/xvmask.c	Thu Jan  1 09:00:00 1970
+--- xv+flmask/xvmask.c	Sun Sep 14 07:17:12 1997
+***************
+*** 0 ****
+--- 1,912 ----
++ /*
++  * xvmask.c - image mask algorithms (FLmask, etc.)
++  *
++  *  Contains:
++  *         void DoMask(int algnum);
++  */
++ 
++ #include "copyright.h"
++ #include "xv.h"
++ 
++ typedef struct { int n; char flg; } CPS;
++ typedef struct { int n; unsigned short int r; } MKT;
++ 
++ /* Flmask */
++ void cpcode 		PARM ((char *, unsigned char *, int));
++ void MaskCr 		PARM ((void));
++ static void FLmask 	PARM ((void));
++ static void Q0mask 	PARM ((void));
++ static void WINmask 	PARM ((void));
++ static void MEKOmask 	PARM ((void));
++ static void CPmask 	PARM ((void));
++ static void XOR80 	PARM ((void));
++ static void RGBchange 	PARM ((void));
++ static void BitReverse 	PARM ((void));
++ static void ColReverse 	PARM ((void));
++ 
++ /***** Flmask *****/
++ static void doMaskCr 		PARM ((byte *, int, int, int, int, int, int));
++ static void doFLmask 		PARM ((byte *, int, int, byte *, int, int, int, int));
++ static void doCPmask 		PARM ((byte *, int, int, byte *, int, int, int, int, char *));
++ static void doMEKOmask 		PARM ((byte *, int, int, byte *, int, int, int, int, int));
++ static void doColReverse 	PARM ((byte *, int, int, byte *, int, int, int, int, int));
++ static void doRGBchange 	PARM ((byte *, int, int, byte *, int, int, int, int));
++ static void doQ0mask 		PARM ((byte *, int, int, byte *, int, int, int, int, int, int));
++ static int *calcFLmask 		PARM ((int, int));
++ static void move8bit 		PARM ((byte *, byte *, int));
++ static void move16bit 		PARM ((byte *, byte *, int));
++ static void moveCP 		PARM ((byte *, byte *, int, int));
++ static void doWINmask 		PARM ((byte *, int, int, byte *, int, int, int, int));
++ static void wincp 		PARM ((int, int, byte *, byte *));
++ 
++ /******************/
++ 
++ int start24bitAlg 		PARM ((byte **, byte **));
++ void end24bitAlg 		PARM ((byte *, byte *));
++ void saveOrigPic 		PARM ((void));
++ void printUTime 		PARM ((char *));
++ 
++ byte *origPic;
++ 
++ #undef TIMING_TEST
++ 
++ #ifdef TIMING_TEST
++ #include <sys/time.h>
++ #include <sys/resource.h>
++ #endif
++ 
++ /************************/
++ void
++ DoMask (anum)
++      int anum;
++ {
++     switch (anum)
++     {
++     case MSK_NONE: 	DoAlg (ALG_NONE); 	break;
++     case MSK_FLMASK: 	FLmask (); 		break;
++     case MSK_Q0MASK: 	Q0mask (); 		break;
++     case MSK_WIN: 	WINmask (); 		break;
++     case MSK_MEKO: 	MEKOmask (); 		break;
++     case MSK_CPMASK: 	CPmask (); 		break;
++     case MSK_RGB: 	RGBchange (); 		break;
++     case MSK_BITREV: 	BitReverse (); 		break;
++     case MSK_COLREV: 	ColReverse (); 		break;
++     }
++ 
++     algMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
++     flmaskMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
++ }
++ 
++ 
++ /******************************
++       Flmask:  FLMASK.
++ ******************************/
++ static void
++ FLmask ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     str = "Doing FLMASK...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic))
++ 	return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doFLmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
++ 
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /******************************
++       Flmask:  BitReverse.
++ ******************************/
++ static void
++ BitReverse ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     str = "Doing reverse bit...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic))
++ 	return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doColReverse (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, 1);
++ 
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /******************************
++       Flmask:  ColReverse.
++ ******************************/
++ static void
++ ColReverse ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     str = "Doing reverse colormap...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic))
++ 	return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doColReverse (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, 0);
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ 
++ /******************************
++       Flmask:  Q0 MASK.
++ ******************************/
++ static void
++ Q0mask ()
++ {
++     int pixX, pixY, err;
++     static char *labels[] = {"\nOk", "\033Cancel"};
++     char txt[256];
++     static char buf[64] = {'8', '\0'};
++     byte *pic24, *p24, *tmpPic, *tp, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     sprintf (txt, "FLmask: Q0mask        \n\nEnter mask pixels size: %s\n", "(ex. '8', '8x16')");
++ 
++     i = GetStrPopUp (txt, labels, 2, buf, 64, "0123456789x", 1);
++     if (i == 1 || strlen (buf) == 0) return;
++ 
++     pixX = pixY = err = 0;
++ 
++     if (index (buf, 'x'))
++     {
++ 	if (sscanf (buf, "%d x %d", &pixX, &pixY) != 2) err++;
++     }
++     else
++     {
++ 	if (sscanf (buf, "%d", &pixX) != 1) err++;
++ 	pixY = pixX;
++     }
++ 
++     if (pixX < 1 || pixY < 1 || err)
++     {
++ 	ErrPopUp ("Error:  The entered string is not valid.",
++ 		  "\nWho Cares!");
++ 	return;
++     }
++     WaitCursor ();
++ 
++     str = "Doing Q0 MASK...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doQ0mask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, pixX, pixY);
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /******************************
++       Flmask:  RGBchange.
++ ******************************/
++ static void
++ RGBchange ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     str = "Doing RGB change...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doRGBchange (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
++ 
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /******************************
++       Flmask:  WINmask.
++ ******************************/
++ static void
++ WINmask ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     str = "Doing WIN mask...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doWINmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
++ 
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /******************************
++       Flmask:  MEKOmask.
++ ******************************/
++ static
++ void
++ MEKOmask ()
++ {
++     static char *labels[] = {"\nForward", "\nBackward"};
++     char txt[256], key[48];
++     byte *pic24, *p24, *tmpPic, *tp, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     memset (key, 0, 48);
++ 
++     sprintf (txt, "FLmask: MEKO mask  \n\n    Select MEKOmask type ",
++ 	     key);
++     i = PopUp (txt, labels, 2);
++ 
++     WaitCursor ();
++     str = "Doing MEKOmask...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++     doMEKOmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, i);
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /************************/
++ static void
++ doMEKOmask (pic24, w, h, results, selx, sely, selw, selh, flag)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh, flag;
++ {
++     register byte *dst, *src;
++     register int x, y, i;
++     register int xmax, ymax;
++     MKT *mt;
++ 
++     printUTime ("start of MEKOmask.");
++ 
++     xmax = selw / 16;
++     ymax = selh / 16;
++ 
++     mt = (MKT *) calcMEKO (xmax * ymax);
++     if (mt == NULL)
++ 	return;
++ 
++     for (i = 0; i < xmax * ymax; i++)
++     {
++ 	ProgressMeter (1, (xmax * ymax) - 1, i, "MEKOmask");
++ 	if ((i & 63) == 0)
++ 	    WaitCursor ();
++ 
++ 	if (flag == 0)
++ 	{
++ 	    dst = results + ((sely + ((mt[i].n - 1) / xmax) * 16) * w
++ 			     + selx + ((mt[i].n - 1) % xmax) * 16) * 3;
++ 	    src = pic24 + ((sely + (i / xmax) * 16) * w
++ 			   + selx + (i % xmax) * 16) * 3;
++ 	}
++ 	else
++ 	{
++ 	    src = pic24 + ((sely + ((mt[i].n - 1) / xmax) * 16) * w
++ 			   + selx + ((mt[i].n - 1) % xmax) * 16) * 3;
++ 	    dst = results + ((sely + (i / xmax) * 16) * w
++ 			     + selx + (i % xmax) * 16) * 3;
++ 	}
++ 	move16bit (dst, src, w);
++     }
++ 
++     free (mt);
++     printUTime ("end of MEKOmask.");
++ }
++ 
++ static void
++ move16bit (byte * dest, byte * src, int w)
++ {
++     int y, x;
++     byte *tmp1, *tmp2;
++ 
++     for (y = 0; y < 16; y++)
++     {
++ 	tmp1 = dest + y * w * 3;
++ 	tmp2 = src + y * w * 3;
++ 	for (x = 0; x < 16 * 3; x++)
++ 	{
++ 	    *tmp1 = *tmp2;
++ 	    tmp1++;
++ 	    tmp2++;
++ 	}
++     }
++ }
++ 
++ /******************************
++       Flmask:  CP MASK.
++ ******************************/
++ static void
++ CPmask ()
++ {
++     static char *labels[] = {"\nOk", "\033Cancel"};
++     char buf[64];
++     char txt[256], key[48];
++     byte *pic24, *p24, *tmpPic, *tp, *tlp;
++     char *str;
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     memset (key, 0, 48);
++     cpcode (fullfname, key, 0);
++     if (key[0] == 0)
++     {
++ 	memset (key, 0, 48);
++ 	cpcode (fullfname, key, 1);
++ 	if (key[0] == 0)
++ 	{
++ 	    memset (key, 0, 48);
++ 	    cpcode (fullfname, key, 2);
++ 	}
++     }
++ 
++     strcpy(buf,key);
++     if (strlen(buf)==0)strcpy(buf,"SAMPLE");
++     sprintf (txt, "FLmask: CPmask          \n\nEnter CPmask code: %s \n",
++     	"(ex. 'SAMPLE')");
++ 
++     i = GetStrPopUp (txt, labels, 2, buf, 64, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1);
++     if (i == 1 || strlen (buf) == 0) return; 
++     strcpy(key,buf);
++ 
++     /*  Old version.
++     sprintf (txt, "FLmask: CP mask  \n\n   CP code = %s ", key);
++     i = PopUp (txt, labels, 2);
++     if (i == 1) return;
++     */
++ 
++     WaitCursor ();
++     str = "Doing CP mask...";
++     SetISTR (ISTR_INFO, str);
++ 
++     if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
++     else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++     doCPmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, key);
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /************************/
++ static void
++ doCPmask (pic24, w, h, results, selx, sely, selw, selh, key)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh;
++      char *key;
++ {
++     register byte *dst, *src;
++     register int x, y, i;
++     register int xmax, ymax;
++     CPS *cps;
++ 
++     printUTime ("start of CPmask.");
++ 
++     xmax = selw / 8;
++     ymax = selh / 8;
++ 
++     cps = (CPS *) calcCPmask (key, xmax * ymax);
++ 
++     for (i = 0; i < xmax * ymax; i++)
++     {
++ 	ProgressMeter (1, (xmax * ymax) - 1, i, "CPmask");
++ 	if ((i & 63) == 0) WaitCursor ();
++ 
++ 	dst = results + ((sely + (cps[i].n / xmax) * 8) * w
++ 			 + selx + (cps[i].n % xmax) * 8) * 3;
++ 	src = pic24 + ((sely + (i / xmax) * 8) * w
++ 		       + selx + (i % xmax) * 8) * 3;
++ 	moveCP (dst, src, w, cps[i].flg);
++     }
++ 
++     free (cps);
++     printUTime ("end of CPmask.");
++ }
++ 
++ static void
++ moveCP (byte * dest, byte * src, int w, int cp_flag)
++ {
++     int y, x;
++     byte *tmp1, *tmp2;
++ 
++     if (cp_flag == 0)
++     {
++ 	for (y = 0; y < 8; y++)
++ 	{
++ 	    tmp1 = dest + y * w * 3;
++ 	    tmp2 = src + y * w * 3;
++ 	    for (x = 0; x < 8 * 3; x += 3)
++ 	    {
++ 		tmp1[0] = (byte) ~ tmp2[1];
++ 		tmp1[1] = (byte) ~ tmp2[0];
++ 		tmp1[2] = (byte) ~ tmp2[2];
++ 		tmp1 += 3;
++ 		tmp2 += 3;
++ 	    }
++ 	}
++     }
++     else
++     {
++ 	for (y = 0; y < 8; y++)
++ 	{
++ 	    tmp1 = dest + y * 3;
++ 	    tmp2 = src + y * w * 3;
++ 	    for (x = 0; x < 8 * 3; x += 3)
++ 	    {
++ 		tmp1[0] = (byte) ~ tmp2[1];
++ 		tmp1[1] = (byte) ~ tmp2[0];
++ 		tmp1[2] = (byte) ~ tmp2[2];
++ 		tmp1 += w * 3;
++ 		tmp2 += 3;
++ 	    }
++ 	}
++     }
++ }
++ 
++ /************************/
++ static void
++ doFLmask (pic24, w, h, results, selx, sely, selw, selh)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh;
++ {
++     register byte *dst, *src;
++     register int x, y, i;
++     register int *ar, xmax, ymax;
++ 
++     printUTime ("start of FLMASK.");
++ 
++     xmax = selw / 8;
++     ymax = selh / 8;
++     ar = (int *) calcFLmask (xmax, ymax);
++ 
++     for (i = 0; i < xmax * ymax; i++)
++     {
++ 	ProgressMeter (1, (xmax * ymax * 2) - 1,
++ 		i + xmax * ymax, "FLMASK");
++ 	if ((i & 63) == 0) WaitCursor ();
++ 
++ 	dst=results+((sely+(ar[xmax*ymax-i-1]/xmax)*8)*w
++ 		+selx+(ar[xmax*ymax-i-1]%xmax)*8)*3;
++ 	src=pic24+((sely+(ar[i]/xmax)*8)*w
++ 		+selx+(ar[i]%xmax)*8)*3;
++ 	if (ar[i] != ar[xmax * ymax - i - 1])
++ 	    move8bit (dst, src, w);
++     }
++ 
++     free (ar);
++     printUTime ("end of FLMASK.");
++ }
++ 
++ static int *
++ calcFLmask (int xmax, int ymax)
++ {
++     int *spc, *tmp_ar;
++     int i, l, x, y, c;
++     struct direction { int x; int y; } dir[4];
++ 
++     dir[0].x = 0;  dir[0].y = -1;
++     dir[1].x = -1; dir[1].y = 0;
++     dir[2].x = 0;  dir[2].y = 1;
++     dir[3].x = 1;  dir[3].y = 0;
++ 
++     spc = (int *) malloc (sizeof (int) * xmax * ymax);
++     tmp_ar = (int *) malloc (sizeof (int) * xmax * ymax);
++ 
++     c = 0;
++     for (l = 0; l < ymax; l++)
++     {
++ 	for (i = 0; i < xmax; i++)
++ 	{
++ 	    spc[c] = c;
++ 	    c++;
++ 	}
++     }
++ 
++     c = 3;
++     x = 0;
++     y = ymax - 1;
++     for (i = 0; i < xmax * ymax; i++)
++     {
++ 	ProgressMeter (1, (xmax * ymax * 2) - 1, i, "FLmask");
++ 	if ((i & 63) == 0) WaitCursor ();
++ 
++ 	tmp_ar[i] = spc[x + y * xmax];
++ 	if ((x + dir[c].x) == xmax || (x + dir[c].x) < 0)
++ 	{
++ 	    c++;
++ 	    if (c == 4) c = 0;
++ 	}
++ 	if ((y + dir[c].y) == ymax || (y + dir[c].y) < 0)
++ 	{
++ 	    c++;
++ 	    if (c == 4) c = 0;
++ 	}
++ 	for (l = 0; l < i; l++)
++ 	{
++ 		if(spc[x+(dir[c].x)+(y+(dir[c].y))*xmax]==tmp_ar[l])
++ 	    {
++ 		c++;
++ 		if (c == 4) c = 0;
++ 		break;
++ 	    }
++ 	}
++ 	x = x + dir[c].x;
++ 	y = y + dir[c].y;
++     }
++     free (spc);
++     return (tmp_ar);
++ }
++ 
++ static void
++ move8bit (byte * dest, byte * src, int w)
++ {
++     int y, x;
++     byte *tmp1, *tmp2;
++ 
++     for (y = 0; y < 8; y++)
++     {
++ 	tmp1 = dest + y * w * 3;
++ 	tmp2 = src + y * w * 3;
++ 	for (x = 0; x < 8 * 3; x++)
++ 	{
++ 	    *tmp1 = (byte) ~ (*tmp2);
++ 	    tmp1++;
++ 	    tmp2++;
++ 	}
++     }
++ }
++ 
++ /************************/
++ static void
++ doColReverse (pic24, w, h, results, selx, sely, selw, selh, bit_flag)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh, bit_flag;
++ {
++     register byte *p24;
++     register byte *rp;
++     register int x, y;
++ 
++     printUTime ("start of Reverse.");
++ 
++     for (y = sely; y < sely + selh; y++)
++     {
++ 
++ 	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Reverse");
++ 	if ((y & 63) == 0) WaitCursor ();
++ 
++ 	rp = results + (y * w + selx) * 3;
++ 	p24 = pic24 + (y * w + selx) * 3;
++ 
++ 	if (bit_flag == 1)
++ 	{
++ 	    /* BitReverse. */
++ 	    for (x = selx; x < selx + selw * 3; x++, p24++, rp++)
++ 		*rp = (byte) ~ (*p24);
++ 
++ 	}
++ 	else
++ 	{
++ 	    /* ColReverse. */
++ 	    for (x = selx; x < selx + selw * 3; x++, p24++, rp++)
++ 		*rp = *p24 ^ 0x80;
++ 	}
++     }
++     printUTime ("end of Reverse.");
++ }
++ 
++ /************************/
++ static void
++ doQ0mask (pic24, w, h, results, selx, sely, selw, selh, pixX, pixY)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh, pixX, pixY;
++ {
++     register byte *p24;
++     register int bperlin, rsum, gsum, bsum;
++     byte *rp;
++     int i, x, y;
++     int skip, y0, x0;
++ 
++     printUTime ("start of Q0mask.");
++ 
++     bperlin = w * 3;
++ 
++     for (y = sely; y < sely + ((selh / pixY) * pixY); y++)
++     {
++ 	ProgressMeter(sely+1,(sely+((selh/pixY)*pixY))-1,y,"Q0mask");
++ 	if ((y & 63) == 0) WaitCursor ();
++ 
++ 	rp = results + (y * w + selx) * 3;
++ 	y0 = y - sely;
++ 	p24=pic24+((((y0/pixY+1)*pixY)-1-(y0%pixY)+sely)*w+selx)*3;
++ 
++ 	for(x=selx;x<selx+((selw/pixX)*pixX);x++,p24+=3,rp+=3)
++ 	{
++ 	    x0 = x - selx;
++ 	    skip = (pixX - 1 - 2 * (x0 % pixX)) * 3;
++ 
++ 	    rp[0] = (byte) ~ p24[skip];
++ 	    rp[1] = (byte) ~ p24[skip + 1];
++ 	    rp[2] = (byte) ~ p24[skip + 2];
++ 	}
++     }
++     printUTime ("end of Q0 MASK.");
++ }
++ 
++ /************************/
++ static void
++ doWINmask (pic24, w, h, results, selx, sely, selw, selh)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh;
++ {
++     register byte *p24;
++     register byte *rp;
++     register int x, y;
++ 
++     printUTime ("start of WIN mask.");
++ 
++     for (y = sely; y < sely + selh; y++)
++     {
++ 
++ 	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "WINmask");
++ 	if ((y & 63) == 0) WaitCursor ();
++ 
++ 	rp = results + (y * w + selx) * 3;
++ 	p24 = pic24 + (y * w + selx) * 3;
++ 
++ 	for(x=selx;x<selx+(selw/16)*16*3;x+=48,p24+=48,rp+=48)
++ 	{
++ 	    wincp ( 0,12, p24, rp);
++ 	    wincp ( 1, 8, p24, rp);
++ 	    wincp ( 2, 6, p24, rp);
++ 	    wincp ( 3,15, p24, rp);
++ 	    wincp ( 4, 9, p24, rp);
++ 	    wincp ( 5,13, p24, rp);
++ 	    wincp ( 6, 2, p24, rp);
++ 	    wincp ( 7,11, p24, rp);
++ 	    wincp ( 8, 1, p24, rp);
++ 	    wincp ( 9, 4, p24, rp);
++ 	    wincp (10,14, p24, rp);
++ 	    wincp (11, 7, p24, rp);
++ 	    wincp (12, 0, p24, rp);
++ 	    wincp (13, 5, p24, rp);
++ 	    wincp (14,10, p24, rp);
++ 	    wincp (15, 3, p24, rp);
++ 	}
++     }
++     printUTime ("end of WIN mask.");
++ }
++ 
++ static void
++ wincp (int src, int dst, byte * p24, byte * rp)
++ {
++     *(rp + dst * 3) = *(p24 + src * 3);
++     *(rp + dst * 3 + 1) = *(p24 + src * 3 + 1);
++     *(rp + dst * 3 + 2) = *(p24 + src * 3 + 2);
++ }
++ 
++ /************************/
++ static void
++ doRGBchange (pic24, w, h, results, selx, sely, selw, selh)
++      byte *pic24, *results;
++      int w, h, selx, sely, selw, selh;
++ {
++     register byte *p24;
++     register byte *rp;
++     register int x, y;
++ 
++     printUTime ("start of RGB change.");
++ 
++     for (y = sely; y < sely + selh; y++)
++     {
++ 
++ 	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Change");
++ 	if ((y & 63) == 0) WaitCursor ();
++ 
++ 	rp = results + (y * w + selx) * 3;
++ 	p24 = pic24 + (y * w + selx) * 3;
++ 
++ 	for (x = selx; x < selx + selw * 3; x += 3, p24 += 3, rp += 3)
++ 	{
++ 	    *rp = *(p24 + 1);
++ 	    *(rp + 1) = *(p24 + 2);
++ 	    *(rp + 2) = *(p24);
++ 	}
++     }
++     printUTime ("end of Reverse.");
++ }
++ 
++ 
++ /******************************
++       Flmask:  MaskCrop.
++ ******************************/
++ void
++ MaskCr ()
++ {
++     byte *pic24, *p24, *tmpPic, *tlp;
++     char str[] = "Doing AutoMaskCrop...";
++     int i, j, v, maxv, sx, sy, sw, sh;
++ 
++     WaitCursor ();
++ 
++     if (HaveSelection ())
++ 	GetSelRCoords (&sx, &sy, &sw, &sh);
++     else
++     {
++ 	sx = 0;
++ 	sy = 0;
++ 	sw = pWIDE - 1;
++ 	sh = pHIGH - 1;
++     }
++ 
++     CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
++ 
++     SetISTR (ISTR_INFO, str);
++ 
++     if (start24bitAlg (&pic24, &tmpPic)) return;
++     xvbcopy ((char *) pic24, (char *) tmpPic,
++ 	     (size_t) (pWIDE * pHIGH * 3));
++ 
++     doMaskCr (pic24, pWIDE, pHIGH, sx, sy, sw, sh);
++ 
++     end24bitAlg (pic24, tmpPic);
++ }
++ 
++ /************************/
++ static void
++ doMaskCr (pic24, w, h, selx, sely, selw, selh)
++      byte *pic24;
++      int w, h, selx, sely, selw, selh;
++ {
++     register byte *p24, *p24u;
++     register int x, y;
++     double edge, *edgeX, *edgeY, maxX, maxY, tmp;
++     int x1, x2, y1, y2, i;
++     int xp1, xp2, yp1, yp2;
++ 
++     printUTime ("start of MaskCrop.");
++ 
++     edgeX = (double *) malloc (sizeof (edge) * selw);
++     edgeY = (double *) malloc (sizeof (edge) * selh);
++     memset (edgeX, 0, sizeof (edge) * selw);
++     memset (edgeY, 0, sizeof (edge) * selh);
++ 
++     for (y = sely + 1; y < sely + selh - 1; y++)
++     {
++ 	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Search");
++ 	if ((y & 63) == 0) WaitCursor ();
++ 
++ 	p24u = pic24 + ((y - 1) * w + selx) * 3;
++ 	p24 = pic24 + (y * w + selx) * 3;
++ 
++ #define DBL(x)	((x)*(x))
++ 	for (x = selx; x < selx + selw * 3; x += 3)
++ 	{
++ 	    edgeX[(x - selx) / 3] += (double) DBL (p24[3] - p24[0]) +
++ 		DBL (p24[4] - p24[1]) + DBL (p24[5] - p24[2]);
++ 	    edgeY[y - sely] += (double) DBL (p24[0] - p24u[0]) +
++ 		DBL (p24[1] - p24u[1]) + DBL (p24[2] - p24u[2]);
++ 	    p24u += 3;
++ 	    p24 += 3;
++ 	}
++     }
++ 
++     maxX = 0;
++     for (x = 0; x < selw; x++)
++     {
++ 	if (maxX < edgeX[x])
++ 	    maxX = edgeX[x];
++     }
++     maxY = 0;
++     for (y = 0; y < selh; y++)
++     {
++ 	if (maxY < edgeY[y])
++ 	    maxY = edgeY[y];
++     }
++ 
++     tmp = 0.3;	/* ←↓この辺の数値は適当に決定されました(?)。 */
++     for (;;)
++     {
++ 	xp1 = 0; xp2 = 0;
++ 	yp1 = 0; yp2 = 0;
++ 	for (x = 1; x < selw - 1; x++) {
++ 	    if (edgeX[x] > maxX * tmp) { xp1 = x; break; }
++ 	}
++ 	for (x = selw - 1; x >= 1; x--) {
++ 	    if (edgeX[x] > maxX * tmp) { xp2 = x; break; }
++ 	}
++ 	for (y = 1; y < selh - 1; y++) {
++ 	    if (edgeY[y] >= maxY * tmp) { yp1 = y; break; }
++ 	}
++ 	for (y = selh - 1; y >= 1; y--) {
++ 	    if (edgeY[y] >= maxY * tmp) { yp2 = y; break; }
++ 	}
++ 	if(xp2-xp1 > 4 && yp2-yp1 > 4 && xp1*xp2*yp1*yp2 != 0) break;
++ 
++ 	if (tmp <= 0.01) return;
++ 	else tmp = tmp / 2.0;
++     }
++ 
++     free (edgeY);
++     free (edgeX);
++ 
++     x1 = xp1 + selx + 1;
++     x2 = xp2 - xp1;
++     y1 = yp1 + sely;
++     y2 = yp2 - yp1;
++ 
++     /* crop1(x1,y1,x2,y2,0);  <-- DO_CROP  */
++     MaskSelect (x1, x2, y1, y2);
++ 
++     printUTime ("end of MaskSearch.");
++ }
+diff -c --new-file xv-3.10a.org/xvmeko.c xv+flmask/xvmeko.c
+*** xv-3.10a.org/xvmeko.c	Thu Jan  1 09:00:00 1970
+--- xv+flmask/xvmeko.c	Tue Sep  9 21:59:21 1997
+***************
+*** 0 ****
+--- 1,962 ----
++ #include <stdio.h>
++ #include <stdlib.h>
++ 
++ unsigned short int mekornd[9216] = {
++     0x2064,0x16F2,0x0AD2,0x0E1F,0x0A31,0x17CE,0x0DE8,0x1C41,0x0878,0x1349,
++     0x184B,0x1B51,0x0841,0x19A3,0x0820,0x0C12,0x1117,0x2117,0x1BC1,0x1F13,
++     0x19ED,0x0230,0x040D,0x1957,0x116D,0x0FD6,0x1E4F,0x0C28,0x1D28,0x077A,
++     0x205E,0x053D,0x0686,0x13AC,0x1A0E,0x16DE,0x1607,0x1504,0x0CED,0x088F,
++     0x159D,0x0EF4,0x0C3F,0x1120,0x225D,0x0B43,0x1B2D,0x184C,0x043D,0x1221,
++     0x0A12,0x225C,0x04F0,0x1399,0x1289,0x1899,0x1B0B,0x1A2B,0x1383,0x084A,
++     0x1DEE,0x118C,0x2395,0x00F5,0x16CD,0x0A9C,0x0E73,0x1FF9,0x0288,0x0014,
++     0x0EA9,0x17B3,0x13AF,0x03A7,0x0CE7,0x20AC,0x0E93,0x1F1E,0x207D,0x00B4,
++     0x1833,0x1DD4,0x09FD,0x0819,0x052A,0x16C9,0x1893,0x2134,0x0D8F,0x1597,
++     0x1573,0x22B5,0x1B55,0x04CE,0x0BB1,0x02FD,0x0685,0x0AAD,0x18DA,0x0A6C,
++     0x0E92,0x15C5,0x0695,0x0A70,0x1D67,0x11D0,0x0CC9,0x1E8A,0x12AC,0x0EF1,
++     0x220D,0x04FB,0x1034,0x00F4,0x0E6D,0x1F90,0x1649,0x108C,0x0AAA,0x1160,
++     0x238F,0x056C,0x0E0C,0x20A7,0x0658,0x0502,0x1973,0x0FB2,0x12D8,0x0D94,
++     0x1201,0x03BA,0x167E,0x237F,0x0D38,0x00E0,0x2183,0x201B,0x1192,0x08C1,
++     0x1240,0x20CB,0x073F,0x10DE,0x1379,0x163A,0x1D2E,0x0A15,0x19DB,0x02CD,
++     0x01BC,0x032C,0x23B9,0x1FD2,0x1E7D,0x1518,0x2148,0x0E72,0x235E,0x1DF0,
++     0x0538,0x1BCB,0x0926,0x1C17,0x0134,0x175A,0x1872,0x0ECF,0x06EB,0x0045,
++     0x100D,0x06EF,0x1EFE,0x0777,0x006C,0x0386,0x1DA4,0x1351,0x07AB,0x21EA,
++     0x1FF2,0x1017,0x182B,0x047B,0x1531,0x19DE,0x0F3A,0x186C,0x052E,0x1A15,
++     0x23E5,0x1901,0x0B44,0x0458,0x20E8,0x20AF,0x0793,0x23DD,0x1F3B,0x17D4,
++     0x1879,0x2262,0x101D,0x224A,0x0D12,0x01F0,0x1B7D,0x1BEE,0x224F,0x04C7,
++     0x1D8F,0x132F,0x1E94,0x0F26,0x2193,0x164A,0x1B0A,0x22F2,0x0393,0x00DA,
++     0x0924,0x1DCD,0x17A2,0x038D,0x0263,0x10AA,0x2344,0x089B,0x0085,0x0C80,
++     0x196A,0x16E7,0x09C5,0x0903,0x08D3,0x21AE,0x0255,0x049D,0x1F67,0x207C,
++     0x0CCA,0x055C,0x0E8F,0x1FD3,0x15A9,0x1B9E,0x1640,0x0983,0x08CC,0x0CE6,
++     0x0E5E,0x15CF,0x2248,0x0BDB,0x1FB4,0x1BD6,0x08B2,0x092B,0x10B7,0x1832,
++     0x1558,0x214F,0x005A,0x1E9D,0x15DC,0x1DAB,0x0435,0x199F,0x0B42,0x23DA,
++     0x1BCD,0x1339,0x095C,0x1A89,0x08FA,0x2379,0x0F74,0x060A,0x1408,0x0EB3,
++     0x1559,0x00AC,0x0D0D,0x14D4,0x07B1,0x1ACC,0x1707,0x03C4,0x0FBE,0x0C76,
++     0x21A8,0x0A0B,0x0D60,0x1E97,0x1625,0x117A,0x0415,0x008F,0x1F9C,0x00A6,
++     0x19C5,0x04E7,0x21F2,0x0E08,0x17BA,0x10B9,0x0656,0x22C4,0x2048,0x070E,
++     0x15CB,0x01F3,0x0488,0x1167,0x14A2,0x08CF,0x0AC2,0x12BE,0x20A1,0x0501,
++     0x01B2,0x004B,0x10E2,0x09C9,0x01FA,0x05B7,0x0E20,0x0D55,0x003B,0x1413,
++     0x1F7E,0x1A03,0x06CB,0x21C4,0x1FA5,0x1E15,0x0C14,0x0A93,0x133B,0x0498,
++     0x1EB7,0x0BFB,0x1774,0x1F14,0x21D0,0x1930,0x04FF,0x0245,0x1B0C,0x2368,
++     0x198C,0x1487,0x08C2,0x20A0,0x18BE,0x010B,0x16AE,0x1C65,0x08EA,0x23E8,
++     0x09D0,0x158B,0x237D,0x1F72,0x2051,0x188E,0x04A7,0x2074,0x1E91,0x1557,
++     0x07DC,0x2136,0x0F50,0x234C,0x1602,0x0572,0x20DB,0x00B8,0x1929,0x17A5,
++     0x0E82,0x0D86,0x03BD,0x1B02,0x2323,0x0445,0x1AB6,0x02B4,0x0D1A,0x1524,
++     0x03FE,0x1231,0x189A,0x18DE,0x15F6,0x17EB,0x0B89,0x14CA,0x0910,0x09B9,
++     0x1380,0x0559,0x169D,0x22A0,0x00D0,0x0F7A,0x0FB7,0x1FFF,0x1996,0x06FF,
++     0x0FA5,0x1C83,0x0C61,0x1ECE,0x061F,0x193E,0x232E,0x048E,0x0B5A,0x03D4,
++     0x1CF9,0x0B0F,0x2274,0x18EF,0x1CB5,0x1CAF,0x18B1,0x0FF3,0x0712,0x19CD,
++     0x1E6E,0x0A25,0x1375,0x0525,0x19DA,0x0042,0x0BF4,0x1FFC,0x03D0,0x1974,
++     0x1C33,0x0DB3,0x0180,0x0E8C,0x22EB,0x1121,0x00A1,0x02FC,0x1B3C,0x1D68,
++     0x15FD,0x22BF,0x1C5D,0x15AB,0x1BB7,0x00F6,0x2219,0x09FB,0x18DF,0x19D5,
++     0x1396,0x044A,0x1381,0x218D,0x1AEF,0x0603,0x22E1,0x237B,0x0BD3,0x110B,
++     0x171A,0x201F,0x0C92,0x059C,0x1B10,0x14AB,0x21E1,0x074B,0x1C8D,0x083E,
++     0x1684,0x117C,0x0D73,0x1740,0x0F45,0x016C,0x153E,0x15FE,0x08C5,0x2080,
++     0x166E,0x05A2,0x1897,0x18EB,0x0038,0x1F4B,0x1EBA,0x07F5,0x0DB4,0x22E9,
++     0x0977,0x0724,0x0287,0x0DCB,0x0EFD,0x11A7,0x0C66,0x1393,0x078E,0x2017,
++     0x1849,0x03B6,0x175F,0x1E05,0x1FB7,0x0AF6,0x03AC,0x02FF,0x10EE,0x07E6,
++     0x1529,0x1EC1,0x005D,0x14BB,0x074F,0x098E,0x214B,0x0EB2,0x0B96,0x1940,
++     0x11FB,0x0721,0x180F,0x2346,0x1163,0x1BE9,0x1BC4,0x1B7E,0x03D7,0x19C0,
++     0x23F6,0x0C0C,0x1F60,0x0CD4,0x1882,0x22FB,0x21EB,0x0948,0x122B,0x0474,
++     0x121B,0x09C2,0x17CF,0x1993,0x2112,0x2259,0x2292,0x142A,0x00D2,0x125B,
++     0x0E63,0x0F81,0x0E2E,0x01EC,0x0D11,0x1791,0x2353,0x0BC5,0x239B,0x1B97,
++     0x1F68,0x173C,0x1DAD,0x0778,0x165C,0x09E2,0x0D5D,0x0E9C,0x1FBB,0x22FF,
++     0x14DF,0x0F96,0x1D08,0x1ECD,0x2114,0x10EF,0x21F4,0x0F04,0x040B,0x07D6,
++     0x01E1,0x1C95,0x0441,0x163D,0x17EE,0x032B,0x0FE6,0x2273,0x18F5,0x21FA,
++     0x0ED3,0x18DC,0x0001,0x014C,0x1144,0x032A,0x0717,0x1D14,0x04F1,0x0225,
++     0x14E3,0x026F,0x147D,0x076C,0x135B,0x1966,0x15BF,0x12D3,0x0785,0x097D,
++     0x036F,0x1B88,0x1CE2,0x1360,0x0A8B,0x1FBC,0x101F,0x005B,0x0A29,0x1303,
++     0x1CD5,0x0706,0x066E,0x04D7,0x0D9C,0x1B25,0x014F,0x1182,0x1FF0,0x1452,
++     0x0683,0x096C,0x0F79,0x0C1C,0x2394,0x1306,0x1FAD,0x081F,0x1A7D,0x181F,
++     0x0D45,0x219A,0x167A,0x1813,0x0329,0x1876,0x126D,0x097C,0x0EB6,0x1820,
++     0x1374,0x2121,0x11E4,0x0AB4,0x071E,0x03AB,0x0FA1,0x1E0A,0x1E59,0x1C85,
++     0x0197,0x1CCA,0x1148,0x1A81,0x0D04,0x1955,0x1705,0x0ED9,0x01D9,0x102E,
++     0x0480,0x0475,0x1641,0x0101,0x18A1,0x09B3,0x1B5F,0x1CFD,0x054E,0x06D5,
++     0x1A95,0x0301,0x05F6,0x150C,0x0086,0x04DC,0x05BD,0x004E,0x043C,0x1020,
++     0x136B,0x0B6D,0x00B3,0x0FCA,0x1CFC,0x16D4,0x1E32,0x09E3,0x1588,0x1B58,
++     0x0A9A,0x036A,0x0C8B,0x11EF,0x1823,0x0AF3,0x1448,0x1DCA,0x1931,0x05D6,
++     0x0CF9,0x1207,0x063F,0x0F88,0x0D46,0x1FCE,0x162F,0x08CD,0x13A6,0x181B,
++     0x2107,0x2197,0x01AF,0x09A1,0x07AA,0x01BF,0x1932,0x118F,0x1EB0,0x0A7F,
++     0x087D,0x0E2F,0x1FE0,0x12EF,0x1BEF,0x1D4D,0x1C19,0x1856,0x1D19,0x1294,
++     0x1D57,0x176C,0x02DC,0x101C,0x22B7,0x0135,0x17B5,0x0310,0x1548,0x1D2A,
++     0x1626,0x0B31,0x1E7C,0x1BE7,0x140C,0x1B81,0x019E,0x1F11,0x11C6,0x0939,
++     0x2182,0x05BB,0x06C8,0x00E4,0x0529,0x1B26,0x13FC,0x1202,0x1A32,0x07F3,
++     0x098D,0x0E58,0x01B7,0x1DB0,0x0152,0x189C,0x2073,0x0D56,0x1D5B,0x0D36,
++     0x09CC,0x18A8,0x0E5D,0x143C,0x1063,0x16CA,0x13CA,0x1E38,0x2359,0x1B9C,
++     0x0A8A,0x0A84,0x046C,0x0FF5,0x0D97,0x0A27,0x0E6B,0x10C2,0x1619,0x0DEE,
++     0x1DDC,0x0576,0x01C8,0x1069,0x0D4F,0x20AD,0x198B,0x09D5,0x0B22,0x033F,
++     0x20AA,0x1CCC,0x005F,0x0D68,0x19CB,0x1081,0x1D97,0x0AE2,0x1C5C,0x0F05,
++     0x123C,0x0B20,0x2371,0x0CEB,0x00CB,0x1F06,0x00BB,0x191B,0x0117,0x2376,
++     0x17BC,0x19CE,0x216D,0x1F07,0x1455,0x14B8,0x1C6A,0x1B80,0x0E5B,0x1851,
++     0x0172,0x23AA,0x0A22,0x0D7F,0x0720,0x0136,0x0666,0x1019,0x13FE,0x1ACE,
++     0x0B51,0x0C24,0x050E,0x1873,0x08AE,0x16AB,0x1A90,0x0A76,0x1552,0x19C4,
++     0x0FAB,0x0ABC,0x06C1,0x050A,0x0E49,0x1FCB,0x11A1,0x1387,0x0C47,0x2174,
++     0x0570,0x1BA2,0x1104,0x00AD,0x1444,0x2383,0x08C7,0x1127,0x056D,0x0D7E,
++     0x1CB9,0x02FA,0x100A,0x0C51,0x0FBA,0x1A94,0x128B,0x1859,0x2190,0x1B20,
++     0x1F56,0x186F,0x01D8,0x01F2,0x10A3,0x192C,0x0528,0x211B,0x1C92,0x0239,
++     0x0334,0x14C0,0x1D5A,0x1DE9,0x12F2,0x0A44,0x17CA,0x0F62,0x15D8,0x069F,
++     0x1D07,0x11FA,0x0816,0x153C,0x1C81,0x02F1,0x2342,0x23F7,0x0160,0x117F,
++     0x1BB9,0x1039,0x2063,0x1E3B,0x0C57,0x13E1,0x139A,0x1F12,0x15EA,0x1D48,
++     0x19C3,0x1A31,0x050C,0x13C5,0x0091,0x13A7,0x1765,0x01F8,0x1B75,0x0EA2,
++     0x1B6D,0x09EC,0x0312,0x113D,0x012D,0x18C3,0x08A0,0x0452,0x0D87,0x167D,
++     0x1DA9,0x0FF6,0x2340,0x19AD,0x007B,0x0CBC,0x1D1A,0x1AE4,0x09B4,0x11B2,
++     0x1B2C,0x14CE,0x1C5E,0x0222,0x162D,0x0C63,0x0584,0x0040,0x1D1F,0x1AF7,
++     0x0C96,0x132C,0x086B,0x136F,0x19E1,0x0DDA,0x22A5,0x22F7,0x2249,0x20C5,
++     0x0A19,0x0FDC,0x1834,0x0C58,0x1C56,0x01DC,0x1D84,0x0A66,0x2336,0x0955,
++     0x0900,0x1ED6,0x0361,0x0D58,0x1D4B,0x10C0,0x1852,0x040E,0x0F0B,0x1978,
++     0x12E8,0x2261,0x05FE,0x0BD2,0x13C8,0x0F3C,0x07A4,0x18CC,0x0A00,0x0642,
++     0x0D65,0x1DA8,0x0D15,0x2168,0x05B5,0x0DF8,0x2352,0x0408,0x07D9,0x15FA,
++     0x0E88,0x0C85,0x1FAB,0x16F5,0x1798,0x12BD,0x1FB3,0x09B6,0x12C2,0x17FA,
++     0x1BE6,0x1434,0x1DD6,0x0E18,0x08F5,0x07A7,0x0AA9,0x0099,0x1E5B,0x09F4,
++     0x1C02,0x0737,0x08B9,0x0504,0x0C05,0x0813,0x1716,0x06BE,0x1ECA,0x1995,
++     0x0D63,0x0745,0x1870,0x221D,0x0C6E,0x20D2,0x23C0,0x11D8,0x0D23,0x1924,
++     0x0D34,0x10AF,0x2339,0x1F37,0x0ACC,0x228E,0x20B1,0x127E,0x0293,0x0294,
++     0x18D2,0x0F77,0x1C89,0x035F,0x1441,0x0143,0x219C,0x042F,0x092E,0x1AC0,
++     0x0932,0x1D93,0x1AE6,0x1E03,0x0F87,0x16B4,0x15B1,0x066F,0x07A1,0x21A6,
++     0x20BD,0x201C,0x10F2,0x16B2,0x13B8,0x0C90,0x013E,0x191C,0x1ACA,0x10E0,
++     0x12DA,0x0047,0x15B8,0x1E51,0x0693,0x02CF,0x169A,0x1571,0x2167,0x022F,
++     0x2150,0x11A0,0x137D,0x143A,0x02D9,0x07AC,0x0B18,0x1730,0x0E1B,0x0BC3,
++     0x2178,0x1656,0x1041,0x1FDE,0x044C,0x21EC,0x1CF0,0x04A0,0x17F2,0x1D8B,
++     0x172B,0x0826,0x0B38,0x1FB6,0x07BA,0x1632,0x0BFF,0x12B8,0x0073,0x1D94,
++     0x0457,0x05B8,0x0CA6,0x08EC,0x1663,0x07CF,0x0E04,0x2116,0x23D6,0x1F6F,
++     0x0884,0x17D1,0x0B14,0x1222,0x0774,0x16C8,0x16A8,0x1DCF,0x1E21,0x1A42,
++     0x0CF4,0x184F,0x1AD3,0x1DA5,0x04F9,0x0F39,0x2173,0x091B,0x0648,0x21A7,
++     0x1481,0x15FB,0x0C69,0x064B,0x00BE,0x08D5,0x211D,0x07E5,0x22F6,0x10A7,
++     0x0791,0x1F88,0x0FB6,0x2004,0x014E,0x187E,0x17D7,0x2345,0x0C83,0x0DE6,
++     0x12B6,0x0365,0x1D4A,0x1C43,0x1266,0x083D,0x1A5F,0x0029,0x223B,0x1809,
++     0x0589,0x001C,0x0F90,0x1B77,0x10CC,0x12CB,0x0703,0x0471,0x0E6E,0x05E6,
++     0x0E95,0x0912,0x18DD,0x1EEA,0x02CA,0x04C2,0x0BDC,0x0EE6,0x158A,0x189B,
++     0x17AD,0x0CD8,0x1246,0x1457,0x0938,0x1D87,0x175C,0x0A85,0x1F20,0x17EC,
++     0x08E7,0x0678,0x0978,0x145E,0x00CF,0x001F,0x0D90,0x09F6,0x20E4,0x217D,
++     0x13E7,0x1CE0,0x1400,0x156D,0x084C,0x1881,0x0140,0x208B,0x21E5,0x041A,
++     0x02A0,0x0F23,0x22CA,0x0520,0x087A,0x1FAC,0x0FE2,0x15CD,0x05CF,0x1C34,
++     0x0BA3,0x033D,0x14DB,0x1251,0x0071,0x15FF,0x0139,0x21FB,0x003C,0x0629,
++     0x008A,0x03ED,0x0EA7,0x018B,0x146D,0x19D4,0x167F,0x1F24,0x21FC,0x04E9,
++     0x057F,0x0CB5,0x0F76,0x1B1A,0x19B0,0x1CDB,0x211E,0x0775,0x17D9,0x0494,
++     0x0C1F,0x0DB6,0x2184,0x1702,0x1165,0x1C4A,0x1043,0x0A5A,0x1004,0x03BE,
++     0x0B33,0x151A,0x038B,0x12ED,0x1287,0x2205,0x1F05,0x1AC8,0x19E3,0x1506,
++     0x0891,0x05DA,0x1C04,0x1ED3,0x0A11,0x061C,0x0DC5,0x01D5,0x1459,0x032E,
++     0x1A7B,0x12E3,0x1A8B,0x17D3,0x1391,0x0ADA,0x0A24,0x13E9,0x05DB,0x2050,
++     0x12C9,0x216A,0x0A09,0x149D,0x142B,0x0FD3,0x229D,0x19FA,0x0547,0x1984,
++     0x0E06,0x1827,0x0477,0x19D1,0x05DF,0x1248,0x12FF,0x01A2,0x10E8,0x095B,
++     0x2227,0x1262,0x00DC,0x0354,0x07E8,0x03DF,0x01FC,0x1AC1,0x0272,0x1AED,
++     0x090B,0x209E,0x1CCB,0x1AA5,0x218B,0x1D9C,0x1467,0x12B2,0x0D2C,0x1B3D,
++     0x0EC1,0x13F3,0x1330,0x1629,0x1576,0x2275,0x0684,0x0C41,0x0CD9,0x1836,
++     0x1280,0x104D,0x168D,0x1DE8,0x0E66,0x0A8C,0x2027,0x0448,0x0DA8,0x0A50,
++     0x1A4F,0x1A1A,0x0CF1,0x2180,0x03C5,0x1CAA,0x0B84,0x18EE,0x026B,0x1E44,
++     0x1F92,0x14F6,0x210E,0x0444,0x030A,0x140E,0x0F6B,0x0F44,0x0894,0x1407,
++     0x085A,0x091E,0x02B7,0x0B83,0x2238,0x1E25,0x0A32,0x19F5,0x06A9,0x239E,
++     0x10D9,0x2019,0x21A2,0x08A7,0x17DF,0x1A82,0x138F,0x08AA,0x12E6,0x074D,
++     0x1CDD,0x1FE1,0x0691,0x1F89,0x0810,0x05A9,0x00AB,0x0AD4,0x0623,0x02D4,
++     0x09D3,0x1232,0x2002,0x1FC3,0x1B73,0x0704,0x0150,0x197D,0x1646,0x0595,
++     0x1BAD,0x2146,0x0AD5,0x074C,0x03FD,0x1018,0x1F08,0x0989,0x1204,0x0499,
++     0x17E4,0x001E,0x0A23,0x13BC,0x1150,0x119C,0x056B,0x0BD7,0x0B8A,0x0AD7,
++     0x05A1,0x0AA6,0x1B27,0x18D1,0x0D42,0x14E9,0x0779,0x027A,0x1C76,0x01A7,
++     0x1FB0,0x1270,0x16C6,0x0142,0x1FF6,0x1172,0x11EB,0x212C,0x071D,0x1543,
++     0x170C,0x0F2F,0x1F9D,0x0F95,0x1CC7,0x043B,0x12EA,0x0F10,0x1D6E,0x0722,
++     0x00D6,0x1829,0x1244,0x1E0B,0x18CF,0x1C16,0x22DE,0x093B,0x01FD,0x15EF,
++     0x2087,0x1E24,0x02FB,0x1F1A,0x009D,0x0C20,0x0A35,0x18F9,0x0363,0x16ED,
++     0x0F4C,0x22B3,0x20A6,0x23C9,0x0C9D,0x10CF,0x0FC2,0x0AB1,0x1514,0x1D88,
++     0x1637,0x0844,0x06AF,0x06A7,0x0400,0x1F96,0x15D3,0x1566,0x0A06,0x1A38,
++     0x006A,0x03EA,0x1E4B,0x119F,0x1B8B,0x1049,0x1080,0x1B21,0x13BE,0x0F57,
++     0x18F6,0x22E4,0x1E9F,0x1BE1,0x1353,0x1644,0x0A45,0x1AA3,0x01C9,0x06F7,
++     0x10EB,0x0032,0x07F8,0x1CED,0x202C,0x0957,0x17B2,0x006B,0x1456,0x03DA,
++     0x061B,0x1A60,0x1C9A,0x137B,0x1EA2,0x1D61,0x0000,0x17FB,0x1BE2,0x046A,
++     0x1CBF,0x2192,0x1F0E,0x1968,0x0AE9,0x1508,0x0182,0x2324,0x2113,0x13CC,
++     0x09F5,0x0B62,0x1283,0x0FFC,0x150B,0x0794,0x0A0D,0x236B,0x1590,0x0808,
++     0x05D2,0x105A,0x1C80,0x207F,0x05CB,0x12FB,0x22BE,0x012A,0x0DC3,0x01CF,
++     0x023C,0x063D,0x060F,0x0447,0x2257,0x01C2,0x050B,0x03A1,0x0780,0x1782,
++     0x12E7,0x1E52,0x135C,0x151C,0x14EB,0x1B4E,0x2250,0x168C,0x118D,0x031D,
++     0x0680,0x2088,0x12D7,0x2133,0x14E0,0x1BE5,0x201E,0x0C3B,0x23AC,0x1B22,
++     0x01D0,0x0B17,0x1904,0x139F,0x1DAA,0x1418,0x0327,0x1527,0x0920,0x0715,
++     0x03C3,0x052C,0x0E8A,0x0812,0x017D,0x0C1D,0x02AA,0x1A7F,0x1DE4,0x058F,
++     0x194E,0x2343,0x0F11,0x1F18,0x0B05,0x2271,0x08E1,0x1CC6,0x1D38,0x20E7,
++     0x12DE,0x00E5,0x180C,0x0AC7,0x0C27,0x1C97,0x2304,0x10E6,0x071F,0x0C03,
++     0x0249,0x1FAA,0x0374,0x1E99,0x1FD5,0x2254,0x1B4C,0x0A92,0x2172,0x0B36,
++     0x011B,0x1CB2,0x0560,0x18F4,0x0460,0x0B24,0x1910,0x0596,0x1C30,0x0BE5,
++     0x1B79,0x1E40,0x21CA,0x0997,0x0F89,0x0173,0x215C,0x0D4E,0x1E14,0x1A45,
++     0x227E,0x18F7,0x1314,0x0C71,0x1D55,0x02B8,0x0C45,0x2232,0x10DC,0x155A,
++     0x1581,0x14A6,0x1683,0x108B,0x0247,0x2247,0x1F69,0x1EC7,0x0F1D,0x0A2A,
++     0x10FA,0x1660,0x16CE,0x0D18,0x0DDD,0x0BC6,0x0269,0x1911,0x187B,0x16F7,
++     0x188A,0x1FA0,0x1EA6,0x11B5,0x04C9,0x214E,0x065F,0x017A,0x05CE,0x1C32,
++     0x194D,0x1C44,0x02C1,0x1BCF,0x235B,0x228D,0x1A2C,0x03A3,0x017B,0x12D0,
++     0x19E8,0x08EF,0x1F25,0x1E65,0x0BA9,0x0DD9,0x1CF8,0x103A,0x1E22,0x15DD,
++     0x03D3,0x1EDE,0x1CF7,0x03C1,0x04F3,0x2240,0x1FFE,0x03BB,0x0D7D,0x1EBF,
++     0x1BA5,0x18E6,0x1CCF,0x1D8C,0x202E,0x0BA2,0x1A75,0x0065,0x104E,0x0661,
++     0x1B85,0x1A7A,0x0DD5,0x0450,0x1CEE,0x026E,0x1C0C,0x10B2,0x20F2,0x0AA7,
++     0x12F4,0x08EB,0x23AB,0x07B3,0x130B,0x094D,0x1EA3,0x18F2,0x0C9C,0x1363,
++     0x2036,0x13A8,0x16B1,0x1428,0x1F02,0x01E8,0x039E,0x1BED,0x1D98,0x08E2,
++     0x14D6,0x1E56,0x2388,0x0C1E,0x19EE,0x04AA,0x0EB8,0x09E5,0x233E,0x1D66,
++     0x07C5,0x211A,0x1088,0x0954,0x0E2A,0x1BC8,0x07A3,0x1E1E,0x1D36,0x1B87,
++     0x1544,0x0137,0x11DB,0x01C0,0x0845,0x216B,0x1BFC,0x08F6,0x0A5D,0x1EDF,
++     0x0FDE,0x0731,0x110A,0x0FB9,0x0E86,0x1415,0x14E7,0x17A3,0x02BC,0x0C60,
++     0x2111,0x0B41,0x234B,0x1C60,0x118A,0x0FDF,0x17CD,0x1323,0x087F,0x0025,
++     0x165D,0x1606,0x0823,0x1368,0x07F2,0x0743,0x02E4,0x23D0,0x0803,0x14AE,
++     0x1465,0x0FE3,0x02BB,0x0ACF,0x137F,0x2212,0x1272,0x01B6,0x0C07,0x08AB,
++     0x11E1,0x0274,0x171F,0x1126,0x09D2,0x1C01,0x23C5,0x1AB0,0x0F3E,0x0DAC,
++     0x00D5,0x14C2,0x17C1,0x028F,0x0DE9,0x06C3,0x0DE2,0x1A70,0x1AEC,0x1638,
++     0x1727,0x15ED,0x1532,0x13FD,0x123F,0x207E,0x0825,0x0066,0x14EC,0x1EE4,
++     0x1FE9,0x14B3,0x1692,0x0557,0x07A0,0x11D6,0x21DD,0x05FA,0x2014,0x0A0C,
++     0x152B,0x0425,0x00D7,0x00F2,0x0316,0x0ECA,0x1B14,0x0896,0x15B3,0x0B80,
++     0x1D20,0x0AF5,0x09C8,0x0BF6,0x134F,0x0E00,0x1B99,0x0953,0x2341,0x21C7,
++     0x1811,0x1032,0x1898,0x1286,0x1998,0x06B0,0x19FB,0x0790,0x15A6,0x16FB,
++     0x16C4,0x0B28,0x0C7B,0x0FED,0x19AC,0x113F,0x1EC3,0x0A52,0x132A,0x048D,
++     0x1B07,0x11D1,0x1F75,0x0838,0x04A5,0x04CB,0x046E,0x0A58,0x076E,0x12DB,
++     0x0AE8,0x185F,0x15E3,0x18A5,0x18CE,0x0236,0x0A46,0x1886,0x0B69,0x03CD,
++     0x17E6,0x0A21,0x06D1,0x0964,0x0630,0x231B,0x1642,0x19FF,0x1880,0x1B6B,
++     0x105C,0x0FCC,0x0043,0x1A4E,0x1554,0x0781,0x0034,0x1D16,0x1522,0x1ABF,
++     0x0F03,0x1B47,0x1A21,0x1E8E,0x007A,0x1E3E,0x0EB0,0x0DD7,0x0534,0x0241,
++     0x051D,0x0C8F,0x0B55,0x1589,0x0256,0x194B,0x1D31,0x0828,0x09AD,0x075F,
++     0x02AF,0x0BAF,0x1C49,0x20ED,0x1D21,0x0E6A,0x1723,0x19F6,0x114E,0x1419,
++     0x1952,0x0F40,0x0B0D,0x2201,0x1D29,0x19C9,0x0A2F,0x1515,0x1F27,0x1CDE,
++     0x0DD3,0x1768,0x0E56,0x1A9C,0x12A4,0x11BE,0x0B46,0x0DAE,0x0AFC,0x164B,
++     0x08D7,0x003A,0x0BDD,0x1E4E,0x0BCF,0x105E,0x2000,0x1BA1,0x19F4,0x2100,
++     0x20D7,0x2398,0x1C2E,0x04BE,0x0199,0x221E,0x0532,0x07B7,0x155B,0x006D,
++     0x16C1,0x1C74,0x0D61,0x17E2,0x0AFF,0x1AC4,0x00E9,0x09E4,0x11BB,0x0674,
++     0x22BD,0x1186,0x0578,0x202A,0x123B,0x15E8,0x0E8B,0x0403,0x097A,0x0105,
++     0x14ED,0x14CB,0x0FDD,0x03FF,0x17AF,0x1E39,0x02F3,0x13D3,0x0C89,0x20BC,
++     0x20B2,0x15BC,0x1CAC,0x2372,0x1B48,0x08D2,0x0446,0x1177,0x0D1F,0x17C6,
++     0x1989,0x0516,0x0DDC,0x024D,0x16AA,0x09EE,0x1062,0x0B50,0x1F77,0x037F,
++     0x07D2,0x093C,0x238A,0x0583,0x2375,0x0CA3,0x18EA,0x182A,0x0621,0x1036,
++     0x02B5,0x01E2,0x22DB,0x0963,0x2399,0x060C,0x1152,0x0F91,0x048A,0x1A7E,
++     0x1E87,0x1BB0,0x15C4,0x1112,0x1021,0x11E2,0x0C56,0x07DD,0x1D46,0x0210,
++     0x04F5,0x1C0E,0x0B8E,0x1040,0x1A6C,0x1AF8,0x08D8,0x1313,0x1C8A,0x20B8,
++     0x0B54,0x08A4,0x0094,0x131E,0x0A86,0x0A28,0x0D10,0x0A74,0x1AD2,0x0653,
++     0x172C,0x21C1,0x1490,0x04FC,0x0BFA,0x1347,0x0B2F,0x1DC4,0x23DB,0x0FB8,
++     0x23BB,0x0C72,0x03E5,0x186A,0x0F9D,0x1295,0x1808,0x04C6,0x1960,0x1FA7,
++     0x0DE0,0x239F,0x1D5F,0x0EED,0x1F79,0x2068,0x06B8,0x0D99,0x15F5,0x1028,
++     0x0202,0x0BAD,0x0098,0x060D,0x0E84,0x18FB,0x1549,0x1E63,0x0ED6,0x009A,
++     0x0B72,0x0B7B,0x06B1,0x0341,0x08F4,0x112A,0x18D5,0x0919,0x1731,0x19A5,
++     0x16FA,0x0195,0x0F9C,0x123D,0x0968,0x0E17,0x0EBF,0x0D27,0x1A33,0x17FD,
++     0x221B,0x208C,0x0694,0x1713,0x1696,0x0692,0x0006,0x1C3E,0x1617,0x0267,
++     0x111D,0x2122,0x025E,0x200E,0x0D22,0x1627,0x1329,0x0048,0x1265,0x0D7A,
++     0x1402,0x149C,0x02A1,0x022C,0x0F75,0x0783,0x124A,0x1134,0x0E1E,0x1C4C,
++     0x1CB0,0x17F1,0x046F,0x0280,0x068B,0x1C46,0x1FDA,0x0D82,0x1CD1,0x0590,
++     0x056E,0x015A,0x121F,0x0B1D,0x019D,0x1EB5,0x0A82,0x16E8,0x117D,0x098F,
++     0x1513,0x122A,0x0C18,0x0FA0,0x1EB1,0x0DD0,0x0E4A,0x23F8,0x190B,0x2053,
++     0x16C0,0x18A3,0x0127,0x0AE1,0x0F52,0x12AF,0x0E24,0x0C32,0x08A6,0x1D3F,
++     0x00CA,0x229B,0x11F6,0x1A46,0x1BF3,0x1EC6,0x0275,0x13B4,0x1210,0x0A49,
++     0x057C,0x0E3F,0x206B,0x05DC,0x21D5,0x18A7,0x14D3,0x1F57,0x1FF8,0x2220,
++     0x0962,0x1BFF,0x2301,0x08AF,0x1EEC,0x20CF,0x17E9,0x2302,0x0FBD,0x1BC9,
++     0x0585,0x0784,0x17BE,0x1B2B,0x111A,0x0AB3,0x1F1F,0x0505,0x0019,0x235F,
++     0x0B59,0x039A,0x03F7,0x193C,0x1994,0x1C1E,0x0CBB,0x0D72,0x1706,0x1C37,
++     0x0002,0x098B,0x2046,0x056A,0x0A1E,0x0A04,0x11C2,0x0883,0x06B3,0x0B48,
++     0x07DF,0x1122,0x04EE,0x215D,0x11D7,0x12A9,0x0F9A,0x0104,0x1618,0x175E,
++     0x1A28,0x1D13,0x1DC9,0x0111,0x110C,0x1779,0x146E,0x1928,0x15B0,0x072C,
++     0x0773,0x1CA2,0x0C3C,0x0BF2,0x1587,0x2269,0x10B0,0x0A6F,0x214D,0x0EEC,
++     0x1EF6,0x14EE,0x20C4,0x1A65,0x1A0B,0x23FA,0x0336,0x1603,0x0946,0x0D6B,
++     0x0545,0x1B9A,0x0605,0x0C95,0x2185,0x0EE3,0x1F98,0x1EB3,0x0A39,0x05EC,
++     0x1A5C,0x123A,0x0848,0x234E,0x023A,0x183E,0x16BD,0x014D,0x106A,0x0EF5,
++     0x213C,0x0046,0x0395,0x2321,0x238D,0x1AEE,0x1170,0x03DD,0x1C70,0x1D65,
++     0x0CF0,0x224D,0x1F87,0x1D0A,0x09A4,0x14CF,0x0A02,0x0093,0x121A,0x02EF,
++     0x22CC,0x0B8D,0x1E00,0x0B58,0x0FF9,0x1D62,0x1E6B,0x2387,0x138B,0x052D,
++     0x081C,0x10A0,0x0194,0x22F9,0x1E5F,0x1E3D,0x06C9,0x167C,0x0096,0x1570,
++     0x19A7,0x0B98,0x18BA,0x12AA,0x11CC,0x22C7,0x0064,0x0440,0x0B7E,0x23BF,
++     0x01A6,0x09ED,0x000B,0x0834,0x008E,0x0A7E,0x0D32,0x0744,0x207A,0x03AF,
++     0x062B,0x21DB,0x1B37,0x1FB1,0x1653,0x1807,0x141F,0x18AF,0x1343,0x0D28,
++     0x221A,0x1064,0x1BAB,0x199D,0x19E9,0x23FF,0x22EF,0x0CB1,0x0EC2,0x0958,
++     0x09D7,0x20EE,0x1AAF,0x1267,0x020B,0x1E58,0x0F2A,0x1B2F,0x0A7B,0x0EF2,
++     0x2334,0x0131,0x164D,0x238E,0x0352,0x1C71,0x1B9B,0x1F54,0x08DD,0x069C,
++     0x0C65,0x1FEB,0x21C2,0x0C38,0x1743,0x23E1,0x10C1,0x110E,0x13EE,0x239A,
++     0x125D,0x21DC,0x057B,0x1B1F,0x0D26,0x0121,0x02C5,0x0189,0x0867,0x190F,
++     0x0A8E,0x064E,0x0C31,0x2149,0x0A5C,0x1B06,0x0A6D,0x2277,0x0DFC,0x1B2A,
++     0x0FBC,0x051A,0x0767,0x00BF,0x1862,0x1414,0x1CDA,0x1484,0x1098,0x0657,
++     0x1C29,0x1C9F,0x0DBF,0x1B28,0x1AAD,0x204C,0x077B,0x0888,0x0ACA,0x1575,
++     0x1780,0x1AC5,0x085E,0x14CD,0x1CB3,0x033C,0x1E62,0x1650,0x0F7E,0x1CE4,
++     0x059E,0x20D6,0x072D,0x1371,0x2332,0x115F,0x204E,0x0282,0x11BF,0x08CE,
++     0x1C10,0x11AD,0x10FF,0x15BD,0x04E1,0x22D9,0x1634,0x048B,0x0346,0x185A,
++     0x083B,0x06F9,0x2124,0x072E,0x1ABA,0x050D,0x18BC,0x003E,0x090A,0x1F2C,
++     0x1734,0x0EE7,0x131A,0x0BB5,0x042E,0x12AD,0x1D5E,0x20EF,0x0C7F,0x1245,
++     0x1AD5,0x0895,0x00ED,0x2314,0x19B9,0x055D,0x20A5,0x112C,0x0436,0x16DA,
++     0x0E12,0x0276,0x178B,0x0EBD,0x0B2E,0x23D5,0x0941,0x1C14,0x1FA2,0x0A90,
++     0x1A99,0x1891,0x02BF,0x1305,0x1B18,0x0E0F,0x0BC1,0x0CD7,0x05AB,0x1ED5,
++     0x1D53,0x04D0,0x0D98,0x062F,0x0BCC,0x0B88,0x2031,0x0295,0x1F29,0x1ECB,
++     0x0DB9,0x00C8,0x2396,0x0A17,0x1773,0x1AC9,0x0459,0x1AD6,0x22CF,0x1DC2,
++     0x1BB8,0x1A23,0x1DFE,0x0604,0x213A,0x1357,0x1EA1,0x20D3,0x1137,0x1233,
++     0x198D,0x1B04,0x041E,0x200D,0x233A,0x02A5,0x0CA7,0x0E15,0x17FE,0x216E,
++     0x07C0,0x0BB0,0x0B9C,0x0A8F,0x0B15,0x0BDA,0x14B0,0x15CA,0x189E,0x19DC,
++     0x1ED9,0x0076,0x0A97,0x0918,0x0BED,0x0B81,0x0E0A,0x11DC,0x165A,0x037D,
++     0x1B74,0x1438,0x1129,0x22A2,0x0373,0x0D43,0x20F0,0x0DDE,0x0AB2,0x0771,
++     0x22F5,0x05F5,0x0662,0x1B39,0x16B0,0x1EF3,0x0AF2,0x0E44,0x0221,0x0A6E,
++     0x0D47,0x1DAC,0x18F1,0x10F6,0x2094,0x2294,0x0B21,0x0192,0x1A1E,0x03C9,
++     0x1777,0x1462,0x2089,0x0A4F,0x1A12,0x1A6B,0x1737,0x1D18,0x0C98,0x2207,
++     0x1FDD,0x2176,0x0109,0x0537,0x00BD,0x1916,0x1C2A,0x1377,0x1094,0x1D72,
++     0x00EE,0x0057,0x1463,0x171B,0x00EB,0x1AF0,0x15B9,0x0368,0x04CC,0x05AC,
++     0x07CA,0x1A62,0x0AFD,0x0C00,0x0548,0x153B,0x00AE,0x08F1,0x17C9,0x0428,
++     0x07F0,0x23D8,0x0DD4,0x201D,0x0C4D,0x04EA,0x0161,0x0C02,0x016D,0x145D,
++     0x1CA8,0x02F7,0x17F3,0x1FEC,0x1933,0x0E23,0x0639,0x1CD8,0x20B7,0x0284,
++     0x1016,0x0DC7,0x05A5,0x0E70,0x1A43,0x1DCB,0x09E8,0x13A9,0x06F5,0x1454,
++     0x033A,0x1E82,0x088D,0x0736,0x14C5,0x14FB,0x190E,0x0B60,0x13EA,0x1260,
++     0x0F8D,0x140B,0x1EDC,0x1E93,0x1095,0x2258,0x088E,0x22F0,0x08F2,0x2364,
++     0x1F97,0x1024,0x064F,0x0C5F,0x2052,0x1BE4,0x1EE9,0x1FE3,0x15A8,0x0DB1,
++     0x0D1D,0x17F7,0x20D8,0x07F6,0x2077,0x15E0,0x1C2F,0x1709,0x05BE,0x1B1B,
++     0x2162,0x1A39,0x1C2C,0x13F7,0x19EC,0x20D4,0x0655,0x049C,0x17AA,0x20E6,
++     0x04F4,0x01DE,0x038F,0x21FF,0x12BB,0x14C3,0x1D23,0x0730,0x0E5A,0x1ADD,
++     0x2300,0x1118,0x21D7,0x0FC5,0x0497,0x0390,0x11EA,0x18E5,0x1EF4,0x1EAE,
++     0x028A,0x102B,0x1365,0x05B1,0x18ED,0x0016,0x0012,0x0887,0x1E68,0x0933,
++     0x1166,0x0F5D,0x1297,0x06B9,0x18C5,0x0F80,0x2305,0x12A0,0x0AA8,0x1766,
++     0x1E2C,0x021D,0x1B30,0x0D3C,0x1585,0x1815,0x1B8D,0x00C1,0x02DD,0x0BD6,
++     0x06DC,0x06AD,0x025B,0x0A59,0x1D6B,0x15E2,0x1388,0x1AE3,0x1E26,0x21AF,
++     0x1CAD,0x02B0,0x09B8,0x0CFA,0x1DED,0x2267,0x0ABA,0x21F9,0x0AB8,0x1278,
++     0x1C58,0x1BCA,0x1042,0x1F4D,0x1F5B,0x1B09,0x0B08,0x0217,0x2097,0x05BC,
++     0x1219,0x1C6B,0x1885,0x1A69,0x01D1,0x0246,0x077C,0x13C4,0x11E9,0x01DD,
++     0x206F,0x0A41,0x16DD,0x08E9,0x1578,0x0846,0x0B99,0x0C4E,0x03A6,0x17F5,
++     0x13AB,0x1D2D,0x1B03,0x1F7F,0x0A96,0x1726,0x1AD9,0x1180,0x0B0C,0x0796,
++     0x1718,0x0CEA,0x0D8B,0x1B78,0x1C66,0x1BFA,0x07C3,0x1195,0x06C2,0x041C,
++     0x11EC,0x148E,0x0E52,0x1987,0x08BC,0x0B7C,0x02C8,0x073D,0x23DE,0x1A8E,
++     0x1D7C,0x220E,0x01E0,0x14C7,0x18B7,0x20E0,0x0739,0x088B,0x0CF5,0x1498,
++     0x0487,0x1699,0x035D,0x0416,0x0406,0x0C67,0x1188,0x1A30,0x00F7,0x063C,
++     0x09B7,0x030F,0x09BD,0x0D5F,0x022D,0x1D00,0x1C45,0x1AFA,0x0D16,0x0325,
++     0x1794,0x21E0,0x18AD,0x09FC,0x0F48,0x1F49,0x0463,0x11E0,0x1BF4,0x2169,
++     0x077D,0x0644,0x1497,0x1A51,0x0FC0,0x14DE,0x2049,0x0110,0x0A3D,0x062D,
++     0x08BE,0x16B3,0x0021,0x20C3,0x0BA5,0x21B4,0x05AA,0x0B16,0x19C1,0x2128,
++     0x0468,0x0E07,0x1F3A,0x052B,0x1161,0x0B9A,0x13FF,0x17D8,0x161B,0x2029,
++     0x0FA3,0x0E29,0x0B70,0x1605,0x1A3F,0x1E78,0x1EC4,0x1429,0x1906,0x19BF,
++     0x07EC,0x1DFA,0x2035,0x0A67,0x22A8,0x1863,0x21E4,0x04E2,0x1175,0x0411,
++     0x1B56,0x037C,0x0262,0x0865,0x000A,0x2287,0x1279,0x1FD9,0x1667,0x1DC1,
++     0x1AF3,0x0148,0x0C59,0x199A,0x0943,0x0D07,0x233C,0x073A,0x14AD,0x12CF,
++     0x0971,0x19EB,0x1EF9,0x15F9,0x0ADC,0x1101,0x1AD4,0x0540,0x0727,0x0986,
++     0x0D69,0x0A20,0x21A5,0x10CA,0x21C6,0x0EAA,0x06FC,0x0E47,0x15F4,0x222C,
++     0x02C2,0x0580,0x05C0,0x11DA,0x10D4,0x0DCF,0x0451,0x021A,0x228C,0x2104,
++     0x1E7A,0x150F,0x043F,0x1B4B,0x0B76,0x1384,0x0208,0x0F33,0x001B,0x1A04,
++     0x21BD,0x006E,0x1889,0x00AA,0x12C5,0x03FC,0x11F8,0x0D2F,0x0CDF,0x1F8C,
++     0x0526,0x1659,0x17EA,0x0BCA,0x119D,0x12B7,0x1392,0x0AB6,0x1331,0x1198,
++     0x15EC,0x01C1,0x22AB,0x130C,0x14F0,0x227B,0x07E9,0x1E4C,0x016B,0x0A13,
++     0x0E37,0x1136,0x1C8E,0x112F,0x1CE8,0x18D8,0x0372,0x011A,0x1411,0x07D1,
++     0x076B,0x085C,0x0084,0x0714,0x0E3C,0x21F7,0x0F6C,0x23E9,0x0385,0x1B17,
++     0x179C,0x159A,0x0506,0x135A,0x0882,0x1C36,0x1AA6,0x1E11,0x1A1F,0x1EF5,
++     0x0E9D,0x0335,0x1658,0x04B8,0x06A2,0x061E,0x17B6,0x1DB6,0x12BF,0x0443,
++     0x220A,0x1983,0x07B0,0x1890,0x177A,0x038A,0x1496,0x1220,0x18B3,0x1149,
++     0x0FA4,0x10EA,0x0620,0x11B1,0x01B1,0x08BA,0x0081,0x0FEC,0x111C,0x0C1B,
++     0x1382,0x0427,0x1582,0x1D54,0x0EE2,0x022A,0x0AAB,0x23EA,0x1922,0x0399,
++     0x2127,0x06CA,0x12D5,0x0A0A,0x1745,0x1F8F,0x009B,0x21B6,0x1BC2,0x0EEE,
++     0x00B6,0x0672,0x16D7,0x13E4,0x0ABF,0x0F29,0x03D2,0x20E3,0x185B,0x08FE,
++     0x0FB0,0x1CBC,0x2024,0x0A16,0x0C2C,0x0B23,0x134A,0x0ADE,0x03E2,0x0A0F,
++     0x2102,0x0CAA,0x19D0,0x220F,0x06E2,0x2391,0x13CF,0x1EDD,0x15B4,0x1012,
++     0x1F15,0x23DF,0x0735,0x223F,0x144B,0x12FC,0x1C86,0x1CE7,0x0DA7,0x082F,
++     0x1720,0x15C7,0x0212,0x22FD,0x133F,0x068C,0x169E,0x0C4F,0x1C31,0x139B,
++     0x0DA6,0x1A91,0x1D99,0x1493,0x160A,0x0077,0x1F45,0x1473,0x1B1E,0x028E,
++     0x0FAC,0x137C,0x2390,0x10A6,0x0129,0x0B67,0x1F53,0x0B97,0x21AC,0x0792,
++     0x0758,0x1AB2,0x0C44,0x1482,0x1436,0x0036,0x1B3A,0x1CC9,0x1AF4,0x152A,
++     0x2355,0x0519,0x1747,0x1275,0x10B3,0x2086,0x14D1,0x20E9,0x12CD,0x0EA4,
++     0x1F48,0x0DBD,0x0265,0x0A55,0x145F,0x2216,0x0D0F,0x103B,0x2381,0x0994,
++     0x1337,0x0CF7,0x06E8,0x2253,0x0936,0x1ECC,0x2208,0x10C3,0x0DE4,0x0A2D,
++     0x09DD,0x1690,0x234D,0x031E,0x0824,0x04A2,0x0F46,0x17B9,0x1F81,0x02E2,
++     0x04D5,0x13A2,0x0A10,0x01B3,0x1523,0x2013,0x0B06,0x1108,0x0244,0x06F6,
++     0x041B,0x03A5,0x21EF,0x052F,0x08FF,0x0855,0x1FC4,0x1E1D,0x2385,0x0B77,
++     0x1B86,0x2123,0x018C,0x2203,0x181A,0x01EB,0x07E1,0x1334,0x1D12,0x0A9D,
++     0x01ED,0x1EDA,0x1A2E,0x18AA,0x0598,0x1A83,0x162A,0x1A84,0x072B,0x2397,
++     0x0166,0x00C0,0x091C,0x2350,0x010A,0x157E,0x142C,0x1F4F,0x1B93,0x1355,
++     0x08F9,0x218E,0x1C57,0x0627,0x06AE,0x2186,0x230D,0x0C6F,0x1229,0x02C9,
++     0x0972,0x0F68,0x217B,0x1130,0x0CDB,0x06B5,0x1045,0x1321,0x0AA0,0x0CCE,
++     0x121E,0x0C0A,0x07EF,0x02D8,0x061D,0x1003,0x0761,0x20FE,0x1519,0x027B,
++     0x1105,0x174A,0x028B,0x0300,0x1EFD,0x1711,0x03BC,0x1FCC,0x1DFF,0x21FE,
++     0x1AE0,0x12C0,0x2266,0x1DEC,0x15E4,0x036B,0x0382,0x01B5,0x2067,0x20C6,
++     0x0B2C,0x0F7F,0x1BEB,0x0988,0x1491,0x0697,0x0F12,0x1096,0x0E78,0x103D,
++     0x02A3,0x21BB,0x1563,0x11D2,0x150D,0x2308,0x21B3,0x0333,0x1213,0x009F,
++     0x08A5,0x10EC,0x0E60,0x009E,0x1530,0x0FC6,0x110F,0x1BA3,0x027E,0x2223,
++     0x009C,0x1B4D,0x1F62,0x1CF6,0x1E86,0x0FB1,0x0332,0x1BAF,0x0C1A,0x0E2C,
++     0x0360,0x197A,0x01D3,0x10F3,0x1B76,0x02EB,0x18CA,0x065B,0x1164,0x103E,
++     0x0C39,0x0F8C,0x073E,0x07CE,0x183C,0x04EC,0x0E9A,0x0BDE,0x0738,0x1093,
++     0x0F0D,0x076A,0x0349,0x0DA9,0x19F9,0x1154,0x1DD0,0x0ED0,0x1D22,0x22D3,
++     0x015B,0x0052,0x0A5B,0x0CE2,0x1D89,0x1565,0x1752,0x0254,0x028C,0x18FD,
++     0x12B9,0x1CA4,0x1F73,0x0567,0x1B01,0x0414,0x1510,0x1ED8,0x05FD,0x1ACF,
++     0x19EA,0x0163,0x0B73,0x1CBE,0x07B6,0x10D1,0x050F,0x1635,0x0413,0x17ED,
++     0x1C40,0x1336,0x0EFF,0x1199,0x1236,0x07BD,0x2312,0x04B1,0x2163,0x1AD1,
++     0x0764,0x21D1,0x14DD,0x0CE8,0x1728,0x0348,0x236D,0x1BA6,0x2119,0x1405,
++     0x0625,0x034C,0x0A1F,0x09E0,0x231C,0x0D4C,0x0839,0x04AF,0x2153,0x12AB,
++     0x0D8C,0x148F,0x03CE,0x2081,0x05A6,0x0F02,0x1D41,0x090F,0x0D8D,0x1CE5,
++     0x0BF5,0x0358,0x0BBD,0x1981,0x1A5E,0x1312,0x103F,0x0347,0x23B0,0x0FAD,
++     0x08D1,0x00D8,0x08E0,0x212A,0x0DC4,0x1EBE,0x169F,0x07A6,0x1BF5,0x1FA3,
++     0x0EE8,0x17B1,0x14A8,0x0EC8,0x2057,0x0586,0x19AF,0x1C1A,0x1D10,0x15D7,
++     0x06CD,0x0901,0x163C,0x1A20,0x1107,0x0879,0x1533,0x1EDB,0x0E94,0x1FC9,
++     0x20F5,0x00A9,0x20BE,0x1011,0x1AFE,0x21DF,0x1D7E,0x0D25,0x13D1,0x099C,
++     0x0A64,0x1729,0x113B,0x17C4,0x21DE,0x0D8A,0x0B4B,0x00E2,0x0C10,0x2358,
++     0x162E,0x1470,0x1DDE,0x0050,0x1468,0x213B,0x106E,0x0490,0x09F2,0x0190,
++     0x1F7A,0x03FB,0x215E,0x02EC,0x01CD,0x0F83,0x1503,0x00A0,0x17E8,0x0ABE,
++     0x019F,0x053A,0x2278,0x1A66,0x12A3,0x0B04,0x23D7,0x144F,0x131B,0x2099,
++     0x0159,0x1D3E,0x1FE4,0x14D8,0x0100,0x130F,0x23F0,0x1623,0x1F40,0x0F13,
++     0x1082,0x221F,0x12FE,0x0B9D,0x080B,0x1EE6,0x14B9,0x2351,0x05D7,0x065E,
++     0x09BB,0x0209,0x0FDA,0x03D5,0x1B82,0x204B,0x1073,0x131C,0x1358,0x230B,
++     0x1BC0,0x1EB9,0x166A,0x11AA,0x1D85,0x08BB,0x1B7B,0x05F7,0x1B40,0x0E11,
++     0x02DB,0x13A3,0x0C15,0x14EA,0x0AB9,0x22E7,0x013A,0x07F4,0x0696,0x1228,
++     0x0FCF,0x1561,0x09E7,0x2221,0x039F,0x028D,0x1171,0x098C,0x1B5B,0x0F93,
++     0x1789,0x1269,0x0A3C,0x14A4,0x1864,0x16A9,0x0493,0x0B5E,0x0BD1,0x0646,
++     0x1A52,0x11FC,0x0934,0x0CA1,0x16C5,0x045B,0x0EAC,0x0EE1,0x1671,0x1918,
++     0x0C4C,0x1D9A,0x2062,0x160D,0x1555,0x0677,0x0F58,0x1621,0x17AB,0x0DB7,
++     0x0F63,0x094B,0x1902,0x23BE,0x0C35,0x0F51,0x149A,0x08FB,0x021F,0x1970,
++     0x0995,0x19E2,0x1DBD,0x1E48,0x0B90,0x02CC,0x15DB,0x2022,0x0CEE,0x2161,
++     0x0A57,0x11AE,0x0B6F,0x05CA,0x1450,0x19B8,0x0F4F,0x1F5A,0x1E2E,0x229A,
++     0x15EB,0x074E,0x2317,0x0ECB,0x0B6C,0x0510,0x091F,0x0F85,0x101B,0x1BD3,
++     0x0E7C,0x11FF,0x0F2C,0x1F9A,0x2382,0x232F,0x23DC,0x0DF7,0x01CB,0x0DCA,
++     0x21D3,0x1857,0x0C6D,0x0FEE,0x0509,0x0543,0x2331,0x1424,0x08FD,0x01E9,
++     0x1CA9,0x23EF,0x100C,0x029A,0x1065,0x1078,0x0F9B,0x14DA,0x0D09,0x0998,
++     0x088C,0x019C,0x10C4,0x20AB,0x20E5,0x16A4,0x0682,0x0424,0x1C15,0x0C13,
++     0x0A36,0x0856,0x07A5,0x1AD7,0x05D0,0x020C,0x16CC,0x1D8D,0x07DA,0x2204,
++     0x1D9F,0x1797,0x1C67,0x09C0,0x0237,0x1BB6,0x10A9,0x0417,0x0949,0x1E49,
++     0x017E,0x0979,0x1753,0x0AA2,0x0362,0x0B8B,0x0536,0x1EA7,0x0EE5,0x04CA,
++     0x2285,0x0DEB,0x05A0,0x0853,0x12BA,0x0491,0x0423,0x11C0,0x0E36,0x1674,
++     0x2010,0x1DC5,0x0709,0x125F,0x0C33,0x2349,0x0481,0x108A,0x0404,0x094F,
++     0x09CB,0x0D3F,0x18C4,0x0EA3,0x060E,0x0654,0x1814,0x09CA,0x1CA3,0x0C34,
++     0x1A17,0x1406,0x14FF,0x0F0E,0x0204,0x0C0F,0x11CB,0x1925,0x16B9,0x1488,
++     0x1D01,0x0E96,0x0562,0x0C04,0x185E,0x0D2D,0x23D4,0x2328,0x030C,0x19A9,
++     0x01EF,0x20FF,0x08F7,0x122E,0x1AC2,0x0C52,0x0296,0x1A59,0x0326,0x1089,
++     0x1DD3,0x1C63,0x06BB,0x146F,0x1237,0x1950,0x203B,0x17A8,0x01A5,0x09D1,
++     0x0591,0x1B15,0x0147,0x0F20,0x17B4,0x1A36,0x1FC5,0x1F5F,0x0C37,0x1BAE,
++     0x06BC,0x12C1,0x10D2,0x0A14,0x0875,0x120A,0x182D,0x0D6D,0x0F1B,0x0FA2,
++     0x1CC2,0x1A64,0x11C4,0x1CF3,0x1FBD,0x0027,0x0C49,0x21CB,0x0462,0x107C,
++     0x0CFD,0x1398,0x0633,0x06A5,0x00B0,0x0BFD,0x1665,0x102A,0x1915,0x150E,
++     0x23A0,0x1344,0x0F69,0x097B,0x023F,0x18BF,0x1423,0x1290,0x22DF,0x1060,
++     0x0168,0x04FA,0x1B72,0x03C0,0x0B49,0x202D,0x227F,0x0D31,0x121C,0x0762,
++     0x1980,0x05EE,0x20DA,0x04BB,0x06FB,0x16E5,0x117B,0x079F,0x1BF1,0x02A6,
++     0x0A5F,0x22ED,0x1517,0x034E,0x1628,0x1A72,0x02F2,0x1761,0x1E2D,0x161C,
++     0x05C1,0x0757,0x138C,0x0438,0x1193,0x1A68,0x0340,0x111F,0x1440,0x1CDF,
++     0x0634,0x23F9,0x064A,0x0C8A,0x1059,0x13A5,0x1B23,0x13D4,0x2210,0x12E4,
++     0x0E03,0x0CA0,0x0355,0x0E0D,0x1D24,0x2155,0x0B93,0x0531,0x0B1C,0x1CFE,
++     0x22BB,0x1B64,0x1D02,0x1F83,0x0C2A,0x01D4,0x000C,0x2213,0x2151,0x1F3C,
++     0x200F,0x0469,0x0B79,0x086F,0x139E,0x1ADA,0x00C4,0x07E0,0x1005,0x013C,
++     0x1869,0x05B6,0x0944,0x0652,0x1EBB,0x047E,0x0D3A,0x05F0,0x2085,0x0342,
++     0x0165,0x236A,0x03DB,0x1E69,0x120B,0x0EDB,0x156A,0x00CD,0x1F2F,0x0797,
++     0x066C,0x0AE7,0x063A,0x1C7D,0x18A4,0x07B5,0x0E87,0x092F,0x213E,0x10D6,
++     0x1F0A,0x1DD7,0x1B4F,0x0E68,0x1958,0x158D,0x14B6,0x0CB8,0x23E2,0x15D0,
++     0x1249,0x1562,0x03D6,0x0513,0x1A3E,0x171E,0x1F09,0x0DF9,0x0A07,0x12AE,
++     0x0690,0x05C6,0x120D,0x20D1,0x17A0,0x2189,0x1D34,0x1799,0x1E5E,0x20C7,
++     0x1B45,0x1359,0x174B,0x0CCC,0x0187,0x21D9,0x15A7,0x1E1F,0x13B1,0x05FF,
++     0x10D5,0x1905,0x01A8,0x0277,0x1FF4,0x0EB5,0x1476,0x1E1C,0x1390,0x018E,
++     0x0484,0x0FCB,0x146B,0x151B,0x1DC6,0x1A76,0x169B,0x0B64,0x0024,0x187A,
++     0x1230,0x2132,0x0ECE,0x149F,0x109A,0x1839,0x0568,0x1F84,0x0BF0,0x092D,
++     0x0C77,0x13EF,0x14F9,0x138D,0x0832,0x0C68,0x0A37,0x0248,0x16EF,0x0125,
++     0x087B,0x09A9,0x17C8,0x02DF,0x06A0,0x0FC3,0x0D75,0x1A10,0x0EAB,0x0D96,
++     0x0CC2,0x1DA2,0x13AA,0x1760,0x0146,0x1636,0x0082,0x1255,0x1206,0x19DF,
++     0x1D71,0x0D67,0x1DB4,0x0F15,0x065C,0x20C0,0x12F9,0x1796,0x1997,0x13B5,
++     0x087E,0x19FC,0x173B,0x163F,0x06CC,0x05F1,0x19B1,0x1D1E,0x16E1,0x1A3B,
++     0x0C3D,0x07C1,0x1A7C,0x00A5,0x181C,0x1593,0x0259,0x167B,0x0120,0x0889,
++     0x0A51,0x0DA1,0x129D,0x1F76,0x045D,0x1471,0x03CC,0x07B2,0x07EE,0x16AF,
++     0x0549,0x1046,0x2217,0x0BBF,0x12C6,0x0AA5,0x1C51,0x1C94,0x0DF4,0x22B8,
++     0x0DBA,0x1284,0x1D15,0x1433,0x1D17,0x15AE,0x0387,0x1052,0x0880,0x107B,
++     0x09E9,0x2012,0x1151,0x0641,0x0ECC,0x156E,0x1771,0x1972,0x09F9,0x12C3,
++     0x0C42,0x0B9E,0x02A4,0x12EB,0x16B7,0x054D,0x1742,0x0600,0x0BF1,0x11C5,
++     0x223E,0x0B35,0x1843,0x1A5D,0x081B,0x1DB2,0x0020,0x0BC7,0x155F,0x015E,
++     0x1341,0x1FD0,0x136D,0x062A,0x1E6C,0x1DA3,0x00C3,0x12EC,0x03C2,0x10D7,
++     0x15F3,0x1489,0x19FD,0x067D,0x12D6,0x1847,0x0F9F,0x0ED7,0x1D9E,0x1ADB,
++     0x10A4,0x0710,0x1866,0x0F32,0x1EC0,0x2309,0x00E8,0x025F,0x135F,0x0C54,
++     0x0FFF,0x0BF9,0x0959,0x14F3,0x17A1,0x0EE9,0x20F3,0x10BE,0x0DF6,0x1D49,
++     0x1111,0x0D2B,0x0226,0x1AB4,0x2337,0x021B,0x019A,0x22C0,0x1C06,0x08E5,
++     0x2047,0x07F9,0x1612,0x0822,0x0E31,0x00F3,0x134C,0x1919,0x189D,0x23FB,
++     0x0EFE,0x07D8,0x10F5,0x1143,0x22D1,0x0476,0x10F9,0x16CB,0x0053,0x16D3,
++     0x0366,0x1B6A,0x0074,0x1DF6,0x165B,0x0308,0x116E,0x0837,0x1A0D,0x15F8,
++     0x0D57,0x1875,0x1A8C,0x0EC0,0x239C,0x0BBE,0x0FB4,0x0009,0x1698,0x0AFE,
++     0x1992,0x23BA,0x0EE0,0x2096,0x00FE,0x1BF7,0x1239,0x23FD,0x1F8E,0x113C,
++     0x084F,0x09B1,0x0931,0x1E2F,0x0976,0x07AF,0x0B45,0x0ABD,0x0F37,0x0C7E,
++     0x06D3,0x238B,0x0759,0x17AC,0x0923,0x1D05,0x14FA,0x1755,0x187C,0x0E02,
++     0x0B03,0x02AE,0x1735,0x0283,0x033B,0x1C77,0x23C1,0x185C,0x0010,0x1595,
++     0x1C96,0x09E1,0x1055,0x19F7,0x1226,0x1790,0x01A9,0x1A8A,0x06B7,0x1A48,
++     0x1A96,0x121D,0x14BE,0x1681,0x131D,0x00BC,0x0D52,0x1401,0x0610,0x1A6F,
++     0x1354,0x0DD6,0x0155,0x07D4,0x017F,0x2154,0x1C9D,0x176B,0x1C4B,0x1C68,
++     0x1F33,0x082D,0x0616,0x23A4,0x0C86,0x1B00,0x0097,0x2357,0x10E4,0x149B,
++     0x0B8F,0x0E71,0x0636,0x062E,0x14AC,0x07C7,0x20FD,0x12BC,0x0228,0x106D,
++     0x0AB0,0x140F,0x2214,0x0C30,0x143B,0x1D77,0x1241,0x1FDB,0x1757,0x17E3,
++     0x0CB4,0x1F93,0x1C75,0x02B3,0x237A,0x0928,0x0CDE,0x12B4,0x11D4,0x1ADC,
++     0x2105,0x1B5C,0x1DF5,0x22FC,0x085F,0x08BF,0x0E1A,0x1564,0x06BF,0x1D59,
++     0x0B7A,0x22D7,0x0AED,0x10F8,0x0D48,0x1B33,0x20C2,0x205D,0x1801,0x228F,
++     0x13BD,0x0F5C,0x062C,0x1F2B,0x1AB7,0x09BE,0x0914,0x0C97,0x1941,0x151E,
++     0x0676,0x01BA,0x0207,0x09F3,0x1F4E,0x1B7A,0x07C2,0x0059,0x1BB4,0x1BA4,
++     0x1025,0x1102,0x0617,0x074A,0x0AF9,0x0915,0x1D3C,0x0B1B,0x0E05,0x0D66,
++     0x06C6,0x1C4D,0x0708,0x21C9,0x08E6,0x1DD9,0x235D,0x1D90,0x0095,0x0814,
++     0x0E4D,0x21C5,0x1DC3,0x0430,0x1E0D,0x235A,0x15DE,0x1B89,0x0729,0x066B,
++     0x23A3,0x2028,0x0398,0x229E,0x1845,0x212F,0x0740,0x029E,0x1D0F,0x1D11,
++     0x151D,0x023E,0x1B05,0x188F,0x0185,0x1584,0x044F,0x0033,0x0133,0x178D,
++     0x0C9A,0x10BC,0x0815,0x2206,0x1AC3,0x0CBA,0x115E,0x1772,0x0909,0x161A,
++     0x015C,0x1E83,0x1E96,0x0A1A,0x1D75,0x179E,0x2175,0x143E,0x17C5,0x12E9,
++     0x0F09,0x0885,0x0D71,0x18F8,0x0359,0x1615,0x0C6C,0x0809,0x1F10,0x1C18,
++     0x199C,0x1553,0x0D1B,0x0C0B,0x1ADF,0x0E4B,0x1B35,0x0B66,0x1264,0x22CB,
++     0x0181,0x154F,0x0D74,0x134D,0x18C1,0x0E43,0x13EC,0x1E37,0x01BE,0x0755,
++     0x0579,0x154B,0x0893,0x19D6,0x2072,0x208E,0x22C2,0x0719,0x04E6,0x00D3,
++     0x02C0,0x194A,0x0486,0x0DC1,0x06FD,0x1A86,0x0BEC,0x1191,0x0840,0x196C,
++     0x1959,0x12A5,0x08F8,0x17B0,0x16CF,0x0602,0x0D85,0x1F21,0x13A4,0x1946,
++     0x06E1,0x14BA,0x20F9,0x182C,0x0E09,0x13D8,0x159C,0x0881,0x0542,0x1948,
++     0x0829,0x1668,0x2060,0x1138,0x172D,0x17C3,0x0013,0x08E8,0x034F,0x1D80,
++     0x018D,0x0E90,0x0551,0x1CAE,0x0643,0x0ECD,0x005C,0x0223,0x0B29,0x10F1,
++     0x0B5D,0x0C5B,0x132B,0x02D1,0x2316,0x147F,0x1335,0x0679,0x06C4,0x04A3,
++     0x108D,0x02C3,0x075A,0x01EA,0x23AE,0x22B6,0x2138,0x232A,0x23EC,0x02AC,
++     0x227C,0x0E39,0x168F,0x0F35,0x06DA,0x0782,0x0556,0x042D,0x11AB,0x224C,
++     0x0F1E,0x0561,0x17A4,0x1B42,0x0AC6,0x1B91,0x0483,0x118B,0x1EED,0x0741,
++     0x177C,0x21E8,0x1AFC,0x209D,0x0FE0,0x1AD0,0x13B2,0x0637,0x20A4,0x1C1D,
++     0x0EAF,0x03E8,0x15F7,0x1686,0x21B2,0x2215,0x1091,0x01CE,0x135E,0x18C8,
++     0x1E46,0x2322,0x0618,0x23CA,0x1795,0x1F03,0x1A3D,0x0C5D,0x2298,0x01AE,
++     0x02E1,0x0D41,0x09D4,0x219D,0x2084,0x0F98,0x0375,0x13C9,0x0AC4,0x09FE,
++     0x1D81,0x0FF0,0x11C7,0x1FA9,0x1301,0x0BEF,0x1031,0x0B07,0x1FBF,0x1370,
++     0x1AA1,0x1956,0x15C0,0x1858,0x13BB,0x0937,0x1804,0x109D,0x03D8,0x0635,
++     0x1E41,0x0999,0x1079,0x15CC,0x15FC,0x09A2,0x1DA7,0x142E,0x03EC,0x1954,
++     0x1215,0x15E9,0x05C5,0x0831,0x13DA,0x14EF,0x22FE,0x1A54,0x06FE,0x23F1,
++     0x17A6,0x1CD2,0x068A,0x0E4C,0x03C8,0x007C,0x02E5,0x0C25,0x0C48,0x0A26,
++     0x1A9F,0x09B2,0x20F6,0x14AF,0x1B6F,0x233F,0x11F7,0x00B2,0x1076,0x1E70,
++     0x0726,0x1F59,0x222D,0x175D,0x1986,0x0AD8,0x2095,0x0214,0x231F,0x10C6,
++     0x1944,0x1816,0x093A,0x1EA5,0x0B4F,0x174E,0x1087,0x0C0E,0x1DDD,0x1CF2,
++     0x15AA,0x2231,0x22E8,0x0B52,0x040C,0x1CE3,0x0B7D,0x197C,0x0234,0x05EF,
++     0x1BDB,0x124E,0x1E95,0x03B4,0x226A,0x0149,0x137A,0x1AF5,0x20D5,0x1D4F,
++     0x0CDA,0x145B,0x026A,0x0473,0x0FF1,0x168A,0x16A5,0x23E4,0x13C6,0x0EB7,
++     0x0D7B,0x0D76,0x178E,0x23B7,0x05E2,0x16EB,0x0535,0x071B,0x2293,0x06E6,
++     0x1903,0x1526,0x1C23,0x0EC7,0x0CCB,0x1F65,0x0D89,0x147C,0x23F5,0x1446,
++     0x228B,0x0063,0x19DD,0x10FE,0x2023,0x0BAC,0x096A,0x22A4,0x1770,0x176D,
++     0x01C7,0x0E83,0x1E08,0x213F,0x2365,0x1EBD,0x1A16,0x0818,0x11FD,0x0E30,
++     0x024E,0x2256,0x0314,0x02D7,0x129B,0x0303,0x1BC7,0x01CC,0x1586,0x0752,
++     0x194C,0x168E,0x1099,0x10A5,0x1009,0x016A,0x0BA6,0x0DCC,0x0124,0x15A3,
++     0x2152,0x1072,0x0EBC,0x2018,0x1EEE,0x1139,0x0CCF,0x1FA1,0x035B,0x19D9,
++     0x1029,0x1048,0x1397,0x18D0,0x075B,0x0C55,0x0188,0x19CA,0x2229,0x20D9,
++     0x132D,0x0179,0x14A9,0x1A9D,0x1F6C,0x173F,0x18FF,0x12B0,0x00F8,0x14D9,
++     0x0CE4,0x0732,0x0169,0x21AA,0x1F0B,0x1F0F,0x16AD,0x0869,0x1DB7,0x0BA8,
++     0x1A55,0x0F6D,0x01BD,0x1DDA,0x1E1B,0x096B,0x09FF,0x2327,0x107D,0x0530,
++     0x11E3,0x0558,0x16A1,0x0CB0,0x1C7E,0x160F,0x1840,0x187D,0x0EEB,0x14B1,
++     0x079E,0x0C22,0x049E,0x0AE3,0x15BB,0x08E4,0x0F4A,0x1920,0x1ECF,0x12DD,
++     0x1A01,0x0C2B,0x0507,0x0AF7,0x04B9,0x0E35,0x209F,0x1805,0x1E66,0x1169,
++     0x2041,0x1EFC,0x1DDB,0x1E89,0x1EF2,0x1430,0x1DFC,0x1E98,0x0D9A,0x0D03,
++     0x0BDF,0x09DC,0x15D5,0x08DB,0x1250,0x0DC6,0x099B,0x07ED,0x1FEE,0x0753,
++     0x1C20,0x1EB8,0x17D2,0x23B2,0x1E34,0x22A3,0x0B5F,0x0ED1,0x0960,0x029B,
++     0x1977,0x0A7D,0x12A1,0x00C9,0x04D3,0x1271,0x1A74,0x08B8,0x1035,0x231A,
++     0x1300,0x047D,0x2202,0x0338,0x115C,0x01A3,0x2209,0x1CFB,0x193F,0x0BE3,
++     0x1E1A,0x1445,0x06A8,0x1F9B,0x1307,0x0916,0x0E34,0x1806,0x23CC,0x144C,
++     0x214A,0x1CE9,0x22B4,0x198A,0x126E,0x0F82,0x0D80,0x0167,0x0AC9,0x04A1,
++     0x184D,0x0E8E,0x190A,0x0268,0x1395,0x20BA,0x170F,0x16E6,0x0601,0x1E81,
++     0x1662,0x19B2,0x165E,0x0E3A,0x0D0B,0x0EDC,0x1235,0x23EE,0x0E28,0x0C88,
++     0x0C8E,0x2196,0x10B5,0x0BEB,0x230F,0x2367,0x0392,0x1404,0x0AEA,0x1A9B,
++     0x0439,0x03FA,0x1DB9,0x1100,0x11C1,0x222B,0x0787,0x007E,0x0E76,0x0261,
++     0x06D4,0x18B5,0x1B4A,0x0647,0x0DDB,0x1976,0x05AE,0x0F34,0x0186,0x0068,
++     0x1075,0x151F,0x0C3A,0x002C,0x233B,0x0A56,0x0DFA,0x0857,0x137E,0x12B1,
++     0x100B,0x0C21,0x0AA4,0x08B4,0x11ED,0x0EEA,0x13EB,0x0614,0x1BD2,0x0356,
++     0x16BA,0x1403,0x0AAE,0x0F00,0x1FFD,0x054A,0x01BB,0x2181,0x21CD,0x013B,
++     0x1F8D,0x2369,0x08C3,0x1669,0x195B,0x1884,0x02EA,0x1090,0x053C,0x11F2,
++     0x0472,0x034A,0x042A,0x223C,0x10AE,0x19A2,0x147E,0x0D6F,0x13AE,0x1CD0,
++     0x1FB5,0x093D,0x19D2,0x10C7,0x0258,0x0106,0x1D44,0x1ABC,0x0B3D,0x1F86,
++     0x1598,0x12E5,0x013D,0x1234,0x0F8A,0x0C6A,0x2318,0x0993,0x222E,0x1CC1,
++     0x106F,0x1A61,0x05BF,0x19B4,0x0EA8,0x03B1,0x1C6C,0x2030,0x0725,0x0E62,
++     0x064D,0x1469,0x2211,0x0004,0x1525,0x0B9F,0x0CB9,0x0EFC,0x0D02,0x1A1B,
++     0x17C0,0x1C50,0x14C4,0x0C0D,0x1CF1,0x02D0,0x1A92,0x0B26,0x0FDB,0x109E,
++     0x0905,0x0E8D,0x1D60,0x1C91,0x23F2,0x111E,0x06F2,0x1A88,0x22F3,0x0AB5,
++     0x1D83,0x0FEA,0x05EB,0x1E55,0x056F,0x08B7,0x18E1,0x1CD3,0x0A94,0x0E3E,
++     0x0E5F,0x1282,0x0CC7,0x0AB7,0x1DBF,0x0213,0x1BD1,0x044D,0x20EC,0x19E0,
++     0x071A,0x0DF1,0x07D5,0x1311,0x0007,0x0F92,0x00C5,0x0433,0x0465,0x073B,
++     0x0851,0x1542,0x05E9,0x0D39,0x0A1B,0x17F6,0x114D,0x0A9F,0x00A4,0x1A98,
++     0x0ACD,0x1835,0x1D8A,0x0649,0x1002,0x1038,0x1E7B,0x0FF2,0x1CF4,0x21B8,
++     0x1A58,0x0FE4,0x038E,0x1458,0x1538,0x1550,0x025A,0x0B82,0x16F0,0x0191,
++     0x171D,0x081E,0x0BD4,0x15DA,0x0849,0x21E2,0x0B7F,0x1A0F,0x18B6,0x1FD7,
++     0x02B9,0x04C1,0x0289,0x1F55,0x13DD,0x0FE1,0x1B1D,0x191D,0x17BB,0x0E4E,
++     0x0175,0x1AC6,0x0044,0x23AD,0x1D03,0x210F,0x17C7,0x05E8,0x0CC0,0x00D1,
++     0x0A60,0x0B3A,0x2299,0x2311,0x13E8,0x0BC8,0x0AC8,0x1E07,0x0380,0x0D50,
++     0x0B56,0x0555,0x2143,0x0479,0x1545,0x1285,0x13E6,0x1926,0x2042,0x2075,
++     0x1D79,0x2362,0x206A,0x187F,0x14B7,0x138E,0x1AA0,0x1C2D,0x0899,0x22CD,
++     0x115B,0x00D4,0x1014,0x1701,0x02CB,0x0028,0x1A2F,0x1FFA,0x21EE,0x16C3,
++     0x1158,0x15CE,0x1831,0x1639,0x04B7,0x00CE,0x0431,0x011F,0x1D35,0x23ED,
++     0x093F,0x0B91,0x0ED2,0x0EDA,0x0369,0x1BC3,0x0B1A,0x21C3,0x040A,0x206C,
++     0x17F9,0x1FB9,0x0CAD,0x1938,0x1661,0x0E19,0x1C1F,0x0A68,0x079B,0x1580,
++     0x0005,0x1D56,0x0CBD,0x0306,0x1F3E,0x0872,0x1D2C,0x0A3A,0x06E9,0x1B43,
++     0x0C8D,0x0113,0x0023,0x1675,0x0218,0x026D,0x1622,0x22A1,0x03F0,0x177F,
++     0x20F4,0x0EF3,0x1D96,0x2281,0x053E,0x0CD2,0x0C70,0x159E,0x1691,0x0713,
++     0x1F5E,0x205B,0x15C6,0x1C09,0x16E0,0x04CF,0x1C1C,0x0C74,0x15E5,0x12F7,
++     0x16D8,0x2245,0x07E2,0x0566,0x0345,0x1FE2,0x2093,0x114B,0x19D8,0x0313,
++     0x2108,0x1E09,0x2110,0x1FA8,0x03F6,0x0D93,0x0BD8,0x067F,0x06DE,0x2242,
++     0x2282,0x120F,0x04E5,0x0E97,0x05DE,0x1D9B,0x09C1,0x19C8,0x029D,0x19A4,
++     0x18BB,0x12F5,0x13D5,0x1AB3,0x11CF,0x0D59,0x094A,0x1574,0x16F6,0x0C08,
++     0x22C3,0x20BB,0x18E3,0x0A73,0x1842,0x093E,0x1114,0x1211,0x1733,0x09DA,
++     0x1ABE,0x1BD0,0x202F,0x0E41,0x222F,0x1F94,0x0D21,0x0553,0x08F0,0x10DA,
++     0x0711,0x11FE,0x1B52,0x07BC,0x0BF3,0x076F,0x0AD1,0x0D1E,0x004F,0x170D,
++     0x107A,0x1103,0x0681,0x02D2,0x0FA7,0x10DD,0x12D4,0x2083,0x0D9F,0x1DEB,
++     0x0422,0x1776,0x1767,0x029F,0x0C7A,0x10E1,0x1C11,0x08D6,0x069A,0x1F47,
++     0x14AA,0x1810,0x0CF6,0x09A3,0x0235,0x180A,0x1708,0x0A72,0x1BEC,0x1026,
++     0x1754,0x0B0B,0x043A,0x2040,0x1119,0x0612,0x0628,0x1187,0x14B4,0x157F,
++     0x1DB3,0x0156,0x01F9,0x082C,0x13FB,0x1218,0x0003,0x19CC,0x1764,0x14DC,
++     0x1F30,0x0011,0x0AA1,0x096F,0x14FE,0x23C3,0x0CAE,0x04DB,0x0F18,0x1F4A,
++     0x039B,0x15E1,0x08CB,0x0ADF,0x1FDF,0x1B50,0x08ED,0x1721,0x2296,0x040F,
++     0x1A29,0x128E,0x0C84,0x218A,0x01CA,0x1D78,0x05D8,0x0D19,0x0B94,0x13C0,
++     0x02E8,0x0426,0x2272,0x10ED,0x1179,0x1E4D,0x1781,0x0219,0x21A9,0x0088,
++     0x2091,0x19E4,0x115A,0x1116,0x17D0,0x1A49,0x14B2,0x0DAD,0x0608,0x1F6E,
++     0x2001,0x1BE0,0x17F0,0x0897,0x004C,0x11C3,0x22E3,0x05C8,0x06E5,0x1678,
++     0x140D,0x1BA9,0x05FC,0x08E3,0x096D,0x03A9,0x092C,0x17F8,0x04BF,0x0902,
++     0x16DB,0x1EE2,0x15E7,0x12E2,0x05AF,0x0C64,0x1345,0x03F2,0x128A,0x0811,
++     0x0716,0x0582,0x031F,0x13DF,0x1E47,0x1B1C,0x0E77,0x1EE3,0x22B2,0x1FBA,
++     0x0E2D,0x2082,0x1A8D,0x1596,0x11B4,0x129C,0x1F95,0x1710,0x1A57,0x1736,
++     0x0D84,0x1B34,0x1D30,0x0D95,0x0B6E,0x1F2A,0x0E64,0x060B,0x0A91,0x0CE9,
++     0x14A7,0x20B3,0x1442,0x1803,0x195C,0x06B2,0x11F9,0x10DF,0x1784,0x0B53,
++     0x10BA,0x1317,0x1420,0x114F,0x1871,0x17C2,0x0742,0x16A2,0x06EC,0x19B7,
++     0x0367,0x0C2E,0x129E,0x06CF,0x0D01,0x0FE7,0x03A8,0x08C4,0x124D,0x139C,
++     0x04AB,0x1CC5,0x0574,0x082B,0x1C79,0x126C,0x216F,0x023B,0x17D5,0x066A,
++     0x0F01,0x0AE6,0x06F0,0x13B6,0x1227,0x0A78,0x230E,0x2348,0x222A,0x0FF4,
++     0x1E9B,0x1FD8,0x136A,0x2335,0x10AC,0x134B,0x1939,0x0273,0x0BC4,0x01E3,
++     0x1D37,0x1AA8,0x0123,0x0609,0x069E,0x03B5,0x1874,0x1896,0x22DA,0x08B3,
++     0x04B4,0x0304,0x1FCD,0x0F6F,0x04B6,0x0A77,0x02A2,0x2109,0x2393,0x23B5,
++     0x21B5,0x2330,0x1CD7,0x15D6,0x0ACB,0x0F94,0x20DE,0x0836,0x1C7A,0x0FFE,
++     0x1645,0x15AD,0x188B,0x184A,0x1B41,0x158E,0x046D,0x173E,0x0B40,0x0378,
++     0x0281,0x0F3D,0x11AC,0x1D70,0x1BF9,0x101E,0x145C,0x0083,0x058E,0x160C,
++     0x1FA6,0x1364,0x1FF1,0x0E48,0x0992,0x086C,0x16D6,0x08DA,0x0C40,0x0253,
++     0x03F9,0x2065,0x2032,0x03B0,0x1281,0x2118,0x1F23,0x1722,0x22FA,0x0328,
++     0x01AA,0x146A,0x12C4,0x2329,0x03EF,0x0DF3,0x0C53,0x09EA,0x01C4,0x1FCA,
++     0x1792,0x09D9,0x1540,0x1F6A,0x0279,0x0145,0x1AA7,0x013F,0x1E19,0x15B6,
++     0x000D,0x0A53,0x186E,0x217F,0x0CE3,0x1853,0x1A11,0x1936,0x1828,0x08BD,
++     0x08DF,0x1EA8,0x12EE,0x1D0C,0x1664,0x20DF,0x04DE,0x083A,0x0D24,0x2361,
++     0x0F2B,0x2354,0x126F,0x109B,0x1DF8,0x174F,0x09A0,0x0D53,0x00C2,0x06BA,
++     0x087C,0x0CC3,0x21B9,0x128C,0x01A1,0x0688,0x1162,0x0C7C,0x1C27,0x20D0,
++     0x0A6B,0x1B44,0x002D,0x119B,0x1855,0x102F,0x19BB,0x20FB,0x11C8,0x05FB,
++     0x058A,0x1C5F,0x1CE6,0x09C7,0x192F,0x0E1D,0x03CB,0x20EA,0x1CC3,0x01DB,
++     0x05C9,0x1B60,0x069B,0x001D,0x2295,0x1C4E,0x0A40,0x105F,0x0141,0x01AC,
++     0x0640,0x032D,0x15B5,0x229F,0x1E17,0x19F0,0x194F,0x0102,0x0675,0x0B5B,
++     0x203A,0x1010,0x1412,0x02E7,0x155C,0x176A,0x0866,0x21A1,0x18E9,0x0565,
++     0x12CA,0x1F44,0x1274,0x1B32,0x0260,0x196F,0x1838,0x13C3,0x003F,0x19C6,
++     0x01C6,0x1600,0x0EDF,0x0FD1,0x0A69,0x0062,0x1ED0,0x0F56,0x0377,0x2333,
++     0x0EA5,0x0350,0x1DF1,0x19A6,0x224B,0x0EA0,0x112D,0x204D,0x04D2,0x1613,
++     0x1793,0x0817,0x1D4E,0x1BF2,0x1913,0x0233,0x0B34,0x0A71,0x109C,0x1775,
++     0x0CDD,0x02DE,0x1EB4,0x1C28,0x021C,0x1D1C,0x1C93,0x1189,0x1999,0x16AC,
++     0x1670,0x1738,0x1E2A,0x2078,0x14BD,0x00EA,0x0898,0x1015,0x0EFA,0x19D7,
++     0x113E,0x1630,0x1DBB,0x0EC9,0x1560,0x1FC8,0x16EC,0x10E3,0x0CF2,0x07C8,
++     0x1174,0x0C5A,0x002E,0x1DB1,0x01D6,0x07E7,0x18CD,0x19A8,0x0CC5,0x0D5C,
++     0x1541,0x12CC,0x0BE9,0x0A1C,0x21CF,0x0171,0x067B,0x1DE3,0x1EE8,0x022B,
++     0x17A9,0x19AB,0x0D20,0x1C03,0x1E45,0x0E80,0x0B19,0x107F,0x124F,0x18AE,
++     0x1907,0x1614,0x18BD,0x0A9B,0x059B,0x0D70,0x12F3,0x10C5,0x2140,0x0BB4,
++     0x2384,0x01F7,0x0748,0x0FFB,0x13B3,0x01AD,0x076D,0x1083,0x1125,0x0018,
++     0x1C39,0x0925,0x19EF,0x0E4F,0x210C,0x159F,0x037E,0x0A62,0x219E,0x211C,
++     0x1C54,0x0BE0,0x1E02,0x09BA,0x1CBB,0x147B,0x1389,0x0B68,0x1023,0x23CB,
++     0x0E75,0x1086,0x1145,0x0BE4,0x1BFD,0x2059,0x2007,0x0022,0x05D5,0x1BF6,
++     0x02F0,0x1D1D,0x129A,0x06E4,0x0F47,0x0673,0x0ADD,0x0871,0x1C52,0x1449,
++     0x232C,0x1E67,0x085B,0x20AE,0x0B74,0x16A7,0x0B85,0x1717,0x0FC7,0x0DFB,
++     0x097F,0x0624,0x1CD6,0x15AF,0x0EFB,0x0E42,0x03B9,0x1369,0x0927,0x047C,
++     0x0D5A,0x0982,0x0E7F,0x217C,0x02D5,0x06DD,0x1E79,0x0D9D,0x1964,0x1153,
++     0x1F70,0x04CD,0x1123,0x22F1,0x1F2D,0x1EA4,0x19B6,0x1C3B,0x1356,0x0E01,
++     0x16C7,0x11C9,0x191A,0x09AC,0x1DE6,0x1FDC,0x0581,0x1F04,0x1178,0x06AB,
++     0x1D06,0x0A48,0x0F5B,0x1E4A,0x15D2,0x0FF8,0x01C3,0x1A14,0x0D17,0x086D,
++     0x0CEF,0x1D50,0x03CF,0x0B3E,0x003D,0x06AC,0x008B,0x1185,0x1732,0x11BD,
++     0x12F8,0x03B8,0x1068,0x18A2,0x1BA0,0x10F0,0x0868,0x03E6,0x1DC8,0x1AA2,
++     0x1B13,0x1C82,0x0055,0x099F,0x2222,0x034B,0x179D,0x1E6F,0x1261,0x0FC8,
++     0x166D,0x1F42,0x127F,0x0C9B,0x00B9,0x1D26,0x181D,0x1320,0x09AE,0x01DA,
++     0x1A35,0x05E3,0x04D6,0x1141,0x1BB2,0x0669,0x1B70,0x1F22,0x1B9D,0x19BE,
++     0x0D2A,0x1057,0x0A3B,0x11D3,0x157B,0x1B49,0x14F7,0x095D,0x0A88,0x0126,
++     0x031B,0x03DE,0x1422,0x0BF8,0x1030,0x1F34,0x210B,0x1B12,0x0379,0x0806,
++     0x1252,0x18A0,0x1778,0x1EE7,0x23C6,0x1611,0x22EC,0x0BE8,0x0950,0x1008,
++     0x0906,0x1D51,0x10A2,0x1DAE,0x22D8,0x1499,0x152F,0x0D08,0x00DB,0x0860,
++     0x0162,0x0AD3,0x2233,0x18A6,0x0DD2,0x1477,0x11B3,0x1CBD,0x2043,0x183A,
++     0x1077,0x15E6,0x1FEA,0x0FE8,0x0396,0x0B0A,0x1296,0x0049,0x2303,0x1818,
++     0x03A2,0x03F8,0x1225,0x05ED,0x15D4,0x030D,0x089D,0x107E,0x0A43,0x14A0,
++     0x235C,0x1426,0x0733,0x0D1C,0x1B96,0x09CE,0x155D,0x0F6E,0x238C,0x0876,
++     0x1DE0,0x1223,0x0FEF,0x078B,0x1EC2,0x09BF,0x1D52,0x1FA4,0x202B,0x14E1,
++     0x0864,0x1F78,0x0FA9,0x1821,0x0E38,0x06A6,0x0211,0x1F9E,0x020A,0x1AF2,
++     0x0981,0x1CC0,0x0766,0x1047,0x1EA9,0x0C16,0x1BE8,0x0464,0x22C8,0x183B,
++     0x0B32,0x2106,0x0D79,0x14F5,0x0A33,0x18D4,0x0482,0x0158,0x13E2,0x1651,
++     0x03C6,0x1750,0x1A5A,0x1C3C,0x1825,0x1DFB,0x1D76,0x2218,0x1F16,0x08EE,
++     0x210A,0x0747,0x0DF5,0x0CD3,0x10D3,0x1BBA,0x1F5D,0x1A78,0x19C7,0x177E,
++     0x13F0,0x2315,0x1F82,0x0922,0x22C6,0x17CC,0x1A50,0x1FE5,0x193D,0x122D,
++     0x03E3,0x07C9,0x20B0,0x217A,0x23F4,0x0DFD,0x1268,0x080E,0x192D,0x0698,
++     0x1EAF,0x170A,0x1E60,0x1947,0x1CE1,0x10BB,0x1505,0x016E,0x207B,0x11E7,
++     0x1F85,0x0F72,0x191E,0x2015,0x04AD,0x0AC1,0x1D73,0x2003,0x02F9,0x1C26,
++     0x1F64,0x0C7D,0x0B2D,0x004D,0x1E2B,0x1432,0x026C,0x1E04,0x218C,0x0CE1,
++     0x000F,0x0A01,0x16D0,0x20C8,0x0E25,0x0C09,0x2199,0x091A,0x0E3B,0x0F5F,
++     0x0D5E,0x223D,0x025D,0x0699,0x00DD,0x20EB,0x1352,0x1B92,0x21A4,0x1E10,
++     0x05E5,0x1292,0x0750,0x0552,0x0061,0x0058,0x07CB,0x02B6,0x12F0,0x0F67,
++     0x070D,0x1837,0x196B,0x09F7,0x153F,0x0BEE,0x1769,0x0B00,0x1142,0x1AE9,
++     0x1B98,0x1B8A,0x11A8,0x1DD2,0x16D2,0x1C7C,0x0F38,0x0F3B,0x1601,0x0151,
++     0x0320,0x1085,0x0B61,0x0DAF,0x1308,0x0E21,0x0371,0x1F7C,0x04DD,0x0F49,
++     0x1146,0x169C,0x1E31,0x1258,0x1E50,0x1F8B,0x205F,0x145A,0x084D,0x23B8,
++     0x0FAF,0x2055,0x160E,0x13D7,0x0908,0x0A7C,0x1022,0x0AC5,0x02DA,0x1962,
++     0x1F9F,0x0467,0x1E9C,0x04E3,0x0F4E,0x1DF9,0x23A5,0x10E7,0x11A9,0x215F,
++     0x117E,0x223A,0x149E,0x01E6,0x18D6,0x03B7,0x104B,0x0FBB,0x1273,0x18C9,
++     0x0A4A,0x215A,0x024C,0x1378,0x1ED2,0x212D,0x0F22,0x1F99,0x212E,0x2044,
++     0x10D0,0x22D2,0x20F7,0x19B5,0x1416,0x1741,0x20B6,0x1159,0x23A6,0x186D,
++     0x0515,0x04A8,0x2171,0x0E9E,0x2325,0x111B,0x1EC8,0x1620,0x1687,0x22BC,
++     0x059F,0x06E7,0x11DD,0x1C88,0x2125,0x0FAA,0x10DB,0x1854,0x1410,0x141C,
++     0x23AF,0x21D6,0x0B8C,0x0AD9,0x0B6B,0x0597,0x0C06,0x0619,0x198F,0x0339,
++     0x0802,0x0859,0x0107,0x0410,0x208A,0x2291,0x0E10,0x1DA6,0x19AA,0x0324,
++     0x10FB,0x049A,0x0CAC,0x2252,0x0299,0x0FD0,0x1DE7,0x086E,0x0FFA,0x09FA,
++     0x23C8,0x18C7,0x0489,0x2195,0x1802,0x19F2,0x1967,0x0FBF,0x02EE,0x0AE4,
++     0x0B63,0x1509,0x178F,0x0843,0x05E7,0x0613,0x1739,0x065A,0x0201,0x06D7,
++     0x21DA,0x11F4,0x0503,0x090D,0x0E32,0x09A8,0x1B5A,0x1EFB,0x20BF,0x11F1,
++     0x1D40,0x1DF2,0x1E75,0x01B0,0x0BCE,0x1346,0x1D5C,0x0546,0x1B0E,0x07B4,
++     0x11E8,0x018A,0x19E6,0x0177,0x134E,0x18E2,0x1546,0x0861,0x054C,0x0119,
++     0x1A77,0x1CEF,0x1110,0x1953,0x1CD9,0x0B65,0x0CD0,0x1E5A,0x1E0F,0x07EB,
++     0x13C2,0x1949,0x16E3,0x0409,0x007F,0x1CFF,0x0485,0x14D0,0x0CD1,0x0E46,
++     0x055E,0x1C48,0x016F,0x1C7B,0x1109,0x18B2,0x0ED5,0x13B0,0x0DFF,0x2061,
++     0x0795,0x2076,0x1A4A,0x029C,0x13BF,0x119A,0x1819,0x227A,0x0388,0x1C24,
++     0x036E,0x1D82,0x0F4B,0x084E,0x23EB,0x13A1,0x0632,0x13DC,0x150A,0x0112,
++     0x05A4,0x073C,0x161D,0x04AC,0x2283,0x0D0A,0x172E,0x2142,0x0319,0x1673,
++     0x17D6,0x0F73,0x0E26,0x14E6,0x1F46,0x13E0,0x1841,0x130E,0x2363,0x10CE,
++     0x0980,0x15A2,0x1FC7,0x04D9,0x11A2,0x0CA8,0x00EF,0x07BF,0x1C12,0x09DE,
++     0x0AE0,0x00DF,0x0D49,0x06C0,0x206E,0x1EE1,0x0A38,0x22F8,0x1DC7,0x0A79,
++     0x1800,0x179B,0x1386,0x1A22,0x01D2,0x094E,0x125C,0x2244,0x1746,0x0EDE,
++     0x002A,0x1CA7,0x099A,0x07E4,0x0264,0x1C6F,0x2389,0x0987,0x1F3D,0x1E88,
++     0x02E0,0x0D44,0x0E6C,0x1E8F,0x0F55,0x2066,0x1CC4,0x0917,0x1DB8,0x089F,
++     0x0615,0x11A5,0x12C8,0x0A42,0x079C,0x0D13,0x0B6A,0x131F,0x136C,0x04AE,
++     0x130D,0x16F8,0x01A0,0x13C7,0x0B4C,0x2279,0x0196,0x1464,0x0F60,0x0231,
++     0x19A0,0x1E9A,0x0397,0x170B,0x133C,0x2265,0x017C,0x1C78,0x048C,0x08D0,
++     0x06A4,0x071C,0x0BBA,0x0DE7,0x0B3F,0x0229,0x1EAD,0x140A,0x037B,0x0EC6,
++     0x0E16,0x0442,0x1894,0x156C,0x0F8F,0x23A1,0x0DCE,0x13CD,0x1AA4,0x0E59,
++     0x162B,0x1AA9,0x1BFB,0x09A7,0x1703,0x0A81,0x2056,0x21BC,0x078F,0x07AD,
++     0x1A24,0x0F31,0x19F3,0x09E6,0x11CD,0x23B6,0x234F,0x0FD2,0x196D,0x06D6,
++     0x035A,0x0AFA,0x005E,0x035C,0x1AB9,0x15A4,0x1318,0x0132,0x08D9,0x0512,
++     0x1693,0x0DB0,0x16A6,0x07FC,0x0B02,0x1D0D,0x09F0,0x21F5,0x0799,0x13E3,
++     0x0768,0x0EF9,0x1176,0x014A,0x15C1,0x0BA1,0x0E99,0x112B,0x1AAE,0x1C0B,
++     0x0178,0x1C69,0x1C0F,0x0130,0x1FC2,0x0E45,0x1694,0x1F0D,0x1A79,0x0911,
++     0x0FE9,0x09AF,0x18C2,0x1B67,0x1DF3,0x0B01,0x14B5,0x1DFD,0x0DCD,0x161E,
++     0x19A1,0x19E5,0x1500,0x14C9,0x0B2A,0x2366,0x1B46,0x14F4,0x0B5C,0x063E,
++     0x03E1,0x0CA5,0x04F7,0x1409,0x0EC3,0x1D5D,0x012C,0x1277,0x1310,0x1214,
++     0x112E,0x1F80,0x0AD6,0x1FD6,0x105B,0x226C,0x1F41,0x19CF,0x2033,0x0D29,
++     0x03CA,0x1A47,0x0756,0x125A,0x06F4,0x1B53,0x0527,0x1D91,0x20CE,0x1975,
++     0x0072,0x1431,0x1EEF,0x0BD0,0x0BE1,0x0C01,0x00E1,0x0A7A,0x23E6,0x0323,
++     0x219F,0x1367,0x07A2,0x1CB6,0x2191,0x0CB2,0x234A,0x1288,0x17DD,0x030B,
++     0x15F2,0x02A8,0x0D83,0x04BD,0x2347,0x0522,0x051B,0x225A,0x228A,0x1B9F,
++     0x13F9,0x1B7C,0x1D7F,0x0A30,0x0220,0x1C3F,0x22EA,0x1680,0x0FC9,0x1190,
++     0x1EF1,0x21CC,0x155E,0x20DD,0x0F27,0x13F6,0x07FF,0x0F71,0x1E6A,0x05B9,
++     0x0F0A,0x2228,0x02E9,0x0ACE,0x205C,0x01E5,0x200B,0x002F,0x1E27,0x0116,
++     0x1B38,0x190C,0x2307,0x07EA,0x152C,0x04C8,0x01FE,0x199B,0x1001,0x1535,
++     0x0930,0x1EC9,0x086A,0x0080,0x141E,0x1066,0x16DF,0x0C79,0x1E42,0x0A4C,
++     0x0667,0x1B7F,0x1679,0x1A3C,0x1A25,0x00E6,0x0611,0x0518,0x0B87,0x16F9,
++     0x22B0,0x1C3A,0x14FD,0x04BC,0x080F,0x21BF,0x1943,0x0266,0x1124,0x002B,
++     0x0670,0x01AB,0x1EC5,0x08B6,0x091D,0x0FA6,0x0541,0x20DC,0x0E65,0x0128,
++     0x08C9,0x11E5,0x1647,0x0D3D,0x01B8,0x1C61,0x2319,0x200C,0x1053,0x1027,
++     0x05F8,0x1A27,0x1133,0x210D,0x11E6,0x0935,0x054B,0x0754,0x02C6,0x0723,
++     0x0852,0x106B,0x161F,0x10B1,0x0E81,0x2054,0x156B,0x1113,0x22C5,0x21B7,
++     0x0AC0,0x042B,0x17DB,0x01B9,0x0CA2,0x055B,0x1A87,0x0D62,0x0A47,0x077F,
++     0x1D25,0x0FB5,0x1F3F,0x04E0,0x16C2,0x011D,0x158C,0x209C,0x0D6E,0x18FE,
++     0x05DD,0x1C05,0x123E,0x1BC6,0x0892,0x232B,0x1E3F,0x11B6,0x10B6,0x144A,
++     0x203F,0x02AD,0x2237,0x1BB3,0x03EB,0x0BBC,0x0311,0x1054,0x011E,0x1712,
++     0x05C2,0x2129,0x0292,0x22D0,0x0E6F,0x1F17,0x2234,0x16B6,0x00B5,0x1502,
++     0x0B0E,0x1299,0x2170,0x08C0,0x1BD4,0x1475,0x141B,0x0D00,0x2026,0x0318,
++     0x1567,0x0A4E,0x03E9,0x1CDC,0x23A8,0x1D8E,0x0DD8,0x0470,0x0286,0x1C22,
++     0x1315,0x1785,0x048F,0x1786,0x1EE0,0x0B37,0x0952,0x02BE,0x0873,0x04DF,
++     0x2101,0x0FCD,0x04B0,0x059D,0x1FCF,0x05E0,0x1C7F,0x0CBE,0x0461,0x024A,
++     0x027C,0x05F4,0x092A,0x0DC9,0x01E7,0x1147,0x03B2,0x1AB8,0x0238,0x174C,
++     0x02B2,0x1C6E,0x04D8,0x0DBC,0x1AB1,0x17FF,0x1443,0x054F,0x1128,0x0370,
++     0x14CC,0x1F35,0x1173,0x0A03,0x1D32,0x12D1,0x02AB,0x09DB,0x153D,0x1425,
++     0x122F,0x06BD,0x17B8,0x1579,0x0890,0x1B0F,0x1050,0x0DDF,0x23E3,0x1860,
++     0x1203,0x11D5,0x0EBB,0x0A80,0x00B7,0x1951,0x15B7,0x1FF3,0x0D14,0x143D,
++     0x164C,0x0E67,0x0C91,0x01F4,0x2243,0x1474,0x03A4,0x2147,0x0270,0x10C9,
++     0x116F,0x127D,0x0B1E,0x10FC,0x1A0A,0x1846,0x1F63,0x1067,0x0BB3,0x191F,
++     0x0EA6,0x0EEF,0x1E29,0x18B9,0x2079,0x090C,0x16FD,0x0EB4,0x0BC9,0x2098,
++     0x080A,0x0183,0x1BFE,0x1631,0x0769,0x1DD8,0x142F,0x0F66,0x1316,0x02A9,
++     0x22EE,0x1C4F,0x0285,0x1013,0x065D,0x0C2D,0x0466,0x033E,0x00E7,0x1900,
++     0x226F,0x1276,0x03AE,0x0EA1,0x23E7,0x174D,0x216C,0x1CA1,0x1A06,0x0665,
++     0x1461,0x2260,0x1F7D,0x1156,0x14E8,0x1327,0x0257,0x089A,0x15DF,0x16F4,
++     0x0EB9,0x03B3,0x0EAD,0x0FD9,0x085D,0x1259,0x1BA8,0x1E90,0x114C,0x2236,
++     0x02C7,0x1E53,0x2115,0x1D33,0x1FF5,0x1AFD,0x185D,0x06EE,0x0DC0,0x078C,
++     0x0AF4,0x15D1,0x0030,0x2131,0x1EB6,0x06E0,0x06B6,0x038C,0x05A8,0x080C,
++     0x0E98,0x1682,0x1DC0,0x1340,0x13B7,0x1C1B,0x0434,0x1AB5,0x1CAB,0x1A1C,
++     0x07D0,0x1ABB,0x22C1,0x0F08,0x027D,0x1238,0x1591,0x07F7,0x0D30,0x13F8,
++     0x1909,0x212B,0x1826,0x0749,0x0D06,0x0D2E,0x104F,0x1F39,0x09EB,0x0EF6,
++     0x22E6,0x16F1,0x0AEE,0x116B,0x17DE,0x0B12,0x0322,0x0BEA,0x064C,0x03D9,
++     0x2374,0x0CA4,0x1293,0x0E5C,0x04B3,0x03A0,0x13AD,0x0E33,0x0353,0x081A,
++     0x0BB2,0x0DA3,0x1E01,0x1322,0x0EBE,0x0D0E,0x0DBB,0x11A3,0x1B57,0x16FF,
++     0x0298,0x1A8F,0x09EF,0x08AD,0x1877,0x22AC,0x147A,0x1B36,0x095A,0x1B08,
++     0x0455,0x10AD,0x0343,0x1B16,0x0CF8,0x082E,0x144D,0x1A37,0x1B5D,0x0702,
++     0x09C4,0x1E16,0x157A,0x1965,0x0A63,0x1C6D,0x0D9E,0x0ED8,0x1E57,0x05CC,
++     0x1758,0x008D,0x0BFE,0x1168,0x04ED,0x1917,0x2251,0x1074,0x2356,0x1719,
++     0x1D3B,0x1FBE,0x22AA,0x14C8,0x211F,0x16D1,0x124B,0x2241,0x1C08,0x0AAC,
++     0x0F06,0x12B5,0x01FB,0x1C72,0x0089,0x23B3,0x02BA,0x15A5,0x1A00,0x1483,
++     0x13F2,0x2016,0x1AEB,0x2187,0x0BF7,0x07FA,0x2005,0x1516,0x13D6,0x0122,
++     0x0420,0x039D,0x0193,0x193B,0x2360,0x0453,0x0A75,0x0BD9,0x1197,0x1923,
++     0x1DB5,0x2225,0x1194,0x2058,0x0E9F,0x1106,0x06A1,0x02F5,0x1B63,0x00FF,
++     0x1F4C,0x2289,0x0CE0,0x1F1D,0x1247,0x19AE,0x1FC0,0x182E,0x05B3,0x0DB2,
++     0x229C,0x0E3D,0x232D,0x1961,0x1B95,0x0CA9,0x1A9E,0x183F,0x0203,0x1E76,
++     0x16BB,0x00B1,0x0A3F,0x237E,0x08A8,0x1B6E,0x0B2B,0x215B,0x119E,0x0945,
++     0x0F86,0x0A4B,0x12C7,0x1616,0x046B,0x20A3,0x0454,0x0405,0x0C19,0x1A08,
++     0x1E33,0x10BD,0x1861,0x2135,0x0C23,0x0F36,0x0C5C,0x049B,0x032F,0x1A19,
++     0x03DC,0x1E84,0x011C,0x1E61,0x096E,0x1F66,0x0798,0x104C,0x1C62,0x1E73,
++     0x03E4,0x0638,0x190D,0x1AF6,0x17EF,0x10FD,0x1B0D,0x1263,0x1512,0x09A5,
++     0x1439,0x0EF7,0x041D,0x04BA,0x08D4,0x1714,0x1B62,0x164F,0x1787,0x114A,
++     0x05B2,0x1812,0x0D33,0x176E,0x1480,0x12FA,0x0E61,0x084B,0x0801,0x079A,
++     0x2034,0x154A,0x23BC,0x20A9,0x1985,0x2286,0x148C,0x0DC2,0x06D8,0x1D4C,
++     0x183D,0x1A41,0x22DD,0x21F1,0x103C,0x14BC,0x0827,0x0850,0x157D,0x02BD,
++     0x03BF,0x00DE,0x0C9E,0x1CB7,0x1BF8,0x0805,0x20A8,0x1DA1,0x1F50,0x1DA0,
++     0x0DA0,0x068E,0x1979,0x0650,0x1F52,0x2239,0x0594,0x1534,0x1C38,0x0351,
++     0x0DE3,0x1672,0x21E3,0x10AB,0x11BC,0x1788,0x1547,0x2071,0x07DE,0x012F,
++     0x22AF,0x2377,0x179A,0x12B3,0x0CF3,0x0B92,0x0BB7,0x070F,0x11CA,0x2039,
++     0x0DAA,0x1521,0x0278,0x0F4D,0x0C87,0x0956,0x0967,0x067E,0x08B0,0x11AF,
++     0x051F,0x099E,0x0C78,0x0E27,0x19BD,0x1DCC,0x15F1,0x01F5,0x1453,0x043E,
++     0x1E8C,0x018F,0x1B54,0x2166,0x1BBC,0x1FE8,0x059A,0x0C6B,0x00C7,0x1E92,
++     0x13DE,0x0B3B,0x05E4,0x15EE,0x22A9,0x2090,0x2276,0x0631,0x105D,0x2038,
++     0x195A,0x17E5,0x1AFF,0x10A8,0x0384,0x0886,0x0456,0x1599,0x0B4E,0x1D47,
++     0x1830,0x051E,0x1C3D,0x20E1,0x1895,0x2092,0x10E9,0x07C6,0x23BD,0x201A,
++     0x209A,0x04C4,0x0315,0x019B,0x237C,0x047A,0x23FC,0x11A6,0x195F,0x2006,
++     0x1328,0x1CCE,0x1DEA,0x0970,0x0067,0x058D,0x1934,0x2120,0x01C5,0x2263,
++     0x04FD,0x1AE1,0x125E,0x1CA0,0x19BC,0x226E,0x0734,0x0BB8,0x0A54,0x19FE,
++     0x0E85,0x1FC6,0x0224,0x171C,0x1FFB,0x1115,0x0524,0x133E,0x0EDD,0x2280,
++     0x1D2F,0x0200,0x0CB3,0x23FE,0x0F19,0x1569,0x1537,0x19C2,0x08DC,0x1F6D,
++     0x068D,0x10F4,0x055A,0x1E30,0x21F0,0x1CF5,0x0D35,0x04A6,0x139D,0x23D3,
++     0x0A8D,0x1D3D,0x0763,0x0575,0x1511,0x1676,0x1304,0x0E13,0x10CD,0x0E55,
++     0x199E,0x236E,0x1257,0x2288,0x13E5,0x0037,0x1D04,0x04EF,0x100E,0x0FAE,
++     0x1E9E,0x067A,0x2320,0x0539,0x21D8,0x07C4,0x045F,0x1D0B,0x1196,0x020E,
++     0x1B68,0x04B5,0x031C,0x00FD,0x1184,0x0F7C,0x166C,0x23D2,0x0C9F,0x2380,
++     0x0B78,0x0F14,0x18F0,0x05AD,0x0252,0x138A,0x13FA,0x1A93,0x1F01,0x126A,
++     0x1D6A,0x11D9,0x182F,0x1492,0x1822,0x0D54,0x16E2,0x05D1,0x1155,0x0C4A,
++     0x1F58,0x00A3,0x17E0,0x0CD6,0x1D43,0x0250,0x16F3,0x0CFB,0x0C29,0x0B86,
++     0x11A4,0x1ED7,0x14FC,0x10D8,0x0F59,0x2338,0x1C5A,0x0F42,0x142D,0x12FD,
++     0x2373,0x11CE,0x0800,0x23E0,0x2025,0x0FFD,0x0A99,0x2264,0x1FF7,0x04A9,
++     0x1A67,0x1ED4,0x0BE2,0x21F3,0x1DF4,0x1927,0x04A4,0x1C84,0x0B09,0x11B9,
++     0x21A0,0x1D7B,0x1EF7,0x006F,0x18C6,0x1478,0x0985,0x1E23,0x0039,0x1EBC,
++     0x13D2,0x0391,0x039C,0x0118,0x1061,0x21C8,0x1A40,0x1EAA,0x175B,0x036C,
++     0x204F,0x19BA,0x1F91,0x193A,0x197B,0x0F24,0x176F,0x1592,0x0854,0x0804,
++     0x0FD4,0x0A2B,0x16FE,0x0D64,0x0587,0x1F00,0x1539,0x203C,0x1E54,0x01B4,
++     0x02E6,0x1B11,0x0A98,0x157C,0x1868,0x0786,0x15C8,0x083C,0x0F84,0x1209,
++     0x0B47,0x0F1C,0x0D77,0x188C,0x06C7,0x0521,0x203E,0x1921,0x0996,0x2020,
++     0x1E5D,0x12CE,0x0940,0x0309,0x1991,0x12A7,0x1E77,0x0830,0x1B94,0x1C73,
++     0x02C4,0x1D86,0x0F0F,0x192B,0x0BFC,0x1451,0x1969,0x09F1,0x010C,0x1865,
++     0x09C6,0x1AE8,0x17B7,0x21F8,0x14A1,0x21F6,0x07D7,0x0C36,0x1CB4,0x1883,
++     0x1655,0x1DDF,0x0863,0x00F0,0x0961,0x0687,0x1070,0x0FE5,0x072F,0x0BC2,
++     0x08C8,0x1AAA,0x0645,0x09CF,0x0FA8,0x2130,0x23CF,0x2246,0x1990,0x1744,
++     0x0D4B,0x0090,0x143F,0x166F,0x1DE5,0x0331,0x09CD,0x1447,0x1CEB,0x0D3B,
++     0x0CCD,0x2159,0x0F78,0x0251,0x068F,0x07BB,0x0877,0x1A2A,0x0700,0x23C2,
++     0x08A2,0x1C98,0x1427,0x0E79,0x15AC,0x0F8B,0x153A,0x0AEC,0x0DEC,0x03EE,
++     0x1AE2,0x1F6B,0x13F4,0x1EFA,0x172F,0x1C87,0x1B3F,0x192A,0x1C53,0x1BB1,
++     0x0297,0x0772,0x1385,0x173D,0x0707,0x17BD,0x007D,0x1A07,0x08C6,0x1D6F,
++     0x09D8,0x1850,0x1C8B,0x180D,0x1CB1,0x148A,0x0492,0x0847,0x0D78,0x0DEF,
++     0x0E7E,0x1D3A,0x0E91,0x1888,0x1C59,0x1AE7,0x1FC1,0x154C,0x058C,0x0078,
++     0x22BA,0x225B,0x0F5E,0x1A4C,0x0D3E,0x195D,0x06DF,0x02A7,0x14E5,0x0CFC,
++     0x16EE,0x0F7D,0x0321,0x178A,0x1097,0x0E0B,0x1479,0x079D,0x1C5B,0x1208,
++     0x0B1F,0x0D7C,0x1963,0x0835,0x1C99,0x2226,0x1417,0x045E,0x18E0,0x0051,
++     0x1243,0x181E,0x0659,0x172A,0x1373,0x1ABD,0x1F0C,0x1749,0x113A,0x06ED,
++     0x09A6,0x027F,0x015D,0x1084,0x022E,0x1A5B,0x1685,0x1D1B,0x0054,0x0FB3,
++     0x20CC,0x23A9,0x220B,0x045A,0x1B24,0x2145,0x148B,0x18EC,0x16BC,0x0B9B,
++     0x120C,0x18B0,0x02E3,0x1A1D,0x0BE7,0x133D,0x0DE1,0x21D4,0x0357,0x1715,
++     0x20A2,0x0A18,0x239D,0x22D6,0x0CD5,0x1942,0x16E9,0x0E54,0x1007,0x069D,
++     0x1CB8,0x12DC,0x0381,0x0C93,0x1EFF,0x04E4,0x1C25,0x1FE7,0x20C1,0x0412,
++     0x0215,0x1594,0x1BC5,0x217E,0x221C,0x173A,0x1F19,0x1183,0x0765,0x20F8,
++     0x05F2,0x130A,0x036D,0x012E,0x06EA,0x0B3C,0x1C42,0x1F43,0x0A95,0x1B8C,
++     0x1F36,0x0622,0x04DA,0x2070,0x089E,0x04D4,0x184E,0x1520,0x1CC8,0x127B,
++     0x1302,0x13D0,0x0626,0x0429,0x004A,0x18C0,0x2144,0x0A34,0x1AEA,0x1212,
++     0x12A2,0x06D2,0x0751,0x1D2B,0x104A,0x133A,0x1E80,0x12F6,0x1C9E,0x1460,
++     0x13BA,0x16D9,0x1648,0x1E3A,0x1B29,0x0592,0x11BA,0x1D0E,0x0153,0x0ADB,
++     0x15C3,0x1507,0x17FC,0x122C,0x14D7,0x21AD,0x1A53,0x14F2,0x16DC,0x20F1,
++     0x118E,0x1AAB,0x04EB,0x0606,0x0D05,0x170E,0x05D9,0x0A83,0x10F7,0x070B,
++     0x04F8,0x0B27,0x2224,0x0F97,0x075E,0x180E,0x2194,0x010E,0x0B57,0x1A80,
++     0x1610,0x1B19,0x1BAC,0x0B30,0x0376,0x1697,0x0668,0x00EC,0x1256,0x1F74,
++     0x110D,0x0807,0x03D1,0x1326,0x0577,0x067C,0x1E5C,0x1D6D,0x06F1,0x075C,
++     0x0394,0x0184,0x1E7E,0x12F1,0x0216,0x0990,0x208D,0x1332,0x1044,0x0EF8,
++     0x0F70,0x075D,0x042C,0x030E,0x17CB,0x0AA3,0x04B2,0x1A63,0x04FE,0x097E,
++     0x213D,0x11DF,0x166B,0x0A2E,0x0664,0x0C75,0x21A3,0x102D,0x1F32,0x1D42,
++     0x0A65,0x14BF,0x0B11,0x22B9,0x08AC,0x1394,0x11B7,0x1FAE,0x1CCD,0x1A05,
++     0x177D,0x0D81,0x1E85,0x0D88,0x0A5E,0x0330,0x0EC4,0x13D9,0x1583,0x1CA6,
++     0x2126,0x0F99,0x158F,0x00F9,0x0176,0x1528,0x1C2B,0x1D69,0x049F,0x0418,
++     0x18B4,0x1ACB,0x236F,0x04C5,0x0705,0x0031,0x20B9,0x15B2,0x1FD4,0x18FC,
++     0x1A6E,0x21B1,0x0DEA,0x0432,0x1F1B,0x0CB7,0x2011,0x07CC,0x21FD,0x1216,
++     0x1F51,0x21AB,0x0974,0x0833,0x06F8,0x1935,0x10B4,0x0164,0x1421,0x1A4D,
++     0x1824,0x07DB,0x1551,0x0E53,0x152D,0x23CE,0x0DFE,0x0D51,0x1A6A,0x1E3C,
++     0x20B4,0x1BAA,0x0C62,0x0973,0x01E4,0x0035,0x01D7,0x0496,0x1A73,0x1435,
++     0x2290,0x22F4,0x1E71,0x0F7B,0x066D,0x0874,0x0DB5,0x0F1A,0x0F2D,0x218F,
++     0x17AE,0x0170,0x1BEA,0x1908,0x204A,0x0728,0x0746,0x18B8,0x0242,0x0F17,
++     0x1F8A,0x0B10,0x0966,0x1DD5,0x0174,0x07AE,0x1485,0x146C,0x0975,0x1556,
++     0x1783,0x2021,0x21E7,0x06DB,0x227D,0x19E7,0x22DC,0x2297,0x1FD1,0x1A26,
++     0x07CD,0x233D,0x1B84,0x1E18,0x21CE,0x0EE4,0x2255,0x0862,0x1887,0x057A,
++     0x20C9,0x17F4,0x1BDD,0x2284,0x1817,0x0929,0x0079,0x18F3,0x0E14,0x1131,
++     0x16B8,0x144E,0x120E,0x16BF,0x058B,0x1C9B,0x05D4,0x0E7B,0x07D3,0x1D27,
++     0x1051,0x1E12,0x2157,0x0A89,0x03E0,0x0DC8,0x219B,0x0495,0x04C0,0x090E,
++     0x1914,0x1A13,0x05C4,0x1C0D,0x0564,0x178C,0x2069,0x0291,0x08B5,0x0138,
++     0x1224,0x14C6,0x14C1,0x1AC7,0x0689,0x1E72,0x1751,0x1E0C,0x2270,0x080D,
++     0x1C00,0x03AD,0x1EF8,0x15C9,0x0F28,0x0E40,0x0F9E,0x0344,0x1D58,0x11F5,
++     0x1EAC,0x17A7,0x188D,0x05BA,0x1472,0x154E,0x0017,0x05C7,0x1ACD,0x2370,
++     0x1140,0x2230,0x0F2E,0x1EB2,0x1CA5,0x1B5E,0x1633,0x09B5,0x08B1,0x1B3E,
++     0x0CFE,0x02ED,0x1CEC,0x020F,0x2103,0x13ED,0x0C99,0x07E3,0x00D9,0x1342,
++     0x2179,0x03AA,0x13F5,0x124C,0x1EAB,0x15BA,0x0F41,0x02F6,0x1652,0x057E,
++     0x0157,0x0BE6,0x09AB,0x148D,0x072A,0x1071,0x09B0,0x0500,0x1B65,0x0A6A,
++     0x13A0,0x0F65,0x21BE,0x01FF,0x19B3,0x1CBA,0x109F,0x1EF0,0x0517,0x0307,
++     0x18AC,0x0FD5,0x1FEF,0x0F16,0x197E,0x1291,0x078A,0x1657,0x13C1,0x0E7A,
++     0x1466,0x07BE,0x164E,0x0419,0x2158,0x0FC4,0x0E7D,0x18D9,0x0942,0x0AEF,
++     0x163E,0x2200,0x226D,0x037A,0x1B66,0x0CAF,0x07FB,0x0CEC,0x0D4A,0x0CB6,
++     0x000E,0x1ADE,0x1BD5,0x1892,0x15A1,0x1DD1,0x1DBC,0x01EE,0x12E0,0x0671,
++     0x0ABB,0x1E0E,0x189F,0x1D9D,0x0DF2,0x0008,0x13CB,0x11B8,0x0571,0x00BA,
++     0x0AC3,0x1568,0x070A,0x21B0,0x16EA,0x1000,0x10BF,0x0C8C,0x0AE5,0x186B,
++     0x1366,0x12DF,0x2156,0x0C82,0x05CD,0x0B25,0x08CA,0x1695,0x0FCE,0x055F,
++     0x0D37,0x1748,0x13DB,0x1E43,0x03E7,0x0D8E,0x095E,0x0AF1,0x0103,0x02F4,
++     0x02F8,0x01F6,0x07FD,0x095F,0x1376,0x1643,0x1350,0x1372,0x06E3,0x14D5,
++     0x0870,0x15D9,0x20CD,0x128D,0x1878,0x0FC1,0x0907,0x127C,0x0A2C,0x0041,
++     0x03F4,0x116C,0x02B1,0x1CEA,0x1A18,0x00FB,0x08DE,0x0660,0x06AA,0x23D1,
++     0x0092,0x230C,0x0D91,0x14A3,0x0478,0x0FF7,0x1AF1,0x001A,0x0E69,0x1F5C,
++     0x162C,0x19F8,0x141A,0x1FE6,0x100F,0x047F,0x1DAF,0x231E,0x236C,0x1725,
++     0x108E,0x0290,0x1006,0x0E74,0x1C0A,0x1E35,0x1B90,0x05A7,0x1C21,0x0F1F,
++     0x0514,0x1937,0x22A6,0x0B4A,0x1A3A,0x1217,0x0E50,0x078D,0x2198,0x1B3B,
++     0x1A44,0x0BAB,0x2268,0x16D5,0x03F3,0x06D0,0x0523,0x1D45,0x18DB,0x0BA7,
++     0x1DBA,0x0776,0x1CFA,0x1E13,0x0271,0x200A,0x0D9B,0x0C4B,0x0588,0x0593,
++     0x18E4,0x082A,0x0533,0x1988,0x0317,0x1848,0x0DAB,0x2177,0x1945,0x126B,
++     0x0842,0x07B9,0x1DE1,0x06F3,0x224E,0x0AF0,0x0026,0x0240,0x010F,0x18E7,
++     0x0E51,0x0947,0x1C35,0x1F28,0x1688,0x07A9,0x1759,0x1608,0x1437,0x0B39,
++     0x2009,0x0389,0x0858,0x15BE,0x08A9,0x22D4,0x0EAE,0x015F,0x0337,0x034D,
++     0x23D9,0x081D,0x1D74,0x0C26,0x1BD9,0x0651,0x1F7B,0x2008,0x16B5,0x23A2,
++     0x05E1,0x1325,0x1E20,0x225F,0x0DED,0x101A,0x1254,0x00A8,0x1F1C,0x1F26,
++     0x1C8C,0x0563,0x12D2,0x0821,0x2160,0x115D,0x11EE,0x0232,0x192E,0x1BDF,
++     0x05F3,0x0E57,0x11F3,0x044E,0x20B5,0x1BDE,0x0F25,0x0DBE,0x1361,0x1971,
++     0x17E7,0x0C46,0x16FC,0x1B2E,0x18CB,0x23C4,0x1912,0x214C,0x0BA4,0x2392,
++     0x1037,0x1666,0x0BBB,0x180B,0x041F,0x20FA,0x1577,0x18D7,0x0115,0x0904,
++     0x136E,0x1867,0x0F53,0x0E2B,0x1A02,0x1FB2,0x1A9A,0x1D6C,0x0EBA,0x0BD5,
++     0x09F8,0x083F,0x0227,0x0E89,0x1495,0x1033,0x0F07,0x0D4D,0x0B4D,0x0F6A,
++     0x07FE,0x1AFB,0x05B0,0x1205,0x06CE,0x02D6,0x09DF,0x1A0C,0x0C3E,0x22C9,
++     0x22E5,0x0FEB,0x0A0E,0x21E6,0x088A,0x1C64,0x10B8,0x0383,0x14F8,0x0ED4,
++     0x05B4,0x2188,0x226B,0x025C,0x020D,0x0D0C,0x0449,0x0C81,0x0965,0x1135,
++     0x0CC1,0x08FC,0x16E4,0x1ED1,0x1BBD,0x1BE3,0x06D9,0x00A2,0x04C3,0x0CBF,
++     0x1324,0x2235,0x116A,0x0789,0x0198,0x05C3,0x1181,0x106C,0x1C8F,0x0984,
++     0x1A71,0x05F9,0x1F61,0x1298,0x2310,0x0075,0x063B,0x0B71,0x10C8,0x1E6D,
++     0x08A3,0x045C,0x1157,0x1DCE,0x0A05,0x1AAC,0x03F5,0x0DD1,0x2137,0x1200,
++     0x0CC4,0x17DA,0x1DF7,0x06C5,0x1C07,0x1B59,0x1AD8,0x0C43,0x15A0,0x0EF0,
++     0x0243,0x1BDA,0x1338,0x0C2F,0x132E,0x1D63,0x0969,0x23F3,0x077E,0x0991,
++     0x1DBE,0x23C7,0x05A3,0x1253,0x1FB8,0x1BCE,0x053B,0x1B8F,0x00E3,0x20E2,
++     0x1B61,0x22CE,0x04E8,0x17E1,0x06A3,0x04D1,0x02D3,0x23B1,0x031A,0x2045,
++     0x1319,0x1E7F,0x20CA,0x21E9,0x0C50,0x1E8D,0x209B,0x2306,0x0A1D,0x044B,
++     0x08A1,0x0437,0x102C,0x11F0,0x159B,0x0913,0x0A08,0x1E36,0x128F,0x06FA,
++     0x0DF0,0x160B,0x1F2E,0x094C,0x0788,0x1309,0x1CD4,0x0599,0x179F,0x0F54,
++     0x1362,0x1763,0x1B6C,0x0302,0x0921,0x231D,0x13F1,0x09C3,0x1348,0x12E1,
++     0x00FA,0x1689,0x16BE,0x18AB,0x1604,0x19F1,0x21BA,0x0D6A,0x20FC,0x21D2,
++     0x21ED,0x0663,0x0421,0x0D92,0x061A,0x165F,0x1D92,0x152E,0x070C,0x12A8,
++     0x1C90,0x0951,0x0CE5,0x1D39,0x0B75,0x168B,0x0A61,0x23B4,0x1572,0x1E06,
++     0x1AF9,0x0F5A,0x00CC,0x2139,0x0114,0x18FA,0x1654,0x18A9,0x0B13,0x0AF8,
++     0x14E4,0x051C,0x098A,0x1C9C,0x0554,0x1BBE,0x0DE5,0x198E,0x1BBB,0x0BCD,
++     0x0511,0x0E22,0x1D95,0x0C11,0x14E2,0x0108,0x1A56,0x0401,0x11B0,0x00C6,
++     0x2165,0x0F64,0x17BF,0x0154,0x0B95,0x14A5,0x0CC8,0x1B8E,0x1D7A,0x024F,
++     0x1762,0x1F71,0x1501,0x1844,0x15C2,0x010D,0x1092,0x0060,0x00AF,0x154D,
++     0x0DA5,0x0DB8,0x196E,0x1EE5,0x035E,0x05D3,0x00FC,0x0BCB,0x0364,0x0CAB,
++     0x16A3,0x23A7,0x014B,0x1536,0x0550,0x0407,0x127A,0x0A9E,0x1D64,0x0FD8,
++     0x14D2,0x0701,0x17DC,0x0BC0,0x1BA7,0x2141,0x0CFF,0x1B31,0x0205,0x22A7,
++     0x0C5E,0x1A09,0x11DE,0x13CE,0x08F3,0x208F,0x0015,0x2037,0x0AAF,0x057D,
++     0x0087,0x0AFB,0x1A85,0x1A97,0x0FD7,0x12D9,0x1FED,0x1DE2,0x197F,0x22B1,
++     0x205A,0x0544,0x0AD0,0x01DF,0x1E64,0x0AEB,0x12A6,0x0F30,0x07F1,0x1BF0,
++     0x230A,0x0573,0x0F61,0x2386,0x1242,0x1C55,0x0DA4,0x0F43,0x22AE,0x0CC6,
++     0x1BB5,0x0CDC,0x16A0,0x02FE,0x053F,0x008C,0x18E8,0x02CE,0x0C17,0x1B71,
++     0x1494,0x15F0,0x0D5B,0x089C,0x0F21,0x0A87,0x10CB,0x1EEB,0x1A2D,0x1F38,
++     0x0508,0x1C13,0x09D6,0x1B83,0x03C7,0x177B,0x0BA0,0x0760,0x00A7,0x07B8,
++     0x0F3F,0x0070,0x163B,0x0718,0x1609,0x2313,0x1058,0x10A1,0x0DA2,0x1BD8,
++     0x19D3,0x203D,0x09AA,0x0F0C,0x0A4D,0x22AD,0x0E9B,0x07A8,0x14F1,0x1056,
++     0x1E74,0x0402,0x0D40,0x0D6C,0x021E,0x1756,0x0056,0x0EB1,0x0E1C,0x0206,
++     0x0C94,0x2326,0x1F31,0x23CD,0x1BBF,0x0BB6,0x0607,0x0E0E,0x13B9,0x1724,
++     0x03F1,0x1BCC,0x01F1,0x1624,0x129F,0x1A6D,0x22E0,0x1132,0x1AE5,0x1B69,
++     0x00F1,0x225E,0x1E28,0x05EA,0x0F8E,0x024B,0x108F,0x0A3E,0x135D,0x0C73,
++     0x18D3,0x1BDC,0x1E8B,0x0BAA,0x1D09,0x0305,0x22E2,0x1D7D,0x012B,0x2164,
++     0x156F,0x0069,0x1333,0x206D,0x04F2,0x1982,0x141D,0x023D,0x0144,0x1EA0,
++     0x2378,0x1486,0x0EC5,0x1677,0x0770,0x06B4,0x04F6,0x09BC,0x1704,0x1DEF,
++     0x1FAF,0x22D5,0x1A34,0x21C0,0x099D,0x1BD7,0x1C47,0x1A4B,0x195E,0x0569,
++     0x10E5,0x0BAE,0x01A4,0x220C,0x0BB9,0x1700};
++ 
++ #define MX_MTBL		(sizeof(mekornd) / sizeof(unsigned short))
++ 
++ typedef struct { int n; unsigned short int r; } MKT;
++ 
++ static int comp_mt(const void *s, const void *d)
++ {
++     MKT *mt1 = (MKT *)s;
++     MKT *mt2 = (MKT *)d;
++     return (int)(short)(mt1->r - mt2->r);
++ }
++ 
++ MKT *calcMEKO(int n)
++ {
++     int i;
++     MKT *mt;
++ 
++     if(n <= 0 || n > MX_MTBL){
++ 	    ErrPopUp ("Error:  Over max array.", "\nOk");
++ 	    return(NULL);
++     }
++ 
++     mt = malloc(sizeof(MKT) * n);
++ 
++     if(!mt) {
++ 	    ErrPopUp ("Error:  No memory.", "\nOk");
++ 	    return(NULL);
++     }
++ 
++     for(i = 0; i < n; i++) {
++         mt[i].r = mekornd[i];
++         mt[i].n = i + 1;
++     }
++     qsort(mt, n, sizeof(MKT), comp_mt);
++     return(mt);
++ }
diff -Naur xv-3.10a.old/bggen.c xv-3.10a/bggen.c
--- xv-3.10a.old/bggen.c	Fri Dec 23 07:34:41 1994
+++ xv-3.10a/bggen.c	Tue Apr 24 09:37:05 2001
@@ -29,7 +29,7 @@
 #define MAXCOLS  128
 
 /* some VMS thing... */
-#ifdef vax11c
+#if defined(vax11c) || (defined(__sony_news) && (defined(bsd43) || defined(__bsd43) || defined(SYSTYPE_BSD) || defined(__SYSTYPE_BSD)))
 #include <ctype.h>
 #endif
 
diff -Naur xv-3.10a.old/bits/br_bzip2 xv-3.10a/bits/br_bzip2
--- xv-3.10a.old/bits/br_bzip2	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_bzip2	Tue Apr 24 09:37:06 2001
@@ -0,0 +1,27 @@
+#define br_bzip2_width 48
+#define br_bzip2_height 48
+static unsigned char br_bzip2_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x7c, 0xbe, 0x3d, 0x0e, 0x02, 0x20, 0xfc, 0xbe, 0x7d, 0x1f, 0x02,
+   0x20, 0xcc, 0xb0, 0x6d, 0x1b, 0x02, 0x20, 0xcc, 0x98, 0x6d, 0x1b, 0x02,
+   0x20, 0xfc, 0x98, 0x6d, 0x18, 0x02, 0x20, 0x7c, 0x8c, 0x7d, 0x0c, 0x02,
+   0x20, 0xcc, 0x8c, 0x3d, 0x0e, 0x02, 0x20, 0xcc, 0x84, 0x0d, 0x06, 0x02,
+   0x20, 0xcc, 0x86, 0x0d, 0x03, 0x02, 0x20, 0xfc, 0xbe, 0x0d, 0x1f, 0x02,
+   0x20, 0x7c, 0xbe, 0x0d, 0x1f, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_mag xv-3.10a/bits/br_mag
--- xv-3.10a.old/bits/br_mag	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_mag	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_mag_width 48
+#define br_mag_height 48
+static unsigned char br_mag_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x0c, 0x86, 0xc1, 0x0f, 0x02,
+   0x20, 0x0c, 0xc6, 0xe3, 0x1f, 0x02, 0x20, 0x1c, 0xe7, 0x67, 0x18, 0x02,
+   0x20, 0x1c, 0x77, 0x6e, 0x18, 0x02, 0x20, 0xbc, 0x37, 0x6c, 0x00, 0x02,
+   0x20, 0xbc, 0x37, 0x6c, 0x00, 0x02, 0x20, 0xec, 0x36, 0x6c, 0x1e, 0x02,
+   0x20, 0xec, 0xf6, 0x6f, 0x1e, 0x02, 0x20, 0x4c, 0xf6, 0x6f, 0x18, 0x02,
+   0x20, 0x4c, 0x36, 0x6c, 0x18, 0x02, 0x20, 0x0c, 0x36, 0x6c, 0x18, 0x02,
+   0x20, 0x0c, 0x36, 0xec, 0x1f, 0x02, 0x20, 0x0c, 0x36, 0xcc, 0x0f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_maki xv-3.10a/bits/br_maki
--- xv-3.10a.old/bits/br_maki	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_maki	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_maki_width 48
+#define br_maki_height 48
+static unsigned char br_maki_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x83, 0x61, 0x18, 0x33, 0x02,
+   0x20, 0x83, 0xf1, 0x98, 0x33, 0x02, 0x20, 0xc7, 0xf9, 0x99, 0x31, 0x02,
+   0x20, 0xc7, 0x9d, 0xdb, 0x30, 0x02, 0x20, 0xef, 0x0d, 0xfb, 0x30, 0x02,
+   0x20, 0xef, 0x0d, 0x7b, 0x30, 0x02, 0x20, 0xbb, 0x0d, 0x7b, 0x30, 0x02,
+   0x20, 0xbb, 0xfd, 0xdb, 0x30, 0x02, 0x20, 0x93, 0xfd, 0xdb, 0x30, 0x02,
+   0x20, 0x93, 0x0d, 0x9b, 0x31, 0x02, 0x20, 0x83, 0x0d, 0x9b, 0x31, 0x02,
+   0x20, 0x83, 0x0d, 0x1b, 0x33, 0x02, 0x20, 0x83, 0x0d, 0x1b, 0x33, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_mgcsfx xv-3.10a/bits/br_mgcsfx
--- xv-3.10a.old/bits/br_mgcsfx	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_mgcsfx	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_mgcsfx_width 48
+#define br_mgcsfx_height 48
+static unsigned char br_mgcsfx_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x3c, 0xcf, 0x71, 0x00, 0x02,
+   0x20, 0x6c, 0x61, 0xda, 0x00, 0x02, 0x20, 0x6c, 0x67, 0xd8, 0x1e, 0x02,
+   0x20, 0x3c, 0x61, 0xd8, 0x1e, 0x02, 0x20, 0x6c, 0x61, 0xda, 0x00, 0x02,
+   0x20, 0x6c, 0xcf, 0x71, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x4e, 0x7a, 0xef, 0x3d, 0x02, 0x20, 0xd3, 0x32, 0x68, 0x6c, 0x02,
+   0x20, 0xc3, 0x32, 0xe4, 0x6c, 0x02, 0x20, 0x5b, 0x33, 0x62, 0x6c, 0x02,
+   0x20, 0x53, 0x33, 0x61, 0x6c, 0x02, 0x20, 0x4e, 0x7a, 0xef, 0x3d, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_pcd xv-3.10a/bits/br_pcd
--- xv-3.10a.old/bits/br_pcd	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_pcd	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_pcd_width 48
+#define br_pcd_height 48
+static unsigned char br_pcd_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x37, 0x00, 0xc0, 0x1c, 0x02,
+   0x20, 0x3f, 0x00, 0xe0, 0x3d, 0x02, 0x20, 0x3b, 0x00, 0x60, 0x2d, 0x02,
+   0x20, 0x3b, 0x60, 0x60, 0x2c, 0x02, 0x20, 0x3b, 0x60, 0x60, 0x2c, 0x02,
+   0x20, 0x7b, 0xf6, 0x66, 0x2c, 0x02, 0x20, 0xff, 0xff, 0x6f, 0x2c, 0x02,
+   0x20, 0xb7, 0x6b, 0x6b, 0x2c, 0x02, 0x20, 0xb3, 0x6b, 0x6b, 0x2c, 0x02,
+   0x20, 0xb3, 0x6b, 0x6b, 0x2c, 0x02, 0x20, 0xb3, 0x6b, 0x6b, 0x2d, 0x02,
+   0x20, 0xb3, 0xef, 0xef, 0x3d, 0x02, 0x20, 0xb3, 0xc6, 0xc6, 0x1c, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_pi xv-3.10a/bits/br_pi
--- xv-3.10a.old/bits/br_pi	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_pi	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_pi_width 48
+#define br_pi_height 48
+static unsigned char br_pi_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x80, 0x1f, 0x7e, 0x00, 0x02,
+   0x20, 0x80, 0x3f, 0x7e, 0x00, 0x02, 0x20, 0x80, 0x31, 0x18, 0x00, 0x02,
+   0x20, 0x80, 0x31, 0x18, 0x00, 0x02, 0x20, 0x80, 0x31, 0x18, 0x00, 0x02,
+   0x20, 0x80, 0x39, 0x18, 0x00, 0x02, 0x20, 0x80, 0x1f, 0x18, 0x00, 0x02,
+   0x20, 0x80, 0x0f, 0x18, 0x00, 0x02, 0x20, 0x80, 0x01, 0x18, 0x00, 0x02,
+   0x20, 0x80, 0x01, 0x18, 0x00, 0x02, 0x20, 0x80, 0x01, 0x18, 0x00, 0x02,
+   0x20, 0x80, 0x01, 0x7e, 0x00, 0x02, 0x20, 0x80, 0x01, 0x7e, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_pic xv-3.10a/bits/br_pic
--- xv-3.10a.old/bits/br_pic	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_pic	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_pic_width 48
+#define br_pic_height 48
+static unsigned char br_pic_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xf0, 0xf3, 0xf3, 0x01, 0x02,
+   0x20, 0xf0, 0xf7, 0xfb, 0x03, 0x02, 0x20, 0x30, 0xc6, 0x18, 0x03, 0x02,
+   0x20, 0x30, 0xc6, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc6, 0x18, 0x00, 0x02,
+   0x20, 0x30, 0xc7, 0x18, 0x00, 0x02, 0x20, 0xf0, 0xc3, 0x18, 0x00, 0x02,
+   0x20, 0xf0, 0xc1, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc0, 0x18, 0x00, 0x02,
+   0x20, 0x30, 0xc0, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc0, 0x18, 0x03, 0x02,
+   0x20, 0x30, 0xf0, 0xfb, 0x03, 0x02, 0x20, 0x30, 0xf0, 0xf3, 0x01, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_pic2 xv-3.10a/bits/br_pic2
--- xv-3.10a.old/bits/br_pic2	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_pic2	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,27 @@
+#define br_pic2_width 48
+#define br_pic2_height 48
+static unsigned char br_pic2_bits[] = {
+   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x3f, 0x3f, 0x1f, 0x1f, 0x02,
+   0x20, 0x7f, 0xbf, 0xbf, 0x3f, 0x02, 0x20, 0x63, 0x8c, 0xb1, 0x31, 0x02,
+   0x20, 0x63, 0x8c, 0x01, 0x30, 0x02, 0x20, 0x63, 0x8c, 0x01, 0x30, 0x02,
+   0x20, 0x73, 0x8c, 0x01, 0x30, 0x02, 0x20, 0x3f, 0x8c, 0x01, 0x18, 0x02,
+   0x20, 0x1f, 0x8c, 0x01, 0x0c, 0x02, 0x20, 0x03, 0x8c, 0x01, 0x06, 0x02,
+   0x20, 0x03, 0x8c, 0x01, 0x03, 0x02, 0x20, 0x03, 0x8c, 0xb1, 0x01, 0x02,
+   0x20, 0x03, 0xbf, 0xbf, 0x3f, 0x02, 0x20, 0x03, 0x3f, 0x9f, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
diff -Naur xv-3.10a.old/bits/br_png xv-3.10a/bits/br_png
--- xv-3.10a.old/bits/br_png	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/br_png	Tue Apr 24 09:37:06 2001
@@ -0,0 +1,28 @@
+#define br_png_width 48
+#define br_png_height 48
+static unsigned char br_png_bits[] = {
+  0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
+  0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
+  0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
+  0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
+  0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0xf8, 0x19, 0xc3, 0x07, 0x02, 0x20, 0x18, 0x3b, 0x63, 0x0c, 0x02,
+  0x20, 0x18, 0x3b, 0x33, 0x00, 0x02, 0x20, 0x18, 0x5b, 0x33, 0x00, 0x02,
+  0x20, 0xf8, 0x59, 0x33, 0x0f, 0x02, 0x20, 0x18, 0x98, 0x33, 0x0c, 0x02,
+  0x20, 0x18, 0x98, 0x33, 0x0c, 0x02, 0x20, 0x18, 0x18, 0x63, 0x0c, 0x02,
+  0x20, 0x18, 0x18, 0xc3, 0x0b, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03,
+  };
diff -Naur xv-3.10a.old/bits/xv_jpext xv-3.10a/bits/xv_jpext
--- xv-3.10a.old/bits/xv_jpext	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/xv_jpext	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,29 @@
+#define xv_jpext_width 111
+#define xv_jpext_height 22
+static unsigned char xv_jpext_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00,
+   0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+   0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x01, 0x23, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4e, 0xe3, 0x64,
+   0x18, 0x0f, 0x06, 0x81, 0xd2, 0x03, 0x93, 0x79, 0xe2, 0x64, 0x20, 0xd1,
+   0x14, 0x5d, 0xa6, 0x8c, 0x09, 0x1f, 0x0c, 0xc1, 0x74, 0x65, 0x12, 0x5d,
+   0x20, 0x5c, 0xc4, 0x45, 0x9e, 0x92, 0x07, 0x01, 0x04, 0xc1, 0x13, 0x95,
+   0x0a, 0x45, 0x20, 0x53, 0x32, 0x45, 0x01, 0x51, 0x00, 0x01, 0x06, 0x29,
+   0x10, 0x89, 0x0a, 0x45, 0xa1, 0x58, 0x8a, 0x45, 0x31, 0x48, 0x0c, 0x01,
+   0x25, 0x25, 0x16, 0x41, 0x8a, 0x44, 0x11, 0xd7, 0x71, 0x45, 0x8e, 0x87,
+   0x03, 0xbf, 0x18, 0xc3, 0x11, 0x3d, 0x72, 0x44, 0x0e, 0x40, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -Naur xv-3.10a.old/bits/xv_jprev xv-3.10a/bits/xv_jprev
--- xv-3.10a.old/bits/xv_jprev	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/bits/xv_jprev	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,22 @@
+#define xv_jprev_width 78
+#define xv_jprev_height 22
+static unsigned char xv_jprev_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00,
+   0x20, 0x40, 0x00, 0x00, 0x7c, 0xf0, 0x83, 0x1f, 0x23, 0x00, 0x20, 0x40,
+   0x00, 0x00, 0x02, 0x10, 0x81, 0x08, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x02, 0x80, 0x00, 0x04, 0x07, 0x4c, 0x28, 0x4f, 0x9c, 0x0c, 0x7a, 0x80,
+   0x03, 0x1c, 0x03, 0x53, 0xa4, 0x4c, 0xa2, 0x0b, 0x86, 0x60, 0x04, 0x23,
+   0x05, 0x8f, 0xa2, 0x52, 0xa1, 0x08, 0x80, 0x00, 0x04, 0x20, 0x89, 0x80,
+   0x22, 0x51, 0xa1, 0x08, 0x80, 0x08, 0x44, 0x20, 0xb1, 0x18, 0x21, 0x48,
+   0x91, 0x08, 0x61, 0x0a, 0x53, 0x18, 0x41, 0x07, 0xa1, 0x47, 0x8e, 0x08,
+   0x1e, 0xf2, 0x90, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00};
diff -Naur xv-3.10a.old/config.h xv-3.10a/config.h
--- xv-3.10a.old/config.h	Fri Jan  6 03:49:21 1995
+++ xv-3.10a/config.h	Tue Apr 24 09:37:06 2001
@@ -13,13 +13,25 @@
  * definition appropriately. (use 'which gunzip' to find if you have gunzip, 
  * and where it lives)
  */
-#undef USE_GUNZIP
+#define USE_GUNZIP
 
 #ifdef USE_GUNZIP
 #  ifdef VMS
 #    define GUNZIP "UNCOMPRESS"
 #  else
-#    define GUNZIP "/usr/local/bin/gunzip -q"
+#    if defined(__FreeBSD__) || defined(__NetBSD__)
+#      define GUNZIP "/usr/bin/gunzip -q" 
+#    else
+#      if defined(__APPLE__)
+#        define GUNZIP "FINKINSTALLPREFIX/bin/gunzip -q"
+#      else
+#        if defined(__linux__)
+#          define GUNZIP "/bin/gunzip -q"
+#        else
+#          define GUNZIP "/usr/local/bin/gunzip -q"
+#        endif
+#      endif
+#    endif
 #  endif
 #endif
 
@@ -37,7 +45,14 @@
  */
 #define UNCOMPRESS "/usr/ucb/uncompress"
 
-#if defined(hpux) || defined(SVR4) || defined(__386BSD__)
+#if defined(hpux) || defined(SVR4) || \
+    defined(__386BSD__) || defined(__FreeBSD__) || defined(__NetBSD__) || \
+    defined(__linux__)
+    /* 
+     I want to use BSD macro for checking if this OS is *BSD or not,
+     but the macro is defined in <sys/parm.h>, which I don't know all
+     machine has or not.
+     */
 #  undef  UNCOMPRESS
 #  define UNCOMPRESS "/usr/bin/uncompress"
 #endif
@@ -65,6 +80,11 @@
 #  define UNCOMPRESS GUNZIP
 #endif
 
+#define USE_BUNZIP2
+
+#ifdef USE_BUNZIP2
+#  define BUNZIP2 "FINKINSTALLPREFIX/bin/bunzip2"
+#endif
 
 /***************************************************************************
  * PostScript file input support:
@@ -88,9 +108,9 @@
  * should not need to be changed
  */
 
-/* #define GS_PATH "/usr/local/bin/gs" */
-/* #define GS_LIB  "."                 */
-/* #define GS_DEV  "ppmraw"            */
+#define GS_PATH "FINKINSTALLPREFIX/bin/gs"
+#define GS_LIB  "."               
+#define GS_DEV  "ppmraw"         
 
 
 /***************************************************************************
@@ -119,3 +139,196 @@
 
 #define BACKING_STORE
 
+
+/***************************************************************************
+ * MAG/PIC/MAKI/Pi/PIC2/PhotoCD format Support:
+ * 
+ * if, for whatever reason, you're unable to get the
+ * MAG/PIC/MAKI/Pi/PIC2/PhotoCD support to compile, *COMMENT OUT* the
+ * following apropriate line(s).
+ */
+
+#define HAVE_MAG
+#define HAVE_PIC
+#define HAVE_MAKI
+#define HAVE_PI
+#define HAVE_PIC2
+#define HAVE_PCD
+
+
+/***************************************************************************
+ * MacBinary file support:
+ *
+ * if you want XV to be able to handle ``MacBinary'' files (which have
+ * 128 byte info file header at the head), change 'undef' to 'define'
+ * in the following line.
+ */
+
+#define MACBINARY
+
+
+/***************************************************************************
+ * Auto Expand support:
+ *
+ * if you want to extract archived file automatically and regard it as
+ * a directory, change 'undef' to 'define' in the AUTO_EXPAND line.
+ *
+ * Virtual Thumbdir support:
+ *
+ * if you want Virtual directory based Thumbdir(It means that XV
+ * does't forget builded Icons still be quited even if the directory
+ * is read-only), change 'undef' to 'define' the VIRTUAL_TD line.
+ */
+
+#define AUTO_EXPAND
+#define VIRTUAL_TD
+
+#if !defined(AUTO_EXPAND) && defined(VIRTUAL_TD)
+#  undef VIRTUAL_TD
+#endif
+
+
+/***************************************************************************
+ * Adjust the aspect ratio of Icons:
+ *
+ * if you want to adjust the aspect ratio of Icons in Visual
+ * Shunauzer, change 'undef' to 'define' in the following line.
+ */
+
+#undef VS_ADJUST
+
+
+/***************************************************************************
+ * Restore original colormap:
+ *
+ * if you want to restore original colormap when icons in Visual
+ * Shunauzer is double-clicked, change 'undef' to 'define' in the
+ * following line.
+ */
+
+#undef VS_RESCMAP
+
+
+/***************************************************************************
+ * TextViewer l10n support:
+ *
+ * if you want XV to show the text in Japanese on TextViewer, change
+ * 'undef' to 'define' in the following line.
+ */
+
+#undef TV_L10N
+
+#ifdef TV_L10N
+/*
+ * if you want to change the default code-set used in case that XV
+ * fails to select correct code-set, uncomment the '#define
+ * LOCALE_DEFAULT' line and change the 'LOCALE_DEFAULT' definition
+ * appropriately.
+ * (0:ASCII, 1:EUC-j, 2:JIS, 3:MS Kanji) */
+
+/* #  define LOCALE_DEFAULT 0 */
+
+/*
+ * Uncomment and edit the following lines, if your X Window System was
+ * not compiled with -DX_LOCALE and you failed to display the Japanese
+ * text in TextViewer.  You don't have to write locale name of JIS code-set
+ * and MicroSoft code-set, if your system doesn't support those code-sets.
+ */
+
+/*
+#  define LOCALE_NAME_EUC     "ja_JP.eucjp"
+#  define LOCALE_NAME_JIS     "ja_JP.JIS"
+#  define LOCALE_NAME_MSCODE  "ja_JP.SJIS"
+*/
+
+/*
+ * if your system doesn't have the Japanese fonts in the sizes,
+ * Uncomment and edit the following font size entries.
+ */
+
+/* #  define TV_FONTSIZE 14,16,24 */
+
+/*
+ * If you need, uncomment and modify the following font name.
+ */
+
+/* #  define TV_FONTSET "-*-fixed-medium-r-normal--%d-*" */
+#endif /* TV_L10N */
+
+
+/***************************************************************************
+ * User definable filter support:
+ *
+ * Use the filters as input and output method for load and save unsupported
+ * image format file. The filter command is recognized by definition of 
+ * magic number or suffix in "~/.xv_mgcsfx" .
+ * To enable this feature, change 'undef' to 'define' in the following line.
+ */
+#undef HAVE_MGCSFX
+
+#ifdef HAVE_MGCSFX
+/*
+ * Support symbol 'auto' as <input image type> in startup file. This type
+ * is not use pipe as input, but write to temporary and recognize by xv 
+ * processing.
+ */
+#define HAVE_MGCSFX_AUTO
+
+/*
+ * The startup file of definition for MgcSfx. 'MGCSFX_SITE_RC' is read
+ * first and '~/MGCSFX_RC' is second. So same definitions in both files
+ * are overrided by '~/MGCSFX_RC'
+ * To define startup file, see the sample of startup file 'xv_mgcsfx.sample'.
+ */
+#  define MGCSFX_SITE_RC  "xv_mgcsfx"
+#  define MGCSFX_RC       ".xv_mgcsfx"
+
+/*
+ * If you want startup file to pass preprocessor in reading time, then
+ * change 'undef' to 'define' in the following line.
+ *
+ * WARNING : If you decide to use preprocessor, you must not write
+ *           '# <comment>' style comment in startup file. Because,
+ *           preprocessor can't recognize.  */
+#  undef USE_MGCSFX_PREPROCESSOR
+
+#  ifdef USE_MGCSFX_PREPROCESSOR
+/*
+ * This is used like "system("MGCSFX_PREPROCESSOR MGCSFX_RC > tmp_name");",
+ * and read tmp_name instead of MGCSFX_RC.
+ */
+#    define MGCSFX_PREPROCESSOR "/usr/lib/cpp"
+/* #    define MGCSFX_PREPROCESSOR "cc -E" */
+
+#  endif /* USE_MGCSFX_PREPROCESSOR */
+
+/*
+ * Default string of command. If input command is required for undefined file,
+ * dialog is popuped with 'MGCSFX_DEFAULT_INPUT_COMMAND'. And, if output
+ * command is required in save dialog of MgcSfx, dialog is popuped with
+ * 'MGCSFX_DEFAULT_OUTPUT_COMMAND'.
+ *
+ * WARNING : Now, supported only 'PNM' image format, when command input is
+ *           required. You should define filter which use 'PNM' image format
+ *           as input or output.
+ */
+#  define MGCSFX_DEFAULT_INPUT_COMMAND  "tifftopnm"
+#  define MGCSFX_DEFAULT_OUTPUT_COMMAND "pnmtotiff"
+
+#endif /* HAVE_MGCSFX */
+
+
+/***************************************************************************
+ * Multi-Lingual TextViewer
+ *
+ * if you want XV to show the text in multi-lingual on TextViewer, change
+ * 'undef' to 'define' in the following line.
+ */
+
+#define TV_MULTILINGUAL
+
+#define TV_DEFAULT_CODESET TV_EUC_JAPAN
+
+#ifdef TV_MULTILINGUAL
+# undef TV_L10N
+#endif
diff -Naur xv-3.10a.old/vdcomp.c xv-3.10a/vdcomp.c
--- xv-3.10a.old/vdcomp.c	Fri Dec 23 07:34:47 1994
+++ xv-3.10a/vdcomp.c	Tue Apr 24 09:37:05 2001
@@ -96,6 +96,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+#define NeXT
+
 /* include a malloc.h, of some sort... */
 #ifndef VMS   /* VMS hates multi-line '#if's */
 # if !defined(ibm032)                    && \
@@ -106,14 +106,25 @@
      !defined(pyr)                       && \
      !defined(__UMAXV__)                 && \
      !defined(bsd43)                     && \
+     !defined(__bsd43)                   && \
      !defined(aux)                       && \
      !defined(__bsdi__)                  && \
      !defined(sequent)

 #  if defined(hp300) || defined(hp800) || defined(NeXT)
+#   if defined(__APPLE__)
+#     include <sys/types.h>               /* Because malloc uses u_short on Mac OS X */
+#   endif
 #   include <sys/malloc.h>                /* it's in 'sys' on HPs and NeXT */
 #  else
-#   include <malloc.h>
+#   if !defined(__386BSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
+    /* 
+     I want to use BSD macro for checking if this OS is *BSD or not,
+     but the macro is defined in <sys/parm.h>, which I don't know all
+     machine has or not.
+     */
+#     include <malloc.h>
+#   endif
 #  endif
 # endif
 #endif /* !VMS */
diff -Naur xv-3.10a.old/xcmap.c xv-3.10a/xcmap.c
--- xv-3.10a.old/xcmap.c	Wed Jan  4 06:14:52 1995
+++ xv-3.10a/xcmap.c	Tue Apr 24 09:37:06 2001
@@ -140,8 +140,13 @@
     nxcells = nycells = 8;
   else if (dispcells>4)
     nxcells = nycells = 4;
-  else
+  else if (dispcells>2)
     nxcells = nycells = 2;
+  else
+  {
+    nxcells = 2;
+    nycells = 1;
+  }
   
   /**************** Create/Open X Resources ***************/
   if ((mfinfo = XLoadQueryFont(theDisp,FONT))==NULL) {
@@ -267,18 +272,25 @@
   
   x=y=w=h=1;
   i=XParseGeometry(geom,&x,&y,&w,&h);
-  if (i&WidthValue)  WIDE = (int) w;
-  if (i&HeightValue) HIGH = (int) h;
-  
-  if (i&XValue || i&YValue) hints.flags = USPosition;  
-  else hints.flags = PPosition;
-  
-  hints.flags |= USSize;
-  
-  if (i&XValue && i&XNegative) 
-    x = XDisplayWidth(theDisp,theScreen)-WIDE-abs(x);
-  if (i&YValue && i&YNegative) 
-    y = XDisplayHeight(theDisp,theScreen)-HIGH-abs(y);
+  if (i&WidthValue)
+  {
+    WIDE = (int) w;
+    hints.flags |= USSize;
+  }
+  if (i&HeightValue)
+  {
+    HIGH = (int) h;
+    hints.flags |= USSize;
+  }
+  
+  if (i&XValue || i&YValue)
+  {
+    if (i&XNegative) 
+      x = XDisplayWidth(theDisp,theScreen)-WIDE-abs(x);
+    if (i&YNegative) 
+      y = XDisplayHeight(theDisp,theScreen)-HIGH-abs(y);
+    hints.flags |= USPosition;  
+  }
   
   hints.x=x;             hints.y=y;
   hints.width  = WIDE;   hints.height = HIGH;
diff -Naur xv-3.10a.old/xv-jp-extension/CHANGELOG.jp-ext xv-3.10a/xv-jp-extension/CHANGELOG.jp-ext
--- xv-3.10a.old/xv-jp-extension/CHANGELOG.jp-ext	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/CHANGELOG.jp-ext	Thu Nov 21 16:43:56 1996
@@ -0,0 +1,444 @@
+Thu Nov 21 16:55:05 JST 1996	rev5.3.3
+	* Visual Shunauzer $B$G(B, $B%U%!%$%k$r%/%j%C%/$7$?$H$-$K%a%$%s%&%#(B
+	  $B%s%I%&$N%+%i!<%^%C%W$r%$%s%9%H!<%k$9$k3HD%$r2C$($?(B.
+	* xvml.c $B$G(B, xv.codeSet $B$r8+$k$h$&$K$7$?(B.
+	* TV_MULTILINGUAL $B$r(B define $B$7$J$$;~(B, $B%3%s%Q%$%k$G$-$J$+$C$?$N(B
+	  $B$r=$@5(B.
+	* xvml.c $B$G(B, malloc $B$N4IM}NN0h$rGK2u$7$F$$$?$+$b$7$l$J$$%P%0$r(B
+	  $B%U%#%C%/%9(B.
+	* xvml.c $B$G(B, $B2~9T$N07$$$K4X$7$F(B, $B?7$7$$%Q%M%k$r:n$k$3$H$GBP=h(B
+	  $B$7$F$_$?(B.
+
+Mon Oct  7 20:27:57 JST 1996	rev5.3.2
+	* Warning $B$r>C$9$?$a$K(B, $BB?$/$N%=!<%9$G%-%c%9%H$r9T$C$?(B.
+	* xvmag.c, xvmaki.c, xvpi.c, xvpic.c $B$G(B, Pad $B5!G=$rMQ$$$?$H$-(B
+	  $B$K(B, $B%;%0%a%s%F!<%7%g%s%U%)!<%k%H$,5/$3$k%P%0$r%U%#%C%/%9(B.
+	* xv.h $B$K(B, RedHat-2.0(linux-2.0.21) + libc-5.3.12 $B$G(B, $B%3%s%Q%$(B
+	  $B%k%(%i!<$,5/$3$k$N$KBP=h$9$k%3!<%I$rDI2C(B.
+	* xvml.c $B$N(B, strdup $B$G5/$3$k(B Warning $B$r=P$J$$$h$&$K$7$?(B.
+	* $B0J2<(B, Multilingual TextViewer $B$NJQ99(B.
+	* $B5!<o4V$N2~9T%3!<%I$NAj0cLdBj$r2r7h$9$k$?$a$N=`Hw$r$7$?(B.
+	* $BD92a$.$k9T$OI=<($K<:GT$9$k$N$G(B, $BESCf$G@Z$jMn$H$9$h$&$K$7$?(B.
+	* ShiftJIS $B"*(B ISO-2022 $B$NJQ49Cf$N(B CR/LF $B"*(B LF $B$NJQ49$r$d$a$?(B.
+
+Thu Mar 28 21:31:32 JST 1996	rev5.3.1
+
+	* MultiLingual TextViewer $B$N(B, $B%U%)%s%H$N8!:w5!9=$rJQ99$7$?(B.
+	* #ifdef TV_MULTILINGUAL $B$,H4$1$F$$$k8D=j$,$"$C$?(B.
+	* Warning $B$r=P$J$$$h$&$K$7$?(B.
+	* MultiLingual TextViewer $B$G(B, $B%U%!%$%kFI$_9~$_;~$H(B, $B%3%a%s%HFI(B
+	  $B$_9~$_;~$NJ8Kv=hM}$r85$KLa$7$?(B.
+	* xvml.c, xvtext.c $B$N%=!<%9$N@0M}(B.
+	* MultiLingual TextViewer $B$G(B, $B%j%=!<%9$H$7$F(B, xv.tabWidth $B$r;X(B
+	  $BDj$G$-$k$h$&$K$7$?(B.
+
+Tue Mar  5 16:24:45 JST 1996	rev5.3.0
+
+	* $B0J2<(B, MultiLingual TextViewer $B$NJQ99(B.
+	* SJIS $B%b!<%I$GD9$5$,(B 0 $B$N%F%-%9%H$N>l9g$@$1FC<l=hM}$r$9$k$h$&(B
+	  $B$K$7$?(B.
+	* $B%U%!%$%kFI$_9~$_;~$H(B, $B%3%a%s%HFI$_9~$_;~$NJ8Kv=hM}$NIT@09g$K(B
+	  $BBP$9$k=$@5(B.
+	* $B%3%a%s%H$,$J$$;~$KA0$N%3%a%s%H$,$=$N$^$^I=<($5$l$F$$$?$N$r=$(B
+	  $B@5(B.
+	* Code Set $B$N%a%K%e!<$rBgI}$KJQ99(B/$BDI2C(B.
+	* Shift JIS $B$r%5%]!<%H(B.
+	* Expose $B%$%Y%s%H$r<u$1$?;~$K(B, $B%F%-%9%H$,>C$($k$3$H$,$"$k$N$r(B
+	  $B=$@5(B.
+	* resize $B;~$K$*$+$7$/$J$k$3$H$,$"$k$N$r=$@5(B.
+	* Ascii$B"*(BHex$B$N@ZBX$N;~$K9T4V$K%4%_$,;D$C$F$$$?$N$r=$@5(B.
+	* Ascii$B;~(B, $B0lHV2<$N9T$N2<$K%4%_$,=P$F$$$?$N$r=$@5(B.
+	* $BI=<($G$-$J$$%3!<%I$r(B \xxx $B$N7A<0$GI=<($9$k;~(B, 'xxx $B$K$J$C$F(B
+	  $B$$$?$N$r=$@5(B.
+
+Thu Feb 29 19:44:31 JST 1996	rev5.2.6
+
+	* MultiLingual TextViewer $B$G(B, $B%&%)!<%K%s%0%a%C%;!<%8$r%]%C%W%"%C(B
+	  $B%W$9$k$h$&$K$7$?(B.
+	* xvml.c $B$G(B, ascii $B%U%)%s%H$,8+$D$+$i$J$$>l9g$K(B, $B%3%"%@%s%W$9(B
+	  $B$k$N$r=$@5(B.
+	* xvml.c $B$G(B, $B0lIt(B exit() $B$,;D$C$F$$$?$N$r(B, Quit() $B$K=$@5(B.
+	* MultiLingual TextViewer $B$G(B, $B%U%)%s%H$r%j%=!<%9$G;XDj$G$-$k$h(B
+	  $B$&$K$7$?(B.
+	* MultiLingual TextViewer $B$G(B, $B5{$r%5%]!<%H(B.
+	* MultiLingual TextViewer $B$N9bB.2=(B.
+	* xvml.h $B$G(B, $B4X?t$N%W%m%H%?%$%W$,4V0c$C$F$$$?$N$r%U%#%C%/%9(B.
+
+Tue Feb 13 13:18:02 JST 1996	rev5.2.5
+
+	* xvml.c $B$G(B, $B%5%$%:$NBg$-$$%F%-%9%H%U%!%$%k$bFI$a$k$h$&$K$7$?(B.
+
+Fri Dec 22 17:37:07 JST 1995	rev5.2.4
+
+	* xvpcd.c $B$G(B, 4Base(1536x1024)$B$N@_Dj$GI=<($5$;$k$H(B, $B:8C<$N=D0l(B
+	  $BNs$K%4%_$,=P$kIT6q9g$r%U%#%C%/%9(B.
+
+Mon Dec  4 18:34:06 JST 1995	rev5.2.3
+
+	* xvml.c $B$G(B, $B0lIt$N2hA|$rI=<($9$k:]$KLdBj$,@8$8$F$$$?$N$r%U%#%C(B
+	  $B%/%9(B.
+
+Wed Nov 29 14:19:43 JST 1995	rev5.2.2
+
+	* xvmgcsfx.c $B$G(B magic [bl]eint32 $B$N%G!<%?$r(B int16 $B$KBeF~$7$F$$(B
+	  $B$?$N$r=$@5(B.
+	* ANSI $B%9%?%$%k$N4X?t$,#2$D$"$C$?$N$G(B, K&R $B%9%?%$%k$K=$@5(B.
+	* SunOS 4.1 $B$N(B cc $B$G$O(B, $B%9%H%j%s%0$,J#?tJB$V$b$N$r%9%H%j%s%0$H(B
+	  $B$7$F2r<a$G$-$J$$$N$G=$@5(B.
+	* xvpic.c $B$G(B, $BJQ?t$N7?$r8m$C$F$$$?$N$r=$@5(B.
+	* xvpic2.c $B$G(B, opaque $B$N=hM}$r8m$C$F$$$?$N$r=$@5(B.
+	  ($B0J>e(B 5$BE@(B, Thanks to $BKYFbJ]=((B <yhori@pino.mei.co.jp>$B$5$s(B).
+        * $B%3%s%H%j%S%e!<%7%g%s%U%#%k%?$H$7$F(B, $B%6%&%k%9<j=q%a%bEy(B to
+	  ppm $B$N%U%#%k%?$r2C$($?(B.
+
+Mon Nov 20 14:12:38 JST 1995	rev5.2.1
+
+	* xvpbm.c $B$N(B, MGCSFX $B$r;HMQ$9$k:](B, DEC OSF/1 v3.0 $B$G%Q%$%W$,ES(B
+	  $BCf$^$G$7$+FI$a$J$$$3$H$K$h$kLdBjE@$r%U%#%C%/%9(B.
+
+Tue Oct 24 15:04:21 JST 1995	rev5.2.0
+
+	* mlview $B$r%^!<%8$7$?(B.
+
+Thu Oct 19 15:07:53 JST 1995	rev5.1.10 (jp-ext release)
+
+	* xv.c $B$G(B, MGCSFX $B$r07$&$?$a$NJQ?t$KLdBj$,$"$C$?$N$G(B, $BJQ99(B.
+
+Fri Oct 13 12:54:59 JST 1995	rev5.1.9
+
+	* $B%W%j%W%m%;%C%5L?Na$N=$@5(B.
+
+Wed Oct 11 17:11:47 JST 1995	rev5.1.8
+
+	* xvmgcsfx.c $B$G(B, signal $B4X78$N<BAu$rJQ99(B.
+	* xvvd.c $B$G(B, Mkvdir() $B$G(B SIGCHLD $B$b%V%m%C%/$9$k$h$&$K$7$?(B.
+
+Mon Oct  2 16:05:50 JST 1995	rev5.1.7
+
+	* $B%f!<%6Dj5A%U%#%k%?$G(B, <in c> $B$N%3%^%s%I<B9T$G%(%i!<$,H/@8$9(B
+	  $B$k$H(B, $BL58B%k!<%W$K4Y$C$F$7$^$&%P%0$r%U%#%C%/%9(B.
+	* $B%3%s%H%j%S%e!<%7%g%s%U%#%k%?$K(B, camtoppm(convert CASIO
+	  Digital camera QV-10's format to ppm(or jpeg))$B$r2C$($?(B.
+
+Mon Sep 25 16:32:23 JST 1995	rev5.1.6
+
+	* xvvd.c $B$G(B, / $BD>2<$N%G%#%l%/%H%j$N?F%G%#%l%/%H%j$N%Q%9:GE,2=(B
+	  $B$,8m$C$F$$$?$N$r%U%#%C%/%9(B.
+	* xvmgcsfx.c $B$G(B, Solaris2.x $B$N$H$-(B SIGCHLD $B$r8+$J$$$h$&$K$7$?(B.
+	* $B%3%s%H%j%S%e!<%7%g%s%U%#%k%?$H$7$F(B, unchc(skip header of
+	  CERN httpd cache file)$B$r2C$($?(B.
+
+Thu Sep 14 19:21:06 JST 1995	rev5.1.5
+
+	* xvmgcsfx.c $B$N%P%0%U%#%/%9(B, $B$*$h$S(B xv_mgcsfx $B$NFI$_9~$_$N$H$-(B
+	  $B$N%(%i!<=hM}$rF~$l$?(B.
+	* xvvd.c $B$G(B, Virtual directory $B$N%Q!<%_%C%7%g%s$r(B 700 $B$K$7$?(B.
+	* $B%U%#%k%?%3%^%s%I$N%=!<%9$r(B, contrib $B$K0\F0(B.
+	* $B%3%s%H%j%S%e!<%7%g%s%U%#%k%?$H$7$F(B, tim(used by SONY
+	  PlayStation) to ppm $B$N%U%#%k%?$r2C$($?(B.
+
+Mon Sep 11 16:13:14 JST 1995	rev5.1.4
+
+	* xvvd.c $B$G(B, $BITMW$J$H$-$K%F%s%]%i%j%G%#%l%/%H%j$r:n@.$9$k$N$r(B
+	  $B$d$a$?(B.
+	* xvmgcsfx.c $B$G(B, DEBUG $B;~$N%3!<%G%#%s%0$rJQ99$7$?(B.
+	* xv_mgcsfx.sample $B$r(B MGCSFXDIR=$(LIBDIR) $B$K%$%s%9%H!<%k$9$k$h(B
+	  $B$&$K$7$?(B. $BF1;~$K(B, $B%5%$%H%3%s%U%#%.%e%l!<%7%g%s%U%!%$%k$,(B,
+	  MGCSFXDIR/MGCSFX_SITE_RC $B$K$J$k$h$&$KJQ99(B.
+
+Sun Sep  3 22:34:12 JST 1995	rev5.1.3
+
+	* xvmgcsfx.c $B$G(B, $BCWL?E*$J%a%b%j$N%"%m%1!<%7%g%s0J30$G$N(B exit() 
+	  $B$r$d$a$k$h$&$K$7$?(B.
+	* <input_image_type> $B$K(B `auto' $B$H5-F~$9$k$H!"%F%s%]%i%j$K=q$-(B
+	  $B=P$7$F!"(BXV $B$NG'<1=hM}$rDL$7$F$+$i%m!<%I$9$k$h$&$K$7$?(B.
+
+Tue Aug 29 19:35:58 JST 1995	rev5.1.2
+
+	* xvmgcsfx.c $B$N(B DEC Alpha $B$NLdBjE@$,$^$@;D$C$F$$$?(B.
+	* $B%f!<%6%U%#%k%?Dj5A%U%!%$%k$G(B, $B%7%s%\%k(B `strings' $B$r(B `magic' 
+	  $B$KJQ99(B.
+
+Sat Aug 26 01:17:28 JST 1995	rev5.1.1
+
+	* xvmgcsfx.c $B$G(B, NEEDSDIR $B$rDj5A$9$k$N$rK:$l$F$$$?(B.
+	* $BF1$8$/(B, USE_MGCSFX_PREPROCESSOR $B$,Dj5A$5$l$F$$$J$$$H$-$NIT6q(B
+	  $B9g$r%U%#%C%/%9(B.
+	* $BF1$8$/(B, DEC Alpha $B$G$O(B, sscanf( ,"%li", )$B$,!"(B64bit $B$K$J$k$N(B
+	  $B$r=$@5(B.
+	* config.h $B$G(B, $B%9%Z%k%_%9$,$"$C$?(B.
+	* bits/br_mgcsfx $B$N%9%Z%k%_%9$r=$@5(B.
+
+Wed Aug 23 19:20:52 JST 1995	rev5.1.0
+
+	* $B%f!<%6Dj5A%U%#%k%?$K(B, $B%W%j%W%m%;%C%55!G=$rDI2C(B.
+
+Wed Aug 23 02:28:29 JST 1995	rev5.0.0
+
+	* $B%f!<%6Dj5A%U%#%k%?5!G=$r%^!<%8(B.
+
+Wed Aug 23 01:42:53 JST 1995	rev4.2.2
+
+	* xvvd.c $B$G(B, vd_recursive_rmdir $B$K$*$$$F(B, closedir $B$rK:$l$F$$(B
+	  $B$?$N$r%U%#%C%/%9(B.
+
+Fri Jun 30 23:58:39 JST 1995	rev4.2.1
+
+	* OLDPIC $B$K$b(B, Japanese Extension $B$N(B Revision $B$rKd$a$3$`$h$&$K(B
+	  $B$7$?(B.
+
+Thu Jun 29 19:21:40 JST 1995	rev4.2.0
+
+	* xvvd.c $B$N4X?tL>$r0lItJQ99(B.
+	* AUTOEXTRACT $B$r(B AUTO_EXPAND $B$KJQ99(B.
+	* Thumbdir(Icon $B$rJ]B8$9$k%G%#%l%/%H%j(B)$B$,:n@.$G$-$J$$>l9g$G$b(B, 
+	  Virtual directory $B5!G=$rMQ$$$F(B, XV $B$r=*N;$9$k$^$G(B Icon $B$N%G!<(B
+	  $B%?$rJ];}$G$-$k5!G=$rDI2C(B.
+	* Visual Shunauzer $B$r(B 2$B$D3+$$$?$H$-$K(B, $B%G%#%l%/%H%j$NG'<1$r8m(B
+	  $B$k%P%0(B($B%*%j%8%J%k$N%P%0(B)$B$r%U%#%C%/%9(B.
+
+Fri Jun 23 15:24:31 JST 1995	rev4.1.0
+
+	* Japanese Extension $B$N(B Revision $B$rKd$a9~$s$@(B.
+	* xvpic2.c $B$G(B, VERSTR $B$NJ8;z?t$r2>Dj$7$?%3!<%I$r%U%#%C%/%9(B.
+	* Visual Shunauzer $B$K(B, aspect $B$r9MN8$9$k%*%W%7%g%s$rDI2C(B.
+	* xvvd.c $B$G(B, arj $B$NH=DjJ}K!$,4V0c$C$F$$$?$N$r%U%#%C%/%9(B.
+
+Wed Jun 14 19:30:14 JST 1995	rev4.0.4
+
+	* config.h $B$G(B, /* #define XXX */ $B$r(B #undef XXX $B$K(B.
+	* xvpcd.c $B$N(B warnning $B$r>C$7$?(B.
+	* macbinary $B%b!<%I$K$*$$$F(B, TextViewer $B$G%F%-%9%H%U%!%$%k$N@h(B
+	  $BF,$,@Z$l$k$N$r%U%#%C%/%9(B.
+	* virtual directory $BCf$N2hA|%U%!%$%k$K$D$$$F(B, $B2hA|%&%#%s%I%&>e(B
+	  $B$K$*$$$F(B, ^t $B$GFbMF$r8+$k$3$H$,$G$-$J$+$C$?$N$r%U%#%C%/%9(B.
+
+Wed Jun 07 17:00:44 JST 1995	rev4.0.3 (jp-ext release)
+
+	* TextViewer
+	  - $B%U%)%s%H$N;XDjJ}K!$rJQ99(B.
+	  - $B8m$C$?(B locale $BL>$r;XDj$7$F$b(B, $BI}$,69$/$J$i$J$$$h$&$K(B.
+	  - DEC OSF/1 $B$G(B, jisx0201 $B$K4^$^$l$k%3!<%I$O(B, `=' $B$GI=<($9$k(B
+	    $B$h$&$K(B.
+	  - $BF|K\8lI=<($,$G$-$J$$4D6-$G$bJ8;z%3!<%I$N<1JL$r9T$C$F$7$^$$(B,
+            $BI=<($,85$N(B TextViewer $B$H0[$J$C$F$7$^$C$F$$$?$N$r%U%#%C%/%9(B.
+	  - $B%-!<%\!<%I$GJ8;z%3!<%I$rJQ$($?$j(B TextViewer $B$rJD$8$?$j$G$-(B
+	    $B$k$h$&$K(B.
+	  - $B%^%/%m$NL>A0$rJQ99(B.
+	  - xv.c $B$H(B xv.h $B$G(B TV_FONTSET $B$,Dj5A$5$l$F$$$?$N$G(B, xv.h $B$NJ}(B
+	    $B$N5-=R$r:o=|(B.
+
+Tue Jun 06 16:21:16 JST 1995	rev4.0.2
+
+	* $B1Q8l$N%I%-%e%a%s%H$r=q$$$?(B.
+	* LOCALE_*, TV_FONTSET $B$r(B xv.h $B$K0\F0(B.
+	* $B2hA|$N%3%a%s%H$r8+$k$H$-$K(B, $BF|K\8l%3!<%IH=JL$,>e<j$/$$$C$F$$(B
+	  $B$J$+$C$?$N$r%U%#%C%/%9(B.
+
+Sat Jun 03 14:01:55 JST 1995	rev4.0.1
+
+	* TextViewer $B$N%\%?%s%i%Y%k$NJQ99(B.
+	* MAG $B$N%3%a%s%H=hM}ItJ,$N(B bug fix.
+	* xv.h $B$K(B SEEK_SET $B$J$I$NDj5A$rDI2C(B.
+	* locale $B$NDj5A$r(B xv.h $B$K0\F0(B.
+	* TV_L10N $B$NBP1~(B OS $B$NDI2C(B.
+
+Thu Jun 01 19:19:48 JST 1995	rev4.0.0
+
+	* HAVE_* $B$rI|3h$5$;$?(B.
+	* TextViewer l10n patch $B$r%^!<%8$7$?(B.
+
+Sat Apr 29 23:05:39 JST 1995	rev3.6.0
+
+	* vd_recursive_{mk|rm}dir$B$r(B $B=q$$$?(B.
+	* $B%G%#%9%W%l%$$r%*!<%W%s$G$-$J$+$C$?$i(B virturl directory $B$,;D$C$F(B
+          $B$$$?(B.
+
+Tue Apr 25 19:06:48 JST 1995	rev3.5.15 (jp-ext release)
+
+	* xvpic2.c $B$N(B warning $B$r>C$7$?(B.
+
+Mon Apr 24 12:44:06 JST 1995	rev3.5.14
+
+	* sh $B7O$N%7%'%k$r;H$C$F(B AUTOEXTRACT $B$9$k$H(B, core dump $B$7$?(B.
+
+Mon Apr 24 11:38:10 JST 1995	rev3.5.13
+
+	* SVR4 $B$b(B sighold $B$r;H$&$h$&$K$7$?(B.
+	* SIGHUP $B$r:F@_Dj$9$k$h$&$K$7$?(B.
+
+Sun Apr 23 16:36:28 JST 1995	rev3.5.12
+
+	* mkvdir $B$r%/%j%F%#%+%k%;%/%7%g%s$K$7$?(B.
+
+Sat Apr 22 18:15:38 JST 1995	rev3.5.11
+
+	* getenv $B$N(B warning $B$r>C$7$?(B.
+	* Solaris $B$G$O(B, C-c $B$r(B2$B2sO"B3$7$F2!$9$H(B /tmp/.xvvdXXXXX/$B$r>C$5$:$K(B
+          $B=*N;$7$F$$$?(B.
+
+Fri Apr 21 16:36:25 JST 1995	rev3.5.10
+
+	* PIC2 $B$N?'$NFbItI=8=$rJQ99(B.
+	* $B%H%i%C%W$9$k%7%0%J%k$r8:$i$7$?(B.
+
+Wed Apr 19 13:45:41 JST 1995	rev3.5.9
+
+	* arc $B$H(B Q4 $B$N%^%8%C%/%J%s%P$NBP:v(B.
+
+Wed Apr 19 11:41:44 JST 1995	rev3.5.8
+
+	* P2SF $B$N?'2=$1$r%U%#%C%/%9(B.
+
+Wed Apr 19 00:42:18 JST 1995	rev3.5.7
+
+	* P2SS $B$N?'2=$1$r%U%#%C%/%9(B.
+
+Mon Apr 10 15:36:42 JST 1995	rev3.5.6 (jp-ext release)
+
+	* 24bit-PIC2 $B$N;EMM$N4*0c$$$r%U%#%C%/%9(B.
+
+Fri Apr 07 17:24:21 JST 1995	rev3.5.5
+
+	* $B%7%0%J%k$r$?$/$5$s%U%C%/$7$F$_$?(B.
+
+Fri Apr 07 14:32:57 JST 1995	rev3.5.4
+
+	* /tmp -> /var/tmp $B$H%j%s%/$rD%$C$F$k;~$NLdBj$r2r7h(B.
+
+Thu Apr 06 00:37:57 JST 1995	rev3.5.3
+
+	* $B$^$@5{$,;D$C$F$$$?(B.
+	* $B%3%^%s%I%i%$%s$G%U%!%$%kL>$@$1$r;XDj$9$k$H(B core dump $B$7$?(B.
+
+Tue Apr 05 13:40:21 JST 1995	rev3.5.2
+
+	* visual schnauzer $B$G%/%j%C%/$G5{$,;D$C$?(B.
+	* save $B$9$k;~$K(B clear virtual directory $B$5$l$F$$$F$bNI$/$7$?(B.
+
+Tue Apr 04 23:54:06 JST 1995	rev3.5.1
+
+	* Load all $B$N8e$G(B clear virtual directory $B$9$k$H$^$:$+$C$?(B.
+
+Tue Apr 04 17:17:33 JST 1995	rev3.5.0
+
+	* $B:#$^$G$N$^$H$a(B.
+
+Tue Apr 04 13:30:10 JST 1995	rev3.4.9
+
+	* $BI8=`%(%i!<=PNO$rDY$7$F(B fork, exec $B$9$k$h$&$K(B.
+
+Mon Apr 03 14:46:01 JST 1995	rev3.4.8
+
+	* chdir $B$,$*$+$7$+$C$?(B.
+
+Mon Apr 03 12:25:46 JST 1995	rev3.4.7
+
+	* popen, pclose $B$r;H$C$F(B fork, exec $B$7$F$_$?(B.
+
+Sun Apr 02 14:19:39 JST 1995	rev3.4.6
+
+	* Visual Schnauzer $B$N%"!<%+%$%V%G%#%l%/%H%jCf$G%9%Z!<%9$d(B BS $B$,8z(B
+	  $B$$$F$J$+$C$?(B.
+
+Sun Apr 02 00:55:47 JST 1995	rev3.4.5
+
+	* $B%"!<%+%$%VCf$N%G%#%l%/%H%j$d%"!<%+%$%V$r(B chdir $B$GA*$Y$k$h$&$K(B.
+
+Thu Mar 30 13:46:44 JST 1995	rev3.4.4
+
+	* vd_archive -> isarchive
+
+Wed Mar 29 18:03:21 JST 1995	rev3.4.3
+
+	* $B%"!<%+%$%VCf$N%"!<%+%$%V$r%3%T!<$7$h$&$H$9$k$H%G%#%l%/%H%j$,(B
+	  $B%3%T!<$5$l$F$$$?(B.
+	* Icon Update $B$,;`$s$G$$$?(B.
+
+Wed Mar 29 15:29:21 JST 1995	rev3.4.2
+
+	* xvvd.c $B$G(B NULL $B$r(B '\0' $B$KJQ99(B.
+
+Wed Mar 29 10:20:35 JST 1995	rev3.4.1
+
+	* xvvd.c $B$N(B optimize_path $B$N%P%0%U%#%C%/%9(B.
+	* $B%3%a%s%H$rIU2C(B.
+
+Wed Mar 29 05:13:23 JST 1995	rev3.4
+
+	* xvvd.c $B$r=q$$$F(B, xvvcd.c $B$r<N$F$?(B.
+
+Wed Mar 29 00:46:16 JST 1995	rev3.3.5
+
+	* archive move $B$N;~$K2>A[%G%#%l%/%H%j$,0\F0$7$F$J$+$C$?(B.
+
+Tue Mar 28 15:34:34 JST 1995	rev3.3.4
+
+	* $B%Q%$%W$N6/@)@ZCG$r%U%#%C%/%9(B.
+
+Tue Mar 28 12:30:15 JST 1995	rev3.3.3
+
+	* gzip $B$N%^%8%C%/%J%s%P$K4X$9$k%U%#%C%/%9(B.
+
+Tue Mar 28 12:30:15 JST 1995	rev3.3.2
+
+	* lzh $B$d(B tar.gz $B$K%"%/%;%9$G$-$J$+$C$?(B.
+
+Tue Mar 28 06:06:52 JST 1995	rev3.3.1
+
+	* lzh $B$r;XDj$7$F(B cd $B$7$h$&$H$7$?;~$NIT6q9g$r%U%#%C%/%9(B.
+
+Tue Mar 28 05:15:43 JST 1995	rev3.3
+
+	* xvvcd.c $B$G%Q%9$r$^$8$a$K%*%W%F%#%^%$%:$9$k$h$&$K$7$?(B.
+
+Sat Mar 25 04:57:45 JST 1995	rev3.0
+
+	* $B%"!<%+%$%V<+F0E83+%Q%C%A$r%^!<%8(B.
+	* $B%"!<%+%$%V<+F0E83+$,5!G=$9$k$h$&$K(B Visual Schnauzer $B$r2~A1(B.
+
+Thu Mar 23 14:23:48 JST 1995	rev2.1
+
+	* $B$^$H$a(B.
+
+Wed Mar 22 22:08:22 JST 1995	rev1.3
+
+	* SunOS $B$G$O%3%s%Q%$%k%(%i!<$,=P$?(B.
+	* xvpcd.c $B$N(B ULineString $B$N0z?t$N=gHV$,4V0c$C$F$$$?(B.
+
+Wed Mar 22 03:51:50 JST 1995	rev1.2
+
+	* $B?7$7$$(B PhotoCD $B%Q%C%A$r%^!<%8(B.
+
+Thu Mar 16 19:49:15 JST 1995	rev1.1 (magpic2-PhotoCD patch release)
+
+	* PhotoCD $B%Q%C%A$r%^!<%8(B.
+
+Tue Mar 14 00:49:46 JST 1995	rev1.0
+
+	* $B:#$^$G$N$^$H$a(B.
+
+Sat Mar 11 13:19:26 JST 1995	rev0.6
+
+	* xvpic2.c $B$r=q$$$?(B.
+
+Thu Mar 09 04:56:29 JST 1995	rev0.5
+
+	* Pi $B$N?'2=$1$r%U%#%C%/%9(B. *_malloc $B$rDI2C(B.
+
+Wed Mar 01 16:24:25 JST 1995	rev0.4
+
+	* xvpi.c $B$r=q$$$?(B.
+
+Fri Feb 24 16:00:26 JST 1995	rev0.3
+
+	* NEWS-OS 4.2 $B$G%3%s%Q%$%k$G$-$k$h$&$K$J$C$?(B.
+
+Fri Feb 24 09:45:49 JST 1995	rev0.2
+
+	* xvmag.c $B$r%P!<%8%g%s%"%C%W(B. xvmaki.c, xvpic.c $B$r=q$$$?(B.
+
+Sat Feb 18 21:02:02 JST 1995	rev0.1 (magpic patch release)
+
+	* xvmag.c $B$O%*%j%8%J%k(B. xvmaki.c $B$O(B coerce $B$+$i(B. xvpic.c $B$O0J(B
+	  $BA0$N$b$N(B.
diff -Naur xv-3.10a.old/xv-jp-extension/Patch.xv310a-ext-5.3.3 xv-3.10a/xv-jp-extension/Patch.xv310a-ext-5.3.3
--- xv-3.10a.old/xv-jp-extension/Patch.xv310a-ext-5.3.3	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/Patch.xv310a-ext-5.3.3	Thu Nov 21 17:14:36 1996
@@ -0,0 +1,18388 @@
+diff -urN xv-3.10a/Imakefile xv-3.10a-jp-extension-current/Imakefile
+--- xv-3.10a/Imakefile	Sat Jan 14 05:24:01 1995
++++ xv-3.10a-jp-extension-current/Imakefile	Wed Oct  9 20:36:29 1996
+@@ -104,11 +104,16 @@
+ SGI = -Dsgi
+ #endif
+ 
++/* install directory of xv_mgcsfx.sample. */
++MGCSFXDIR = $(LIBDIR)
++/* Directory of default configuration file. */
++MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
+ 
+ 
+ 
+ 
+ 
++
+ /* This marks the end of the configuration parameters */
+ 
+ 
+@@ -137,6 +142,8 @@
+ #if defined(SCOArchitecture)
+ SCO= -Dsco -DPOSIX -DNO_RANDOM 
+ SYS_LIBRARIES=        -lm -lc -lx 
++#elif defined(HPArchitecture)
++SYS_LIBRARIES=        -lm -lV3
+ #else
+ SYS_LIBRARIES=        -lm
+ #endif
+@@ -147,7 +154,7 @@
+ 
+ DEFINES= $(SCO) $(UNIX) $(NODIRENT) $(VPRINTF) $(TIMERS) \
+ 	$(HPUX7) $(JPEG) $(TIFF) $(PDS) $(DXWM) $(RAND) \
+-	$(BACKING_STORE) $(BSDTYPES) $(SGI)
++	$(BACKING_STORE) $(BSDTYPES) $(SGI) $(MGCSFX)
+ 
+ INCLUDES = $(JPEGINCLUDE) $(TIFFINCLUDE)
+ 
+@@ -157,7 +164,9 @@
+ 	xvdial.c xvgraf.c xvsunras.c xvjpeg.c xvps.c xvpopup.c xvdflt.c \
+ 	xvtiff.c xvtiffwr.c xvpds.c xvrle.c xviris.c xvgrab.c vprintf.c \
+ 	xvbrowse.c xvtext.c xvpcx.c xviff.c xvtarga.c xvxpm.c xvcut.c \
+-	xvxwd.c xvfits.c
++	xvxwd.c xvfits.c \
++	xvmag.c xvpic.c xvmaki.c xvpi.c xvpic2.c xvpcd.c xvvd.c xvmgcsfx.c \
++	xvml.c
+ 
+ OBJS1 =	xv.o xvevent.o xvroot.o xvmisc.o xvimage.o xvcolor.o xvsmooth.o \
+ 	xv24to8.o xvgif.o xvpm.o xvinfo.o xvctrl.o xvscrl.o xvalg.o \
+@@ -165,7 +174,9 @@
+ 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
+ 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
+ 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
+-	xvxwd.o xvfits.o
++	xvxwd.o xvfits.o \
++	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
++	xvml.o
+ 
+ SRCS2=	bggen.c
+ OBJS2=	bggen.o
+@@ -266,6 +277,8 @@
+ InstallManPageLong(docs/xvp2p,$(MANDIR),xvpictoppm)
+ InstallManPageLong(docs/vdcomp,$(MANDIR),vdcomp)
+ 
++InstallNonExecFile(xv_mgcsfx.sample,$(MGCSFXDIR))
++
+ tar:
+ 	tar cf xv.tar Makefile* Imakefile *.c *.h bits docs \
+ 		 docs unsupt vms $(JPEGDIR) $(TIFFDIR) $(MISC)
+diff -urN xv-3.10a/Makefile xv-3.10a-jp-extension-current/Makefile
+--- xv-3.10a/Makefile	Tue Jan 24 05:20:54 1995
++++ xv-3.10a-jp-extension-current/Makefile	Wed Oct  9 20:36:23 1996
+@@ -78,10 +78,12 @@
+ #----------System V----------
+ 
+ # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
+-# Solaris, etc., uncomment the following line to get mostly there.  
+-#UNIX = -DSVR4
++# Sikarusm etc, uncomment one of the following lines to get you *most* of
++# the way there.  SYSV means System V R3.
++# UNIX = -DSVR4
++# UNIX = -DSYSV
++     
+ 
+-
+ #----------Machine Specific Configurations----------
+ 
+ ### If you are using an SGI system, uncomment the following line
+@@ -99,6 +101,9 @@
+ # note:  You may need to add '-I/usr/include/X11R5' (or R6, or whatever)
+ # to whichever of those lines you used, as HP tends to store their X11
+ # include files in a non-standard place...
++#
++# And, you probably have to add '-lV3' to the end of the LIBS def,
++# when use AUTO_EXPAND feauture.
+ 
+ 
+ ### for LINUX, uncomment the following line
+@@ -177,6 +182,16 @@
+ #VPRINTF = -DNEED_VPRINTF -DLONGINT -DNOSTDHDRS
+ 
+ 
++# if your X Window System compiled with -DX_LOCALE, 
++# uncomment the following line:
++# TVL10N = -DX_LOCALE
++
++# Install directory of xv_mgcsfx.sample.
++MGCSFXDIR = $(LIBDIR)
++# Directory of default configuration file.
++MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
++
++
+ 
+ 
+ ################ END OF CONFIGURATION OPTIONS #################
+@@ -186,7 +201,7 @@
+ 
+ CFLAGS = $(CCOPTS) $(JPEG) $(JPEGINC) $(TIFF) $(TIFFINC) $(PDS) \
+ 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
+-	$(DXWM) $(MCHN)
++	$(DXWM) $(MCHN) $(TVL10N) $(MGCSFX)
+ 
+ LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+ 
+@@ -196,7 +211,9 @@
+ 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
+ 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
+ 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
+-	xvxwd.o xvfits.o
++	xvxwd.o xvfits.o \
++	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
++	xvml.o
+ 
+ MISC = README INSTALL CHANGELOG IDEAS
+ 
+@@ -244,6 +261,7 @@
+ 	cp docs/xvp2p.man  $(MANDIR)/xvpictoppm.$(MANSUF)
+ 	cp docs/vdcomp.man $(MANDIR)/vdcomp.$(MANSUF)
+ 	cp docs/xvdocs.ps* $(LIBDIR)
++	cp xv_mgcsfx.sample $(MGCSFXDIR)
+ 
+ tar:
+ 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
+diff -urN xv-3.10a/Makefile.std xv-3.10a-jp-extension-current/Makefile.std
+--- xv-3.10a/Makefile.std	Tue Jan 24 10:06:26 1995
++++ xv-3.10a-jp-extension-current/Makefile.std	Wed Oct  9 20:36:30 1996
+@@ -78,10 +78,12 @@
+ #----------System V----------
+ 
+ # if you are running on a SysV-based machine, such as HP, Silicon Graphics,
+-# Solaris, etc., uncomment the following line to get mostly there.  
+-#UNIX = -DSVR4
++# Sikarusm etc, uncomment one of the following lines to get you *most* of
++# the way there.  SYSV means System V R3.
++# UNIX = -DSVR4
++# UNIX = -DSYSV
++     
+ 
+-
+ #----------Machine Specific Configurations----------
+ 
+ ### If you are using an SGI system, uncomment the following line
+@@ -99,6 +101,9 @@
+ # note:  You may need to add '-I/usr/include/X11R5' (or R6, or whatever)
+ # to whichever of those lines you used, as HP tends to store their X11
+ # include files in a non-standard place...
++#
++# And, you probably have to add '-lV3' to the end of the LIBS def,
++# when use AUTO_EXPAND feauture.
+ 
+ 
+ ### for LINUX, uncomment the following line
+@@ -177,6 +182,16 @@
+ #VPRINTF = -DNEED_VPRINTF -DLONGINT -DNOSTDHDRS
+ 
+ 
++# if your X Window System compiled with -DX_LOCALE, 
++# uncomment the following line:
++# TVL10N = -DX_LOCALE
++
++# Install directory of xv_mgcsfx.sample.
++MGCSFXDIR = $(LIBDIR)
++# Directory of default configuration file.
++MGCSFX = -DMGCSFXDIR=\"$(MGCSFXDIR)\"
++
++
+ 
+ 
+ ################ END OF CONFIGURATION OPTIONS #################
+@@ -186,7 +201,7 @@
+ 
+ CFLAGS = $(CCOPTS) $(JPEG) $(JPEGINC) $(TIFF) $(TIFFINC) $(PDS) \
+ 	$(NODIRENT) $(VPRINTF) $(TIMERS) $(UNIX) $(BSDTYPES) $(RAND) \
+-	$(DXWM) $(MCHN)
++	$(DXWM) $(MCHN) $(TVL10N) $(MGCSFX)
+ 
+ LIBS = -lX11 $(JPEGLIB) $(TIFFLIB) -lm
+ 
+@@ -196,7 +211,9 @@
+ 	xvdial.o xvgraf.o xvsunras.o xvjpeg.o xvps.o xvpopup.o xvdflt.o \
+ 	xvtiff.o xvtiffwr.o xvpds.o xvrle.o xviris.o xvgrab.o vprintf.o \
+ 	xvbrowse.o xvtext.o xvpcx.o xviff.o xvtarga.o xvxpm.o xvcut.o \
+-	xvxwd.o xvfits.o
++	xvxwd.o xvfits.o \
++	xvmag.o xvpic.o xvmaki.o xvpi.o xvpic2.o xvpcd.o xvvd.o xvmgcsfx.o \
++	xvml.o
+ 
+ MISC = README INSTALL CHANGELOG IDEAS
+ 
+@@ -244,6 +261,7 @@
+ 	cp docs/xvp2p.man  $(MANDIR)/xvpictoppm.$(MANSUF)
+ 	cp docs/vdcomp.man $(MANDIR)/vdcomp.$(MANSUF)
+ 	cp docs/xvdocs.ps* $(LIBDIR)
++	cp xv_mgcsfx.sample $(MGCSFXDIR)
+ 
+ tar:
+ 	tar cvf xv.tar Makefile* Imakefile *.c *.h bits \
+diff -urN xv-3.10a/bggen.c xv-3.10a-jp-extension-current/bggen.c
+--- xv-3.10a/bggen.c	Fri Dec 23 07:34:41 1994
++++ xv-3.10a-jp-extension-current/bggen.c	Wed Oct  9 20:36:22 1996
+@@ -29,7 +29,7 @@
+ #define MAXCOLS  128
+ 
+ /* some VMS thing... */
+-#ifdef vax11c
++#if defined(vax11c) || (defined(__sony_news) && (defined(bsd43) || defined(__bsd43) || defined(SYSTYPE_BSD) || defined(__SYSTYPE_BSD)))
+ #include <ctype.h>
+ #endif
+ 
+diff -urN xv-3.10a/bits/br_mag xv-3.10a-jp-extension-current/bits/br_mag
+--- xv-3.10a/bits/br_mag
++++ xv-3.10a-jp-extension-current/bits/br_mag	Wed Oct  9 20:37:18 1996
+@@ -0,0 +1,27 @@
++#define br_mag_width 48
++#define br_mag_height 48
++static unsigned char br_mag_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x0c, 0x86, 0xc1, 0x0f, 0x02,
++   0x20, 0x0c, 0xc6, 0xe3, 0x1f, 0x02, 0x20, 0x1c, 0xe7, 0x67, 0x18, 0x02,
++   0x20, 0x1c, 0x77, 0x6e, 0x18, 0x02, 0x20, 0xbc, 0x37, 0x6c, 0x00, 0x02,
++   0x20, 0xbc, 0x37, 0x6c, 0x00, 0x02, 0x20, 0xec, 0x36, 0x6c, 0x1e, 0x02,
++   0x20, 0xec, 0xf6, 0x6f, 0x1e, 0x02, 0x20, 0x4c, 0xf6, 0x6f, 0x18, 0x02,
++   0x20, 0x4c, 0x36, 0x6c, 0x18, 0x02, 0x20, 0x0c, 0x36, 0x6c, 0x18, 0x02,
++   0x20, 0x0c, 0x36, 0xec, 0x1f, 0x02, 0x20, 0x0c, 0x36, 0xcc, 0x0f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_maki xv-3.10a-jp-extension-current/bits/br_maki
+--- xv-3.10a/bits/br_maki
++++ xv-3.10a-jp-extension-current/bits/br_maki	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_maki_width 48
++#define br_maki_height 48
++static unsigned char br_maki_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x83, 0x61, 0x18, 0x33, 0x02,
++   0x20, 0x83, 0xf1, 0x98, 0x33, 0x02, 0x20, 0xc7, 0xf9, 0x99, 0x31, 0x02,
++   0x20, 0xc7, 0x9d, 0xdb, 0x30, 0x02, 0x20, 0xef, 0x0d, 0xfb, 0x30, 0x02,
++   0x20, 0xef, 0x0d, 0x7b, 0x30, 0x02, 0x20, 0xbb, 0x0d, 0x7b, 0x30, 0x02,
++   0x20, 0xbb, 0xfd, 0xdb, 0x30, 0x02, 0x20, 0x93, 0xfd, 0xdb, 0x30, 0x02,
++   0x20, 0x93, 0x0d, 0x9b, 0x31, 0x02, 0x20, 0x83, 0x0d, 0x9b, 0x31, 0x02,
++   0x20, 0x83, 0x0d, 0x1b, 0x33, 0x02, 0x20, 0x83, 0x0d, 0x1b, 0x33, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_mgcsfx xv-3.10a-jp-extension-current/bits/br_mgcsfx
+--- xv-3.10a/bits/br_mgcsfx
++++ xv-3.10a-jp-extension-current/bits/br_mgcsfx	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_mgcsfx_width 48
++#define br_mgcsfx_height 48
++static unsigned char br_mgcsfx_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x3c, 0xcf, 0x71, 0x00, 0x02,
++   0x20, 0x6c, 0x61, 0xda, 0x00, 0x02, 0x20, 0x6c, 0x67, 0xd8, 0x1e, 0x02,
++   0x20, 0x3c, 0x61, 0xd8, 0x1e, 0x02, 0x20, 0x6c, 0x61, 0xda, 0x00, 0x02,
++   0x20, 0x6c, 0xcf, 0x71, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x4e, 0x7a, 0xef, 0x3d, 0x02, 0x20, 0xd3, 0x32, 0x68, 0x6c, 0x02,
++   0x20, 0xc3, 0x32, 0xe4, 0x6c, 0x02, 0x20, 0x5b, 0x33, 0x62, 0x6c, 0x02,
++   0x20, 0x53, 0x33, 0x61, 0x6c, 0x02, 0x20, 0x4e, 0x7a, 0xef, 0x3d, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x7f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_pcd xv-3.10a-jp-extension-current/bits/br_pcd
+--- xv-3.10a/bits/br_pcd
++++ xv-3.10a-jp-extension-current/bits/br_pcd	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_pcd_width 48
++#define br_pcd_height 48
++static unsigned char br_pcd_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x37, 0x00, 0xc0, 0x1c, 0x02,
++   0x20, 0x3f, 0x00, 0xe0, 0x3d, 0x02, 0x20, 0x3b, 0x00, 0x60, 0x2d, 0x02,
++   0x20, 0x3b, 0x60, 0x60, 0x2c, 0x02, 0x20, 0x3b, 0x60, 0x60, 0x2c, 0x02,
++   0x20, 0x7b, 0xf6, 0x66, 0x2c, 0x02, 0x20, 0xff, 0xff, 0x6f, 0x2c, 0x02,
++   0x20, 0xb7, 0x6b, 0x6b, 0x2c, 0x02, 0x20, 0xb3, 0x6b, 0x6b, 0x2c, 0x02,
++   0x20, 0xb3, 0x6b, 0x6b, 0x2c, 0x02, 0x20, 0xb3, 0x6b, 0x6b, 0x2d, 0x02,
++   0x20, 0xb3, 0xef, 0xef, 0x3d, 0x02, 0x20, 0xb3, 0xc6, 0xc6, 0x1c, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_pi xv-3.10a-jp-extension-current/bits/br_pi
+--- xv-3.10a/bits/br_pi
++++ xv-3.10a-jp-extension-current/bits/br_pi	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_pi_width 48
++#define br_pi_height 48
++static unsigned char br_pi_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x80, 0x1f, 0x7e, 0x00, 0x02,
++   0x20, 0x80, 0x3f, 0x7e, 0x00, 0x02, 0x20, 0x80, 0x31, 0x18, 0x00, 0x02,
++   0x20, 0x80, 0x31, 0x18, 0x00, 0x02, 0x20, 0x80, 0x31, 0x18, 0x00, 0x02,
++   0x20, 0x80, 0x39, 0x18, 0x00, 0x02, 0x20, 0x80, 0x1f, 0x18, 0x00, 0x02,
++   0x20, 0x80, 0x0f, 0x18, 0x00, 0x02, 0x20, 0x80, 0x01, 0x18, 0x00, 0x02,
++   0x20, 0x80, 0x01, 0x18, 0x00, 0x02, 0x20, 0x80, 0x01, 0x18, 0x00, 0x02,
++   0x20, 0x80, 0x01, 0x7e, 0x00, 0x02, 0x20, 0x80, 0x01, 0x7e, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_pic xv-3.10a-jp-extension-current/bits/br_pic
+--- xv-3.10a/bits/br_pic
++++ xv-3.10a-jp-extension-current/bits/br_pic	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_pic_width 48
++#define br_pic_height 48
++static unsigned char br_pic_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xf0, 0xf3, 0xf3, 0x01, 0x02,
++   0x20, 0xf0, 0xf7, 0xfb, 0x03, 0x02, 0x20, 0x30, 0xc6, 0x18, 0x03, 0x02,
++   0x20, 0x30, 0xc6, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc6, 0x18, 0x00, 0x02,
++   0x20, 0x30, 0xc7, 0x18, 0x00, 0x02, 0x20, 0xf0, 0xc3, 0x18, 0x00, 0x02,
++   0x20, 0xf0, 0xc1, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc0, 0x18, 0x00, 0x02,
++   0x20, 0x30, 0xc0, 0x18, 0x00, 0x02, 0x20, 0x30, 0xc0, 0x18, 0x03, 0x02,
++   0x20, 0x30, 0xf0, 0xfb, 0x03, 0x02, 0x20, 0x30, 0xf0, 0xf3, 0x01, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/br_pic2 xv-3.10a-jp-extension-current/bits/br_pic2
+--- xv-3.10a/bits/br_pic2
++++ xv-3.10a-jp-extension-current/bits/br_pic2	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,27 @@
++#define br_pic2_width 48
++#define br_pic2_height 48
++static unsigned char br_pic2_bits[] = {
++   0xe0, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x11, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00,
++   0x20, 0x00, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0xff, 0x03,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x3f, 0x3f, 0x1f, 0x1f, 0x02,
++   0x20, 0x7f, 0xbf, 0xbf, 0x3f, 0x02, 0x20, 0x63, 0x8c, 0xb1, 0x31, 0x02,
++   0x20, 0x63, 0x8c, 0x01, 0x30, 0x02, 0x20, 0x63, 0x8c, 0x01, 0x30, 0x02,
++   0x20, 0x73, 0x8c, 0x01, 0x30, 0x02, 0x20, 0x3f, 0x8c, 0x01, 0x18, 0x02,
++   0x20, 0x1f, 0x8c, 0x01, 0x0c, 0x02, 0x20, 0x03, 0x8c, 0x01, 0x06, 0x02,
++   0x20, 0x03, 0x8c, 0x01, 0x03, 0x02, 0x20, 0x03, 0x8c, 0xb1, 0x01, 0x02,
++   0x20, 0x03, 0xbf, 0xbf, 0x3f, 0x02, 0x20, 0x03, 0x3f, 0x9f, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0xff, 0xff, 0xff, 0x3f, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x02,
++   0x20, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x03};
+diff -urN xv-3.10a/bits/xv_jpext xv-3.10a-jp-extension-current/bits/xv_jpext
+--- xv-3.10a/bits/xv_jpext
++++ xv-3.10a-jp-extension-current/bits/xv_jpext	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,29 @@
++#define xv_jpext_width 111
++#define xv_jpext_height 22
++static unsigned char xv_jpext_bits[] = {
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00,
++   0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++   0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x01, 0x23, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4e, 0xe3, 0x64,
++   0x18, 0x0f, 0x06, 0x81, 0xd2, 0x03, 0x93, 0x79, 0xe2, 0x64, 0x20, 0xd1,
++   0x14, 0x5d, 0xa6, 0x8c, 0x09, 0x1f, 0x0c, 0xc1, 0x74, 0x65, 0x12, 0x5d,
++   0x20, 0x5c, 0xc4, 0x45, 0x9e, 0x92, 0x07, 0x01, 0x04, 0xc1, 0x13, 0x95,
++   0x0a, 0x45, 0x20, 0x53, 0x32, 0x45, 0x01, 0x51, 0x00, 0x01, 0x06, 0x29,
++   0x10, 0x89, 0x0a, 0x45, 0xa1, 0x58, 0x8a, 0x45, 0x31, 0x48, 0x0c, 0x01,
++   0x25, 0x25, 0x16, 0x41, 0x8a, 0x44, 0x11, 0xd7, 0x71, 0x45, 0x8e, 0x87,
++   0x03, 0xbf, 0x18, 0xc3, 0x11, 0x3d, 0x72, 0x44, 0x0e, 0x40, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+diff -urN xv-3.10a/bits/xv_jprev xv-3.10a-jp-extension-current/bits/xv_jprev
+--- xv-3.10a/bits/xv_jprev
++++ xv-3.10a-jp-extension-current/bits/xv_jprev	Wed Oct  9 20:40:21 1996
+@@ -0,0 +1,22 @@
++#define xv_jprev_width 78
++#define xv_jprev_height 22
++static unsigned char xv_jprev_bits[] = {
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00,
++   0x20, 0x40, 0x00, 0x00, 0x7c, 0xf0, 0x83, 0x1f, 0x23, 0x00, 0x20, 0x40,
++   0x00, 0x00, 0x02, 0x10, 0x81, 0x08, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x02, 0x80, 0x00, 0x04, 0x07, 0x4c, 0x28, 0x4f, 0x9c, 0x0c, 0x7a, 0x80,
++   0x03, 0x1c, 0x03, 0x53, 0xa4, 0x4c, 0xa2, 0x0b, 0x86, 0x60, 0x04, 0x23,
++   0x05, 0x8f, 0xa2, 0x52, 0xa1, 0x08, 0x80, 0x00, 0x04, 0x20, 0x89, 0x80,
++   0x22, 0x51, 0xa1, 0x08, 0x80, 0x08, 0x44, 0x20, 0xb1, 0x18, 0x21, 0x48,
++   0x91, 0x08, 0x61, 0x0a, 0x53, 0x18, 0x41, 0x07, 0xa1, 0x47, 0x8e, 0x08,
++   0x1e, 0xf2, 0x90, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++   0x00, 0x00, 0x00, 0x00};
+diff -urN xv-3.10a/config.h xv-3.10a-jp-extension-current/config.h
+--- xv-3.10a/config.h	Fri Jan  6 03:49:21 1995
++++ xv-3.10a-jp-extension-current/config.h	Tue Oct 22 18:45:59 1996
+@@ -19,7 +19,15 @@
+ #  ifdef VMS
+ #    define GUNZIP "UNCOMPRESS"
+ #  else
+-#    define GUNZIP "/usr/local/bin/gunzip -q"
++#    if defined(__FreeBSD__) || defined(__NetBSD__)
++#      define GUNZIP "/usr/bin/gunzip -q" 
++#    else
++#      if defined(__linux__)
++#        define GUNZIP "/bin/gunzip -q"
++#      else
++#        define GUNZIP "/usr/local/bin/gunzip -q"
++#      endif
++#    endif
+ #  endif
+ #endif
+ 
+@@ -37,7 +45,14 @@
+  */
+ #define UNCOMPRESS "/usr/ucb/uncompress"
+ 
+-#if defined(hpux) || defined(SVR4) || defined(__386BSD__)
++#if defined(hpux) || defined(SVR4) || \
++    defined(__386BSD__) || defined(__FreeBSD__) || defined(__NetBSD__) || \
++    defined(__linux__)
++    /* 
++     I want to use BSD macro for checking if this OS is *BSD or not,
++     but the macro is defined in <sys/parm.h>, which I don't know all
++     machine has or not.
++     */
+ #  undef  UNCOMPRESS
+ #  define UNCOMPRESS "/usr/bin/uncompress"
+ #endif
+@@ -119,3 +134,196 @@
+ 
+ #define BACKING_STORE
+ 
++
++/***************************************************************************
++ * MAG/PIC/MAKI/Pi/PIC2/PhotoCD format Support:
++ * 
++ * if, for whatever reason, you're unable to get the
++ * MAG/PIC/MAKI/Pi/PIC2/PhotoCD support to compile, *COMMENT OUT* the
++ * following apropriate line(s).
++ */
++
++#define HAVE_MAG
++#define HAVE_PIC
++#define HAVE_MAKI
++#define HAVE_PI
++#define HAVE_PIC2
++#define HAVE_PCD
++
++
++/***************************************************************************
++ * MacBinary file support:
++ *
++ * if you want XV to be able to handle ``MacBinary'' files (which have
++ * 128 byte info file header at the head), change 'undef' to 'define'
++ * in the following line.
++ */
++
++#undef MACBINARY
++
++
++/***************************************************************************
++ * Auto Expand support:
++ *
++ * if you want to extract archived file automatically and regard it as
++ * a directory, change 'undef' to 'define' in the AUTO_EXPAND line.
++ *
++ * Virtual Thumbdir support:
++ *
++ * if you want Virtual directory based Thumbdir(It means that XV
++ * does't forget builded Icons still be quited even if the directory
++ * is read-only), change 'undef' to 'define' the VIRTUAL_TD line.
++ */
++
++#undef AUTO_EXPAND
++#undef VIRTUAL_TD
++
++#if !defined(AUTO_EXPAND) && defined(VIRTUAL_TD)
++#  undef VIRTUAL_TD
++#endif
++
++
++/***************************************************************************
++ * Adjust the aspect ratio of Icons:
++ *
++ * if you want to adjust the aspect ratio of Icons in Visual
++ * Shunauzer, change 'undef' to 'define' in the following line.
++ */
++
++#undef VS_ADJUST
++
++
++/***************************************************************************
++ * Restore original colormap:
++ *
++ * if you want to restore original colormap when icons in Visual
++ * Shunauzer is double-clicked, change 'undef' to 'define' in the
++ * following line.
++ */
++
++#undef VS_RESCMAP
++
++
++/***************************************************************************
++ * TextViewer l10n support:
++ *
++ * if you want XV to show the text in Japanese on TextViewer, change
++ * 'undef' to 'define' in the following line.
++ */
++
++#undef TV_L10N
++
++#ifdef TV_L10N
++/*
++ * if you want to change the default code-set used in case that XV
++ * fails to select correct code-set, uncomment the '#define
++ * LOCALE_DEFAULT' line and change the 'LOCALE_DEFAULT' definition
++ * appropriately.
++ * (0:ASCII, 1:EUC-j, 2:JIS, 3:MS Kanji) */
++
++/* #  define LOCALE_DEFAULT 0 */
++
++/*
++ * Uncomment and edit the following lines, if your X Window System was
++ * not compiled with -DX_LOCALE and you failed to display the Japanese
++ * text in TextViewer.  You don't have to write locale name of JIS code-set
++ * and MicroSoft code-set, if your system doesn't support those code-sets.
++ */
++
++/*
++#  define LOCALE_NAME_EUC     "ja_JP.EUC"
++#  define LOCALE_NAME_JIS     "ja_JP.JIS"
++#  define LOCALE_NAME_MSCODE  "ja_JP.SJIS"
++*/
++
++/*
++ * if your system doesn't have the Japanese fonts in the sizes,
++ * Uncomment and edit the following font size entries.
++ */
++
++/* #  define TV_FONTSIZE 14,16,24 */
++
++/*
++ * If you need, uncomment and modify the following font name.
++ */
++
++/* #  define TV_FONTSET "-*-fixed-medium-r-normal--%d-*" */
++#endif /* TV_L10N */
++
++
++/***************************************************************************
++ * User definable filter support:
++ *
++ * Use the filters as input and output method for load and save unsupported
++ * image format file. The filter command is recognized by definition of 
++ * magic number or suffix in "~/.xv_mgcsfx" .
++ * To enable this feature, change 'undef' to 'define' in the following line.
++ */
++#undef HAVE_MGCSFX
++
++#ifdef HAVE_MGCSFX
++/*
++ * Support symbol 'auto' as <input image type> in startup file. This type
++ * is not use pipe as input, but write to temporary and recognize by xv 
++ * processing.
++ */
++#define HAVE_MGCSFX_AUTO
++
++/*
++ * The startup file of definition for MgcSfx. 'MGCSFX_SITE_RC' is read
++ * first and '~/MGCSFX_RC' is second. So same definitions in both files
++ * are overrided by '~/MGCSFX_RC'
++ * To define startup file, see the sample of startup file 'xv_mgcsfx.sample'.
++ */
++#  define MGCSFX_SITE_RC  "xv_mgcsfx"
++#  define MGCSFX_RC       ".xv_mgcsfx"
++
++/*
++ * If you want startup file to pass preprocessor in reading time, then
++ * change 'undef' to 'define' in the following line.
++ *
++ * WARNING : If you decide to use preprocessor, you must not write
++ *           '# <comment>' style comment in startup file. Because,
++ *           preprocessor can't recognize.  */
++#  undef USE_MGCSFX_PREPROCESSOR
++
++#  ifdef USE_MGCSFX_PREPROCESSOR
++/*
++ * This is used like "system("MGCSFX_PREPROCESSOR MGCSFX_RC > tmp_name");",
++ * and read tmp_name instead of MGCSFX_RC.
++ */
++#    define MGCSFX_PREPROCESSOR "/usr/lib/cpp"
++/* #    define MGCSFX_PREPROCESSOR "cc -E" */
++
++#  endif /* USE_MGCSFX_PREPROCESSOR */
++
++/*
++ * Default string of command. If input command is required for undefined file,
++ * dialog is popuped with 'MGCSFX_DEFAULT_INPUT_COMMAND'. And, if output
++ * command is required in save dialog of MgcSfx, dialog is popuped with
++ * 'MGCSFX_DEFAULT_OUTPUT_COMMAND'.
++ *
++ * WARNING : Now, supported only 'PNM' image format, when command input is
++ *           required. You should define filter which use 'PNM' image format
++ *           as input or output.
++ */
++#  define MGCSFX_DEFAULT_INPUT_COMMAND  "tifftopnm"
++#  define MGCSFX_DEFAULT_OUTPUT_COMMAND "pnmtotiff"
++
++#endif /* HAVE_MGCSFX */
++
++
++/***************************************************************************
++ * Multi-Lingual TextViewer
++ *
++ * if you want XV to show the text in multi-lingual on TextViewer, change
++ * 'undef' to 'define' in the following line.
++ */
++
++#undef TV_MULTILINGUAL
++
++#define TV_DEFAULT_CODESET TV_EUC_JAPAN
++
++#ifdef TV_MULTILINGUAL
++# undef TV_L10N
++#endif
+diff -urN xv-3.10a/vdcomp.c xv-3.10a-jp-extension-current/vdcomp.c
+--- xv-3.10a/vdcomp.c	Fri Dec 23 07:34:47 1994
++++ xv-3.10a-jp-extension-current/vdcomp.c	Wed Oct  9 20:36:27 1996
+@@ -106,6 +106,7 @@
+      !defined(pyr)                       && \
+      !defined(__UMAXV__)                 && \
+      !defined(bsd43)                     && \
++     !defined(__bsd43)                   && \
+      !defined(aux)                       && \
+      !defined(__bsdi__)                  && \
+      !defined(sequent)
+@@ -113,7 +114,14 @@
+ #  if defined(hp300) || defined(hp800) || defined(NeXT)
+ #   include <sys/malloc.h>                /* it's in 'sys' on HPs and NeXT */
+ #  else
+-#   include <malloc.h>
++#   if !defined(__386BSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
++    /* 
++     I want to use BSD macro for checking if this OS is *BSD or not,
++     but the macro is defined in <sys/parm.h>, which I don't know all
++     machine has or not.
++     */
++#     include <malloc.h>
++#   endif
+ #  endif
+ # endif
+ #endif /* !VMS */
+diff -urN xv-3.10a/xv.c xv-3.10a-jp-extension-current/xv.c
+--- xv-3.10a/xv.c	Fri Jan 20 03:08:43 1995
++++ xv-3.10a-jp-extension-current/xv.c	Wed Oct  9 20:36:20 1996
+@@ -62,6 +62,19 @@
+ 
+ static char   basefname[128];   /* just the current fname, no path */
+ 
++#ifdef TV_L10N
++#  ifndef TV_FONTSET
++#    define TV_FONTSET "-*-fixed-medium-r-normal--%d-*"
++#  endif
++#  ifndef TV_FONTSIZE
++#    define TV_FONTSIZE 14,16
++#  endif
++
++static int    mfontsize[] = { TV_FONTSIZE, 0 };
++static char   mfontset[256];
++#endif
++  
++
+ /* things to do upon successfully loading an image */
+ static int    autoraw    = 0;   /* force raw if using stdcmap */
+ static int    autodither = 0;   /* dither */
+@@ -78,6 +91,9 @@
+ 
+ static int    force8     = 0;   /* force 8-bit mode */
+ static int    force24    = 0;   /* force 24-bit mode */
++#ifdef HAVE_PCD
++static int    PcdSize    = -1;  /* force 24-bit mode */
++#endif /* HAVE_PCD */
+ 
+ /* used in DeleteCmd() and Quit() */
+ static char  **mainargv;
+@@ -122,6 +138,10 @@
+      *infogeom, *fgstr, *bgstr, *ctrlgeom, *gamgeom, *browgeom, *tmpstr;
+ char *rootfgstr, *rootbgstr, *visualstr, *textgeom, *cmtgeom;
+ char *monofontname, *flistName;
++#ifdef TV_L10N
++char **misscharset, *defstr;
++int nmisscharset;
++#endif
+ int  curstype, stdinflag, browseMode, savenorm, preview, pscomp, preset, 
+      rmodeset, gamset, cgamset, perfect, owncmap, rwcolor, stdcmap;
+ int  nodecor;
+@@ -137,6 +157,9 @@
+ /*******************************************/
+ {
+   int    i;
++#ifdef TV_L10N
++  int    j;
++#endif
+   XColor ecdef;
+   Window rootReturn, parentReturn, *children;
+   unsigned int numChildren, rootDEEP;
+@@ -153,6 +176,12 @@
+   /*** variable Initialization                       ***/
+   /*****************************************************/
+ 
++#ifdef TV_L10N
++  setlocale(LC_ALL, localeList[LOCALE_EUCJ]);
++  xlocale = (int)XSupportsLocale();	/* assume that (Bool) is (int) */
++	/* if X doesn't support ja_JP.ujis text viewer l10n doesn't work. */
++#endif
++
+   xv_getwd(initdir, sizeof(initdir));
+   searchdir[0] = '\0';
+   fullfname[0] = '\0';
+@@ -277,6 +306,18 @@
+   tiffW = (Window) NULL;  tiffUp = 0;
+ #endif
+ 
++#ifdef HAVE_PIC2
++  pic2W = (Window) NULL;  pic2Up = 0;
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++  pcdW = (Window) NULL;  pcdUp = 0;
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++  mgcsfxW = (Window) NULL;  mgcsfxUp = 0;
++#endif /* HAVE_MGCSFX */
++
+   imap = ctrlmap = gmap = browmap = cmtmap = 0;
+ 
+   ch_offx = ch_offy = p_offx = p_offy = 0;
+@@ -300,6 +341,10 @@
+   /* handle user-specified resources and cmd-line arguments */
+   parseResources(argc,argv);
+   parseCmdLine(argc, argv);
++#ifdef AUTO_EXPAND
++  Vdinit();
++  vd_handler_setup();
++#endif
+   verifyArgs();
+ 
+ 
+@@ -649,7 +694,62 @@
+   }
+ 
+   monofont=monofinfo->fid;
+-  
++
++#ifdef TV_L10N  
++  if (xlocale) {
++    i = 0;
++    while (mfontsize[i]) {
++      xlocale = 1;	/* True */
++
++      sprintf(mfontset, TV_FONTSET, mfontsize[i]);
++/*fprintf(stderr, "FontSet: %s\n", mfontset);*/
++
++      monofset = XCreateFontSet(theDisp, mfontset,
++				&misscharset, &nmisscharset, &defstr);
++#  if 0	/* not useful */
++      if (!monofset) {
++	/* the current locale is not supported */
++/*fprintf(stderr, "Current locale `%s' is not supported.\n", localeList[i]);*/
++	xlocale = 0;
++	break;
++      }
++#  endif
++/*fprintf(stderr, "# of misscharset in mfontsize[%d]: %d\n", i,nmisscharset);*/
++
++      for (j = 0; j < nmisscharset; j++) {
++	if (!strncmp(misscharset[j], "jisx0208", 8)) {
++	  /* font for JIS X 0208 is not found */
++	  xlocale = 0;
++	  break;
++	}
++      }
++
++      if (xlocale) {
++	monofsetinfo = XExtentsOfFontSet(monofset);
++	monofsetinfo->max_logical_extent.width = mfontsize[i];
++		/* correct size of TextViewer
++		   in case that JIS X 0208 is not found */
++	break;
++      }
++
++      i++;
++    } /* while (mfontsize[i]) */
++
++#  if 0
++    if (nmisscharset > 0) {
++      sprintf(str,"missing %d charset:\n", nmisscharset);
++      for (i = 0; i < nmisscharset; i++) {
++	sprintf(str, "%s\t%s\n", str, misscharset[i]);
++      }
++#    if 0
++      FatalError(str);
++#    else
++      fprintf(stderr, "%s", str);
++#    endif
++    }
++#  endif
++  }
++#endif	/* TV_L10N */
+ 
+   
+   
+@@ -782,7 +882,21 @@
+   XSetTransientForHint(theDisp, tiffW, dirW);
+ #endif
+   
+-  
++#ifdef HAVE_PIC2
++  CreatePIC2W();
++  XSetTransientForHint(theDisp, pic2W, dirW);
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++  CreatePCDW();
++  XSetTransientForHint(theDisp, pcdW, dirW);
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++  CreateMGCSFXW();
++  XSetTransientForHint(theDisp, mgcsfxW, dirW);
++#endif /* HAVE_MGCSFX */
++
+   LoadFishCursors();
+   SetCursors(-1);
+   
+@@ -1096,17 +1210,32 @@
+   if (rd_flag("infoMap"))        imap        = def_int;
+   if (rd_flag("loadBrowse"))     browseMode  = def_int;
+   if (rd_str ("lowlight"))       lostr       = def_str;
++#ifdef MACBINARY
++  if (rd_flag("macbinary"))      handlemacb  = def_int;
++#endif
++#ifdef HAVE_MGCSFX
++  if (rd_flag("mgcsfx"))         mgcsfx      = def_int;
++#endif /* HAVE_MGCSFX */
+   if (rd_flag("mono"))           mono        = def_int;
+   if (rd_str ("monofont"))       monofontname = def_str;
+   if (rd_int ("ncols"))          ncols       = def_int;
+   if (rd_flag("ninstall"))       ninstall    = def_int;
+   if (rd_flag("nodecor"))        nodecor     = def_int;
+   if (rd_flag("nolimits"))       nolimits    = def_int;
++#ifdef HAVE_MGCSFX
++  if (rd_flag("nomgcsfx"))       nomgcsfx    = def_int;
++#endif /* HAVE_MGCSFX */
++#if defined(HAVE_PIC) || defined(HAVE_PIC2)
++  if (rd_flag("nopicadjust"))    nopicadjust = def_int;
++#endif /* HAVE_PIC || HAVE_PIC2 */
+   if (rd_flag("nopos"))          nopos       = def_int;
+   if (rd_flag("noqcheck"))       noqcheck    = def_int;
+   if (rd_flag("nostat"))         nostat      = def_int;
+   if (rd_flag("ownCmap"))        owncmap     = def_int;
+   if (rd_flag("perfect"))        perfect     = def_int;
++#ifdef HAVE_PIC2
++  if (rd_flag("pic2split"))      pic2split   = def_int;
++#endif /* HAVE_PIC2 */
+   if (rd_flag("popupKludge"))    winCtrPosKludge = def_int;
+   if (rd_str ("print"))          strncpy(printCmd, def_str, 
+ 					 (size_t) PRINTCMDLEN);
+@@ -1124,6 +1253,9 @@
+   if (rd_str ("textviewGeometry")) textgeom  = def_str;
+   if (rd_flag("useStdCmap"))     stdcmap     = def_int;
+   if (rd_str ("visual"))         visualstr   = def_str;
++#ifdef VS_ADJUST
++  if (rd_flag("vsadjust"))       vsadjust    = def_int;
++#endif /* VS_ADJUST */
+   if (rd_flag("vsDisable"))      novbrowse   = def_int;
+   if (rd_str ("vsGeometry"))     browgeom    = def_str;
+   if (rd_flag("vsMap"))          browmap     = def_int;
+@@ -1158,7 +1290,13 @@
+       }
+ 
+       if (numnames<MAXNAMES) {
++#ifdef AUTO_EXPAND
++	if(Isarchive(argv[i]) == 0){ /* Not archive file */
++	  namelist[numnames++] = argv[i];
++	}
++#else
+ 	namelist[numnames++] = argv[i];
++#endif
+ 	if (numnames==MAXNAMES) {
+ 	  fprintf(stderr,"%s: too many filenames.  Only using first %d.\n",
+ 		  cmd, MAXNAMES);
+@@ -1339,10 +1477,18 @@
+     if (!argcmp(argv[i],"-max",4,1,&automax));	        /* auto maximize */
+     else if (!argcmp(argv[i],"-maxpect",5,1,&pm))       /* auto maximize */
+       { automax=pm; fixedaspect=pm; }
++
++#ifdef MACBINARY
++    else if (!argcmp(argv[i],"-macbinary",3,1,&handlemacb)); /* macbinary */
++#endif
+     
+     else if (!argcmp(argv[i],"-mfn",3,0,&pm))           /* mono font name */
+       { if (++i<argc) monofontname = argv[i]; }
+ 
++#ifdef HAVE_MGCSFX
++    else if (!argcmp(argv[i],"-mgcsfx", 4,1,&mgcsfx));  /* mgcsfx */
++#endif /* HAVE_MGCSFX */
++
+     else if (!argcmp(argv[i],"-mono",3,1,&mono));	/* mono */
+     
+     else if (!argcmp(argv[i],"-name",3,0,&pm))          /* name */
+@@ -1355,13 +1501,26 @@
+     else if (!argcmp(argv[i],"-nodecor",   4,1,&nodecor));
+     else if (!argcmp(argv[i],"-nofreecols",4,1,&noFreeCols));
+     else if (!argcmp(argv[i],"-nolimits",  4,1,&nolimits));   /* nolimits */
++#ifdef HAVE_MGCSFX
++    else if (!argcmp(argv[i],"-nomgcsfx", 4,1,&nomgcsfx));    /* nomgcsfx */
++#endif /* HAVE_MGCSFX */
++#if defined(HAVE_PIC) || defined(HAVE_PIC2)
++    else if (!argcmp(argv[i],"-nopicadjust", 4,1,&nopicadjust));/*nopicadjust*/
++#endif /* HAVE_PIC || HAVE_PIC2 */
+     else if (!argcmp(argv[i],"-nopos",     4,1,&nopos));      /* nopos */
+     else if (!argcmp(argv[i],"-noqcheck",  4,1,&noqcheck));   /* noqcheck */
+     else if (!argcmp(argv[i],"-noresetroot",5,1,&resetroot)); /* reset root*/
+     else if (!argcmp(argv[i],"-norm",      5,1,&autonorm));   /* norm */
+     else if (!argcmp(argv[i],"-nostat",    4,1,&nostat));     /* nostat */
+     else if (!argcmp(argv[i],"-owncmap",   2,1,&owncmap));    /* own cmap */
++#ifdef HAVE_PCD
++    else if (!argcmp(argv[i],"-pcd",       3,0,&pm))    /* pcd with size */
++	{ if (++i<argc) PcdSize = atoi(argv[i]); }
++#endif /* HAVE_PCD */
+     else if (!argcmp(argv[i],"-perfect",   3,1,&perfect));    /* -perfect */
++#ifdef HAVE_PIC2
++    else if (!argcmp(argv[i],"-pic2split", 3,1,&pic2split));  /* pic2split */
++#endif /* HAVE_PIC2 */
+     else if (!argcmp(argv[i],"-pkludge",   3,1,&winCtrPosKludge));
+     else if (!argcmp(argv[i],"-poll",      3,1,&polling));    /* chk mod? */
+ 
+@@ -1415,6 +1574,10 @@
+     else if (!argcmp(argv[i],"-visual",4,0,&pm))           /* visual */
+       { if (++i<argc) visualstr = argv[i]; }
+     
++#ifdef VS_ADJUST
++    else if (!argcmp(argv[i],"-vsadjust", 3,1,&vsadjust));  /* vsadjust */
++#endif /* VS_ADJUST */
++
+     else if (!argcmp(argv[i],"-vsdisable",4,1,&novbrowse)); /* disable sch? */
+     
+     else if (!argcmp(argv[i],"-vsgeometry",4,0,&pm))	/* visSchnauzer geom */
+@@ -1453,7 +1616,11 @@
+   /* check options for validity */
+ 
+   if (strlen(searchdir)) {  /* got a search directory */
++#ifdef AUTO_EXPAND
++    if (Chvdir(searchdir)) {
++#else
+     if (chdir(searchdir)) {
++#endif
+       fprintf(stderr,"xv: unable to cd to directory '%s'.\n",searchdir);
+       fprintf(stderr,
+        "    Ignoring '-dir' option and/or 'xv.searchDirectory' resource\n");
+@@ -1600,9 +1767,15 @@
+   printoption("[-/+lbrowse]");
+   printoption("[-lo color]");
+   printoption("[-/+loadclear]");
++#ifdef MACBINARY
++  printoption("[-/+macbinary]");
++#endif
+   printoption("[-/+max]");
+   printoption("[-/+maxpect]");
+   printoption("[-mfn font]");
++#ifdef HAVE_MGCSFX
++  printoption("[-/+mgcsfx]");
++#endif /* HAVE_MGCSFX */
+   printoption("[-/+mono]");
+   printoption("[-name str]");
+   printoption("[-ncols #]");
+@@ -1610,13 +1783,25 @@
+   printoption("[-/+nodecor]");
+   printoption("[-/+nofreecols]");
+   printoption("[-/+nolimits]");
++#ifdef HAVE_MGCSFX
++  printoption("[-/+nomgcsfx]");
++#endif /* HAVE_MGCSFX */
++#if defined(HAVE_PIC) || defined(HAVE_PIC2)
++  printoption("[-/+nopicadjust]");
++#endif /* HAVE_PIC || HAVE_PIC2 */
+   printoption("[-/+nopos]");
+   printoption("[-/+noqcheck]");
+   printoption("[-/+noresetroot]");
+   printoption("[-/+norm]");
+   printoption("[-/+nostat]");
+   printoption("[-/+owncmap]");
++#ifdef HAVE_PCD
++  printoption("[-pcd size]");
++#endif /* HAVE_PCD */
+   printoption("[-/+perfect]");
++#ifdef HAVE_PIC2
++  printoption("[-/+pic2split]");
++#endif /* HAVE_PIC2 */
+   printoption("[-/+pkludge]");
+   printoption("[-/+poll]");
+   printoption("[-preset #]");
+@@ -1640,6 +1825,9 @@
+   printoption("[-/+vflip]");
+   printoption("[-/+viewonly]");
+   printoption("[-visual type]");
++#ifdef VS_ADJUST
++  printoption("[-/+vsadjust]");
++#endif /* VS_ADJUST */
+   printoption("[-/+vsdisable]");
+   printoption("[-vsgeometry geom]");
+   printoption("[-/+vsmap]");
+@@ -1723,6 +1911,10 @@
+   char *fullname,       /* full name of the original file */
+         filename[512],  /* full name of file to load (could be /tmp/xxx)*/
+         globnm[512];    /* globbed version of fullname of orig file */
++#ifdef MACBINARY
++  char origname[512];	/* file name of original file (NO processing) */
++  origname[0] = '\0';
++#endif
+ 
+   xvbzero((char *) &pinfo, sizeof(PICINFO));
+ 
+@@ -1855,8 +2047,22 @@
+       frompipe = 1;
+     }
+   }
++#ifdef AUTO_EXPAND
++  else {
++    fullname = (char *) malloc(MAXPATHLEN+2);
++    strcpy(fullname, namelist[filenum]);
++    freename = 1;
++  }
++  tmp = (char *) rindex(fullname, '/');
++  if (tmp) {
++      *tmp = '\0';
++      Mkvdir(fullname);
++      *tmp = '/';
++  }
++  Dirtovd(fullname);
++#else
+   else fullname = namelist[filenum];
+-
++#endif
+ 
+   strcpy(fullfname, fullname);
+   tmp = BaseName(fullname);
+@@ -1991,6 +2197,12 @@
+   filetype = ReadFileType(filename);
+ 
+ 
++#ifdef HAVE_MGCSFX
++  if (mgcsfx && filetype == RFT_UNKNOWN){ /* force use MgcSfx */
++    if(getInputCom() != 0) filetype = RFT_MGCSFX;
++  }
++#endif /* HAVE_MGCSFX */
++
+   if (filetype == RFT_COMPRESS) {   /* a compressed file.  uncompress it */
+     char tmpname[128];
+ 
+@@ -2014,6 +2226,51 @@
+     WaitCursor();
+   }
+ 
++#ifdef MACBINARY
++  if (handlemacb && macb_file == True) {
++    char tmpname[128];
++
++    if (RemoveMacbinary(filename, tmpname)) {
++      if (strcmp(fullname,filename)!=0) unlink(filename);
++      strcpy(origname, filename);
++      strcpy(filename, tmpname);
++    }
++    else filetype = RFT_ERROR;
++
++    WaitCursor();
++  }
++#endif
++
++#ifdef HAVE_MGCSFX_AUTO
++  if(filetype == RFT_MGCSFX){
++      char tmpname[128], tmp[256];
++      char *icom;
++
++      if((icom = mgcsfx_auto_input_com(filename)) != NULL){
++	sprintf(tmpname, "%s/xvmsautoXXXXXX", tmpdir);
++	mktemp(tmpname);
++	SetISTR(ISTR_INFO, "Converting to known format by MgcSfx auto...");
++	sprintf(tmp,"%s >%s", icom, tmpname);
++      }else goto ms_auto_no;
++
++#ifndef VMS
++      if (system(tmp)) {
++#else
++      if (!system(tmp)) {
++#endif
++        SetISTR(ISTR_INFO, "Unable to convert '%s' by MgcSfx auto.", BaseName(filename
++));
++        Warning();
++	filetype = RFT_ERROR;
++        goto ms_auto_no;
++      }
++
++      filetype = ReadFileType(tmpname);
++      if (strcmp(fullname,filename)!=0) unlink(filename);
++      strcpy(filename, tmpname);
++  }
++ms_auto_no:
++#endif /* HAVE_MGCSFX_AUTO */
+ 
+   if (filetype == RFT_ERROR) {
+     char  foostr[512];
+@@ -2027,7 +2284,12 @@
+ 
+   if (filetype == RFT_UNKNOWN) {
+     /* view as a text/hex file */
+-    TextView(filename);
++#ifdef MACBINARY
++    if (origname[0])
++      TextView(origname);
++    else
++#endif
++      TextView(filename);
+     SetISTR(ISTR_INFO,"'%s' not in a recognized format.", basefname);
+     /* Warning();  */
+     goto SHOWN_AS_TEXT;
+@@ -2540,6 +2802,9 @@
+   FILE *fp;
+   byte  magicno[30];    /* first 30 bytes of file */
+   int   rv, n;
++#ifdef MACBINARY
++  int macbin_alrchk = False;
++#endif
+ 
+   if (!fname) return RFT_ERROR;   /* shouldn't happen */
+ 
+@@ -2553,12 +2818,29 @@
+ 
+   rv = RFT_UNKNOWN;
+ 
++#ifdef MACBINARY
++  macb_file = False;
++  while (1) {
++#endif
++
++#ifdef HAVE_MGCSFX
++  if(is_mgcsfx(fname, magicno, 30) != 0) rv = RFT_MGCSFX;
++
++  else if (strncmp((char *) magicno,"GIF87a", (size_t) 6)==0 ||
++      strncmp((char *) magicno,"GIF89a", (size_t) 6)==0)        rv = RFT_GIF;
++#else
+   if (strncmp((char *) magicno,"GIF87a", (size_t) 6)==0 ||
+       strncmp((char *) magicno,"GIF89a", (size_t) 6)==0)        rv = RFT_GIF;
++#endif /* HAVE_MGCSFX */
+ 
+   else if (strncmp((char *) magicno,"VIEW", (size_t) 4)==0 ||
+ 	   strncmp((char *) magicno,"WEIV", (size_t) 4)==0)     rv = RFT_PM;
+ 
++#ifdef HAVE_PIC2
++  else if (magicno[0]=='P' && magicno[1]=='2'
++	   &&magicno[2]=='D'&&magicno[3]=='T')		rv = RFT_PIC2;
++#endif /* HAVE_PIC2 */
++
+   else if (magicno[0] == 'P' && magicno[1]>='1' && 
+ 	   magicno[1]<='6')                             rv = RFT_PBM;
+ 
+@@ -2625,6 +2907,49 @@
+ 	   strncmp((char *) magicno, "\004%!", (size_t) 3)==0)   rv = RFT_PS;
+ #endif
+ 
++#ifdef HAVE_MAG
++  else if (strncmp((char *) magicno,"MAKI02  ", (size_t) 8)==0)  rv = RFT_MAG;
++#endif /* HAVE_MAG */
++
++#ifdef HAVE_MAKI
++  else if (strncmp((char *) magicno,"MAKI01A ", (size_t) 8)==0 ||
++	   strncmp((char *) magicno,"MAKI01B ", (size_t) 8)==0)  rv = RFT_MAKI;
++#endif /* HAVE_MAKI */
++
++#ifdef HAVE_PIC
++  else if (magicno[0]=='P' && magicno[1]=='I'&&magicno[2]=='C') rv = RFT_PIC;
++#endif /* HAVE_PIC */
++
++#ifdef HAVE_PI
++  else if (magicno[0]=='P' && magicno[1]=='i') rv = RFT_PI;
++#endif /* HAVE_PI */
++
++#ifdef HAVE_PCD
++  else if (magicno[0]==0xff && magicno[1]==0xff &&
++           magicno[2]==0xff && magicno[3]==0xff) rv = RFT_PCD;
++#endif /* HAVE_PCD */
++
++#ifdef MACBINARY
++    /* Now, we became handled `MacBinary' files, but it way is VERY dirty... */
++    if (macbin_alrchk == True) {
++      macb_file = True;
++      break;
++    }
++
++    if (rv != RFT_UNKNOWN)
++      break;
++
++    /* Skip MACBSIZE and recheck */
++    macbin_alrchk = True;
++    fp = xv_fopen(fname, "r");
++    if (!fp) return RFT_ERROR;
++    fseek(fp, MACBSIZE, SEEK_SET);
++    n = fread(magicno, (size_t) 1, (size_t) 30, fp);  
++    fclose(fp);
++
++    if (n<30) return RFT_UNKNOWN;    /* files less than 30 bytes long... */
++  }
++#endif
+   return rv;
+ }
+ 
+@@ -2639,7 +2964,8 @@
+   /* if quick is set, we're being called to generate icons, or something
+      like that.  We should load the image as quickly as possible.  Currently,
+      this only affects the LoadPS routine, which, if quick is set, only
+-     generates the page file for the first page of the document */
++     generates the page file for the first page of the document .
++	 Also now affects PCD which now only loads a thumbnail */
+ 
+   int rv = 0;
+ 
+@@ -2650,7 +2976,11 @@
+   switch (ftype) {
+   case RFT_GIF:     rv = LoadGIF   (fname, pinfo);         break;
+   case RFT_PM:      rv = LoadPM    (fname, pinfo);         break;
++#ifdef HAVE_MGCSFX
++  case RFT_PBM:     rv = LoadPBM   (fname, pinfo, -1);     break;
++#else
+   case RFT_PBM:     rv = LoadPBM   (fname, pinfo);         break;
++#endif /* HAVE_MGCSFX */
+   case RFT_XBM:     rv = LoadXBM   (fname, pinfo);         break;
+   case RFT_SUNRAS:  rv = LoadSunRas(fname, pinfo);         break;
+   case RFT_BMP:     rv = LoadBMP   (fname, pinfo);         break;
+@@ -2679,6 +3009,43 @@
+   case RFT_PS:      rv = LoadPS    (fname, pinfo, quick);    break;
+ #endif
+ 
++#ifdef HAVE_MAG
++  case RFT_MAG:     rv = LoadMAG   (fname, pinfo);  break;
++#endif /* HAVE_MAG */
++
++#ifdef HAVE_MAKI
++  case RFT_MAKI:    rv = LoadMAKI  (fname, pinfo);  break;
++#endif /* HAVE_MAKI */
++
++#ifdef HAVE_PIC
++  case RFT_PIC:     rv = LoadPIC   (fname, pinfo);  break;
++#endif /* HAVE_PIC */
++
++#ifdef HAVE_PI
++  case RFT_PI:      rv = LoadPi    (fname, pinfo);  break;
++#endif /* HAVE_PI */
++
++#ifdef HAVE_PIC2
++  case RFT_PIC2:    rv = LoadPIC2  (fname, pinfo, quick);    break;
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++  case RFT_PCD:      
++    if (quick == 1)
++      rv = LoadPCD(fname, pinfo, 0);  
++    else
++      rv = LoadPCD(fname, pinfo, PcdSize);  
++    break;
++
++	/* If quick is switched on use the smallest image size don't ask
++	*	the user.
++	*/
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++  case RFT_MGCSFX:    rv = LoadMGCSFX  (fname, pinfo);    break;
++#endif /* HAVE_MGCSFX */
++
+   }
+   return rv;
+ }
+@@ -2773,6 +3140,44 @@
+   return 1;
+ }
+ 
++
++#ifdef MACBINARY
++/********************************/
++int RemoveMacbinary(src, dst)
++     char *src, *dst;
++{
++  char tmpname[128], buffer[8192]; /* XXX */
++  int n, eof;
++  FILE *sfp, *dfp;
++
++  sprintf(dst, "%s/xvmXXXXXX", tmpdir);
++  mktemp(dst);
++  SetISTR(ISTR_INFO, "Removing MacBinary...");
++
++  sfp = xv_fopen(src, "r"); 
++  dfp = xv_fopen(dst, "w"); 
++  if (!sfp || !dfp) {
++    SetISTR(ISTR_INFO, "Unable to remove a InfoFile header form '%s'.", src);
++    Warning();
++    return 0;
++  }
++  fseek(sfp, MACBSIZE, SEEK_SET);
++  while ((n = fread(buffer, 1, sizeof(buffer), sfp)) == 8192) /* XXX */
++    fwrite(buffer, 1, n, dfp);
++  if (eof = feof(sfp))
++    fwrite(buffer, 1, n, dfp);
++  fclose(sfp);
++  fclose(dfp);
++  if (!eof) {
++    SetISTR(ISTR_INFO, "Unable to remove a InfoFile header form '%s'.", src);
++    Warning();
++    return 0;
++  }
++
++  return 1;
++}
++#endif
++
+ 
+ /********************************/
+ void KillPageFiles(bname, numpages)
+diff -urN xv-3.10a/xv.h xv-3.10a-jp-extension-current/xv.h
+--- xv-3.10a/xv.h	Tue Jan 24 05:22:23 1995
++++ xv-3.10a-jp-extension-current/xv.h	Tue Oct 22 18:17:25 1996
+@@ -8,8 +8,8 @@
+ #include "config.h"
+ 
+ 
+-#define REVDATE   "Version 3.10a  Rev: 12/29/94"
+-#define VERSTR    "3.10a"
++#define REVDATE   "Version 3.10a+jp5.3.3  Rev: 12/29/94"
++#define VERSTR    "3.10a+jp5.3.3"
+ 
+ /*
+  * uncomment the following, and modify for your site, but only if you've
+@@ -68,6 +68,20 @@
+ #  endif
+ #endif
+ 
++#if defined(__sony_news) && defined(bsd43) && !defined(__bsd43)
++#  define __bsd43
++#elif defined(__sony_news) && (defined(SYSTYPE_BSD) || defined(__SYSTYPE_BSD)) && !defined(bsd43) && !defined(__bsd43)
++#  define bsd43
++#  define __bsd43
++#endif
++
++#ifndef __osf__
++#undef SIGCHLD           /* defined in both Xos.h and signal.h */
++#endif /* !__osf__ */
++#include <signal.h>      /* for interrupt handling */
++#ifdef __linux__
++#  define sigmask __sigmask
++#endif
+ 
+ #include <X11/Xos.h>     /* need type declarations immediately */
+ 
+@@ -99,6 +113,16 @@
+ #endif
+ 
+ 
++#if defined(__sony_news) && defined(__bsd43)
++#  include <unistd.h>
++#endif
++
++
++#if defined(__FreeBSD__)
++#  include <sys/param.h>
++#endif
++
++
+ /* include files */
+ #include <stdio.h>
+ #include <math.h>
+@@ -115,7 +139,7 @@
+ #ifndef VMS
+ #  include <errno.h>
+    extern int   errno;             /* SHOULD be in errno.h, but often isn't */
+-#  ifndef __NetBSD__
++#  if !(defined(BSD) && (BSD >= 199103))
+      extern char *sys_errlist[];     /* this too... */
+ #  endif
+ #endif
+@@ -128,7 +152,9 @@
+ #  define ERRSTR(x) strerror(x, vaxc$errno)
+ #endif
+ 
+-
++#ifdef __linux__
++  extern char *strdup PARM((const char *));
++#endif
+ 
+ 
+ #ifdef VMS   /* VMS config, hacks & kludges */
+@@ -157,6 +183,8 @@
+      !defined(pyr)                       && \
+      !defined(__UMAXV__)                 && \
+      !defined(bsd43)                     && \
++     !defined(__bsd43)                   && \
++     !(defined(BSD) && (BSD >= 199103))  && \
+      !defined(aux)                       && \
+      !defined(__bsdi__)                  && \
+      !defined(sequent)
+@@ -179,9 +207,10 @@
+ #include <X11/Xatom.h>
+ #include <X11/Xmd.h>
+ 
++#ifdef TV_L10N
++#  include <X11/Xlocale.h>
++#endif
+ 
+-#undef SIGCHLD           /* defined in both Xos.h and signal.h */
+-#include <signal.h>      /* for interrupt handling */
+ 
+ #include <sys/types.h>
+ 
+@@ -314,6 +343,9 @@
+ #  endif
+ #endif
+ 
++#if (defined(SYSV) || defined(SVR4)) && !defined(USE_GETCWD)
++#  define USE_GETCWD
++#endif
+ 
+ /*****************************/
+ /* END OF CONFIGURATION INFO */
+@@ -458,6 +490,45 @@
+ #define F_TIFINC  0
+ #endif
+ 
++#ifdef HAVE_MAG
++#define F_MAGINC  1
++#else
++#define F_MAGINC  0
++#endif /* HAVE_MAG */
++
++#ifdef HAVE_PIC
++#define F_PICINC  1
++#else
++#define F_PICINC  0
++#endif /* HAVE_PIC */
++
++#ifdef HAVE_MAKI
++#define F_MAKINC  1
++#else
++#define F_MAKINC  0
++#endif /* HAVE_MAKI */
++
++#ifdef HAVE_PI
++#define F_PAIINC  1
++#else
++#define F_PAIINC  0
++#endif /* HAVE_PI */
++
++#ifdef HAVE_PIC2
++#define F_PC2INC  1
++#else
++#define F_PC2INC  0
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_MGCSFX
++#define F_MGCSFXINC  1
++#else
++#define F_MGCSFXINC  0
++#endif /* HAVE_MGCSFX */
++
++#ifdef MACBINARY
++#define MACBSIZE 128
++#endif
+ 
+ #define F_GIF         0
+ #define F_JPEG      ( 0 + F_JPGINC)
+@@ -473,9 +544,17 @@
+ #define F_TARGA     ( 9 + F_JPGINC + F_TIFINC)
+ #define F_FITS      (10 + F_JPGINC + F_TIFINC)
+ #define F_PM        (11 + F_JPGINC + F_TIFINC)
+-#define F_DELIM1    (12 + F_JPGINC + F_TIFINC)     /* ----- */
+-#define F_FILELIST  (13 + F_JPGINC + F_TIFINC)
+-#define F_MAXFMTS   (14 + F_JPGINC + F_TIFINC)     /* 15, normally */
++#define JP_EXT_F    (F_PM)
++#define F_MAG       (JP_EXT_F + F_MAGINC)
++#define F_PIC       (JP_EXT_F + F_MAGINC + F_PICINC)
++#define F_MAKI      (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC)
++#define F_PI        (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC)
++#define F_PIC2      (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC + F_PC2INC)
++#define F_MGCSFX    (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC + F_PC2INC + F_MGCSFXINC)         /* ----- */
++#define JP_EXT_F_END  (F_MGCSFX)
++#define F_DELIM1    (JP_EXT_F_END + 1)
++#define F_FILELIST  (JP_EXT_F_END + 2)
++#define F_MAXFMTS   (JP_EXT_F_END + 3)     /* 16, normally */
+ 
+ 
+ 
+@@ -505,6 +584,14 @@
+ #define RFT_XPM      17
+ #define RFT_XWD      18
+ #define RFT_FITS     19
++#define JP_EXT_RFT   (RFT_FITS)
++#define RFT_MAG      (JP_EXT_RFT + 1)
++#define RFT_MAKI     (JP_EXT_RFT + 2)
++#define RFT_PIC      (JP_EXT_RFT + 3)
++#define RFT_PI       (JP_EXT_RFT + 4)
++#define RFT_PIC2     (JP_EXT_RFT + 5)
++#define RFT_PCD      (JP_EXT_RFT + 6)
++#define RFT_MGCSFX   (JP_EXT_RFT + 7)
+ 
+ /* definitions for page up/down, arrow up/down list control */
+ #define LS_PAGEUP   0
+@@ -942,6 +1029,10 @@
+ WHERE u_long        blkRGB, whtRGB;
+ WHERE Font          mfont, monofont;
+ WHERE XFontStruct   *mfinfo, *monofinfo;
++#ifdef TV_L10N
++WHERE XFontSet      monofset;
++WHERE XFontSetExtents *monofsetinfo;
++#endif
+ WHERE Visual        *theVisual;
+ WHERE Cursor        arrow, cross, tcross, zoom, inviso;
+ WHERE Pixmap        iconPix, iconmask;
+@@ -960,6 +1051,10 @@
+ WHERE int            picType;               /* CONV24_8BIT,CONV24_24BIT,etc.*/
+ WHERE char          *picComments;           /* text comments on current pic */
+ 
++#ifdef TV_L10N
++WHERE int            xlocale;		    /* true if Xlib supports locale */
++#endif
++
+ WHERE int            numPages, curPage;     /* for multi-page files */
+ WHERE char           pageBaseName[64];      /* basename for multi-page files */
+ 
+@@ -993,6 +1088,23 @@
+ WHERE unsigned long  cols[256];    /* maps pic pixel values to X pixel vals */
+ WHERE int            fc2pcol[256]; /* maps freecols into pic pixel values */
+ WHERE int            numcols;      /* # of desired colors in picture */
++#ifdef MACBINARY
++WHERE char           macb_file;    /* True if this file type is MacBinary */
++WHERE int            handlemacb;   /* True if we want to handle MacBinary */
++#endif /* MACBINARY */
++#if defined(HAVE_PIC) || defined(HAVE_PIC2)
++WHERE int            nopicadjust;  /* True if we don't want to adjust aspect */
++#endif /* HAVE_PIC || HAVE_PIC2 */
++#ifdef HAVE_PIC2
++WHERE int            pic2split;    /* True if we want to split multiblocks */
++#endif /* HAVE_PIC2 */
++#ifdef VS_ADJUST
++WHERE int            vsadjust; /* True if we want to adjust aspect of icons */
++#endif /* VS_ADJUST */
++#ifdef HAVE_MGCSFX
++WHERE int            mgcsfx;    /* True if we want to force use MgcSfx */
++WHERE int            nomgcsfx;  /* True if we don't want to use MgcSfx */
++#endif /* HAVE_MGCSFX */
+ 
+ /* Std Cmap stuff */
+ WHERE byte           stdr[256], stdg[256], stdb[256];  /* std 3/3/2 cmap */
+@@ -1153,6 +1265,77 @@
+ WHERE int           tiffUp;       /* is tiffW mapped, or what? */
+ #endif
+ 
++#ifdef HAVE_PIC2
++/* stuff used for 'pic2' box */
++WHERE Window        pic2W;
++WHERE int           pic2Up;      /* is pic2W mapped, or what? */
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++/* stuff used for 'pcd' box */
++WHERE Window        pcdW;
++WHERE int           pcdUp;       /* is pcdW mapped, or what? */
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++/* stuff used for 'mgcsfx' box */
++WHERE Window        mgcsfxW;
++WHERE Window        mgcsfxNameW;
++WHERE int           mgcsfxUp;      /* is mgcsfxW mapped, or what? */
++#endif /* HAVE_MGCSFX */
++
++#ifdef TV_L10N
++/* stuff used for TextViewer Japanization */
++#  define LOCALE_USASCII    0
++#  define LOCALE_EUCJ       1
++#  define LOCALE_JIS        2
++#  define LOCALE_MSCODE     3
++
++#  ifndef LOCALE_DEFAULT
++#    define LOCALE_DEFAULT  0
++#  endif /* !LOCALE_DEFAULT */
++
++#  ifndef MAIN
++     extern char *localeList[];
++#  else
++#    ifndef LOCALE_NAME_EUC
++#      ifndef X_LOCALE
++#        if defined(__FreeBSD__)
++	   char *localeList[] = {"", "ja_JP.EUC", "none", "none"};
++#        elif defined(__sun) || defined(sun)
++	   char *localeList[] = {"", "ja", "none", "none"};
++#        elif defined(__sgi)	/* sgi, __sgi, __sgi__ (gcc) */
++	   char *localeList[] = {"", "ja_JP.EUC", "none", "none"};
++#        elif defined(sony_news)
++	   char *localeList[] = {"", "ja_JP.EUC", "none", "ja_JP.SJIS"};
++#        elif defined(nec)
++	   char *localeList[] = {"", "japan", "none", "none"};
++#        elif defined(__hpux)
++	   char *localeList[] = {"", "japanese.euc", "none", "japanese"};
++#        elif defined(__osf__)
++	   char *localeList[] = {"", "ja_JP.deckanji", "none", "ja_JP.SJIS"};
++#        elif defined(_AIX)
++	   char *localeList[] = {"", "ja_JP", "none", "Ja_JP" };
++#        elif defined(__bsdi)
++	   char *localeList[] = {"", "Japanese-EUC", "none", "none" };
++#        else
++	   char *localeList[] = {"", "ja_JP.EUC", "ja_JP.JIS", "ja_JP.SJIS"};
++#        endif
++#      else
++#        if (XlibSpecificationRelease > 5)
++           char *localeList[] = {"", "ja_JP.eucJP", "ja_JP.JIS7",
++				 "ja_JP.SJIS"};
++#        else
++           char *localeList[] = {"", "ja_JP.ujis", "ja_JP.jis7",
++				 "ja_JP.mscode"};
++#        endif
++#      endif /* X_LOCALE */
++#    else
++       char *localeList[] = {"", LOCALE_NAME_EUC,
++			     LOCALE_NAME_JIS, LOCALE_NAME_MSCODE};
++#    endif /* LOCALE_NAME_EUC */
++#  endif /* MAIN */
++#endif /* TV_L10N */
+ 
+ #undef WHERE
+ 
+@@ -1165,6 +1348,9 @@
+ int   ReadPicFile       PARM((char *, int, PICINFO *, int));
+ int   UncompressFile    PARM((char *, char *));
+ void  KillPageFiles     PARM((char *, int));
++#ifdef MACBINARY
++int   RemoveMacbinary   PARM((char *, char *));
++#endif
+ 
+ void NewPicGetColors    PARM((int, int));
+ void FixAspect          PARM((int, int *, int *));
+@@ -1392,6 +1578,9 @@
+ int  CheckPoll             PARM((int));
+ void DIRDeletedFile        PARM((char *));
+ void DIRCreatedFile        PARM((char *));
++FILE *pic2_OpenOutFile     PARM((char *, int *));
++void pic2_KillNullFile     PARM((FILE *));
++int  OpenOutFileDesc       PARM((char *));
+ 
+ 
+ /*************************** XVBROWSE.C ************************/
+@@ -1429,6 +1618,8 @@
+ int  TextCheckEvent        PARM((XEvent *, int *, int *));
+ int  TextDelWin            PARM((Window));
+ 
++int  CharsetCheckEvent     PARM((XEvent *));
++int  CharsetDelWin         PARM((Window));
+ 
+ 
+ /**************************** XVGAM.C **************************/
+@@ -1548,7 +1739,11 @@
+ 				 byte *, byte *, int, int, char *));
+ 
+ /**************************** XVPBM.C ***************************/
++#ifdef HAVE_MGCSFX
++int LoadPBM                PARM((char *, PICINFO *, int));
++#else
+ int LoadPBM                PARM((char *, PICINFO *));
++#endif /* HAVE_MGCSFX */
+ int WritePBM               PARM((FILE *, byte *, int, int, int, byte *, 
+ 				 byte *, byte *, int, int, int, char *));
+ 
+@@ -1624,6 +1819,71 @@
+ void  PSResize             PARM((void));
+ int   LoadPS               PARM((char *, PICINFO *, int));
+ 
++/*************************** XVMAG.C ***************************/
++int   LoadMAG              PARM((char *, PICINFO *));
++int   WriteMAG             PARM((FILE *, byte *, int, int, int, 
++				 byte *, byte *, byte *, int, int, char *));
++
++/*************************** XVMAKI.C ***************************/
++int   LoadMAKI             PARM((char *, PICINFO *));
++int   WriteMAKI            PARM((FILE *, byte *, int, int, int, 
++				 byte *, byte *, byte *, int, int));
++
++/*************************** XVPIC.C ***************************/
++int   LoadPIC              PARM((char *, PICINFO *));
++int   WritePIC             PARM((FILE *, byte *, int, int, int, 
++				 byte *, byte *, byte *, int, int, char *));
++
++/*************************** XVPI.C ***************************/
++int   LoadPi               PARM((char *, PICINFO *));
++int   WritePi              PARM((FILE *, byte *, int, int, int, 
++				 byte *, byte *, byte *, int, int, char *));
++
++/*************************** XVPIC2.C ***************************/
++int   LoadPIC2             PARM((char *, PICINFO *, int));
++void  CreatePIC2W          PARM((void));
++void  PIC2Dialog           PARM((int));
++int   PIC2CheckEvent       PARM((XEvent *));
++int   PIC2SetParamOptions  PARM((char *));
++
++/**************************** XVPCD.C ***************************/
++int   LoadPCD              PARM((char *, PICINFO *,int));
++void  CreatePCDW           PARM((void));
++void  PCDDialog            PARM((int));
++int   PCDCheckEvent        PARM((XEvent *));
++void  PCDSetParamOptions   PARM((char *));
++
++/*************************** XVMGCSFX.C ***************************/
++int   is_mgcsfx             PARM((char *, unsigned char *, int));
++char *mgcsfx_auto_input_com PARM((char *));
++int   LoadMGCSFX            PARM((char *, PICINFO *));
++void  CreateMGCSFXW         PARM((void));
++void  MGCSFXDialog          PARM((int));
++int   MGCSFXCheckEvent      PARM((XEvent *));
++int   MGCSFXSaveParams      PARM((char *, int));
++
++int getInputCom             PARM((void));
++int getOutputCom            PARM((void));
++
++/**************************** XVVD.C ****************************/
++void  Vdinit               PARM((void));
++void  Vdsettle             PARM((void));
++int   Chvdir               PARM((char *));
++void  Dirtovd              PARM((char *));
++void  Vdtodir              PARM((char *));
++void  Dirtosubst           PARM((char *));
++int   Mkvdir               PARM((char *));
++void  Mkvdir_force         PARM((char *));
++int   Rmvdir               PARM((char *));
++int   Movevdir             PARM((char *, char *));
++int   Isarchive            PARM((char *));
++int   Isvdir               PARM((char *));
++void  vd_HUPhandler        PARM((void));
++void  vd_handler           PARM((int));
++int   vd_Xhandler          PARM((Display *, XErrorEvent *));
++int   vd_XIOhandler        PARM((Display *));
++void  vd_handler_setup     PARM((void));
++
+ /*************************** XVPOPUP.C ***************************/
+ void  CenterMapWindow      PARM((Window, int, int, int, int));
+ int   PopUp                PARM((char *, char **, int));
+@@ -1677,3 +1937,13 @@
+ void CoordP2E              PARM((int, int, int *, int *));
+ void CoordE2P              PARM((int, int, int *, int *));
+ 
++#if defined(__mips) && defined(__SYSTYPE_BSD43)
++# define strstr(A,B) pds_strstr((A),(B))
++# undef S_IFIFO
++#endif /* !mips_bsd */
++
++#ifndef SEEK_SET
++#define SEEK_SET 0
++#define SEEK_CUR 1
++#define SEEK_END 2
++#endif
+diff -urN xv-3.10a/xv_mgcsfx.sample xv-3.10a-jp-extension-current/xv_mgcsfx.sample
+--- xv-3.10a/xv_mgcsfx.sample
++++ xv-3.10a-jp-extension-current/xv_mgcsfx.sample	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,125 @@
++#/*
++# Configuration file for XV with recognition of 'Magic and Suffix'
++#
++#
++# $Id: xv_mgcsfx.sample,v 1.11 95/10/03 17:00:05 tin329 Exp Locker: tin329 $
++#
++# Author: Tetsuya INOUE  <tin329@chino.it.okayama-u.ac.jp>
++#
++#
++# MgcSfx definition should write in one line.
++#  Format:
++#      <desc>:<ms type>:<ofs>:<magic>:<suffix>:<in it>:<in c>:<out it>:<out c>
++#  If you decide to not use preprocessor, comment style is allowed.
++#      # <comment>
++#
++#   <desc>            Description of your recognized image format.
++#   <ms type>         Type ID for recognition. (You should use 'magic'.)
++#                        * magic        Data of string style.
++#                                        `\' escape for special characters:
++#                                           \b \f \n \r \t \v \\ \' \" \a \?
++#                                           \0  ...\377   octal value
++#                                           \x0 ...\xff   hexadecimal value
++#                        * suffix       Suffix of file name.
++#                                         This type check <suffix> instead
++#                                         of <magic>.
++#                        * [b|l]eint16  2 byte integer of [big|little] endian.
++#                        * [b|l]eint32  4 byte integer of [big|little] endian.
++#   <ofs>             Offset of magic number in the target image file.
++#   <magic>           Data(magic number) of <ms type> to match at <ofs>.
++#   <suffix>          Suffix of filename with '.'start.
++#
++#   <in it>           Input image format type (output from <in c>).
++#                        * PNM       (PPM, PGM, PBM)
++#                        * AUTO      Recognized by xv management, and load.
++#                                    This is different from others, because
++#                                    this write file to temporary.
++#   <out it>          Output image format type (input to <out c>).
++#                        * PNM_RAW   (PPM_RAW, PGM_RAW, PBM_RAW)
++#                        * PNM_ASCII (PPM_ASCII, PGM_ASCII, PBM_ASCII)
++#
++#   <in c>            Command to get the input image.
++#                        * Command mast read stdin or file(specified by
++#                          argument), and write to stdout.
++#                        * Use %s to represent the file name. Without %s,
++#                          get file on stdin.
++#   <out c>           Command to put the output image.
++#                        * Command mast read stdin and write to stdout.
++#
++#   <comment>         Any message.
++#*/
++
++#/*############################################################################
++#
++# definition of the rule with Magic and Suffix
++#
++#*/
++
++# /* Canon View Station Image Format */
++ViewStation(std):magic:0:VsStdImf V0.2:.vs:PNM:VStopnm %s:PNM_RAW:pnmtoVS
++ViewStation(obj):magic:0:VsObjFormat V1.0:.vs:PNM:VSobjtopnm -:PNM_RAW:pnmtoVSobj
++
++# /* CERN httpd cache */
++# /* unchc skip header of CERN httpd cache file, and write data to stdout. */
++CERN httpd cache:magic:0:HTTP/1.0::AUTO:unchc %s::
++
++# /* XLD4(Q4) image format */
++XLD(Q4):magic:11:MAJYO:.q4:PNM:q4toppm::
++
++# /* ML1 image format */
++ML1:magic:0:\1\0\0\x1a:.ml1:PNM:ml1toppm %s::
++
++# /* Pict image format, 256 color only */
++PICT:suffix:::.pict:PNM:picttoppm:PNM_RAW:ppmquant 256 | ppmtopict 
++PICT(gzip):suffix:::.pict.gz:PNM:gzip -dc | picttoppm:PNM_RAW:ppmquant 256 | ppmtopict | gzip
++PICT(compress):suffix:::.pict.Z:PNM:compress -dc | picttoppm:PNM_RAW:ppmquant 256 | ppmtopict | compress
++
++# /* Tim image format(used by SONY PlayStation) */
++TIM:magic:0:\x10\x00\x00\x00:.tim:PNM:timtoppm::
++
++# /* Cam image format(used by CASIO QV-10) */
++# /* CAM:magic:0:\x07\x20\x4d\x4d:.cam:AUTO:camtoppm -j:PNM_RAW */
++CAM:magic:0:\x07\x20\x4d\x4d:.cam:PNM:camtoppm::
++
++# /* Portable Network Graphics (PNG) format : magic is "0x89 PNG" */
++PNG:magic:0:\x89\x50\x4e\x47:.png:PNM:pngtopnm %s:PNM_RAW:pnmtopng
++# /* PNG(interlace):magic:0:\x89\x50\x4e\x47:.png:PNM:pngtopnm %s:PNM_RAW:pnmtopng -interlace */
++
++# /* DB-Z, SAURUS Freehand Memo, PV-F1 Action Board, Wiz Quick Memo format */
++# /* Use xbm2free-1.10 or later. Old version is NOT a filter. */
++# /* To show version of xbm2free, type "xbm2free" (with no argument). */
++ZAURUS:magic:19:IMG1:.zau:PBM_ASCII:free2pbm:PBM:pbmtoxbm|xbm2free -s -
++DBZ:magic:19:IMG1:.dbz:::PBM:pbmtoxbm|xbm2free -d -
++PVF1:magic:12:IMG1:.pvf1:PBM_ASCII:free2pbm:PBM:pbmtoxbm|xbm2free -v -
++# /* WIZ:magic:19:IMG1:.wiz:::PBM:pbmtoxbm|xbm2free -w - */
++
++
++
++# /* Compress:magic:0:\037\235:.Z:AUTO:uncompress %s:: */
++# /* Gzip:magic:0:\037\213:.gz:AUTO:gunzip %s:: */
++# /* Gzip(old):magic:0:\037\236:.z:AUTO:gunzip %s:: */
++
++# /* MAKI:magic:0:MAKI01A\040:.mki:::: */
++# /* MAKI:magic:0:MAKI01B\040:.mki:::: */
++# /* MAG:magic:0:MAKI02\040\040:.mag:::: */
++# /* Pi:magic:0:Pi:.pi:::: */
++# /* PIC:magic:0:PIC:.pic:::: */
++# /* PIC2:magic:0:P2DT:.p2:::: */
++# /* PhotoCD:magic:0:\xff\xff\xff\xff:.pcd:::: */
++
++# /* PBM(ascii):magic:0:P1:.pbm:::: */
++# /* PGM(ascii):magic:0:P2:.pgm:::: */
++# /* PPM(ascii):magic:0:P3:.ppm:::: */
++# /* PBM(raw):magic:0:P4:.pbm:::: */
++# /* PGM(raw):magic:0:P5:.pgm:::: */
++# /* PPM(raw):magic:0:P6:.ppm:::: */
++
++# /* Sun raster:magic:0:\131\246\152\225:.sun:::: */
++# /* JFIF(JPEG):magic:0:\xff\xd8\xff:.jpg:::: */
++# /* TIFF big-endian:magic:0:\115\115:.tif:::: */
++# /* TIFF little-endian:magic:0:\111\111:.tif:::: */
++# /* GIF(87):magic:0:GIF87a:.gif:::: */
++# /* GIF(89):magic:0:GIF89a:.gif:::: */
++# /* SGI(1):magic:0:\x01\xda:.rgb:::: */
++# /* SGI(2):magic:0:\xda\x01:.rgb:::: */
++# /* XWD:magic:0:\0\0\0\7: :::: */
+diff -urN xv-3.10a/xvbrowse.c xv-3.10a-jp-extension-current/xvbrowse.c
+--- xv-3.10a/xvbrowse.c	Fri Jan 20 02:49:17 1995
++++ xv-3.10a-jp-extension-current/xvbrowse.c	Thu Nov 21 16:34:02 1996
+@@ -20,7 +20,7 @@
+ #define NEEDSDIR
+ #include "xv.h"
+ 
+-#if defined(VMS) || defined(isc)
++#if defined(VMS) || defined(isc) || (defined(__sony_news) && defined(__bsd43))
+ typedef unsigned int mode_t;  /* file mode bits */
+ #endif
+ 
+@@ -55,6 +55,13 @@
+ #include "bits/br_xpm"
+ #include "bits/br_xwd"
+ #include "bits/br_fits"
++#include "bits/br_mag"
++#include "bits/br_maki"
++#include "bits/br_pic"
++#include "bits/br_pi"
++#include "bits/br_pic2"
++#include "bits/br_pcd"
++#include "bits/br_mgcsfx"
+ 
+ #include "bits/br_trash"
+ #include "bits/fcurs"
+@@ -94,7 +101,16 @@
+ #define BF_XPM      25
+ #define BF_XWD      26
+ #define BF_FITS     27
+-#define BF_MAX      28    /* # of built-in icons */
++#define JP_EXT_BF   (BF_FITS)
++#define BF_MAG      (JP_EXT_BF + 1)
++#define BF_MAKI     (JP_EXT_BF + 2)
++#define BF_PIC      (JP_EXT_BF + 3)
++#define BF_PI       (JP_EXT_BF + 4)
++#define BF_PIC2     (JP_EXT_BF + 5)
++#define BF_PCD      (JP_EXT_BF + 6)
++#define BF_MGCSFX   (JP_EXT_BF + 7)
++#define JP_EXT_BF_END  (BF_MGCSFX)
++#define BF_MAX      (JP_EXT_BF_END + 1)    /* # of built-in icons */
+ 
+ #define ISLOADABLE(ftyp) (ftyp!=BF_DIR  && ftyp!=BF_CHR && ftyp!=BF_BLK && \
+ 			  ftyp!=BF_SOCK && ftyp!=BF_FIFO) 
+@@ -140,8 +156,14 @@
+ #define BR_NBUTTS   13   /* # of command buttons */
+ #define BR_SEP1     13   /* separator */
+ #define BR_HIDDEN   14
++#ifdef AUTO_EXPAND
++#define BR_CLEARVD  15
++#define BR_SELFILES 16
++#define BR_NCMDS    17   /* # of menu commands */
++#else
+ #define BR_SELFILES 15
+ #define BR_NCMDS    16   /* # of menu commands */
++#endif
+ 
+ #define BUTTW 80
+ #define BUTTH 24
+@@ -164,6 +186,9 @@
+ 			    "Close window\t^c",
+ 			    MBSEP,
+ 			    "Show hidden files",     /* no equiv */
++#ifdef AUTO_EXPAND
++			    "Clear virtual directory",
++#endif
+ 			    "Select files...\t^f"
+ 			    };
+ 
+@@ -294,7 +319,11 @@
+ static void cp_special       PARM((struct stat *, int));
+ static void cp_fifo          PARM((struct stat *, int));
+ 
++#ifdef AUTO_EXPAND
++static int  stat2bf          PARM((u_int, char *));
++#else
+ static int  stat2bf          PARM((u_int));
++#endif
+ 
+ static int  selmatch         PARM((char *, char *));
+ static int  selmatch1        PARM((char *, char *));
+@@ -524,6 +553,15 @@
+   bfIcons[BF_XPM] =MakePix1(br->win,br_xpm_bits, br_xpm_width, br_xpm_height);
+   bfIcons[BF_XWD] =MakePix1(br->win,br_xwd_bits, br_xwd_width, br_xwd_height);
+   bfIcons[BF_FITS]=MakePix1(br->win,br_fits_bits,br_fits_width,br_fits_height);
++  bfIcons[BF_MAG] = MakePix1(br->win,br_mag_bits,br_mag_width,br_mag_height);
++  bfIcons[BF_MAKI] = MakePix1(br->win,br_maki_bits,
++				 br_maki_width,br_maki_height);
++  bfIcons[BF_PIC] = MakePix1(br->win,br_pic_bits,br_pic_width,br_pic_height);
++  bfIcons[BF_PI]  = MakePix1(br->win,br_pi_bits,br_pi_width,br_pi_height);
++  bfIcons[BF_PIC2]=MakePix1(br->win,br_pic2_bits,br_pic2_width,br_pic2_height);
++  bfIcons[BF_PCD] = MakePix1(br->win,br_pcd_bits,br_pcd_width,br_pcd_height);
++  bfIcons[BF_MGCSFX] = MakePix1(br->win,br_mgcsfx_bits,
++                             br_mgcsfx_width,br_mgcsfx_height);
+ 
+ 
+   /* check that they all got built */
+@@ -698,6 +736,9 @@
+   }
+ }
+ 
++#ifdef VS_RESCMAP
++static int _IfTempOut=0; 
++#endif
+ 
+ /***************************************************************/
+ void KillBrowseWindows()
+@@ -730,7 +771,6 @@
+   return 0;
+ }
+ 
+-
+ /***************************************************************/
+ static int brChkEvent(br, xev)
+      BROWINFO *br;
+@@ -746,6 +786,23 @@
+ 
+   if (!hasBeenSized) return 0;  /* ignore evrythng until we get 1st Resize */
+ 
++
++#ifdef VS_RESCMAP
++  /* force change color map if have LocalCmap */
++  if (browPerfect && browCmap && (_IfTempOut==2)) 
++    {
++	XSetWindowAttributes  xswa;
++	if(LocalCmap)
++	      xswa.colormap = LocalCmap;
++	else
++	      xswa.colormap = theCmap;
++	for(i=0;i<MAXBRWIN;i++)
++	  XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
++	XFlush(theDisp);
++	_IfTempOut=1;
++    }
++#endif
++  
+   if (xev->type == Expose) {
+     int x,y,w,h;
+     XExposeEvent *e = (XExposeEvent *) xev;
+@@ -807,7 +864,20 @@
+     int i,x,y;
+     x = e->x;  y = e->y;
+ 
+-    if (e->button == Button1) {
++#ifdef VS_RESCMAP
++    if (browCmap && browPerfect && (_IfTempOut!=0)) 
++      {
++	  XSetWindowAttributes  xswa;
++	  _IfTempOut--;
++	  xswa.colormap = browCmap;
++	  for(i=0;i<MAXBRWIN;i++)
++	    XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
++	  XFlush(theDisp);
++      }
++
++#endif
++
++  if (e->button == Button1) {
+       if      (e->window == br->win)      clickBrow(br,x,y);
+       else if (e->window == br->scrl.win) SCTrack(&(br->scrl),x,y);
+       else if (e->window == br->iconW) {
+@@ -1101,6 +1171,10 @@
+   case BR_SELFILES: doSelFilesCmd(br);   break;
+ 
+   case BR_RECURSUP: doRecurseCmd(br);    break;
++
++#ifdef AUTO_EXPAND
++  case BR_CLEARVD:  Vdsettle();          break;
++#endif
+   }
+ }
+ 
+@@ -1250,6 +1324,18 @@
+   int i, allowtext;
+ 
+   if (!nostr) setSelInfoStr(br, sel);
++#ifdef AUTO_EXPAND
++  if (Isvdir(br->path)) {
++    BTSetActive(&br->but[BR_DELETE],  0);
++    br->cmdMB.dim[BR_DELETE] = 1;
++
++    BTSetActive(&br->but[BR_RENAME],  0);
++    br->cmdMB.dim[BR_RENAME] = 1;
++
++    BTSetActive(&br->but[BR_MKDIR],  0);
++    br->cmdMB.dim[BR_MKDIR] = 1;
++  } else {
++#endif
+   BTSetActive(&br->but[BR_DELETE],  br->numlit>0);
+   br->cmdMB.dim[BR_DELETE] = !(br->numlit>0);
+ 
+@@ -1258,6 +1344,11 @@
+ 
+   BTSetActive(&br->but[BR_GENICON], br->numlit>0);
+   br->cmdMB.dim[BR_GENICON] = !(br->numlit>0);
++#ifdef AUTO_EXPAND
++  BTSetActive(&br->but[BR_MKDIR],  1);
++  br->cmdMB.dim[BR_MKDIR] = 0;
++  }
++#endif
+ 
+   /* turn on 'text view' cmd if exactly one non-dir is lit */
+   allowtext = 0;
+@@ -1318,6 +1409,9 @@
+ 	  struct stat st;
+ 	      
+ 	  sprintf(buf, "%s%s", br->path, bf->name);  /* build filename */
++#ifdef AUTO_EXPAND
++	  Dirtovd(buf);
++#endif
+ 	  if (stat(buf, &st) == 0) {
+ 	    sprintf(buf, "%s:  %ld bytes", bf->name, st.st_size);
+ 	    strcat(buf, buf1);
+@@ -2165,13 +2259,32 @@
+     else sprintf(buf, "%s%s", br->path, br->bfList[sel].name);
+ #endif
+ 
++#ifdef AUTO_EXPAND
++    if (Chvdir(buf)) {
++#else
+     if (chdir(buf)) {
++#endif
+       char str[512];
+       sprintf(str,"Unable to cd to '%s'\n", br->bfList[sel].name);
+       setBrowStr(br, str);
+       XBell(theDisp, 50);
+     }
+     else {
++#ifdef AUTO_EXPAND
++      if (Isvdir(buf)) {
++	BTSetActive(&br->but[BR_DELETE],  0);
++	br->cmdMB.dim[BR_DELETE] = 1;
++
++	BTSetActive(&br->but[BR_RENAME],  0);
++	br->cmdMB.dim[BR_RENAME] = 1;
++
++	BTSetActive(&br->but[BR_MKDIR],  0);
++	br->cmdMB.dim[BR_MKDIR] = 1;
++      } else {
++	BTSetActive(&br->but[BR_MKDIR],  1);
++	br->cmdMB.dim[BR_MKDIR] = 0;
++      }
++#endif
+       scanDir(br);
+       SCSetVal(&(br->scrl), 0);  /* reset to top on a chdir */
+     }
+@@ -2193,7 +2306,29 @@
+       *event_retP = THISNEXT;
+     }
+     else { *event_retP = LOADPIC;  SetDirFName(buf);  }
+-    
++
++#ifdef VS_RESCMAP
++    /* Change Colormap for browser */
++    if (browPerfect && browCmap) 
++      {
++	  int i;
++	  XSetWindowAttributes  xswa;
++	  if(LocalCmap)
++	    {
++		xswa.colormap = LocalCmap;
++		_IfTempOut=2;
++	    }
++	  else
++	    {
++		xswa.colormap = theCmap;
++		_IfTempOut=2;
++	    }
++	  for(i=0;i<MAXBRWIN;i++)
++	    XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
++	  XFlush(theDisp);
++      }
++#endif
++
+     *event_doneP = 1;     /* make MainLoop load image */
+   }
+ }
+@@ -2348,6 +2483,9 @@
+ 
+ 	  /* try to open this file */
+ 	  sprintf(foo, "%s%s", br->path, br->bfList[i].name);
++#ifdef AUTO_EXPAND
++	Dirtovd(foo);
++#endif
+ 	  for (j=0; j<numnames && strcmp(namelist[j],foo); j++);
+ 	  if (j<numnames) {
+ 	    curname = nList.selected = j;
+@@ -2363,6 +2501,9 @@
+       else {          /* not SPACE, or SPACE and lit=1 and not shift */
+ 	for (i=0; i<br->bfLen && !br->bfList[i].lit; i++);  /* find lit one */
+ 	sprintf(fname, "%s%s", br->path, br->bfList[i].name);
++#ifdef AUTO_EXPAND
++	Dirtovd(fname);
++#endif
+ 	viewsel = !(strcmp(fname, fullfname));
+ 	
+ 	if (viewsel) {
+@@ -2554,7 +2695,11 @@
+     }
+ #endif
+ 
++#ifdef AUTO_EXPAND
++    if (Chvdir(tmppath)) {
++#else
+     if (chdir(tmppath)) {
++#endif
+       char str[512];
+       sprintf(str,"Unable to cd to '%s'\n", tmppath);
+       MBRedraw(&(br->dirMB));
+@@ -2562,6 +2707,21 @@
+       XBell(theDisp, 50);
+     }
+     else {
++#ifdef AUTO_EXPAND
++      if (Isvdir(tmppath)) {
++	BTSetActive(&br->but[BR_DELETE],  0);
++	br->cmdMB.dim[BR_DELETE] = 1;
++
++	BTSetActive(&br->but[BR_RENAME],  0);
++	br->cmdMB.dim[BR_RENAME] = 1;
++
++	BTSetActive(&br->but[BR_MKDIR],  0);
++	br->cmdMB.dim[BR_MKDIR] = 1;
++      } else {
++	BTSetActive(&br->but[BR_MKDIR],  1);
++	br->cmdMB.dim[BR_MKDIR] = 0;
++      }
++#endif
+       scanDir(br);
+       SCSetVal(&br->scrl, 0);  /* reset to top of window on a chdir */
+     }
+@@ -2582,7 +2742,11 @@
+   if ((strlen(br->path) > (size_t) 2) && br->path[strlen(br->path)-1] == '/')
+     br->path[strlen(br->path)-1] = '\0';
+ 
++#ifdef AUTO_EXPAND
++  rv = Chvdir(br->path);
++#else
+   rv = chdir(br->path);
++#endif
+   if (rv) {
+     char str[512];
+     sprintf(str, "Unable to cd to '%s'\n", br->path);
+@@ -2590,6 +2754,22 @@
+     XBell(theDisp, 50);
+   }
+ 
++#ifdef AUTO_EXPAND
++  if (Isvdir(br->path)) {
++    BTSetActive(&br->but[BR_DELETE],  0);
++    br->cmdMB.dim[BR_DELETE] = 1;
++
++    BTSetActive(&br->but[BR_RENAME],  0);
++    br->cmdMB.dim[BR_RENAME] = 1;
++
++    BTSetActive(&br->but[BR_MKDIR],  0);
++    br->cmdMB.dim[BR_MKDIR] = 1;
++  } else {
++    BTSetActive(&br->but[BR_MKDIR],  1);
++    br->cmdMB.dim[BR_MKDIR] = 0;
++  }
++#endif
++
+   strcat(br->path, "/");   /* put trailing '/' back on */
+   return rv;
+ }
+@@ -2616,8 +2796,10 @@
+     strcpy(dstbr->mblist[i], srcbr->mblist[i]);
+   }
+ 
+-  dstbr->dirMB.list  = srcbr->mblist;
+-  dstbr->dirMB.nlist = srcbr->ndirs;
++/*  dstbr->dirMB.list  = srcbr->mblist;  /* original bug..? */
++/*  dstbr->dirMB.nlist = srcbr->ndirs;                      */
++  dstbr->dirMB.list  = dstbr->mblist;    /* fixed by        */
++  dstbr->dirMB.nlist = dstbr->ndirs;     /*   jp-extension. */
+ 
+   XClearArea(theDisp, dstbr->dirMB.win, dstbr->dirMB.x, dstbr->dirMB.y, 
+ 	     dstbr->dirMB.w+3, dstbr->dirMB.h+3, False);
+@@ -2975,7 +3157,11 @@
+ 	
+ 
+   if (stat(bf->name, &st)==0) {
++#ifdef AUTO_EXPAND
++    bf->ftype = stat2bf((u_int) st.st_mode , bf->name);
++#else
+     bf->ftype = stat2bf((u_int) st.st_mode);
++#endif
+     if (bf->ftype == BF_FILE && (st.st_mode & 0111)) bf->ftype = BF_EXE;
+ 
+     switch (bf->ftype) {
+@@ -3020,6 +3206,13 @@
+     case RFT_XPM:      bf->ftype = BF_XPM;      break;
+     case RFT_XWD:      bf->ftype = BF_XWD;      break;
+     case RFT_FITS:     bf->ftype = BF_FITS;     break;
++    case RFT_MAG:      bf->ftype = BF_MAG;      break;
++    case RFT_MAKI:     bf->ftype = BF_MAKI;     break;
++    case RFT_PIC:      bf->ftype = BF_PIC;      break;
++    case RFT_PI:       bf->ftype = BF_PI;       break;
++    case RFT_PIC2:     bf->ftype = BF_PIC2;     break;
++    case RFT_PCD:      bf->ftype = BF_PCD;      break;
++    case RFT_MGCSFX:   bf->ftype = BF_MGCSFX;   break;
+     }
+   }
+ }
+@@ -3406,7 +3599,7 @@
+   double  wexpand,hexpand;
+   int     iwide, ihigh;
+   byte   *icon24, *icon8;
+-  char    str[256], str1[256], *readname, uncompname[128];
++  char    str[256], str1[256], readname[128], uncompname[128];
+   char    basefname[128], *uncName;
+   
+   
+@@ -3415,7 +3608,7 @@
+   basefname[0] = '\0';
+   pinfo.pic = (byte *) NULL;
+   pinfo.comment = (char *) NULL;
+-  readname = bf->name;
++  strcpy(readname, bf->name);
+   
+   /* free any old info in 'bf' */
+   if (bf->imginfo) free          (bf->imginfo);
+@@ -3445,7 +3638,7 @@
+     
+     if (UncompressFile(uncName, uncompname)) {
+       filetype = ReadFileType(uncompname);
+-      readname = uncompname;
++      strcpy(readname, uncompname);
+     }
+     else {
+       sprintf(str, "Couldn't uncompress file '%s'", bf->name);
+@@ -3454,6 +3647,51 @@
+     }
+   }
+   
++#ifdef MACBINARY
++  if (handlemacb && macb_file == True && bf->ftype != BF_ERROR) {
++    if (RemoveMacbinary(readname, uncompname)) {
++      if (strcmp(readname, bf->name)!=0) unlink(readname);
++      strcpy(readname, uncompname);
++    }
++    else {
++      sprintf(str, "Unable to remove a InfoFile header form '%s'.", bf->name);
++      setBrowStr(br, str);
++      bf->ftype = BF_ERROR;
++    }
++  }
++#endif
++
++#ifdef HAVE_MGCSFX_AUTO
++  if (bf->ftype != BF_ERROR) {
++    if(filetype == RFT_MGCSFX){
++      char tmpname[128];
++      char *icom;
++
++      if((icom = mgcsfx_auto_input_com(bf->name)) != NULL){
++	sprintf(tmpname, "%s/xvmsautoXXXXXX", tmpdir);
++	mktemp(tmpname);
++	SetISTR(ISTR_INFO, "Converting to known format by MgcSfx auto...");
++	sprintf(str,"%s >%s", icom, tmpname);
++      }else goto ms_auto_no;
++
++#ifndef VMS
++      if (system(str)) {
++#else
++      if (!system(str)) {
++#endif
++        sprintf(str, "Unable to convert '%s' by MgcSfx auto.", bf->name);
++        setBrowStr(br, str);
++        bf->ftype = BF_ERROR;
++      } else {
++        filetype = ReadFileType(tmpname);
++        if (strcmp(readname, bf->name)!=0) unlink(readname);
++        strcpy(readname, tmpname);
++      }
++    }
++  }
++ms_auto_no:
++#endif /* HAVE_MGCSFX_AUTO */
++
+   /* get rid of comments.  don't need 'em */
+   if (pinfo.comment) free(pinfo.comment);  pinfo.comment = (char *) NULL;
+   
+@@ -3471,6 +3709,9 @@
+   else {
+     /* otherwise it's a known filetype... do the *hard* part now... */
+     
++#ifdef VS_ADJUST
++    normaspect = defaspect;
++#endif /* VS_ADJUST */
+     i = ReadPicFile(readname, filetype, &pinfo, 1);
+     KillPageFiles(pinfo.pagebname, pinfo.numpages);
+     
+@@ -3490,7 +3731,7 @@
+   }
+   
+   /* if we made an uncompressed file, we can rm it now */
+-  if (readname != bf->name) unlink(readname);
++  if (strcmp(readname, bf->name)!=0) unlink(readname);
+   
+   
+   /* at this point either BF_ERROR, BF_UNKNOWN, BF_EXE or pic */
+@@ -3508,21 +3749,39 @@
+   
+   /* compute size of icon  (iwide,ihigh) */
+   
++#ifdef VS_ADJUST
++  if (!vsadjust) normaspect = 1;
++
++  wexpand = (double) (pinfo.w * normaspect) / (double) ISIZE_WIDE;
++#else
+   wexpand = (double) pinfo.w / (double) ISIZE_WIDE;
++#endif /* VS_ADJUST */
+   hexpand = (double) pinfo.h / (double) ISIZE_HIGH;
+ 
+   if (wexpand >= 1.0 || hexpand >= 1.0) {   /* don't expand small icons */
+     if (wexpand>hexpand) {
++#ifdef VS_ADJUST
++      iwide = (int) ((pinfo.w * normaspect) / wexpand + 0.5);
++#else
+       iwide = (int) (pinfo.w / wexpand + 0.5);
++#endif /* VS_ADJUST */
+       ihigh = (int) (pinfo.h / wexpand + 0.5);
+     }
+     else {
++#ifdef VS_ADJUST
++      iwide = (int) ((pinfo.w * normaspect) / hexpand + 0.5);
++#else
+       iwide = (int) (pinfo.w / hexpand + 0.5);
++#endif /* VS_ADJUST */
+       ihigh = (int) (pinfo.h / hexpand + 0.5);
+     }
+   }
+   else {  /* smaller than ISIZE.  Leave it that way. */
++#ifdef VS_ADJUST
++    iwide = pinfo.w * normaspect;  ihigh = pinfo.h;
++#else
+     iwide = pinfo.w;  ihigh = pinfo.h;
++#endif /* VS_ADJUST */
+   }
+ 
+ 
+@@ -3567,6 +3826,13 @@
+   case RFT_XPM:      strcat(str,"XPM file");              break;
+   case RFT_XWD:      strcat(str,"XWD file");              break;
+   case RFT_FITS:     strcat(str,"FITS file");             break;
++  case RFT_MAG:      strcat(str,"MAG file");              break;
++  case RFT_MAKI:     strcat(str,"MAKI file");             break;
++  case RFT_PIC:      strcat(str,"PIC file");              break;
++  case RFT_PI:       strcat(str,"PI file");               break;
++  case RFT_PIC2:     strcat(str,"PIC2 file");             break;
++  case RFT_PCD:      strcat(str,"Photo CD file");         break;
++  case RFT_MGCSFX:   strcat(str,"Magic Suffix file");     break;
+   default:           strcat(str,"file of unknown type");  break;
+   }
+   
+@@ -3670,6 +3936,10 @@
+ 
+   sprintf(thFname, "%s%s/%s", br->path, THUMBDIR, bf->name);
+ 
++#ifdef AUTO_EXPAND
++  Dirtovd(thFname);
++#endif
++
+   fp = fopen(thFname, "r");
+   if (!fp) return;            /* nope, it doesn't have one */
+ 
+@@ -3785,6 +4055,10 @@
+ 
+   sprintf(thFname, "%s%s/%s", br->path, THUMBDIR, bf->name);
+ 
++#ifdef AUTO_EXPAND
++  Dirtovd(thFname);
++#endif
++
+   fp = fopen(thFname, "w");
+   if (!fp) {
+     sprintf(buf, "Can't create thumbnail file '%s':  %s", thFname, 
+@@ -3849,15 +4123,30 @@
+ 
+   sprintf(thFname, "%s%s", br->path, THUMBDIRNAME);
+ 
++#ifdef AUTO_EXPAND
++  Dirtovd(thFname);
++#endif
++
+   i = stat(thFname, &st);
+   if (i) {                      /* failed, let's create it */
+     sprintf(thFname, "%s.", br->path);
++#ifdef AUTO_EXPAND
++  Dirtovd(thFname);
++#endif
+     i = stat(thFname, &st);     /* get permissions of parent dir */
+     if (!i) perm = st.st_mode & 07777;
+        else perm = 0755;
+ 
+     sprintf(thFname, "%s%s", br->path, THUMBDIRNAME);
++#ifdef AUTO_EXPAND
++    Dirtovd(thFname);
++#  ifdef VIRTUAL_TD
++    if (mkdir(thFname, (mode_t) perm) < 0)
++      Mkvdir_force(thFname);
++#  else
+     mkdir(thFname, (mode_t) perm);
++#  endif
++#endif
+   }
+ }
+ 
+@@ -3964,7 +4253,11 @@
+       sprintf(thfname, "%s/%s", THUMBDIR, dp->d_name);
+       if (stat(thfname, &thumbst)==0) {  /* success */
+ 	int tmp;
++#ifdef AUTO_EXPAND
++	tmp  = stat2bf((u_int) thumbst.st_mode , thfname);
++#else
+ 	tmp  = stat2bf((u_int) thumbst.st_mode);
++#endif
+ 
+ 	if (tmp == BF_FILE) {  /* a plain file */
+ 	  /* see if this thumbfile has an associated pic file */
+@@ -4043,6 +4336,15 @@
+   static char *labels[] = { "\nOk", "\033Cancel" };
+   struct stat st;
+ 
++#ifdef AUTO_EXPAND
++  if (Isvdir(br->path)) {
++    sprintf(buf,"Sorry, you can't rename file in the virtual directory, '%s'",
++	    br->path);
++    ErrPopUp(buf, "\nBummer!");
++    return;
++  }
++#endif
++
+   if (cdBrow(br)) return;
+ 
+   /* find the selected file */
+@@ -4130,6 +4432,15 @@
+   static char *labels[] = { "\nOk", "\033Cancel" };
+   struct stat  st;
+ 
++#ifdef AUTO_EXPAND
++  if (Isvdir(br->path)) {
++    sprintf(buf,"Sorry, you can't mkdir in the virtual directory, '%s'",
++	    br->path);
++    ErrPopUp(buf, "\nBummer!");
++    return;
++  }
++#endif
++
+   if (cdBrow(br)) return;
+ 
+   buf[0] = '\0';
+@@ -4198,12 +4509,31 @@
+     if (cdBrow(br)) return;     /* prints its own error message */
+   }
+ 
++#ifdef AUTO_EXPAND
++  if (Chvdir(buf)) {
++#else
+   if (chdir(buf)) {
++#endif
+     sprintf(str,"Unable to cd to '%s'\n", buf);
+     setBrowStr(br, str);
+     XBell(theDisp, 50);
+   }
+   else {
++#ifdef AUTO_EXPAND
++      if (Isvdir(buf)) {
++	BTSetActive(&br->but[BR_DELETE],  0);
++	br->cmdMB.dim[BR_DELETE] = 1;
++
++	BTSetActive(&br->but[BR_RENAME],  0);
++	br->cmdMB.dim[BR_RENAME] = 1;
++
++	BTSetActive(&br->but[BR_MKDIR],  0);
++	br->cmdMB.dim[BR_MKDIR] = 1;
++      } else {
++	BTSetActive(&br->but[BR_MKDIR],  1);
++	br->cmdMB.dim[BR_MKDIR] = 0;
++      }
++#endif
+     scanDir(br);
+     SCSetVal(&(br->scrl), 0);	/* reset to top on a chdir */
+   }
+@@ -4230,6 +4560,15 @@
+   char   buf[512];
+   static char *yesno[]  = { "\004Delete", "\033Cancel" };
+ 
++#ifdef AUTO_EXPAND
++  if (Isvdir(br->path)) {
++    sprintf(buf,"Sorry, you can't delete file at the virtual directory, '%s'",
++	    br->path);
++    ErrPopUp(buf, "\nBummer!");
++    return;
++  }
++#endif
++
+   if (!br->bfLen || !br->bfList || !br->numlit) return;
+ 
+   if (cdBrow(br)) return;     /* can't cd to this directory.  screw it! */
+@@ -4252,7 +4591,11 @@
+   for (i=0, bf=br->bfList; i<br->bfLen; i++,bf++) {
+     if (bf->lit) {
+       if (firstdel == -1) firstdel = i;
+-      if (bf->ftype == BF_DIR) numdirs++;
++      if (bf->ftype == BF_DIR
++#ifdef AUTO_EXPAND
++	  && (!Isarchive(bf->name))
++#endif
++			     ) numdirs++;
+       else numfiles++;
+     }
+   }
+@@ -4266,7 +4609,12 @@
+     slen = strlen(buf);
+ 
+     for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
++#ifdef AUTO_EXPAND
++      if (bf->lit && (bf->ftype != BF_DIR || Isarchive(bf->name))) {
++#else
+       if (bf->lit && bf->ftype != BF_DIR) {
++#endif
++					
+ 	if ( (slen + strlen(bf->name) + 1) > 256) {
+ 	  strcat(buf,"...");
+ 	  break;
+@@ -4291,7 +4639,11 @@
+     slen = strlen(buf);
+ 
+     for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
++#ifdef AUTO_EXPAND
++      if (bf->lit && (bf->ftype == BF_DIR || !Isarchive(bf->name))) {
++#else
+       if (bf->lit && bf->ftype == BF_DIR) {
++#endif
+ 	if ( (slen + strlen(bf->name) + 1) > 256) {
+ 	  strcat(buf,"...");
+ 	  break;
+@@ -4312,7 +4664,11 @@
+   
+   for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
+     if (bf->lit) {
+-      if (bf->ftype == BF_DIR) rm_dir (br, bf->name);
++      if (bf->ftype == BF_DIR
++#ifdef AUTO_EXPAND
++	  && !Isarchive(bf->name)
++#endif
++			     ) rm_dir (br, bf->name);
+                           else rm_file(br, bf->name);
+     }
+   }
+@@ -4441,7 +4797,11 @@
+   xv_getwd(orgDir, sizeof(orgDir));
+ 
+   sprintf(curDir, "%s%s", br->path, subdir);
++#ifdef AUTO_EXPAND
++  if (Chvdir(curDir)) {
++#else
+   if (chdir(curDir)) {
++#endif
+     char str[512];
+     sprintf(str, "Unable to cd to '%s'\n", curDir);
+     setBrowStr(br, str);
+@@ -4453,14 +4813,22 @@
+   /* have we looped? */
+   for (i=0; i<dirStackLen && strcmp(curDir, dirStack[i]); i++);
+   if (i<dirStackLen) {   /* YES */
++#ifdef AUTO_EXPAND
++    Chvdir(orgDir);
++#else
+     chdir(orgDir);
++#endif
+     return;
+   }
+ 
+   sp = (char *) malloc((size_t) strlen(curDir) + 1);
+   if (!sp) {
+     setBrowStr(br, "malloc() error in recurseUpdate()\n");
++#ifdef AUTO_EXPAND
++    Chvdir(orgDir);
++#else
+     chdir(orgDir);
++#endif
+     return;
+   }
+ 
+@@ -4495,7 +4863,11 @@
+ 
+   xv_getwd(curDir, sizeof(curDir));
+   if (strcmp(orgDir, curDir)) {   /* change back to orgdir */
++#ifdef AUTO_EXPAND
++    Chvdir(orgDir);
++#else
+     chdir(orgDir);
++#endif
+     scanDir(br);
+   }
+ }
+@@ -4519,6 +4891,13 @@
+     setBrowStr(br, buf);
+   }
+ 
++#ifdef AUTO_EXPAND
++  if (Rmvdir(name)) {
++    sprintf(buf, "fail to remove virturl directory: %s", name);
++    setBrowStr(br, buf);
++  }
++#endif
++
+   /* try to delete a thumbnail file, as well.  ignore errors */
+   strcpy(buf1, name);          /* tmp1 = leading path of name */
+   tmp = (char *) rindex(buf1, '/');
+@@ -4587,7 +4966,12 @@
+ 	goto done;
+       }
+ 	
++#ifdef AUTO_EXPAND
++      if ((stat2bf((u_int) st.st_mode , rmdirPath) == BF_DIR)
++	  && !Isarchive(rmdirPath)) {  /* skip, for now */
++#else
+       if (stat2bf((u_int) st.st_mode) == BF_DIR) {  /* skip, for now */
++#endif
+ 	rmdirPath[oldpathlen] = '\0';
+ 	continue;   /* don't remove from list */
+       }
+@@ -4677,11 +5061,26 @@
+   }
+   else if (strcmp(dstdir,".")!=0) sprintf(dstp, "%s%s/", dstpath, dstdir);
+ 
++#ifdef AUTO_EXPAND
++  if (Isvdir(dstp)) {
++    sprintf(buf,"Sorry, you can't %s to the virtual directory, '%s'",
++	    cpymode ? "copy" : "move", dstp);
++    ErrPopUp(buf, "\nBummer!");
++    SetCursors(-1);
++    return;
++  }
++  if (Isvdir(srcpath))
++      cpymode = 1;
++#endif
++
+ 
+ 
+   /* if there is a thumbnail directory in 'srcpath', make one for dstpath */
+   sprintf(src,"%s%s", srcpath, THUMBDIR);
+   dothumbs = 0;
++#ifdef AUTO_EXPAND
++  Dirtovd(src);
++#endif
+   if (stat(src, &st)==0) {
+     sprintf(dst,"%s%s", dstp, THUMBDIR);
+     mkdir(dst, st.st_mode & 07777);
+@@ -4712,6 +5111,14 @@
+     if (overwrite == OWRT_CANCEL) break;         /* abort move */
+     if (j==1) fail++;
+ 
++#ifdef AUTO_EXPAND
++    if (!cpymode && j==0)
++      if (Movevdir(src,dst)) {
++	sprintf(buf, "fail to move virturl directory: %s", names[i]);
++	setBrowStr(srcBr, buf);
++      }
++#endif
++
+     if (dothumbs && j==0) {
+       sprintf(src,"%s%s/%s", srcpath, THUMBDIR, names[i]);
+       sprintf(dst,"%s%s/%s", dstp,    THUMBDIR, names[i]);
+@@ -4816,12 +5223,25 @@
+ 
+   if (DEBUG) fprintf(stderr,"moveFile %s %s\n", src, dst);
+ 
++#ifdef AUTO_EXPAND
++  Dirtosubst(src);
++#endif
++
+   if (stat(src, &st)) return 0;    /* src doesn't exist, it would seem */
++#ifdef AUTO_EXPAND
++  srcdir = (stat2bf((u_int) st.st_mode , src) == BF_DIR);
++#else
+   srcdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
++#endif
+ 
+   /* see if destination exists */
++
+   if (stat(dst, &st)==0) {
+-    dstdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
++#ifdef AUTO_EXPAND
++  dstdir = (stat2bf((u_int) st.st_mode , dst) == BF_DIR);
++#else
++  dstdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
++#endif
+ 
+     if (overwrite==OWRT_ASK) {
+       sprintf(buf, "%s '%s' exists.\n\nOverwrite?", 
+@@ -4915,13 +5335,22 @@
+ 
+   if (DEBUG) fprintf(stderr,"copyFile %s %s\n", src, dst);
+ 
++#ifdef AUTO_EXPAND
++  Dirtosubst(src);
++#endif
++
+   if (stat(src,&srcSt)) return 0;  /* source doesn't exist, it would seem */
+ 
+   dstExists = (stat(dst, &dstSt)==0);
+ 
+   if (dstExists) {   /* ask about overwriting... */
+-    srcdir = (stat2bf((u_int) srcSt.st_mode) == BF_DIR);
+-    dstdir = (stat2bf((u_int) dstSt.st_mode) == BF_DIR);
++#ifdef AUTO_EXPAND
++  srcdir = (stat2bf((u_int) srcSt.st_mode , src) == BF_DIR);
++  dstdir = (stat2bf((u_int) dstSt.st_mode , dst) == BF_DIR);
++#else
++  srcdir = (stat2bf((u_int) srcSt.st_mode) == BF_DIR);
++  dstdir = (stat2bf((u_int) dstSt.st_mode) == BF_DIR);
++#endif
+ 
+     sprintf(buf, "%s '%s' already exists.  Replace it with %s '%s'?",
+ 	    (dstdir) ? "Directory" : "File", dst,
+@@ -5037,7 +5466,11 @@
+   }
+ 
+ 
++#ifdef AUTO_EXPAND
++  switch(stat2bf((u_int) srcSt.st_mode , cpDstPath)) {   
++#else
+   switch(stat2bf((u_int) srcSt.st_mode)) {   
++#endif
+     /* determine how to copy, by filetype */
+ 
+     /* NOTE:  There is no S_IFLNK case here, since we're using 'stat()' and
+@@ -5053,7 +5486,11 @@
+     }
+   }
+   else {
++#ifdef AUTO_EXPAND
++    if (stat2bf((u_int) dstSt.st_mode , cpDstPath) != BF_DIR) {
++#else
+     if (stat2bf((u_int) dstSt.st_mode) != BF_DIR) {
++#endif
+       SetISTR(ISTR_WARNING,"%s: not a directory", cpDstPath);
+       copyerr++;
+       return;
+@@ -5131,7 +5568,11 @@
+       goto done;
+     }
+      
+-    if (stat2bf((u_int) srcSt.st_mode) == BF_DIR) {
++#ifdef AUTO_EXPAND
++    if (stat2bf((u_int) srcSt.st_mode , cpSrcPath) == BF_DIR) {
++#else
++     if (stat2bf((u_int) srcSt.st_mode) == BF_DIR) {
++#endif
+       cpSrcPath[oldsrclen] = '\0';
+       continue;                     /* don't remove from list, just skip */
+     }
+@@ -5304,8 +5745,14 @@
+ 
+   
+ /*********************************/
++#ifdef AUTO_EXPAND
++static int stat2bf(uistmode, path)
++     u_int uistmode;
++     char *path;
++#else
+ static int stat2bf(uistmode)
+      u_int uistmode;
++#endif
+ {
+   /* given the 'st.st_mode' field from a successful stat(), returns 
+      BF_FILE, BF_DIR, BF_BLK, BF_CHR, BF_FIFO, or BF_SOCK.  Does *NOT*
+@@ -5319,6 +5766,9 @@
+   else if (S_ISBLK(stmode))  rv = BF_BLK;
+   else if (S_ISFIFO(stmode)) rv = BF_FIFO;
+   else if (S_ISSOCK(stmode)) rv = BF_SOCK;
++#ifdef AUTO_EXPAND
++  else if (Isarchive(path))  rv = BF_DIR;
++#endif
+   else                       rv = BF_FILE;
+ 
+   return rv;
+diff -urN xv-3.10a/xvdflt.c xv-3.10a-jp-extension-current/xvdflt.c
+--- xv-3.10a/xvdflt.c	Fri Dec 23 07:34:42 1994
++++ xv-3.10a-jp-extension-current/xvdflt.c	Wed Oct  9 20:36:26 1996
+@@ -18,6 +18,8 @@
+ #include "bits/xf_left"
+ #include "bits/xf_right"
+ #include "bits/font5x9.h"
++#include "bits/xv_jpext"
++#include "bits/xv_jprev"
+ 
+ 
+ #ifndef USEOLDPIC
+@@ -101,22 +103,35 @@
+ 
+ 
+   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2+1, 203+1, 252);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2+1, 186+1, 252);
+   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2,   203, 250);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2,   186, 250);
+ 
+   i = xv_ver_width + xv_rev_width + 30;
+ 
+   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+-       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2+1, 220+1,252);
++       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2+1, 203+1,252);
+   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+-       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2+1, 220+1,252);
++       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2+1, 203+1,252);
+ 
+   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 250);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 203, 250);
+   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 250);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 203, 250);
+ 
++  /* Japanese Extension Revision */
++  i = xv_jpext_width + xv_jprev_width + 30;
++
++  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
++       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2+1, 220+1,252);
++  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
++       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2+1, 220+1,252);
++
++  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2, 220, 250);
++  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2, 220, 250);
++
+   strcpy(str,"Press <right> mouse button for menu.");
+   DrawStr2Pic(str, DWIDE/2+1, 241+1, dfltpic, DWIDE, DHIGH, 252);
+   DrawStr2Pic(str, DWIDE/2, 241, dfltpic, DWIDE, DHIGH, 250);
+@@ -194,15 +209,23 @@
+ 	   dfltpic, DWIDE, DHIGH, DWIDE/2, 160, 102);
+ 
+   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2, 203, 102);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2, 194, 102);
+ 
+   i = xv_ver_width + xv_rev_width + 30;
+ 
+   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 102);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 209, 102);
+ 
+   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
+-	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 102);
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 209, 102);
++
++  /* Japanese Extension Revision */
++  i = xv_jpext_width + xv_jprev_width + 30;
++
++  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2, 222, 102);
++  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
++	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2, 222, 102);
+ 
+   strcpy(str,"Press <right> mouse button for menu.");
+   DrawStr2Pic(str, DWIDE/2, 241, dfltpic, DWIDE, DHIGH, 102);
+diff -urN xv-3.10a/xvdir.c xv-3.10a-jp-extension-current/xvdir.c
+--- xv-3.10a/xvdir.c	Wed Jan  4 06:21:39 1995
++++ xv-3.10a-jp-extension-current/xvdir.c	Wed Oct  9 20:36:22 1996
+@@ -73,6 +73,24 @@
+ 			       "Targa (24-bit)",
+ 			       "FITS",
+ 			       "PM",
++#ifdef HAVE_MAG
++			       "MAG",
++#endif /* HAVE_MAG */
++#ifdef HAVE_PIC
++			       "PIC",
++#endif /* HAVE_PIC */
++#ifdef HAVE_MAKI
++			       "MAKI",
++#endif /* HAVE_MAKI */
++#ifdef HAVE_PI
++			       "PI",
++#endif /* HAVE_PI */
++#ifdef HAVE_PIC2
++			       "PIC2",
++#endif /* HAVE_PIC2 */
++#ifdef HAVE_MGCSFX
++			       "MgcSfx",
++#endif /* HAVE_MGCSFX */
+ 			       MBSEP,
+ 			       "Filename List"};
+ 
+@@ -571,7 +589,11 @@
+     }
+ #endif
+ 
++#ifdef AUTO_EXPAND
++    if (Chvdir(tmppath)) {
++#else
+     if (chdir(tmppath)) {
++#endif
+       char str[512];
+       sprintf(str,"Unable to cd to '%s'\n", tmppath);
+       *trunc_point = '/';  /* restore the path */
+@@ -636,7 +658,11 @@
+   xv_getwd(path, sizeof(path));
+ #endif
+ 
++#ifdef AUTO_EXPAND
++  if (Chvdir(path)) {
++#else
+   if (chdir(path)) {
++#endif
+     ErrPopUp("Current load/save directory seems to have gone away!",
+ 	     "\nYikes!");
+ #ifdef apollo
+@@ -644,7 +670,11 @@
+ #else
+     strcpy(path,"/");
+ #endif
++#ifdef AUTO_EXPAND
++    Chvdir(path);
++#else
+     chdir(path);
++#endif
+   }
+ 
+   changedDir = strcmp(path, oldpath);
+@@ -749,6 +779,9 @@
+ 	else if (S_ISFIFO(ftype)) fnames[i][0] = C_FIFO;
+ 	else if (S_ISSOCK(ftype)) fnames[i][0] = C_SOCK;
+         else if (fnames[i][0] == C_REG && (mode&0111)) fnames[i][0] = C_EXE;
++#ifdef AUTO_EXPAND
++	else if (Isarchive(fnames[i]+1)) fnames[i][0] = C_DIR;
++#endif
+       }
+       else {
+ 	/* fprintf(stderr,"problems 'stat-ing' files\n");*/
+@@ -1054,6 +1087,25 @@
+ 
+   fullname = GetDirFullName();
+ 
++#ifdef AUTO_EXPAND
++  {
++      char path[MAXPATHLEN];
++
++      GetDirPath(path);
++      Mkvdir(path);
++      if ((i = Isvdir(fullname)) & 01) {
++	  char buf[128];
++	  sprintf(buf,
++		  "Sorry, you can't save file in the virtual directory, '%s'",
++		  path);
++	  ErrPopUp(buf, "\nBummer!");
++	  return -1;
++      }
++      if (i & 06)
++	  Rmvdir(fullname);
++  }
++#endif
++
+   fmt = MBWhich(&fmtMB);
+   col = MBWhich(&colMB);
+ 
+@@ -1115,7 +1167,25 @@
+   }
+ #endif
+ 
++#ifdef HAVE_PIC2
++  else if (fmt == F_PIC2) {   /* PIC2 */
++    if (PIC2SaveParams(fullname, col) < 0)
++	return 0;
++    PIC2Dialog(1);                   /* open PIC2 Dialog box */
++    dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
++    return 0;                      /* always 'succeeds' */
++  }
++#endif /* HAVE_PIC2 */
+ 
++#ifdef HAVE_MGCSFX
++  else if (fmt == F_MGCSFX) {   /* MGCSFX */
++    if (MGCSFXSaveParams(fullname, col) < 0)
++	return 0;
++    MGCSFXDialog(1);                   /* open MGCSFX Dialog box */
++    dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
++    return 0;                      /* always 'succeeds' */
++  }
++#endif /* HAVE_MGCSFX */
+ 
+ 
+   WaitCursor();
+@@ -1169,12 +1239,34 @@
+   case F_XPM:
+     rv = WriteXPM   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
+ 		     fullname, picComments);    
++    break;
+   case F_FITS:
+     rv = WriteFITS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
+ 		     picComments);    
+     break;
++#ifdef HAVE_MAG
++  case F_MAG:
++    rv = WriteMAG   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
++		     picComments);    break;
++#endif /* HAVE_MAG */
++#ifdef HAVE_PIC
++  case F_PIC:
++    rv = WritePIC   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
++		     picComments);    break;
++#endif /* HAVE_PIC */
++#ifdef HAVE_MAKI
++  case F_MAKI:
++    rv = WriteMAKI  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);    break;
++#endif /* HAVE_MAKI */
++
++#ifdef HAVE_PI
++  case F_PI:
++    rv = WritePi    (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
++		     picComments);    break;
++#endif /* HAVE_PI */
++
+   }
+-  
++
+ 
+   if (CloseOutFile(fp, fullname, rv) == 0) {
+     DirBox(0);
+@@ -1387,7 +1479,13 @@
+       (strcmp(lowsuf,"jpeg")==0) ||
+       (strcmp(lowsuf,"jfif")==0) ||
+       (strcmp(lowsuf,"tif" )==0) ||
+-      (strcmp(lowsuf,"tiff")==0)) {
++      (strcmp(lowsuf,"tiff")==0) ||
++      (strcmp(lowsuf,"mag" )==0) ||
++      (strcmp(lowsuf,"pic" )==0) ||
++      (strcmp(lowsuf,"mki" )==0) ||
++      (strcmp(lowsuf,"pi"  )==0) ||
++      (strcmp(lowsuf,"p2"  )==0) ||
++      (strcmp(lowsuf,"pcd" )==0)){
+ 
+     /* found one.  set lowsuf = to the new suffix, and tack on to filename */
+ 
+@@ -1423,8 +1521,29 @@
+ #ifdef HAVE_TIFF
+     case F_TIFF:     strcpy(lowsuf,"tif");  break;
+ #endif
++
++#ifdef HAVE_MAG
++    case F_MAG:      strcpy(lowsuf,"mag");  break;
++#endif /* HAVE_MAG */
++
++#ifdef HAVE_PIC
++    case F_PIC:      strcpy(lowsuf,"pic");  break;
++#endif /* HAVE_PIC */
++
++#ifdef HAVE_MAKI
++    case F_MAKI:     strcpy(lowsuf,"mki");  break;
++#endif /* HAVE_MAKI */
++
++#ifdef HAVE_PI
++    case F_PI:       strcpy(lowsuf,"pi");   break;
++#endif /* HAVE_PI */
++
++#ifdef HAVE_PIC2
++    case F_PIC2:     strcpy(lowsuf,"p2");   break;
++#endif /* HAVE_PIC2 */
+     }
+ 
++
+     if (allcaps) {  /* upper-caseify lowsuf */
+       for (sp=lowsuf; *sp; sp++) 
+ 	*sp = (islower(*sp)) ? toupper(*sp) : *sp;
+@@ -1490,6 +1609,11 @@
+   }
+ #endif
+ 
++#ifdef AUTO_EXPAND
++  Mkvdir(newpath);
++  Dirtovd(newpath);
++#endif
++
+   if (stat(newpath, &st)==0) {
+     int isdir;
+ 
+@@ -1587,7 +1711,11 @@
+   dopipe = 0;
+ 
+   /* make sure we're in the correct directory */
++#ifdef AUTO_EXPAND
++  if (strlen(path)) Chvdir(path);
++#else
+   if (strlen(path)) chdir(path);
++#endif
+ 
+   if (ISPIPE(filename[0])) {   /* do piping */
+     /* make up some bogus temp file to put this in */
+@@ -2062,3 +2190,150 @@
+ }
+ 
+ 
++#ifdef HAVE_PIC2
++/**** Stuff for PIC2Dialog box ****/
++FILE *pic2_OpenOutFile(filename, append)
++char *filename;
++int *append;
++{
++    /* opens file for output.  does various error handling bits.  Returns
++       an open file pointer if success, NULL if failure */
++
++    FILE *fp;
++    struct stat st;
++
++    if (!filename || filename[0] == '\0')
++	return (NULL);
++    strcpy(outFName, filename);
++    dopipe = 0;
++
++    /* make sure we're in the correct directory */
++#ifdef AUTO_EXPAND
++    if (strlen(path)) Chvdir(path);
++#else
++    if (strlen(path)) chdir(path);
++#endif
++
++    if (ISPIPE(filename[0])) {   /* do piping */
++	/* make up some bogus temp file to put this in */
++#ifndef VMS
++	sprintf(outFName, "%s/xvXXXXXX", tmpdir);
++#else
++	strcpy(outFName, "[]xvXXXXXX.lis");
++#endif
++	mktemp(outFName);
++	dopipe = 1;
++    }
++
++
++    /* see if file exists (ie, we're overwriting) */
++    *append = 0;
++    if (stat(outFName, &st)==0)     /* stat succeeded, file must exist */
++	if (ReadFileType(outFName) != RFT_PIC2) {
++	    static char *foo[] = { "\nOk", "\033Cancel" };
++	    char str[512];
++
++	    sprintf(str,"Overwrite existing file '%s'?", outFName);
++	    if (PopUp(str, foo, 2))
++		return (NULL);
++	} else {
++	    static char *foo[] = { "\nOk", "\033Cancel" };
++	    char str[512];
++
++	    sprintf(str,"Append to existing file '%s'?", outFName);
++	    if (PopUp(str, foo, 2)) {
++		sprintf(str,"Overwrite existing file '%s'?", outFName);
++		if (PopUp(str, foo, 2))
++		    return (NULL);
++	    } else
++		*append = 1;
++	}
++
++    
++    /* Open file */
++    fp = *append ? fopen(outFName, "r+") : fopen(outFName, "w");
++    if (!fp) {
++	char  str[512];
++	sprintf(str,"Can't write file '%s'\n\n  %s.",outFName, ERRSTR(errno));
++	ErrPopUp(str, "\nBummer");
++	return (NULL);
++    }
++
++    return (fp);
++}
++
++
++/***************************************/
++void pic2_KillNullFile(fp)
++FILE *fp;
++{
++    fseek(fp, (size_t) 0, SEEK_END);
++    if (ftell(fp) > 0) {
++	fclose(fp);
++	return;
++    } else {
++	fclose(fp);
++	unlink(outFName);
++	return;
++    }
++}
++#endif /* HAVE_PIC2 */
++
++
++#ifdef HAVE_MGCSFX
++/**** Stuff for MGCSFX Dialog box ****/
++/***************************************/
++int OpenOutFileDesc(filename)
++     char *filename;
++{
++  /* opens file for output.  does various error handling bits.  Returns
++     an open file pointer if success, NULL if failure */
++
++  int         fd;
++  struct stat st;
++
++  if (!filename || filename[0] == '\0') return -1;
++  strcpy(outFName, filename);
++  dopipe = 0;
++
++  /* make sure we're in the correct directory */
++#ifdef AUTO_EXPAND
++  if (strlen(path)) Chvdir(path);
++#else
++  if (strlen(path)) chdir(path);
++#endif
++
++  if (ISPIPE(filename[0])) {   /* do piping */
++    /* make up some bogus temp file to put this in */
++#ifndef VMS
++    sprintf(outFName, "%s/xvXXXXXX", tmpdir);
++#else
++    strcpy(outFName, "[]xvXXXXXX.lis");
++#endif
++    mktemp(outFName);
++    dopipe = 1;
++  }
++
++
++  /* see if file exists (ie, we're overwriting) */
++  if (stat(outFName, &st)==0) {   /* stat succeeded, file must exist */
++    static char *foo[] = { "\nOk", "\033Cancel" };
++    char str[512];
++
++    sprintf(str,"Overwrite existing file '%s'?", outFName);
++    if (PopUp(str, foo, 2)) return -1;
++  }
++
++
++  /* Open file */
++  fd = open(outFName, O_WRONLY | O_CREAT | O_TRUNC, (0644));
++  if (fd < 0) {
++    char  str[512];
++    sprintf(str,"Can't write file '%s'\n\n  %s.",outFName, ERRSTR(errno));
++    ErrPopUp(str, "\nBummer");
++    return -1;
++  }
++
++  return fd;
++}
++#endif /* HAVE_MGCSFX */
+diff -urN xv-3.10a/xvevent.c xv-3.10a-jp-extension-current/xvevent.c
+--- xv-3.10a/xvevent.c	Tue Jan 24 08:20:24 1995
++++ xv-3.10a-jp-extension-current/xvevent.c	Sat Oct 12 16:32:46 1996
+@@ -155,6 +155,8 @@
+ {
+   static int wasInfoUp=0, wasCtrlUp=0, wasDirUp=0, wasGamUp=0, wasPsUp=0;
+   static int wasJpegUp=0, wasTiffUp=0;
++  static int wasPic2Up=0, wasPcdUp=0;
++  static int wasMgcSfxUp=0;
+ 
+   static int mainWKludge=0;  /* force first mainW expose after a mainW config
+ 				to redraw all of mainW */
+@@ -233,6 +235,22 @@
+     if (TIFFCheckEvent(event)) break;   /* event has been processed */
+ #endif
+ 
++#ifdef HAVE_PIC2
++    if (PIC2CheckEvent(event)) break;   /* event has been processed */
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++    if (PCDCheckEvent (event)) break;   /* event has been processed */
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++    if (MGCSFXCheckEvent(event)) break; /* event has been processed */
++#endif /* HAVE_MGCSFX */
++
++#ifdef TV_MULTILINGUAL
++    if (CharsetCheckEvent(event)) break; /* event has been processed */
++#endif
++
+     if (GamCheckEvent (event)) break;   /* event has been processed */
+     if (BrowseCheckEvent (event, &retval, &done)) break;   /* event eaten */
+     if (TextCheckEvent   (event, &retval, &done)) break;   /* event eaten */
+@@ -344,6 +362,9 @@
+ 
+       if (BrowseDelWin(client_event->window)) break;
+       if (TextDelWin(client_event->window)) break;
++#ifdef TV_MULTILINGUAL
++      if (CharsetDelWin(client_event->window)) break;
++#endif
+ 
+       if      (client_event->window == infoW) InfoBox(0);
+       else if (client_event->window == gamW)  GamBox(0);
+@@ -359,6 +380,18 @@
+       else if (client_event->window == tiffW) TIFFDialog(0);
+ #endif
+ 
++#ifdef HAVE_PIC2
++      else if (client_event->window == pic2W) PIC2Dialog(0);
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++      else if (client_event->window == pcdW)  PCDDialog(0);
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++      else if (client_event->window == mgcsfxW) MGCSFXDialog(0);
++#endif /* HAVE_MGCSFX */
++
+       else if (client_event->window == mainW) Quit(0);
+     }
+   }
+@@ -538,6 +571,19 @@
+ #ifdef HAVE_TIFF
+ 	if (wasTiffUp) { TIFFDialog(wasTiffUp);  wasTiffUp=0; }
+ #endif
++
++#ifdef HAVE_PIC2
++	if (wasPic2Up) { PIC2Dialog(wasPic2Up);  wasPic2Up=0; }
++#endif /* HAVE_PIC2 */
++ 
++#ifdef HAVE_PCD
++	if (wasPcdUp)  { PCDDialog(wasPcdUp);    wasPcdUp=0; }
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++	if (wasMgcSfxUp) { MGCSFXDialog(wasMgcSfxUp);  wasMgcSfxUp=0; }
++#endif /* HAVE_MGCSFX */
++
+       }
+     }
+   }
+@@ -576,6 +622,19 @@
+ #ifdef HAVE_TIFF
+ 	  if (tiffUp) { wasTiffUp = tiffUp;  TIFFDialog(0); }
+ #endif
++
++#ifdef HAVE_PIC2
++	  if (pic2Up) { wasPic2Up = pic2Up;  PIC2Dialog(0); }
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++	  if (pcdUp)  { wasPcdUp = pcdUp;    PCDDialog(0); }
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++	  if (mgcsfxUp) { wasMgcSfxUp = mgcsfxUp;  MGCSFXDialog(0); }
++#endif /* HAVE_MGCSFX */
++
+ 	}
+       }
+     }
+@@ -1147,6 +1206,22 @@
+     if (TIFFCheckEvent(event)) break;
+ #endif
+     
++#ifdef HAVE_PIC2
++    if (PIC2CheckEvent(event)) break;
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++    if (PCDCheckEvent (event)) break;
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++    if (MGCSFXCheckEvent(event)) break;
++#endif /* HAVE_MGCSFX */
++
++#ifdef TV_MULTILINGUAL
++    if (CharsetCheckEvent(event)) break;
++#endif
++
+     if (GamCheckEvent (event)) break;
+     if (BrowseCheckEvent (event, &retval, &done)) break;
+     if (TextCheckEvent   (event, &retval, &done)) break;
+@@ -1366,6 +1441,18 @@
+     if (TIFFCheckEvent(event)) break;
+ #endif
+ 
++#ifdef HAVE_PIC2
++    if (PIC2CheckEvent(event)) break;
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++    if (PCDCheckEvent (event)) break;
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++    if (MGCSFXCheckEvent(event)) break;
++#endif /* HAVE_MGCSFX */
++
+     if (GamCheckEvent (event)) break;
+     if (BrowseCheckEvent (event, &retval, &done)) break;
+     if (TextCheckEvent   (event, &retval, &done)) break;
+@@ -2372,6 +2459,18 @@
+   if (tiffUp) TIFFDialog(0);  /* close tiff window */
+ #endif
+ 
++#ifdef HAVE_PIC2
++  if (pic2Up) PIC2Dialog(0);  /* close pic2 window */
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++  if (pcdUp)  PCDDialog(0);   /* close pcd window */
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++  if (mgcsfxUp) MGCSFXDialog(0);  /* close mgcsfx window */
++#endif /* HAVE_MGCSFX */
++
+   ClosePopUp();
+ 
+   /* make the interrupt signal look like a '\n' keypress in ctrlW */
+diff -urN xv-3.10a/xvmag.c xv-3.10a-jp-extension-current/xvmag.c
+--- xv-3.10a/xvmag.c
++++ xv-3.10a-jp-extension-current/xvmag.c	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,867 @@
++/*
++ *  xvmag.c - load routine for `MAG' format pictures.
++ *
++ *  The `MAG' format is used by many Japanese personal computer users.
++ *  This program is based on MAGBIBLE.DOC which is the specification
++ *  for `MAG' format written by Woody RINN.  It is written in Japanese,
++ *  and exists in some anon-ftp sites.
++ */
++
++#include "xv.h"
++#include <setjmp.h>
++
++#ifdef HAVE_MAG
++
++typedef unsigned short data16;
++
++struct mag {
++    jmp_buf jmp;
++    FILE *fp;
++    long fsize;
++    int m_256, m_dig, m_8, m_200;
++    int x1, y1, x2, y2, left_pad, right_pad;
++    int p_width, p_height, width, height;
++    long h_off, a_off, a_size, b_off, b_size, p_off, p_size;
++    byte *a, *b, *p;
++};
++
++static void mag_open_file       PARM((struct mag*, char*));
++static void mag_read_check_data PARM((struct mag*));
++static void mag_read_comment    PARM((struct mag*, char**));
++static void mag_read_header     PARM((struct mag*));
++static void mag_read_palette    PARM((struct mag*, byte*, byte*, byte*));
++static void mag_read_flags      PARM((struct mag*));
++static void mag_read_pixel_data PARM((struct mag*));
++static void mag_expand_body     PARM((struct mag*, byte**));
++
++static void mag_compress_data    PARM((struct mag*, byte*));
++static void mag_write_check_data PARM((struct mag*));
++static void mag_write_comment    PARM((struct mag*, char *));
++static void mag_write_palette    PARM((struct mag*, int,
++				       byte*, byte*, byte*, int));
++static void mag_write_flags      PARM((struct mag*));
++static void mag_write_pixel_data PARM((struct mag*));
++static void mag_write_header     PARM((struct mag*));
++static void mag_set_double_word  PARM((long, byte *));
++
++static void mag_init_info        PARM((struct mag*));
++static void mag_cleanup_mag_info PARM((struct mag*, int));
++static void mag_cleanup_pinfo    PARM((PICINFO*));
++static void mag_memory_error     PARM((char*, char*));
++static void mag_error            PARM((struct mag*, int));
++static void mag_file_error       PARM((struct mag*, int));
++static void mag_file_warning     PARM((struct mag*, int));
++static void mag_show_struct      PARM((struct mag*));
++static void *mag_malloc          PARM((size_t, char*));
++static void *mag_realloc         PARM((void*, size_t, char*));
++
++
++static char *mag_id = "MAKI02  ";
++static struct{
++    int dx, dy;
++}points[16] = {
++    { 0,  0}, { 1,  0}, { 2,  0}, { 4,  0},
++    { 0,  1}, { 1,  1},
++    { 0,  2}, { 1,  2}, { 2,  2},
++    { 0,  4}, { 1,  4}, { 2,  4},
++    { 0,  8}, { 1,  8}, { 2,  8},
++    { 0, 16},
++};
++static int try[15] = {1, 4, 5, 6, 7, 9, 10, 2, 8, 11, 12, 13, 14, 3, 15};
++
++static char *mag_msgs[] = {
++    NULL,
++#define MAG_OPEN 1
++    "can't open file",
++#define MAG_CORRUPT 2
++    "file currupted.",
++#define MAG_FORMAT 3
++    "not MAG format.",
++#define MAG_WRITE 4
++    "write failed.",
++};
++
++
++#define H4(x) (((int) (x) >> 4) & 0x0f)	/* operates on a byte */
++#define L4(x) ((x) & 0x0f)
++#define H8(x) (((x) >> 8) & 0xff)	/* operates on a data16 */
++#define L8(x) ((x) & 0xff)
++
++#define error(msgnum) longjmp(mi->jmp, msgnum)
++
++
++/* The main routine to load a MAG file. */
++int LoadMAG(fname, pinfo)
++    char *fname;
++    PICINFO *pinfo;
++{
++    struct mag mag;
++    int e;
++    
++    if(DEBUG) fputs("LoadMAG:\n", stderr);
++    
++    pinfo->comment = NULL;
++    mag_init_info(&mag);
++    if((e = setjmp(mag.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	mag_cleanup_mag_info(&mag, 0);
++	mag_cleanup_pinfo(pinfo);
++	return 0;
++    }
++    
++    mag_open_file(&mag, fname);
++    mag_read_check_data(&mag);
++    mag_read_comment(&mag, &pinfo->comment);
++    mag_read_header(&mag);
++    mag_read_palette(&mag, pinfo->r, pinfo->g, pinfo->b);
++    mag_read_flags(&mag);
++    mag_read_pixel_data(&mag);
++    mag_expand_body(&mag, &pinfo->pic);
++    
++    pinfo->w = pinfo->normw = mag.width;
++    pinfo->h = pinfo->normh = mag.height;
++    pinfo->type = PIC8;
++    pinfo->frmType = F_MAG;
++    pinfo->colType = F_FULLCOLOR;
++    sprintf(pinfo->fullInfo, "MAG, %d colors%s (%ld bytes)",
++	    mag.m_256 ? 256 : (mag.m_8 ? 8 : 16),
++	    mag.m_200 ? ", aspect 0.5" : "", mag.fsize);
++    sprintf(pinfo->shrtInfo, "%dx%d MAG", mag.width, mag.height);
++    if(mag.m_200)
++	normaspect = 0.5;
++    
++    mag_cleanup_mag_info(&mag, 0);
++    return 1;
++}
++
++static void mag_open_file(mi, fname)
++    struct mag *mi;
++    char *fname;
++{
++    if((mi->fp = fopen(fname, "rb")) == NULL)
++	mag_file_error(mi, MAG_OPEN);
++    fseek(mi->fp, (size_t) 0, SEEK_END);
++    mi->fsize = ftell(mi->fp);
++    fseek(mi->fp, (size_t) 0, SEEK_SET);
++}
++
++static void mag_read_check_data(mi)
++    struct mag *mi;
++{
++    char buffer[8];
++    
++    if(fread(buffer, (size_t) 8, (size_t) 1, mi->fp) != 1)
++	mag_file_error(mi, MAG_CORRUPT);
++    if(strncmp(buffer, mag_id, (size_t) 8) != 0)
++	mag_error(mi, MAG_FORMAT);
++}
++
++static void mag_read_comment(mi, p)
++    struct mag *mi;
++    char **p;
++{
++    int max = -1, i = 0;
++    int c;
++    
++    while((c = fgetc(mi->fp)) != EOF){
++	if(c == 0x1a)
++	    break;
++	if(max < i){
++	    max += 16;
++	    *p = mag_realloc(*p, (size_t) max + 1, "mag_read_comment#1");
++	}
++	(*p)[i++] = c;
++    }
++    
++    if(c == EOF)
++	mag_file_error(mi, MAG_CORRUPT);
++    
++    if(max < i){
++	*p = mag_realloc(*p, (size_t) max + 2, "mag_read_comment#2");
++    }
++    if(i > 24){
++	(*p)[i] = '\0';
++	strcpy(*p, &(*p)[24]);
++    }else{
++	(*p)[0] = '\0';
++    }
++}
++
++static void mag_read_header(mi)
++    struct mag *mi;
++{
++    byte buf[32];
++    
++    mi->h_off = ftell(mi->fp);
++    
++    if(fread(buf, (size_t) 32, (size_t) 1, mi->fp) != 1)
++	mag_file_error(mi, MAG_CORRUPT);
++    
++    mi->m_256 = buf[3] & 0x80;
++    mi->m_dig = buf[3] & 0x04;
++    mi->m_8   = buf[3] & 0x02;
++    mi->m_200 = buf[3] & 0x01;
++    
++    mi->x1 = buf[ 4] + buf[ 5] * 256;
++    mi->y1 = buf[ 6] + buf[ 7] * 256;
++    mi->x2 = buf[ 8] + buf[ 9] * 256;
++    mi->y2 = buf[10] + buf[11] * 256;
++    
++#define get_dword(a, b, c, d) \
++    ((long)(a) << 24 | (long)(b) << 16 | (long)(c) << 8 | (long)(d))
++
++    mi->a_off  = get_dword(buf[15], buf[14], buf[13], buf[12]);
++    mi->b_off  = get_dword(buf[19], buf[18], buf[17], buf[16]);
++    mi->b_size = get_dword(buf[23], buf[22], buf[21], buf[20]);
++    mi->p_off  = get_dword(buf[27], buf[26], buf[25], buf[24]);
++    mi->p_size = get_dword(buf[31], buf[30], buf[29], buf[28]);
++#undef get_dword
++    
++    mi->a_size = mi->b_off - mi->a_off;
++    mi->a_off += mi->h_off;
++    mi->b_off += mi->h_off;
++    mi->p_off += mi->h_off;
++    
++    mi->width     = mi->x2 - mi->x1 + 1;
++    mi->height    = mi->y2 - mi->y1 + 1;
++    mi->left_pad  =       mi->x1 & 07;
++    mi->right_pad = 07 - (mi->x2 & 07);
++    mi->x1       -= mi->left_pad;		/* x1 = 8m   */
++    mi->x2       += mi->right_pad;		/* x2 = 8n+7 */
++    mi->p_width   = ((mi->x2 + 1) - mi->x1) / (mi->m_256 ? 2 : 4);
++    mi->p_height  =  (mi->y2 + 1) - mi->y1;
++    
++    if(DEBUG) mag_show_struct(mi);
++}
++
++static void mag_read_palette(mi, r, g, b)
++    struct mag *mi;
++    byte *r, *g, *b;
++{
++    int num_palettes;
++    int i;
++    byte *buf;
++    
++    if(mi->m_256)
++	num_palettes = 256;
++    else
++	num_palettes = 16;
++    
++    buf = mag_malloc((size_t)num_palettes * 3, "mag_read_palette");
++    
++    if(fread(buf, (size_t) 3, (size_t) num_palettes, mi->fp) != num_palettes){
++	free(buf);
++	mag_file_error(mi, MAG_CORRUPT);
++    }
++    
++    for(num_palettes--; num_palettes >= 0; num_palettes--){
++	g[num_palettes] = buf[num_palettes * 3    ];
++	r[num_palettes] = buf[num_palettes * 3 + 1];
++	b[num_palettes] = buf[num_palettes * 3 + 2];
++    }
++    
++    free(buf);
++}
++
++static void mag_read_flags(mi)
++     struct mag *mi;
++{
++    mi->a = mag_malloc((size_t) mi->a_size, "mag_read_flags#1");
++    mi->b = mag_malloc((size_t) mi->b_size, "mag_read_flags#2");
++    
++    fseek(mi->fp, mi->a_off, SEEK_SET);
++    if(fread(mi->a, (size_t) mi->a_size, (size_t) 1, mi->fp) != 1)
++	mag_file_warning(mi, MAG_CORRUPT);
++    if(fread(mi->b, (size_t) mi->b_size, (size_t) 1, mi->fp) != 1)
++	mag_file_warning(mi, MAG_CORRUPT);
++}
++
++static void mag_read_pixel_data(mi)
++    struct mag *mi;
++{
++    mi->p = mag_malloc((size_t) mi->p_size, "mag_read_pixel_data");
++    
++    fseek(mi->fp, mi->p_off, SEEK_SET);
++    if(fread(mi->p, (size_t) mi->p_size, (size_t) 1, mi->fp) != 1)
++	mag_file_warning(mi, MAG_CORRUPT);
++}
++
++/* MAG expanding routine */
++static void mag_expand_body(mi, pic0)
++    struct mag *mi;
++    byte **pic0;
++{
++    int ai, bi, fi, pi, i;
++    int px, py, x, y;
++    byte *flag;
++    byte mask;
++    data16 *pixel0;
++    
++    flag   = mag_malloc((size_t) mi->p_width / 2, "mag_expand_body#1");
++    *pic0  = mag_malloc((size_t) mi->width * mi->height, "mag_expand_body#2");
++    pixel0 = mag_malloc((size_t) 2 * mi->p_width * 17, "mag_expand_body#3");
++    
++#define pixel(x, y) pixel0[(y) % 17 * mi->p_width + (x)]
++    
++    ai = bi = pi = 0;
++    mask = 0x80;
++    for(y = py = 0; py < mi->p_height; py++){
++	for(fi = 0; fi < mi->p_width / 2; fi++){
++	    if(py == 0){
++		if(mi->a[ai] & mask)
++		    flag[fi] = mi->b[bi++];
++		else
++		    flag[fi] = 0;
++	    }else{
++		if(mi->a[ai] & mask)
++		    flag[fi] ^= mi->b[bi++];
++	    }
++	    if((mask >>= 1) == 0){
++		mask = 0x80;
++		ai++;
++	    }
++	}
++	
++	for(px = fi = 0; fi < mi->p_width / 2; fi++){
++	    int f = H4(flag[fi]);
++	    if(f == 0){
++		pixel(px, py) = mi->p[pi] + mi->p[pi + 1] * 256;
++		px++;
++		pi+=2;
++	    }else{
++		int dx = points[f].dx, dy = points[f].dy;
++		pixel(px, py) = pixel(px - dx, py - dy);
++		px++;
++	    }
++	    
++	    f = L4(flag[fi]);
++	    if(f == 0){
++		pixel(px, py) = mi->p[pi] + mi->p[pi + 1] * 256;
++		px++;
++		pi+=2;
++	    }else{
++		int dx = points[f].dx, dy = points[f].dy;
++		pixel(px, py) = pixel(px - dx, py - dy);
++		px++;
++	    }
++	}
++	
++#define inside(x) ((unsigned int)(x) < mi->width)
++#define  pic(x, y) (*pic0)[(y) * mi->width + (x)]
++	for(x = -mi->left_pad, px = 0; px < mi->p_width; px++){
++	    data16 p = pixel(px, py);
++	    if(mi->m_256){
++		if(inside(x))
++		    pic(x, y) = L8(p);
++		x++;
++		if(inside(x))
++		    pic(x, y) = H8(p);
++		x++;
++	    }else{
++		if(inside(x))
++		    pic(x, y) = H4(L8(p));
++		x++;
++		if(inside(x))
++		    pic(x, y) = L4(L8(p));
++		x++;
++		if(inside(x))
++		    pic(x, y) = H4(H8(p));
++		x++;
++		if(inside(x))
++		    pic(x, y) = L4(H8(p));
++		x++;
++	    }
++	}
++	y++;
++    }
++#undef pic
++#undef inside
++#undef pixel
++    
++    free(flag);
++    free(pixel0);
++}
++
++
++/* The main routine to write a MAG file. */
++int WriteMAG(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
++	      comment)
++    FILE *fp;
++    byte *pic;
++    int ptype, w, h;
++    byte *rmap, *gmap, *bmap;
++    int numcols, colorstyle;
++    char *comment;
++{
++    byte rtemp[256], gtemp[256], btemp[256];
++    struct mag mag;
++    int e;
++    
++    if(DEBUG) fputs("WriteMag\n", stderr);
++    
++    mag_init_info(&mag);
++    mag.fp = fp;
++    
++    if(ptype == PIC24){
++	if(!(pic = Conv24to8(pic, w, h, 256, rtemp, gtemp, btemp)))
++	    mag_memory_error("Conv24to8", "WriteMAG");
++	rmap = rtemp;
++	gmap = gtemp;
++	bmap = btemp;
++	numcols = 256;
++	mag.m_256 = 1;
++    }else{
++	if(numcols > 16)
++	    mag.m_256 = 1;
++    }
++    
++    if((e = setjmp(mag.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	mag_cleanup_mag_info(&mag, 1);
++	return -1;
++    }
++    
++    mag.x2 = w - 1;
++    mag.y2 = h - 1;
++    mag.right_pad = 07 - (mag.x2 & 07);
++    mag.p_width = (w + mag.right_pad) / (mag.m_256 ? 2 : 4);
++    mag.p_height = h;
++    mag.width = w;
++    mag.height = h;
++    mag.a_size = (mag.p_width * mag.p_height + 15) / 16;	/* x/2/8 */
++    if(mag.a_size % 2)
++	mag.a_size++;
++    
++    mag_compress_data(&mag, pic);
++    mag_write_check_data(&mag);
++    mag_write_comment(&mag, comment);
++    
++    mag.h_off = ftell(mag.fp);
++    
++    mag_write_palette(&mag, numcols, rmap, gmap, bmap,
++		      colorstyle == F_GREYSCALE);
++    mag_write_flags(&mag);
++    mag_write_pixel_data(&mag);
++    mag_write_header(&mag);
++    
++    mag_cleanup_mag_info(&mag, 1);
++    return 0;
++}
++
++/* MAG compressing routine */
++static void mag_compress_data(mi, pic0)
++    struct mag *mi;
++    byte *pic0;
++{
++    int ai, bi, pi, i;
++    int bmax, pmax;
++    byte mask;
++    byte *flag0;
++    data16 *pixel0;
++    int px, py, x, y;
++    
++    pixel0 = mag_malloc((size_t) 2 * mi->p_width * mi->p_height,
++			"mag_compress_data#1");
++    flag0 = mag_malloc((size_t) mi->p_width * mi->p_height,
++		       "mag_compress_data#2");
++    
++#define pic(x, y) pic0[(y) * mi->width + (x)]
++    /* convert dots to pixels */
++    i = 0; 
++    for(y = py = 0; py < mi->p_height; py++){
++	for(x = px = 0; px < mi->p_width; px++){
++	    data16 p = 0;
++	    if(mi->m_256){
++		if(x < mi->width)
++		    p += pic(x, y);
++		x++;
++		if(x < mi->width)
++		    p += pic(x, y) * 256;
++		x++;
++	    }else{
++		if(x < mi->width)
++		    p += pic(x, y) * 16;
++		x++;
++		if(x < mi->width)
++		    p += pic(x, y);
++		x++;
++		if(x < mi->width)
++		    p += pic(x, y) * 4096;
++		x++;
++		if(x < mi->width)
++		    p += pic(x, y) * 256;
++		x++;
++	    }
++	    pixel0[i++] = p;
++	}
++	y++;
++    }
++#undef pic
++    
++#define pixel(x, y) pixel0[(y) * mi->p_width + (x)]
++#define  flag(x, y)  flag0[(y) * mi->p_width + (x)]
++    /* get flags */
++    pmax = pi = 0;
++    for(py = 0; py < mi->p_height; py++){
++	for(px = 0; px < mi->p_width; px++){
++	    int t;
++	    for(t = 0; t < 15; t++){
++		int dx = points[try[t]].dx, dy = points[try[t]].dy;
++		if(dx <= px && dy <= py){
++		    if(pixel(px - dx, py - dy) == pixel(px, py))
++			break;
++		}
++	    }
++	    if(t < 15){
++		flag(px, py) = try[t];
++	    }else{
++		flag(px, py) = 0;
++		if(pmax <= pi + 1){
++		    pmax += 128;
++		    mi->p = mag_realloc(mi->p, (size_t) pmax,
++					"mag_compress_data#3");
++		}
++		mi->p[pi++] = L8(pixel(px, py));
++		mi->p[pi++] = H8(pixel(px, py));
++	    }
++	}
++    }
++#undef flag
++#undef pixel
++    
++    /* pack 2 flags into 1 byte */
++    for(i = 0; i < mi->p_width / 2 * mi->p_height; i++)
++	flag0[i] = flag0[i * 2] * 16 + flag0[i * 2 + 1];
++    
++#define flag(x, y)  flag0[(y) * mi->p_width / 2 + (x)]
++    for(py = mi->p_height - 1; py >= 1; py--){
++	for(px = 0; px < mi->p_width / 2; px++)
++	    flag(px, py) ^= flag(px, py - 1);
++    }
++#undef flag
++    
++    mask = 0x80;
++    ai = bi = bmax = 0;
++    mi->a = mag_malloc((size_t) mi->a_size, "mag_compress_data#4");
++    for(i = 0; i < mi->p_width / 2 * mi->p_height; i++){
++	if(flag0[i] == 0){
++	    mi->a[ai] &= ~mask;
++	}else{
++	    if(bmax == bi){
++		bmax += 128;
++		mi->b = mag_realloc(mi->b, (size_t) bmax,
++				    "mag_compress_data#4");
++	    }
++	    mi->b[bi++] = flag0[i];
++	    mi->a[ai] |= mask;
++	}
++	
++	if((mask >>= 1) == 0){
++	    mask = 0x80;
++	    ai++;
++	}
++    }
++    
++    if(bi % 2)
++	bi++;
++    mi->b_size = bi;
++    
++    mi->p_size = pi;
++    
++    free(pixel0);
++    free(flag0);
++}
++
++static void mag_write_check_data(mi)
++    struct mag *mi;
++{
++    if(fwrite(mag_id, (size_t) 8, (size_t) 1, mi->fp) != 1)
++	mag_file_error(mi, MAG_WRITE);
++}
++
++static void mag_write_comment(mi, comment)
++    struct mag *mi;
++    char *comment;
++{
++    char *p;
++    int i;
++    
++    if(fputs("XV   ", mi->fp) == EOF)
++	mag_file_error(mi, MAG_WRITE);
++    
++    if((p = (char *) getenv("USER")) == NULL)
++	p = "????????";
++    for(i = 5; i < 24; i++){
++	if(*p == '\0')
++	    break;
++	if(fputc(*p++, mi->fp) == EOF)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++    for( ; i < 24; i++){
++	if(fputc(' ', mi->fp) == EOF)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++    
++    if(comment){
++	int l = strlen(comment);
++	if(l > 0){
++	    int i;
++	    for(i = 0; i < l; i++){
++		if(comment[i] == 0x1a)
++		    comment[i] = ' ';
++	    }
++	    if(fwrite(comment, (size_t) l, (size_t) 1, mi->fp) != 1)
++		mag_file_error(mi, MAG_WRITE);
++	}
++    }
++    
++    if(fputc(0x1a, mi->fp) == EOF)
++	mag_file_error(mi, MAG_WRITE);
++}
++
++static void mag_write_palette(mi, num, r, g, b, grey)
++    struct mag *mi;
++    int num;
++    byte *r, *g, *b;
++    int grey;
++{
++    int i, left;
++    char buf[3];
++    
++    fseek(mi->fp, 32L, SEEK_CUR);	/* skip header area */
++    for(i = 0; i < num; i++){
++	buf[0] = *g++;
++	buf[1] = *r++;
++	buf[2] = *b++;
++	if(grey)
++	    buf[0] = buf[1] = buf[2] = MONO(buf[1], buf[0], buf[2]);
++	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++    if(num < 16){
++	left = 16 - num;
++    }else if(num == 16){
++	left = 0;
++    }else if(num < 256){
++	left = 256 - num;
++    }else if(num == 256){
++	left = 0;
++    }else
++	left = 0;	/* shouldn't happen */
++    
++    if(left > 0){
++	for(i = 0; i < left; i++){
++	    if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
++		mag_file_error(mi, MAG_WRITE);
++	}
++    }
++}
++
++static void mag_write_flags(mi)
++    struct mag *mi;
++{
++    int i;
++    
++    mi->a_off = ftell(mi->fp);
++    for(i = 0; i < mi->a_size; i++){
++	if(fputc(mi->a[i], mi->fp) == EOF)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++    
++    mi->b_off = ftell(mi->fp);
++    for(i = 0; i < mi->b_size; i++){
++	if(fputc(mi->b[i], mi->fp) == EOF)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++}
++
++static void mag_write_pixel_data(mi)
++    struct mag *mi;
++{
++    int i;
++    
++    mi->p_off = ftell(mi->fp);
++    for(i = 0; i < mi->p_size; i++){
++	if(fputc(mi->p[i], mi->fp) == EOF)
++	    mag_file_error(mi, MAG_WRITE);
++    }
++}
++
++static void mag_write_header(mi)
++    struct mag *mi;
++{
++    byte buf[32];
++    
++    if(DEBUG) mag_show_struct(mi);
++    
++    mi->a_off -= mi->h_off;
++    mi->b_off -= mi->h_off;
++    mi->p_off -= mi->h_off;
++    
++    buf[ 0] = buf[1] = buf[2] = 0;
++    buf[ 3] = (mi->m_256 ? 0x80 : 0);
++    buf[ 4] = buf[5] = 0;
++    buf[ 6] = buf[7] = 0;
++    buf[ 8] = L8(mi->x2);
++    buf[ 9] = H8(mi->x2);
++    buf[10] = L8(mi->y2);
++    buf[11] = H8(mi->y2);
++    mag_set_double_word(mi->a_off,  &buf[12]);
++    mag_set_double_word(mi->b_off,  &buf[16]);
++    mag_set_double_word(mi->b_size, &buf[20]);
++    mag_set_double_word(mi->p_off,  &buf[24]);
++    mag_set_double_word(mi->p_size, &buf[28]);
++    
++    fseek(mi->fp, mi->h_off, SEEK_SET);
++    if(fwrite(buf, (size_t) 32, (size_t) 1, mi->fp) != 1)
++	mag_file_error(mi, MAG_WRITE);
++}
++
++static void mag_set_double_word(n, p)
++    long n;
++    byte *p;
++{
++    p[0] = n % 256;
++    p[1] = n / 256 % 256;
++    p[2] = n / 256 / 256 % 256;
++    p[3] = n / 256 / 256 / 256 % 256;
++}
++
++/*
++ * The routines to initialize or clean up.
++ * mag_init_info:
++ *	initializes a mag structure.
++ * mag_cleanup_mag_info:
++ *	cleans up a mag structure.
++ * mag_cleanup_pinfo:
++ *	cleans up a PICINFO structure.
++ */
++static void mag_init_info(mi)
++    struct mag *mi;
++{
++    mi->fp = NULL;
++    mi->fsize = 0;
++    mi->m_256 = mi->m_dig = mi->m_8 = mi->m_200 = 0;
++    mi->x1 = mi->y1 = mi->x2 = mi->y2 = 0;
++    mi->left_pad = mi->right_pad = 0;
++    mi->p_width = mi->p_height = mi->width = mi->height = 0;
++    mi->h_off = mi->p_off = mi->p_size = 0;
++    mi->a_off = mi->a_size = mi->b_off = mi->b_size = 0;
++    mi->a = NULL;
++    mi->b = NULL;
++    mi->p = NULL;
++}
++
++static void mag_cleanup_mag_info(mi, writing)
++    struct mag *mi;
++    int writing;
++{
++    if(mi->fp && !writing)
++	fclose(mi->fp);
++    if(mi->a)
++	free(mi->a);
++    if(mi->b)
++	free(mi->b);
++    if(mi->p)
++	free(mi->p);
++}
++
++static void mag_cleanup_pinfo(pinfo)
++    PICINFO *pinfo;
++{
++    if(pinfo->comment){
++	free(pinfo->comment);
++	pinfo->comment = NULL;
++    }
++    if(pinfo->pic){
++	free(pinfo->pic);
++	pinfo->pic = NULL;
++    }
++}
++
++/*
++ * Error handler.
++ * mag_memory_error:
++ *	shows an error message, and terminates.
++ * mag_error:
++ *	shows an non-file error message, and jumps to the entry for errors.
++ * mag_file_error:
++ *	shows an file error message, and jumps to the entry for errors.
++ * mag_file_warning:
++ *	shows an file warning message.
++ */
++static void mag_memory_error(scm, fn)
++    char *scm, *fn;
++{
++    char buf[128];
++    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
++    FatalError(buf);
++}
++
++static void mag_error(mi, mn)
++    struct mag *mi;
++    int mn;
++{
++    SetISTR(ISTR_WARNING, "%s", mag_msgs[mn]);
++    longjmp(mi->jmp, 1);
++}
++
++static void mag_file_error(mi, mn)
++    struct mag *mi;
++    int mn;
++{
++    if(feof(mi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", mag_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", mag_msgs[mn], ERRSTR(errno));
++    longjmp(mi->jmp, 1);
++}
++
++static void mag_file_warning(mi, mn)
++    struct mag *mi;
++    int mn;
++{
++    if(feof(mi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", mag_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", mag_msgs[mn], ERRSTR(errno));
++}
++
++static void mag_show_struct (mi)
++    struct mag *mi;
++{
++    fprintf(stderr, "  256 colors: %s\n", mi->m_256 ? "true" : "false");
++    fprintf(stderr, "  8 colors: %s\n", mi->m_8 ? "true" : "false");
++    fprintf(stderr, "  digital colors: %s\n", mi->m_dig ? "true" : "false");
++    fprintf(stderr, "  aspect ratio: %f\n", mi->m_200 ? 0.5 : 1.0);
++    fprintf(stderr, "  image size: %dx%d\n", mi->width, mi->height);
++    fprintf(stderr, "  left pad: %d\n", mi->left_pad);
++    fprintf(stderr, "  right pad: %d\n", mi->right_pad);
++    fprintf(stderr, "  h_off: %ld\n", mi->h_off);
++    fprintf(stderr, "  A: off:%ld, size:%ld\n", mi->a_off, mi->a_size);
++    fprintf(stderr, "  B: off:%ld, size:%ld\n", mi->b_off, mi->b_size);
++    fprintf(stderr, "  P: off:%ld, size:%ld\n", mi->p_off, mi->p_size);
++}
++
++/* Memory related routines. */
++static void *mag_malloc(n, fn)
++    size_t n;
++    char *fn;
++{
++    void *r = (void *) malloc(n);
++    if(r == NULL)
++	mag_memory_error("malloc", fn);
++    return r;
++}
++
++static void *mag_realloc(p, n, fn)
++    void *p;
++    size_t n;
++    char *fn;
++{
++    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
++    if(r == NULL)
++	mag_memory_error("realloc", fn);
++    return r;
++}
++#endif /* HAVE_MAG */
+diff -urN xv-3.10a/xvmaki.c xv-3.10a-jp-extension-current/xvmaki.c
+--- xv-3.10a/xvmaki.c
++++ xv-3.10a-jp-extension-current/xvmaki.c	Wed Oct  9 20:37:19 1996
+@@ -0,0 +1,789 @@
++/*
++ * xvmaki.c - load routine for `MAKI' format pictures.
++ *
++ * The `MAKI' format was used by some Japanese personal computer users.
++ */
++
++#include "xv.h"
++#include <setjmp.h>
++
++#ifdef HAVE_MAKI
++
++typedef unsigned short data16;
++typedef unsigned int data32;
++
++struct maki_info {
++    jmp_buf jmp;
++    FILE *fp;
++    long fsize;
++    int x0, y0, x1, y1;
++    int width, height;
++    float aspect;
++    long fb_size;
++    long pa_size, pb_size;
++    int m_maki01b, m_200, m_dig8;
++    data16 ext_flag;
++    byte *fa, *fb, *pa, *pb;
++    byte *vs;
++    int numcols;
++    byte *forma, *formb;
++};
++
++
++static void maki_open_file             PARM((struct maki_info*, char*));
++static void maki_check_id              PARM((struct maki_info*));
++static void maki_skip_comment          PARM((struct maki_info*));
++static void maki_read_header           PARM((struct maki_info*));
++static void maki_read_palette          PARM((struct maki_info*,
++					     byte*, byte*, byte*));
++static void maki_read_flags            PARM((struct maki_info*));
++static void maki_read_pixel_data       PARM((struct maki_info*));
++static void maki_expand_virtual_screen PARM((struct maki_info*));
++static void maki_expand_pixel_data     PARM((struct maki_info*, byte**));
++static void maki_init_info             PARM((struct maki_info*));
++
++static void maki_make_pixel_data       PARM((struct maki_info*, byte*));
++static void maki_make_virtual_screen   PARM((struct maki_info*));
++static void maki_make_flags            PARM((struct maki_info*));
++static void maki_write_check_id        PARM((struct maki_info*));
++static void maki_write_comment         PARM((struct maki_info*));
++static void maki_write_header          PARM((struct maki_info*));
++static void maki_write_palette         PARM((struct maki_info*,
++					     byte*, byte*, byte*, int));
++static void maki_write_flags           PARM((struct maki_info*));
++static void maki_write_pixel_data      PARM((struct maki_info*));
++
++static void maki_cleanup_maki_info     PARM((struct maki_info*, int));
++static void maki_cleanup_pinfo         PARM((PICINFO*));
++static void maki_memory_error          PARM((char*, char*));
++static void maki_error                 PARM((struct maki_info*, int));
++static void maki_file_error            PARM((struct maki_info*, int));
++static void maki_file_warning          PARM((struct maki_info*, int));
++static void maki_show_maki_info        PARM((struct maki_info*));
++static void *maki_malloc               PARM((size_t, char*));
++static void *maki_realloc              PARM((void *, size_t, char*));
++
++static char maki_id_a[] = "MAKI01A ";
++static char maki_id_b[] = "MAKI01B ";
++
++static char *maki_msgs[] = {
++    NULL,
++#define MAKI_OPEN 1
++    "can't open file.",
++#define MAKI_CORRUPT 2
++    "file corrupted.",
++#define MAKI_FORMAT 3
++    "not MAKI format.",
++#define MAKI_BAD_DATA 4
++    "bad data.",
++#define MAKI_COMMENT 5
++    "no '^Z' after comment.",
++#define MAKI_SIZE 6
++    "bad size.",
++#define MAKI_WRITE 7
++    "write failed.",
++};
++
++#define H4(b) ((b) >> 4 & 0xf)
++#define L4(b) ((b)      & 0xf)
++#define error(msg_num) longjmp(mi->jmp, msg_num)
++
++int LoadMAKI(fname, pinfo)
++    char *fname;
++    PICINFO *pinfo;
++{
++    struct maki_info maki;
++    int e;
++    
++    if(DEBUG) fputs("LoadMAKI:\n", stderr);
++    
++    pinfo->comment = NULL;
++    maki_init_info(&maki);
++    if((e = setjmp(maki.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	maki_cleanup_maki_info(&maki, 0);
++	maki_cleanup_pinfo(pinfo);
++	return 0;
++    }
++    
++    maki_open_file(&maki, fname);
++    maki_check_id(&maki);
++    maki_skip_comment(&maki);
++    maki_read_header(&maki);
++    maki_read_palette(&maki, pinfo->r, pinfo->g, pinfo->b);
++    maki_read_flags(&maki);
++    maki_read_pixel_data(&maki);
++    maki_expand_virtual_screen(&maki);
++    maki_expand_pixel_data(&maki, &pinfo->pic);
++    
++    pinfo->w = pinfo->normw = maki.width;
++    pinfo->h = pinfo->normh = maki.height;
++    pinfo->type = PIC8;
++    pinfo->frmType = F_MAKI;
++    pinfo->colType = F_FULLCOLOR;
++    sprintf(pinfo->fullInfo, "MAKI, 16 colors (%ld bytes)", maki.fsize);
++    sprintf(pinfo->shrtInfo, "%dx%d MAKI", maki.width, maki.height);
++    normaspect = maki.aspect;
++    
++    maki_cleanup_maki_info(&maki, 0);
++    return 1;
++}
++
++static void maki_open_file(mi, fname)
++    struct maki_info *mi;
++    char *fname;
++{
++    if((mi->fp = fopen(fname, "rb")) == NULL)
++	maki_file_error(mi, MAKI_OPEN);
++    fseek(mi->fp, (size_t) 0, SEEK_END);
++    mi->fsize = ftell(mi->fp);
++    fseek(mi->fp, (size_t) 0, SEEK_SET);
++}
++
++static void maki_check_id(mi)
++    struct maki_info *mi;
++{
++    char buf[8];
++    if(fread(buf, (size_t) 8, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_CORRUPT);
++    if(strncmp(buf, maki_id_a, (size_t) 8) != 0 &&
++       strncmp(buf, maki_id_b, (size_t) 8) != 0)
++	maki_error(mi, MAKI_FORMAT);
++    mi->m_maki01b = (buf[6] == 'B');
++}
++
++static void maki_skip_comment(mi)
++    struct maki_info *mi;
++{
++    int i;
++    int c;
++    
++    for(i = 0; i < 24; i++){
++	if((c = fgetc(mi->fp)) == EOF)
++	    maki_file_error(mi, MAKI_CORRUPT);
++	if(c == '\032')	/* ^Z, 0x1a */
++	    break;
++    }
++    if(c != '\032')
++	maki_file_error(mi, MAKI_COMMENT);
++    
++    fseek(mi->fp, 32L, SEEK_SET);
++}
++
++static void maki_read_header(mi)
++    struct maki_info *mi;
++{
++    byte buf[16];
++    
++    if(fread(buf, (size_t) 16, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_CORRUPT);
++    
++    mi->fb_size  = (long)buf[ 0] << 8 | (long)buf[ 1];
++    mi->pa_size  = (long)buf[ 2] << 8 | (long)buf[ 3];
++    mi->pb_size  = (long)buf[ 4] << 8 | (long)buf[ 5];
++    mi->ext_flag = (long)buf[ 6] << 8 | (long)buf[ 7];
++    mi->x0       = (long)buf[ 8] << 8 | (long)buf[ 9];
++    mi->y0       = (long)buf[10] << 8 | (long)buf[11];
++    mi->x1       = (long)buf[12] << 8 | (long)buf[13];
++    mi->y1       = (long)buf[14] << 8 | (long)buf[15];
++    
++    mi->width  = mi->x1-- - mi->x0;
++    mi->height = mi->y1-- - mi->y0;
++    mi->m_200  = mi->ext_flag & 1;
++    mi->m_dig8 = mi->ext_flag & 2;
++    mi->aspect = mi->m_200 ? 0.5 : 1.0;
++    
++    if(DEBUG) maki_show_maki_info(mi);
++}
++
++static void maki_read_palette(mi, r, g, b)
++    struct maki_info *mi;
++    byte *r, *g, *b;
++{
++    byte buf[48], *p;
++    
++    if(fread(buf, (size_t) 48, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_CORRUPT);
++    
++    for(p = buf; p < &buf[48]; ){
++	*g++ = *p++;
++	*r++ = *p++;
++	*b++ = *p++;
++    }
++}
++
++static void maki_read_flags(mi)
++    struct maki_info *mi;
++{
++    mi->fa = maki_malloc((size_t) 1000       , "maki_read_flags#1");
++    mi->fb = maki_malloc((size_t) mi->fb_size, "maki_read_flags#2");
++    
++    if(fread(mi->fa, (size_t) 1000, (size_t) 1, mi->fp) != 1)
++	maki_file_warning(mi, MAKI_CORRUPT);
++    if(fread(mi->fb, (size_t) mi->fb_size, (size_t) 1, mi->fp) != 1)
++	maki_file_warning(mi, MAKI_CORRUPT);
++}
++
++static void maki_read_pixel_data(mi)
++    struct maki_info *mi;
++{
++    mi->pa = maki_malloc((size_t) mi->pa_size, "maki_read_pixel_data#1");
++    mi->pb = maki_malloc((size_t) mi->pb_size, "maki_read_pixel_data#2");
++    
++    if(fread(mi->pa, (size_t) mi->pa_size, (size_t) 1, mi->fp) != 1)
++	maki_file_warning(mi, MAKI_CORRUPT);
++    if(fread(mi->pb, (size_t) mi->pb_size, (size_t) 1, mi->fp) != 1)
++	maki_file_warning(mi, MAKI_CORRUPT);
++}
++
++static void maki_expand_virtual_screen(mi)
++    struct maki_info *mi;
++{
++    int x, y, fai, fbi;
++    int bpl = mi->width / 2 / 8;		/* bytes per line */
++    byte mask;
++    mi->vs = maki_malloc((size_t) bpl * mi->height,
++			 "maki_expand_virtual_screen");
++    
++    fai = fbi = 0;
++    mask = 0x80;
++    for(y = 0; y < mi->height; y += 4){
++	for(x = 0; x < mi->width / 2; x += 4){
++	    if(mi->fa[fai] & mask){
++		byte bh, bl;
++		bh = mi->fb[fbi++];
++		bl = mi->fb[fbi++];
++		if(x % 8 == 0){
++		    mi->vs[ y      * bpl + x / 8] = H4(bh) << 4;
++		    mi->vs[(y + 1) * bpl + x / 8] = L4(bh) << 4;
++		    mi->vs[(y + 2) * bpl + x / 8] = H4(bl) << 4;
++		    mi->vs[(y + 3) * bpl + x / 8] = L4(bl) << 4;
++		}else{
++		    mi->vs[ y      * bpl + x / 8] |= H4(bh);
++		    mi->vs[(y + 1) * bpl + x / 8] |= L4(bh);
++		    mi->vs[(y + 2) * bpl + x / 8] |= H4(bl);
++		    mi->vs[(y + 3) * bpl + x / 8] |= L4(bl);
++		}
++	    }else{
++		if(x % 8 == 0){
++		    mi->vs[ y      * bpl + x / 8] = 0;
++		    mi->vs[(y + 1) * bpl + x / 8] = 0;
++		    mi->vs[(y + 2) * bpl + x / 8] = 0;
++		    mi->vs[(y + 3) * bpl + x / 8] = 0;
++		}else{
++/*		    mi->vs[ y      * bpl + x / 8] |= 0;
++		    mi->vs[(y + 1) * bpl + x / 8] |= 0;
++		    mi->vs[(y + 2) * bpl + x / 8] |= 0;
++		    mi->vs[(y + 3) * bpl + x / 8] |= 0; */
++		}
++	    }
++	    
++	    if((mask >>= 1) == 0){
++		mask = 0x80;
++		fai++;
++	    }
++	}
++    }
++}
++
++static void maki_expand_pixel_data(mi, pic)
++    struct maki_info *mi;
++    byte **pic;
++{
++    int x, y;
++    int vsi, pi, max_pi;
++    byte *p;
++    byte mask;
++    int gap;
++    *pic = maki_malloc((size_t) mi->width * mi->height,
++		       "maki_expand_pixel_data");
++    
++    vsi = pi = 0;
++    p = mi->pa;
++    max_pi = mi->pa_size - 1;
++    mask = 0x80;
++    for(y = 0; y < mi->height; y++){
++	for(x = 0; x < mi->width; x += 2){
++	    if(mi->vs[vsi] & mask){
++		if(pi > max_pi){
++		    if(p == mi->pb)
++			maki_error(mi, MAKI_BAD_DATA);
++		    pi = 0;
++		    p = mi->pb;
++		    max_pi = mi->pb_size - 1;
++		}
++		(*pic)[y * mi->width + x    ] = H4(p[pi]);
++		(*pic)[y * mi->width + x + 1] = L4(p[pi]);
++		pi++;
++	    }else{
++		(*pic)[y * mi->width + x    ] = 0;
++		(*pic)[y * mi->width + x + 1] = 0;
++	    }
++	    
++	    if((mask >>= 1) == 0){
++		mask = 0x80;
++		vsi++;
++	    }
++	}
++    }
++    
++    gap = mi->m_maki01b ? 4 : 2;
++    
++    for(y = gap; y < mi->height; y++){
++	for(x = 0; x < mi->width; x++)
++	    (*pic)[y * mi->width + x] ^= (*pic)[(y - gap) * mi->width + x];
++    }
++}
++
++
++int WriteMAKI(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle)
++    FILE *fp;
++    byte *pic;
++    int ptype, w, h;
++    byte *rmap, *gmap, *bmap;
++    int numcols, colorstyle;
++{
++    byte rtemp[256], gtemp[256], btemp[256];
++    struct maki_info maki, *mi = &maki;
++    int e;
++    
++    if(DEBUG) fputs("WriteMAKI:\n", stderr);
++    
++    maki_init_info(&maki);
++    if((e = setjmp(maki.jmp)) != 0){
++	/* An error occurs */
++	maki_cleanup_maki_info(&maki, 1);
++	return -1;
++    }
++    
++    if(w != 640 || h != 400)
++	maki_error(mi, MAKI_SIZE);
++    
++    maki.fp = fp;
++    maki.width = w;
++    maki.height = h;
++    maki.x1 = w - 1;
++    maki.y1 = h - 1;
++    
++    if(ptype == PIC24){
++	if(!(pic = Conv24to8(pic, w, h, 16, rtemp, gtemp, btemp)))
++	    maki_memory_error("Conv24to8#1", "WriteMAKI");
++	rmap = rtemp;
++	gmap = gtemp;
++	bmap = btemp;
++    }else if(numcols > 16){
++	if(!(pic = Conv8to24(pic, w, h, rmap, gmap, bmap)))
++	    maki_memory_error("Conv8to24", "WriteMAKI");
++	if(!(pic = Conv24to8(pic, w, h, 16, rtemp, gtemp, btemp)))
++	    maki_memory_error("Conv24to8#2", "WriteMAKI");
++	rmap = rtemp;
++	gmap = gtemp;
++	bmap = btemp;
++    }else
++	maki.numcols = numcols;
++    
++    maki_make_pixel_data(&maki, pic);
++    maki_make_virtual_screen(&maki);
++    maki_make_flags(&maki);
++    maki_write_check_id(&maki);
++    maki_write_comment(&maki);
++    maki_write_header(&maki);
++    maki_write_palette(&maki, rmap, gmap, bmap, colorstyle == F_GREYSCALE);
++    maki_write_flags(&maki);
++    maki_write_pixel_data(&maki);
++    
++    maki_cleanup_maki_info(&maki, 1);
++    return 0;
++}
++
++static void maki_make_pixel_data(mi, pic)
++    struct maki_info *mi;
++    byte *pic;
++{
++    int x, y, i;
++    int nza, nzb;
++    
++    mi->forma = maki_malloc((size_t) mi->width / 2 * mi->height,
++			    "maki_make_pixel_data#1");
++    mi->formb = maki_malloc((size_t) mi->width / 2 * mi->height,
++			    "maki_make_pixel_data#2");
++    
++    for(y = 0; y < mi->height; y++){
++	for(x = 0; x < mi->width; x += 2){
++	    byte b;
++	    b = pic[y * mi->width + x] << 4 | pic[y * mi->width + x + 1];
++	    mi->forma[y * mi->width / 2 + x / 2] = b;
++	    mi->formb[y * mi->width / 2 + x / 2] = b;
++	}
++    }
++    
++    for(y = mi->height - 1; y >= 2; y--){
++	for(x = 0; x < mi->width / 2; x++){
++	    mi->forma[y * mi->width / 2 + x] ^=
++		mi->forma[(y - 2) * mi->width / 2 + x];
++	}
++    }
++    
++    for(y = mi->height - 1; y >= 4; y--){
++	for(x = 0; x < mi->width / 2; x++){
++	    mi->formb[y * mi->width / 2 + x] ^=
++		mi->formb[(y - 4) * mi->width / 2 + x];
++	}
++    }
++    
++    nza = nzb = 0;
++    for(i = 0; i < mi->width / 2 * mi->height; i++){
++	if(mi->forma[i] != 0)
++	    nza++;
++	if(mi->formb[i] != 0)
++	    nzb++;
++    }
++    if(nza > nzb){
++	mi->m_maki01b = 1;
++	free(mi->forma);
++	mi->forma = NULL;
++    }else{
++	mi->m_maki01b = 0;
++	free(mi->formb);
++	mi->formb = NULL;
++    }
++}
++
++static void maki_make_virtual_screen(mi)
++    struct maki_info *mi;
++{
++    int bpl = mi->width / 2 / 8;
++    int vsi, pai, pbi, max_pai, max_pbi;
++    byte mask;
++    byte *pixels;
++    int x, y;
++    
++    mi->vs = maki_malloc((size_t) bpl * mi->height,
++			 "maki_make_virtual_screen#1");
++    
++    if(mi->m_maki01b)
++	pixels = mi->formb;
++    else
++	pixels = mi->forma;
++    
++    vsi = pai = pbi = 0;
++    max_pai = max_pbi = -1;
++    mask = 0x80;
++    for(y = 0; y < mi->height; y++){
++	for(x = 0; x < mi->width / 2; x++){
++	    if(pixels[y * mi->width / 2 + x] == 0){
++		mi->vs[vsi] &= ~mask;
++	    }else{
++		mi->vs[vsi] |= mask;
++		if(y < 200){
++		    if(pai > max_pai){
++			max_pai += 1024;
++			mi->pa = maki_realloc(mi->pa, (size_t) max_pai + 1,
++					      "maki_make_virtual_screen#2");
++		    }
++		    mi->pa[pai++] = pixels[y * mi->width / 2 + x];
++		}else{
++		    if(pbi > max_pbi){
++			max_pbi += 1024;
++			mi->pb = maki_realloc(mi->pb, (size_t) max_pbi + 2,
++					      "maki_make_virtual_screen#3");
++		    }
++		    mi->pb[pbi++] = pixels[y * mi->width / 2 + x];
++		}
++	    }
++	    
++	    if((mask >>= 1) == 0){
++		mask = 0x80;
++		vsi++;
++	    }
++	}
++    }
++    
++    mi->pa_size = pai;
++    mi->pb_size = pbi;
++}
++
++static void maki_make_flags(mi)
++    struct maki_info *mi;
++{
++    int bpl = mi->width / 2 / 8;
++    int fbi, max_fbi;
++    int fai;
++    int x, y;
++    byte mask;
++    
++    mi->fa = maki_malloc((size_t) bpl * mi->height, "maki_make_flags#1");
++    
++    fbi = fai = 0;
++    max_fbi = -1;
++    mask = 0x80;
++    for(y = 0; y < mi->height; y += 4){
++	for(x = 0; x < mi->width / 2; x += 4){
++	    if(x % 8 == 0){
++		if(H4(mi->vs[ y      * bpl + x / 8]) == 0 &&
++		   H4(mi->vs[(y + 1) * bpl + x / 8]) == 0 &&
++		   H4(mi->vs[(y + 2) * bpl + x / 8]) == 0 &&
++		   H4(mi->vs[(y + 3) * bpl + x / 8]) == 0){
++		    mi->fa[fai] &= ~mask;
++		}else{
++		    mi->fa[fai] |= mask;
++		    if(fbi + 1 > max_fbi){
++			max_fbi += 1024;
++			mi->fb = maki_realloc(mi->fb, (size_t) max_fbi + 1,
++					      "maki_make_flags#2");
++		    }
++		    mi->fb[fbi++] = H4(mi->vs[ y      * bpl + x / 8]) << 4
++				  | H4(mi->vs[(y + 1) * bpl + x / 8]);
++		    mi->fb[fbi++] = H4(mi->vs[(y + 2) * bpl + x / 8]) << 4
++				  | H4(mi->vs[(y + 3) * bpl + x / 8]);
++		}
++	    }else{
++		if(L4(mi->vs[ y      * bpl + x / 8]) == 0 &&
++		   L4(mi->vs[(y + 1) * bpl + x / 8]) == 0 &&
++		   L4(mi->vs[(y + 2) * bpl + x / 8]) == 0 &&
++		   L4(mi->vs[(y + 3) * bpl + x / 8]) == 0){
++		    mi->fa[fai] &= ~mask;
++		}else{
++		    mi->fa[fai] |= mask;
++		    if(fbi + 1 > max_fbi){
++			max_fbi += 1024;
++			mi->fb = maki_realloc(mi->fb, (size_t) max_fbi + 1,
++					      "maki_make_flags#3");
++		    }
++		    mi->fb[fbi++] = L4(mi->vs[ y      * bpl + x / 8]) << 4
++				  | L4(mi->vs[(y + 1) * bpl + x / 8]);
++		    mi->fb[fbi++] = L4(mi->vs[(y + 2) * bpl + x / 8]) << 4
++				  | L4(mi->vs[(y + 3) * bpl + x / 8]);
++		}
++	    }
++	    
++	    if((mask >>= 1) == 0){
++		mask = 0x80;
++		fai++;
++	    }
++	}
++    }
++    
++    mi->fb_size = fbi;
++}
++
++static void maki_write_check_id(mi)
++    struct maki_info *mi;
++{
++    char *id = mi->m_maki01b ? maki_id_b : maki_id_a;
++    if(fwrite(id, (size_t) 8, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++}
++
++static void maki_write_comment(mi)
++    struct maki_info *mi;
++{
++    char buf[24];
++    char *p;
++    int i = 0;
++    
++    strcpy(buf, "XV   ");
++    
++    if((p = (char *) getenv("USER")) == NULL)
++	p = "????????";
++    for(i = 5; i < 23; i++){
++	if(*p == '\0')
++	    break;
++	buf[i] = *p++;
++    }
++    for( ; i < 23; i++)
++	buf[i] = ' ';
++    
++    buf[i] = '\032';	/* ^Z, 0x1a */
++    
++    if(fwrite(buf, (size_t) 24, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++}
++
++static void maki_write_header(mi)
++    struct maki_info *mi;
++{
++    byte buf[16];
++    
++    if(DEBUG) maki_show_maki_info(mi);
++    
++#define set_word(i, v) {buf[i]=(v)>>8&0xff;buf[i+1]=(v)&0xff;}
++    set_word(0, mi->fb_size);
++    set_word(2, mi->pa_size);
++    set_word(4, mi->pb_size);
++    set_word(6, mi->ext_flag);
++    set_word(8, mi->x0);
++    set_word(10, mi->y0);
++    set_word(12, mi->x1 + 1);
++    set_word(14, mi->y1 + 1);
++#undef set_word
++    
++    if(fwrite(buf, (size_t) 16, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++}
++
++static void maki_write_palette(mi, r, g, b, grey)
++    struct maki_info *mi;
++    byte *r, *g, *b;
++    int grey;
++{
++    int i;
++    char buf[3];
++    for(i = 0; i < mi->numcols; i++){
++	buf[0] = *g++;
++	buf[1] = *r++;
++	buf[2] = *b++;
++	if(grey)
++	    buf[0] = buf[1] = buf[2] = MONO(buf[1], buf[0], buf[2]);
++	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
++	    maki_file_error(mi, MAKI_WRITE);
++    }
++    for( ; i < 16; i++){
++	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
++	    maki_file_error(mi, MAKI_WRITE);
++    }
++}
++
++static void maki_write_flags(mi)
++    struct maki_info *mi;
++{
++    int bpl = mi->width / 2 / 8;
++    if(fwrite(mi->fa, (size_t) bpl * mi->height / 16, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++    
++    if(fwrite(mi->fb, (size_t) mi->fb_size, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++}
++
++static void maki_write_pixel_data(mi)
++    struct maki_info *mi;
++{
++    if(fwrite(mi->pa, (size_t) mi->pa_size, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++    
++    if(fwrite(mi->pb, (size_t) mi->pb_size, (size_t) 1, mi->fp) != 1)
++	maki_file_error(mi, MAKI_WRITE);
++}
++
++
++
++static void maki_init_info(mi)
++    struct maki_info *mi;
++{
++    mi->fp = NULL;
++    mi->fsize = 0;
++    mi->x0 = mi->y0 = mi->x1 = mi->y1 = 0;
++    mi->width = mi->height = 0;
++    mi->aspect = 1.0;
++    mi->fb_size = mi->pa_size = mi->pb_size = 0;
++    mi->m_maki01b = mi->m_200 = mi->m_dig8 = 0;
++    mi->ext_flag = 0;
++    mi->fa = mi->fb = mi->pa = mi->pb = NULL;
++    mi->vs = NULL;
++    mi->numcols = 16;
++    mi->forma = mi->formb = NULL;
++}
++
++static void maki_cleanup_maki_info(mi, writing)
++    struct maki_info *mi;
++    int writing;
++{
++    if(mi->fp && !writing)
++	fclose(mi->fp);
++    if(mi->fa)
++	free(mi->fa);
++    if(mi->fb)
++	free(mi->fb);
++    if(mi->pa)
++	free(mi->pa);
++    if(mi->pb)
++	free(mi->pb);
++    if(mi->vs)
++	free(mi->vs);
++    if(mi->forma)
++	free(mi->forma);
++    if(mi->formb)
++	free(mi->formb);
++}
++
++static void maki_cleanup_pinfo(pi)
++    PICINFO *pi;
++{
++    if(pi->pic){
++	free(pi->pic);
++	pi->pic = NULL;
++    }
++}
++
++static void maki_memory_error(scm, fn)
++    char *scm, *fn;
++{
++    char buf[128];
++    sprintf(buf, "%s: coulndn't allocate memory. (%s)", scm, fn);
++    FatalError(buf);
++}
++
++static void maki_error(mi, mn)
++    struct maki_info *mi;
++    int mn;
++{
++    SetISTR(ISTR_WARNING, "%s", maki_msgs[mn]);
++    longjmp(mi->jmp, 1);
++}
++
++static void maki_file_error(mi, mn)
++    struct maki_info *mi;
++    int mn;
++{
++    if(feof(mi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", maki_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", maki_msgs[mn], ERRSTR(errno));
++    longjmp(mi->jmp, 1);
++}
++
++static void maki_file_warning(mi, mn)
++    struct maki_info *mi;
++    int mn;
++{
++    if(feof(mi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", maki_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", maki_msgs[mn], ERRSTR(errno));
++}
++
++static void maki_show_maki_info(mi)
++    struct maki_info *mi;
++{
++    fprintf(stderr, "  file size: %ld.\n", mi->fsize);
++    fprintf(stderr, "  image size: %dx%d.\n", mi->width, mi->height);
++    fprintf(stderr, "  aspect: %f.\n", mi->aspect);
++    fprintf(stderr, "  flag B size: %ld.\n", mi->fb_size);
++    fprintf(stderr, "  pixel data size: A:%ld, B:%ld.\n",
++	    mi->pa_size, mi->pb_size);
++    fprintf(stderr, "  MAKI01B: %s.\n", mi->m_maki01b ? "true" : "false");
++    fprintf(stderr, "  200 line mode: %s.\n", mi->m_200 ? "true" : "false");
++    fprintf(stderr, "  digital 8 colors: %s.\n", mi->m_dig8 ? "true" : "false");
++}
++
++static void *maki_malloc(n, fn)
++    size_t n;
++    char *fn;
++{
++    void *r = (void *) malloc(n);
++    if(r == NULL)
++	maki_memory_error("malloc", fn);
++    return r;
++}
++
++static void *maki_realloc(p, n, fn)
++    void *p;
++    size_t n;
++    char *fn;
++{
++    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
++    if(r == NULL)
++	maki_memory_error("realloc", fn);
++    return r;
++}
++#endif /* HAVE_MAKI */
+diff -urN xv-3.10a/xvmgcsfx.c xv-3.10a-jp-extension-current/xvmgcsfx.c
+--- xv-3.10a/xvmgcsfx.c
++++ xv-3.10a-jp-extension-current/xvmgcsfx.c	Wed Oct  9 20:37:20 1996
+@@ -0,0 +1,2263 @@
++/*
++ * $Id: xvmgcsfx.c,v 1.23 95/11/27 19:03:36 tin329 Exp Locker: tin329 $
++ * xvmgcsfx.c - Use the filters as input and output method.
++ *
++ * Features
++ * ========
++ * Use the filters as input and output method for load and save unsupported
++ * image format file. The filter command is recognized by definition of 
++ * magic number or suffix in "~/.xv_mgcsfx" .
++ *
++ * Bugs
++ * ====
++ * There are many bugs.
++ * Let's go hunting for insects with an insect net. (it's all joke.)
++ *
++ * Author
++ * ======
++ * Tetsuya INOUE  <tin329@chino.it.okayama-u.ac.jp>
++ */
++
++/*
++ * Known Bugs and Todo  /  $B$"$l$3$l5$$K$J$k$3$H(B
++ *
++ *  ~/.xv_mgcsfx $BFb(B
++ *    $B!&Dj5A$,IT40A4$@$H%(%i!<(B (':'$B$N?t(B)$B!#(B
++ *    $B!&%G%j%_%?$H$7$F(B ':' $B$r;H$&$N$G!"%9%?!<%H%"%C%W%U%!%$%kFb$G(B
++ *      ':' $B$rMQ$$$FDj5A$O$G$-$J$$!#(B'\:'$B$G$b%@%a!#(B
++ *    $B!&(B magic $B%?%$%W$G!"#8?J?t$O#37eJ,#0!A#7$rD4$Y!"#1#6?J?t$O(B
++ *       isxdigit $B$,??$rJV$94VCf=hM}$5$l$k!#$7$+$7!"#1#b#y#t#e$H(B
++ *       $B$7$F$7$+I>2A$5$l$J$$!#(B
++ *    $B!&%W%j%W%m%;%C%5$r;H$&$H$-$O!"%3%a%s%H$N=q$-J}$KCm0U$7$J$1$l$P$J(B
++ *        $B$i$J$$!#%W%j%W%m%;%C%5$K$h$C$F$O%3%a%s%H$,%(%i!<$K$J$k!#(B
++ *    $B!&%Q%$%W$X$NF~=PNO$N%U%)!<%^%C%H$N<oN`$,(B PNM $B$N$_(B
++ *        $BF~NO(B
++ *            $B%U%!%$%k%]%$%s%?$r(B seek $B$7$F$O$$$1$J$$(B
++ *            $B%U%!%$%k%5%$%:$rMQ$$$F$O$$$1$J$$(B
++ *        $B=PNO(B
++ *            $B%U%!%$%k%]%$%s%?$r(B seek $B$7$F$O$$$1$J$$(B
++ *            exec $B$G$-$J$/$F=*N;$7$?%W%m%;%9$K=q$-9~$_IT2D(B
++ *    $B!&%5%U%#%C%/%9$H%^%8%C%/%J%s%P!<$N;H$$J,$1$r$I$&$9$k$+!#(B
++ *        $B%^%8%C%/%J%s%P!<$,F1$8$G!"%5%U%#%C%/%9$,0[$J$k>l9g$rG'$a$k$+!)(B
++ *    $B!&(Bcompress(gzip)$B$N%U%!%$%k$O%F%s%]%i%j$G$O(B xvtmp??? $B$H$$$&L>A0$J(B
++ *      $B$N$G(B suffix $B$G$O<1JL$G$-$J$$!#(B
++ *
++ *  $BG'<1$9$k;~$K(B MACBINARY $B$K$OIi$1$k(B(in xv.c)$B!#(B
++ *
++ *  $BB?=E$K(B pipe $B$rDL$9$3$H$,$G$-$J$$!#(B(pipe $B$,(B seek $B$G$-$J$$$+$i(B)
++ *    $B!&(Bsocketpair $B$G!"(Brecv $B$K(B MSG_PEEK $B%U%i%0$r$D$+$C$F6uFI$_$9$k!#(B
++ *    $B!&$3$l$r$d$k$H%U%!%$%k$NG'<1$,$a$A$c$a$A$cCY$/$J$k!#(B
++ *
++ *  $B%j%=!<%9$G@_Dj(B
++ *    $B!&%j%=!<%9$G@_Dj$9$kJ}$,LLE]$/$5$$(B
++ *
++ *  $B%^%8%C%/%J%s%P!<$N@_Dj$K@55,I=8=(B
++ *
++ *  $B%;!<%VMQ%W%m%;%9$,<:GT$9$k>l9g$NBP:v$,:#0l$D(B
++ *
++ *  DEC OSF/1 V3.0 $B$G$O!"%Q%$%W$K%G!<%?$,$^$@$J$$;~$KFI$_9~$b$&$H$9$k$H!"(B
++ *  read $B$,IT40A4$K$J$k!#(B(in xvpbm.c)
++ *  $BF1MM$K=q$-9~$_;~$K$bLdBj$,@8$8$k$+$b$7$l$J$$!#(B
++ */
++
++#define  NEEDSDIR               /* for stat() */
++#include "xv.h"
++
++
++#ifdef HAVE_MGCSFX
++
++
++#ifdef __osf__
++#ifdef __alpha
++#define ARCHITECTURE64 1
++#endif /* __alpha */
++#endif /* __osf__ */
++
++#ifdef ARCHITECTURE64
++typedef short int16;
++typedef int   int32;
++typedef long  int64;
++#else
++typedef short int16;
++typedef long  int32;
++#endif /* ARCHITECTURE64 */
++
++#ifdef sgi
++#define vfork fork
++#endif
++
++#define USE_SIGCHLD
++#if 0
++#undef  USE_SIGCHLD
++#endif
++
++typedef struct _mgcsfxtab
++{
++  struct _mgcsfxtab *next;
++  char              *description;
++  int                mgcsfx_type;
++  int                offset;
++  union{
++    int16            int16_data;
++    int32            int32_data;
++    char            *string_data;
++  }                  dt;
++  int                string_len;
++  char              *suffix;
++  int                input_image_type;
++  char              *input_command;
++  int                output_image_type;
++  char              *output_command;
++} mgcsfxtab;
++
++
++#ifndef MGCSFXDIR
++#  define MGCSFXDIR       "/usr/local/lib"
++#endif
++#ifndef MGCSFX_SITE_RC
++#  define MGCSFX_SITE_RC  "xv_mgcsfx"
++#endif
++#ifndef MGCSFX_RC
++#  define MGCSFX_RC       ".xv_mgcsfx"
++#endif
++
++#ifdef USE_MGCSFX_PREPROCESSOR
++#ifndef MGCSFX_PREPROCESSOR
++#define MGCSFX_PREPROCESSOR "/usr/lib/cpp"
++#endif
++#endif
++
++
++/* Check type for Magic number and Suffix */
++enum {T_UNKNOWN,
++      T_MAGIC, T_SUFFIX,
++      T_BEINT16, T_BEINT32, T_BEINT64,
++      T_LEINT16, T_LEINT32, T_LEINT64};
++
++/* Image Type for input and output format */
++enum {IT_UNKNOWN,
++#ifdef HAVE_MGCSFX_AUTO
++      IT_AUTO,
++#endif /* HAVE_MGCSFX_AUTO */
++      IT_PNM, IT_PPM, IT_PGM, IT_PBM,
++      IT_PNM_RAW, IT_PPM_RAW, IT_PGM_RAW, IT_PBM_RAW,
++      IT_PNM_ASCII, IT_PPM_ASCII, IT_PGM_ASCII, IT_PBM_ASCII,
++      IT_GIF, IT_JPEG, IT_TIFF, IT_JFIF, /* IT_PS, IT_COMPRESS,*/
++      IT_XBM, IT_XPM, IT_BMP, IT_SUNRAS, IT_IRIS, IT_XWD,
++      /* IT_TARGA, IT_FITS, IT_PM, IT_UTAHRLE, IT_PCX, IT_PDSVICAR, IT_IFF, */
++      IT_MAG, IT_MAKI, IT_PI, IT_PIC, IT_PIC2 /* , IT_PCD */};
++
++
++/*--------------------------------------------------------------------------*/
++void  mgcsfx_handler        PARM((int));
++void  mgcsfx_handler_setup  PARM((void));
++
++#ifdef USE_MGCSFX_PREPROCESSOR
++static char      *get_tmp_fname          PARM((void));
++static char      *make_preprocessed_file PARM((char *));
++#endif /* USE_MGCSFX_PREPROCESSOR */
++
++int   is_mgcsfx             PARM((char *, unsigned char *, int));
++
++char *mgcsfx_auto_input_com PARM((char *));
++
++
++static mgcsfxtab *free_mgcsfx PARM((mgcsfxtab *));
++static char      *fgettoken   PARM((FILE*, int));
++static int        string_fin  PARM((char *));
++static int        type_mgcsfx PARM((char *));
++static int        type_image  PARM((char *));
++
++static void       read_mgcsfx PARM((mgcsfxtab **, char *));
++static void       init_mgcsfx PARM((void));
++static mgcsfxtab *find_mgcsfx PARM((char *, unsigned char *, int));
++
++int   LoadMGCSFX            PARM((char *, PICINFO *));
++
++#ifdef SVR4
++typedef void Sigfunc(int);
++static Sigfunc   *xv_signal   PARM((int , Sigfunc *));
++#endif
++
++/*--------------------------------------------------------------------------*/
++mgcsfxtab *mgcsfx_table = NULL;
++int       mgcsfx_setup_flag = 0;
++
++int       nitem_mgcsfx = 0;
++int       desc_width = 0;
++
++int       max_offset_mgcsfx = 0;
++int       max_length_mgcsfx = 0;
++int       need_buf_size = 0;
++
++static char input_command_ex[1024];
++static int  input_command_ex_flag = 0;
++
++#ifdef USE_SIGCHLD
++static int  w_p_fail=0;
++#endif
++
++/*--------------------------------------------------------------------------*/
++
++/***************************************************/
++void mgcsfx_handler(sig)
++     int sig;
++{
++  int pid, pst;
++
++#if defined(SYSV) || defined(SVR4)
++  sighold(sig);
++#else
++  sigblock(sigmask(sig));
++#endif
++
++#ifdef USE_SIGCHLD
++  if(w_p_fail == 1){
++    /* 
++     * At this point, process write to broken pipe.
++     * Probably external command was can't exec.
++     */
++    w_p_fail = 2;
++    pid = wait(&pst);
++  }
++#endif
++
++  return;
++
++  /* Quit(1); */ /*exit(1);*/
++}
++
++void mgcsfx_handler_setup()
++{
++#ifdef SVR4
++  xv_signal(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
++  xv_signal(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
++#else
++# ifdef SYSV
++  sigset(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
++  sigset(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
++# else
++  signal(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
++  signal(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
++# endif
++#endif
++}
++
++/***************************************************/
++#ifdef USE_MGCSFX_PREPROCESSOR
++static char *get_tmp_fname()
++{
++  static char tmp[MAXPATHLEN+1];
++
++#ifndef VMS
++  sprintf(tmp, "%s/xvmgcsfxXXXXXX",tmpdir);
++#else
++  /* sprintf(tmp, "Sys$Scratch:xvmgcsfxXXXXXX"); */
++  strcpy(tmp, "[]xvmgcsfxXXXXXX");
++#endif /* VMS */
++
++  mktemp(tmp);
++
++  return tmp;
++}
++#endif /* USE_MGCSFX_PREPROCESSOR */
++
++#ifdef USE_MGCSFX_PREPROCESSOR
++static char *make_preprocessed_file(fname)
++     char *fname;
++{
++  char buf[512];
++  char *tmp_name;
++
++  tmp_name = get_tmp_fname();
++
++#ifndef VMS
++  sprintf(buf,"%s %s > %s", MGCSFX_PREPROCESSOR, fname, tmp_name);
++#else /* it IS VMS */
++  sprintf(buf,"%s %s > %s", MGCSFX_PREPROCESSOR, fname, tmp_name);/* realy OK? */
++#endif
++
++  SetISTR(ISTR_INFO, "Preprocessing '%s'...", BaseName(fname));
++#ifndef VMS
++  if (system(buf)) {
++#else
++  if (!system(buf)) {
++#endif
++    SetISTR(ISTR_INFO, "Unable to preprocess '%s'.", BaseName(fname));
++    Warning();
++    return NULL;
++  }
++
++  return tmp_name;
++}
++#endif /* USE_MGCSFX_PREPROCESSOR */
++
++/***************************************************/
++/* $BG'<1$G$-$k%U%!%$%k$+$I$&$+D4$Y$k(B */
++int is_mgcsfx(fname,buffer,size)
++     char          *fname;
++     unsigned char *buffer;
++     int            size;
++{
++  mgcsfxtab          *magic;
++  FILE               *fp;
++  unsigned char      *buf;
++  int                 s;
++
++  if(nomgcsfx){
++    return 0;
++  }else{
++    if(size < need_buf_size){
++      if((buf = (unsigned char *)calloc(need_buf_size, sizeof(char)))==NULL){
++	fprintf(stderr,"Can't allocate memory\n");
++	return 0;
++      }
++      if((fp = xv_fopen(fname, "r"))==NULL){
++	fprintf(stderr,"Can't open file %s\n", fname);
++	free(buf);
++	return 0;
++      }
++      s = fread(buf, 1, need_buf_size, fp);
++      if((magic = find_mgcsfx(fname, buf, s))!=NULL &&
++	magic->input_command != NULL){
++	free(buf);
++	fclose(fp);
++	return 1;
++      }else{
++	free(buf);
++	fclose(fp);
++	return 0;
++      }
++    }else{
++      if((magic = find_mgcsfx(fname, buffer, size))!=NULL &&
++	magic->input_command != NULL){
++	return 1;
++      }else{
++	return 0;
++      }
++    }
++  }
++}
++
++#ifdef HAVE_MGCSFX_AUTO
++char *mgcsfx_auto_input_com(fname)
++char *fname;
++{
++  static char command[1024];
++  mgcsfxtab       *magic;
++  char *ptr;
++
++  FILE *fp;
++  unsigned char *buf;
++  int                 s;
++
++  if((buf = (unsigned char *)calloc(need_buf_size, sizeof(char)))==NULL){
++    fprintf(stderr,"Can't allocate memory\n");
++    return NULL;
++  }
++  if((fp = xv_fopen(fname, "r"))==NULL){
++    fprintf(stderr,"Can't open file %s\n", fname);
++    free(buf);
++    return NULL;
++  }
++  s = fread(buf, 1, need_buf_size, fp);
++  if((magic = find_mgcsfx(fname, buf, s))!=NULL &&
++     magic->input_command != NULL && magic->input_image_type == IT_AUTO){
++    if (ptr = strstr(magic->input_command, "%s")){
++      sprintf(command, magic->input_command, fname);
++    }else{
++      sprintf(command, "%s < %s", magic->input_command, fname);
++    }
++    free(buf);
++    fclose(fp);
++    return command;
++  }else{
++    free(buf);
++    fclose(fp);
++    return NULL;
++  }
++}
++#endif /* HAVE_MGCSFX_AUTO */
++
++/***************************************************/
++static mgcsfxtab *free_mgcsfx(m)
++     mgcsfxtab *m;
++{
++  mgcsfxtab *next;
++  if(m == NULL) return NULL;
++  next = m->next;
++  if(m->description != NULL) free(m->description);
++  if(m->mgcsfx_type == T_MAGIC && m->dt.string_data != NULL)
++    free(m->dt.string_data);
++  if(m->suffix != NULL) free(m->suffix);
++  if(m->input_command != NULL) free(m->input_command);
++  if(m->output_command != NULL) free(m->output_command);
++  free(m);
++  return next;
++}
++
++
++
++/***************************************************/
++/* char c $B$^$?$O(B '\n' $B$G6h@Z$i$l$?J8;zNs$r<h$j=P$9(B
++ *  $B%U%!%$%k$N:G8e$^$GFI$s$@$i(B NULL $B$rJV$9(B
++ *  $B2~9T$J$i2~9T$rJV$9(B($B2~9T$G6h@Z$i$l$?>l9g$O(B '\n' $B$r%9%H%j!<%`$KLa$9(B)
++ */
++#define CBUF_SIZE 1024
++static char *fgettoken(fp, c)
++     FILE *fp;
++     int   c; /* Real mean is char */
++{
++  char *buf;
++  char *buf2;
++  int   i;
++  int   n=0;
++  int   max=0;
++  int   count = 1;
++
++  char *ss;
++  char *se;
++
++  if((buf = (char *)calloc(CBUF_SIZE, sizeof(char))) == NULL){
++    fprintf(stderr,"Can't allocate memory\n");
++    exit(1);
++  }
++  max = CBUF_SIZE;
++  count = 2;
++
++  do{
++    if((i = getc(fp))==EOF || i == '\n' || i == c) break;
++
++    buf[n] = (char)i;
++
++    if(i != c && n == max-1){
++      buf[max] = '\0';
++      if((buf2 = (char *)calloc(CBUF_SIZE * count, sizeof(char))) == NULL){
++	fprintf(stderr,"Can't allocate memory\n");
++	exit(1);
++      }
++      strcpy(buf2, buf);
++      free(buf);
++      buf = buf2;
++      buf2 = NULL;
++      max = CBUF_SIZE * count;
++      count++;
++    }
++
++    n++;
++  }while(i != c);
++
++  buf[n] = '\0';
++
++  /* $B:G=i$H:G8e$N6uGrJ8;z$r@Z$j5M$a$k(B */
++  ss = buf + strspn(buf, " \t\b\r\n"); /* find the first non-white space */
++  se = buf + strlen(buf);              /* find the end of the string */
++
++  /* strip from the end first */
++  while ((--se >= ss) && strchr(" \t\b\r\n", *se));
++  *(++se) = '\0';
++
++  if(i == EOF && strlen(ss)==0){        /* EOF $B$J$i(B NULL $B$rJV$9(B */
++    free(buf);
++    return NULL;
++  }else if(i == '\n' && strlen(ss)==0){ /* $B2~9T$N$_$N>l9g(B */
++    static char cr[2] = {'\n','\0'};
++    buf2 = strdup(cr);
++    free(buf);
++    return buf2;
++  }else{                                /* $BDL>o(B */
++    if(i == '\n' && strlen(ss)>0) ungetc(i,fp);
++    buf2 = strdup(ss);
++    free(buf);
++    return buf2;
++  }
++}
++
++
++
++/***************************************************/
++/* $BJ8;zNsCf$NFC<l5-9f(B(\)$B$r@5$7$$$b$N$K$9$k(B
++ */
++static int string_fin(string_data)
++     char *string_data;
++{
++  char *cptr;
++  char *ptr;
++  int   length;
++
++  /* Change all the \xx sequences into a single character */
++  cptr = string_data;
++
++  for (ptr = cptr; *ptr; ++ptr){
++    if (*ptr != '\\'){
++      *cptr = *ptr;
++    }else{
++      switch (*(++ptr)){
++#if defined(__STDC__)
++      case 'a': /* Audible alert (terminal bell) */
++	*cptr = '\007';
++	break;
++      case '?': /* Question mark */
++	*cptr = '\?';
++	break;
++#endif
++      case 'b': /* Backspace */
++	*cptr = '\b';
++	break;
++      case 'f': /* Form feed */
++	*cptr = '\f';
++	break;
++      case 'n': /* Line feed */
++	*cptr = '\n';
++	break;
++      case 'r': /* Carriage return */
++	*cptr = '\r';
++	break;
++      case 't': /* Horizontal tab */
++	*cptr = '\t';
++	break;
++      case 'v': /* Vertical tab */
++	*cptr = '\v';
++	break;
++      case '\\': /* Backslash */
++	*cptr = '\\';
++	break;
++      case '\'': /* Single quote */
++	*cptr = '\'';
++	break;
++      case '"': /* Double quote */
++	*cptr = '\"';
++	break;
++      case '0': /* Octal constant  \0 ... \377 */
++      case '1':
++      case '2':
++      case '3':
++      case '4':
++      case '5':
++      case '6':
++      case '7':
++	if ((ptr[1] >= '0') && (ptr[1] <= '7')){
++	  if ((ptr[2] >= '0') && (ptr[2] <= '7')){ /* \000 ...\377 */
++	    *cptr = ((*ptr - '0') * 64) +((ptr[1] - '0') * 8) +(ptr[1] - '0');
++	    ptr += 2;
++	  }else{ /* \00 ...\77 */
++	    *cptr = ((*ptr - '0') * 8) + (ptr[1] - '0');
++	    ++ptr;
++	  }
++	}else{ /* \0 ...\7 */
++	  *cptr = *ptr - '0';
++	}
++	break;
++      case 'x': /* Hexadecimal constant  \x0 .. \xff */
++	if (isxdigit (ptr[1])){
++	  *cptr = 0;
++	  while (isxdigit (*(++ptr)))
++	    *cptr = (*cptr * 16) +
++	      (*ptr > '9' ? tolower (*ptr) - ('a' - 10) : *ptr - '0');
++	  --ptr;
++	  break;
++	}
++      default:
++	/*  *(cptr++) = '\\';  No use for treat '\z' as 'z' */
++	*cptr = *ptr;
++	break;
++      }
++    }
++    ++cptr;
++  }
++  *cptr = '\0';
++  length = cptr - string_data;
++  return length;
++}
++
++/***************************************************/
++static int type_mgcsfx(str)
++     char *str;
++{
++  if(str == NULL){
++    return T_UNKNOWN;
++  }else if(!strcmp(str, "magic")   || !strcmp(str, "MAGIC")){
++    return T_MAGIC;
++  }else if(!strcmp(str, "string")  || !strcmp(str, "STRING")){
++    return T_MAGIC;
++  }else if(!strcmp(str, "suffix")  || !strcmp(str, "SUFFIX")){
++    return T_SUFFIX;
++  }else if(!strcmp(str, "beint16") || !strcmp(str, "BEINT16")){
++    return T_BEINT16;
++  }else if(!strcmp(str, "leint16") || !strcmp(str, "LEINT16")){
++    return T_LEINT16;
++  }else if(!strcmp(str, "beint32") || !strcmp(str, "BEINT32")){
++    return T_BEINT32;
++  }else if(!strcmp(str, "leint32") || !strcmp(str, "LEINT32")){
++    return T_LEINT32;
++  }else{
++    return T_UNKNOWN;
++  }
++}
++
++/***************************************************/
++static int type_image(str)
++     char *str;
++{
++  if(str == NULL){
++    return IT_UNKNOWN;
++#ifdef HAVE_MGCSFX_AUTO
++  }else if(!strcmp(str, "auto") || !strcmp(str, "AUTO")){
++    return IT_AUTO;
++#endif /* HAVE_MGCSFX_AUTO */
++  }else if(!strcmp(str, "pnm") || !strcmp(str, "PNM")){
++    return IT_PNM;
++  }else if(!strcmp(str, "ppm") || !strcmp(str, "PPM")){
++    return IT_PPM;
++  }else if(!strcmp(str, "pgm") || !strcmp(str, "PGM")){
++    return IT_PGM;
++  }else if(!strcmp(str, "pbm") || !strcmp(str, "PBM")){
++    return IT_PBM;
++  }else if(!strcmp(str, "pnm_raw") || !strcmp(str, "PNM_RAW")){
++    return IT_PNM_RAW;
++  }else if(!strcmp(str, "ppm_raw") || !strcmp(str, "PPM_RAW")){
++    return IT_PPM_RAW;
++  }else if(!strcmp(str, "pgm_raw") || !strcmp(str, "PGM_RAW")){
++    return IT_PGM_RAW;
++  }else if(!strcmp(str, "pbm_raw") || !strcmp(str, "PBM_RAW")){
++    return IT_PBM_RAW;
++  }else if(!strcmp(str, "pnm_ascii") || !strcmp(str, "PNM_ASCII")){
++    return IT_PNM_ASCII;
++  }else if(!strcmp(str, "ppm_ascii") || !strcmp(str, "PPM_ASCII")){
++    return IT_PPM_ASCII;
++  }else if(!strcmp(str, "pgm_ascii") || !strcmp(str, "PGM_ASCII")){
++    return IT_PGM_ASCII;
++  }else if(!strcmp(str, "pbm_ascii") || !strcmp(str, "PBM_ASCII")){
++    return IT_PBM_ASCII;
++
++  }else if(!strcmp(str, "gif")  || !strcmp(str, "GIF")){
++    return IT_GIF;
++  }else if(!strcmp(str, "jpeg") || !strcmp(str, "JPEG")){
++    return IT_JPEG;
++  }else if(!strcmp(str, "tiff") || !strcmp(str, "TIFF")){
++    return IT_TIFF;
++  }else if(!strcmp(str, "jfif") || !strcmp(str, "JFIF")){
++    return IT_JFIF;
++
++  }else if(!strcmp(str, "xbm") || !strcmp(str, "XBM")){
++    return IT_XBM;
++  }else if(!strcmp(str, "xpm") || !strcmp(str, "XPM")){
++    return IT_XPM;
++  }else if(!strcmp(str, "bmp") || !strcmp(str, "BMP")){
++    return IT_BMP;
++  }else if(!strcmp(str, "sunras") || !strcmp(str, "SUNRAS")){
++    return IT_SUNRAS;
++  }else if(!strcmp(str, "iris") || !strcmp(str, "IRIS")){
++    return IT_IRIS;
++  }else if(!strcmp(str, "xwd") || !strcmp(str, "XWD")){
++    return IT_XWD;
++
++  }else if(!strcmp(str, "mag") || !strcmp(str, "MAG")){
++    return IT_MAG;
++  }else if(!strcmp(str, "maki") || !strcmp(str, "MAKI")){
++    return IT_MAKI;
++  }else if(!strcmp(str, "pi") || !strcmp(str, "PI")){
++    return IT_PI;
++  }else if(!strcmp(str, "pic") || !strcmp(str, "PIC")){
++    return IT_PIC;
++  }else if(!strcmp(str, "pic2") || !strcmp(str, "PIC2")){
++    return IT_PIC2;
++
++  }else{
++    return IT_UNKNOWN;
++  }
++}
++
++/*--------------------------------------------------------------------------*/
++#define mgcsfx_read_error(FILENAME, LINENUM, AFTERFIELD) \
++fprintf (stderr,\
++"%s: line %d: missing fields of %s field\n",\
++FILENAME, LINENUM, AFTERFIELD);
++
++#define magic_type_error(FILENAME, LINENUM, MAGICNUMBER) \
++fprintf (stderr,\
++"%s: line %d: invalid <magic type> field '%s'\n",\
++FILENAME, LINENUM, MAGICNUMBER);
++/*--------------------------------------------------------------------------*/
++
++/***************************************************/
++static void read_mgcsfx(mgcsfx_table, fname)
++     mgcsfxtab **mgcsfx_table;
++     char       *fname;
++{
++  FILE *fp;
++  char *s;
++  int   line_number = 0;
++  int   str_len;
++  int   reach_end;
++  int   def_err;
++
++  char *description;
++  char *mgcsfx_type;
++  char *offset;
++  char *magic;
++  char *suffix;
++  char *i_img;
++  char *i_com;
++  char *o_img;
++  char *o_com;
++
++  mgcsfxtab  *ent;
++  mgcsfxtab **entry;
++
++
++  if((fp=fopen(fname, "r"))==NULL){
++    /* fprintf(stderr, "Can't open %s\n",fname); */
++    return;
++  }
++
++  while(1){
++retry:
++    line_number++;
++    def_err = 0;
++
++    s= NULL;
++    description = mgcsfx_type = offset = magic = suffix
++      = i_img = i_com = o_img = o_com = NULL;
++    reach_end = 0;
++
++    if((s = fgettoken(fp, ':'))==NULL) break; /* EOF $B$J$i=*$j(B */
++    if(*s == '#'){/* $B@hF,$,(B '#' $B$J$iFI$_$H$P$9(B */
++      while((s = fgettoken(fp, '\n'))!=NULL){
++	if(*s == '\n'){
++	  free(s);
++	  goto retry;
++	}
++	free(s);
++      }
++      if(s == NULL) break;
++    }else if(*s == '\n'){/* $B6u9T$OL5;k(B */
++      free(s);
++      goto retry;
++    }
++    if(strlen(s) > 0) description = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "data type");
++      goto next;
++    }
++    if(strlen(s) > 0) mgcsfx_type = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "byte offset");
++      goto next;
++    }
++    if(strlen(s) > 0) offset = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "magic number");
++      goto next;
++    }
++    if(strlen(s) > 0) magic = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "suffix");
++      goto next;
++    }
++    if(strlen(s) > 0) suffix = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "input image type");
++      goto next;
++    }
++    if(strlen(s) > 0) i_img = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "input command");
++      goto next;
++    }
++    if(strlen(s) > 0) i_com = s;
++    else free(s);
++
++    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++      if(s != NULL) free(s);
++      mgcsfx_read_error(fname, line_number, "output image type");
++      goto next;
++    }
++    if(strlen(s) > 0) o_img = s;
++    else free(s);
++
++    if((s = fgettoken(fp, '#'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
++    /*
++      free(s);
++      mgcsfx_read_error(fname, line_number, "output command");
++      goto next;
++     */
++      if(s != NULL){
++	*s = '\0';
++	reach_end = 1;
++      }
++    }
++    if(s != NULL){
++      if(strlen(s) > 0) o_com = s;
++      else free(s);
++    }
++
++    if(reach_end == 0){
++      while((s = fgettoken(fp, '\n'))!=NULL){/* $B9TKv$N%4%_$r<N$F$k(B */
++	if(*s == '\n'){
++	  free(s);
++	  break; /* goto next; */
++	}
++	free(s);
++      }
++    }else{
++      reach_end = 0;
++    }
++
++
++
++    /* --------------------------------------------------------------------- */
++next:;
++
++    if(DEBUG){
++      fprintf(stderr,"Read:  file %s:  line %d.\n", fname, line_number);
++      fprintf(stderr,"Description : %s\n",
++	      description ? description : "-- error --");
++      fprintf(stderr,"Type        : %s\n",
++	      mgcsfx_type ? mgcsfx_type : "-- error --");
++      fprintf(stderr,"Offset      : %s\n", offset ? offset : "--+--");
++      fprintf(stderr,"Magic       : %s\n", magic ? magic : "--+--");
++      fprintf(stderr,"Suffix      : %s\n", suffix ? suffix : "--+--");
++      fprintf(stderr,"i Image     : %s\n", i_img ? i_img : "--+--");
++      fprintf(stderr,"i Command   : %s\n", i_com ? i_com : "--+--");
++      fprintf(stderr,"o Image     : %s\n", o_img ? o_img : "--+--");
++      fprintf(stderr,"o Command   : %s\n", o_com ? o_com : "--+--");
++      fprintf(stderr,"\n");
++    }
++
++    /* create mgcsfxtab */
++    if((ent = (mgcsfxtab *) malloc (sizeof (mgcsfxtab)))==NULL){
++      fprintf(stderr,"Can't allocate memory\n");
++      exit(1);
++    }
++    ent->next              = NULL;
++    ent->description       = NULL;
++    ent->mgcsfx_type       = T_UNKNOWN;
++    ent->offset            = 0;
++    ent->string_len        = 0;
++    ent->suffix            = NULL;
++    ent->input_image_type  = IT_UNKNOWN;
++    ent->input_command     = NULL;
++    ent->output_image_type = IT_UNKNOWN;
++    ent->output_command    = NULL;
++
++    if(description != NULL){
++      ent->description = description;
++      description = NULL;
++    }else{
++      fprintf (stderr,"%s: line %d: undefined <description> field.\n",
++	       fname, line_number);
++      def_err ++;
++      goto next2;
++    }
++
++    if(mgcsfx_type == NULL){
++      fprintf (stderr,"%s: line %d: undefined <mgcsfx type> field.\n",
++	       fname, line_number);
++      def_err ++;
++      goto next2;
++    }
++    ent->mgcsfx_type = type_mgcsfx(mgcsfx_type);
++    switch(ent->mgcsfx_type){
++    case T_SUFFIX:
++      if(suffix == NULL){
++	fprintf (stderr,
++              "%s: line %d: conflict definition : undefined <suffix> field.\n",
++		 fname, line_number);
++	def_err ++;
++	goto next2;
++      }
++      break;
++    case T_BEINT16:
++      if (sscanf(magic, "%hi", &(ent->dt.int16_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++    case T_LEINT16:
++      if (sscanf(magic, "%hi", &(ent->dt.int16_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++#ifdef ARCHITECTURE64
++    case T_BEINT32:
++      if (sscanf(magic, "%i", &(ent->dt.int32_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++    case T_LEINT32:
++      if (sscanf(magic, "%i", &(ent->dt.int32_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++#else
++    case T_BEINT32:
++      if (sscanf(magic, "%li", &(ent->dt.int32_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++    case T_LEINT32:
++      if (sscanf(magic, "%li", &(ent->dt.int32_data)) != 1){
++	magic_type_error(fname, line_number, magic);
++	def_err ++;
++	goto next2;
++      }
++      break;
++#endif /* ARCHITECTURE64 */
++    case T_MAGIC:
++      if(magic == NULL){
++	fprintf (stderr,"%s: line %d: undefined <magic> field.\n",
++		 fname, line_number);
++	def_err ++;
++	goto next2;
++      }
++      if((str_len = string_fin(magic))<=0){
++	fprintf (stderr,"%s: line %d: invalid <magic> field.\n",
++		 fname, line_number);
++	def_err ++;
++	goto next2;
++      }
++
++      ent->string_len = str_len;
++      if((ent->dt.string_data = (char *)malloc(str_len + 1))==NULL){
++	fprintf(stderr,"Can't allocate memory\n");
++	exit(1);
++      }
++      memcpy(ent->dt.string_data, magic, str_len + 1);
++      break;
++    case T_UNKNOWN:
++    default:
++      fprintf (stderr,"%s: line %d: invalid <mgcsfx type> field.\n",
++	       fname, line_number);
++      def_err ++;
++      goto next2;
++      break;
++    };
++
++
++    if(offset == NULL){
++      if(ent->mgcsfx_type == T_MAGIC ||
++	 ent->mgcsfx_type == T_BEINT16 ||
++	 ent->mgcsfx_type == T_LEINT16 ||
++	 ent->mgcsfx_type == T_BEINT32 ||
++	 ent->mgcsfx_type == T_LEINT32){
++	fprintf (stderr,
++	      "%s: line %d: conflict definition : undefined <offset> field.\n",
++		 fname, line_number);
++	def_err ++;
++	goto next2;
++      }
++    }else{
++      if(ent->mgcsfx_type != T_SUFFIX) sscanf(offset, "%i", &(ent->offset));
++    }
++
++    if(suffix != NULL){
++      ent->suffix = suffix;
++      suffix = NULL;
++    }
++
++    if((i_img == NULL && i_com == NULL) && (o_img == NULL || o_com == NULL)){
++      fprintf (stderr,"%s: line %d: invalid definition.\n",
++	       fname, line_number);
++      def_err ++;
++      goto next2;
++    }
++    if((o_img == NULL && o_com == NULL) && (i_img == NULL || i_com == NULL)){
++      fprintf (stderr,"%s: line %d: invalid definition.\n",
++	       fname, line_number);
++      def_err ++;
++      goto next2;
++    }
++
++    if(i_img != NULL && i_com != NULL){
++      ent->input_image_type  = type_image(i_img);
++      ent->input_command = i_com;
++      i_com = NULL;
++    }else{
++      ent->input_image_type  = IT_UNKNOWN;
++      ent->input_command = NULL;
++    }
++
++    if(o_img != NULL && o_com != NULL){
++      ent->output_image_type = type_image(o_img);
++      ent->output_command = o_com;
++      o_com = NULL;
++    }else{
++      ent->output_image_type = IT_UNKNOWN;
++      ent->output_command = NULL;
++    }
++    /* end of create mgcsfxtab */
++
++
++next2:;
++
++    if(def_err != 0 || DEBUG){
++      fprintf(stderr,"Description : %s \t -> %s\n",
++	      description ? description : "--+--",
++	      ent->description ? ent->description : "-- error --");
++      fprintf(stderr,"Type        : %s \t -> %d\n",
++	      mgcsfx_type ? mgcsfx_type : "--+--",
++	      ent->mgcsfx_type);
++      fprintf(stderr,"Offset      : %s \t -> %d\n",
++	      offset ? offset : "--+--",
++	      ent->offset);
++
++      fprintf(stderr,"Magic       : %s", magic ? magic : "--+--");
++      switch(ent->mgcsfx_type){
++      case T_BEINT16:
++      case T_LEINT16:
++	fprintf(stderr," \t -> %d\n",ent->dt.int16_data);
++	break;
++      case T_BEINT32:
++      case T_LEINT32:
++	fprintf(stderr," \t -> %d\n",ent->dt.int32_data);
++	break;
++      case T_MAGIC:
++	fprintf(stderr," \t -> %s\n",ent->dt.string_data);
++	break;
++      default:
++	fprintf(stderr,"\n");
++	break;
++      };
++
++      fprintf(stderr,"Suffix      : %s \t -> %s\n",
++	      suffix ? suffix : "--+--",
++	      ent->suffix ? ent->suffix : "--+--");
++      fprintf(stderr,"i Image     : %s \t -> %d\n",
++	      i_img ? i_img : "--+--",
++	      ent->input_image_type);
++      fprintf(stderr,"i Command   : %s \t -> %s\n",
++	      i_com ? i_com : "--+--",
++	      ent->input_command ? ent->input_command : "--+--");
++      fprintf(stderr,"o Image     : %s \t -> %d\n",
++	      o_img ? o_img : "--+--",
++	      ent->output_image_type);
++      fprintf(stderr,"o Command   : %s \t -> %s\n",
++	      o_com ? o_com : "--+--",
++	      ent->output_command ? ent->output_command : "--+--");
++      fprintf(stderr,"\n");
++    }
++
++    if(description != NULL) free(description);
++    if(mgcsfx_type != NULL) free(mgcsfx_type);
++    if(offset      != NULL) free(offset);
++    if(magic       != NULL) free(magic);
++    if(suffix      != NULL) free(suffix);
++    if(i_img       != NULL) free(i_img);
++    if(i_com       != NULL) free(i_com);
++    if(o_img       != NULL) free(o_img);
++    if(o_com       != NULL) free(o_com);
++
++
++    if(def_err != 0) goto next3;
++
++    /* Override any existing entry for this magic number/file type */
++    for(entry = mgcsfx_table; *entry; entry = &((*entry)->next)){
++      if((ent->mgcsfx_type == (*entry)->mgcsfx_type) &&
++	 (
++	   ((ent->offset == (*entry)->offset) &&
++	    (((ent->mgcsfx_type == T_BEINT16) &&
++	      (ent->dt.int16_data == (*entry)->dt.int16_data)) ||
++	     ((ent->mgcsfx_type == T_BEINT32) &&
++	      (ent->dt.int32_data == (*entry)->dt.int32_data)) ||
++	     ((ent->mgcsfx_type == T_LEINT16) &&
++	      (ent->dt.int16_data == (*entry)->dt.int16_data)) ||
++	     ((ent->mgcsfx_type == T_LEINT32) &&
++	      (ent->dt.int32_data == (*entry)->dt.int32_data)) ||
++
++	     ((ent->mgcsfx_type == T_MAGIC) &&
++	      !memcmp(ent->dt.string_data, (*entry)->dt.string_data,
++		      ent->string_len))
++	      )) ||
++	  ((ent->mgcsfx_type == T_SUFFIX) &&
++	   !strcmp(ent->suffix, (*entry)->suffix))
++	 )
++	){
++
++	free ((*entry)->description);
++	(*entry)->description = ent->description;
++	ent->description = NULL;
++
++	(*entry)->input_image_type = ent->input_image_type;
++	if ((*entry)->input_command) free ((*entry)->input_command);
++	(*entry)->input_command = ent->input_command;
++	ent->input_command = NULL;
++
++	(*entry)->output_image_type = ent->output_image_type;
++	if ((*entry)->output_command) free ((*entry)->output_command);
++	(*entry)->output_command = ent->output_command;
++	ent->output_command = NULL;
++
++	free_mgcsfx(ent);
++	break;
++      }
++    }
++    if (!*entry){
++      ent->next = NULL;
++      *entry = ent;
++    }
++
++    /* if(s == NULL) break; */
++next3:;
++    if(def_err != 0) free_mgcsfx(ent);
++  } /* end of while(1) */
++}
++
++
++/***************************************************/
++/* $B%^%8%C%/%J%s%P!<Dj5A%U%!%$%kL>$rF@$F!"FI$_9~$^$;$k(B */
++static void init_mgcsfx ()
++{
++  extern char *getenv ();
++
++  char      *home_dir;
++  char       fname[1024];
++  mgcsfxtab *entry;
++  int        len;
++  struct stat st;
++
++#ifdef USE_MGCSFX_PREPROCESSOR
++  char      *pp_fname;
++#endif /* USE_MGCSFX_PREPROCESSOR */
++
++  mgcsfx_table = NULL;
++
++  mgcsfx_handler_setup();
++
++  if(nomgcsfx){
++    mgcsfx_setup_flag = 1;
++    nitem_mgcsfx = 0;
++    desc_width = 0;
++  }else{
++    sprintf (fname, "%s/%s", MGCSFXDIR, MGCSFX_SITE_RC);
++    if(stat(fname, &st) == 0 && S_ISREG(st.st_mode)){
++      /* Read the site MagicSuffix table into a linked list */
++#ifdef USE_MGCSFX_PREPROCESSOR
++      if((pp_fname = make_preprocessed_file(fname)) != NULL){
++	read_mgcsfx (&mgcsfx_table, pp_fname);
++      }
++      unlink(pp_fname);
++#else
++      read_mgcsfx (&mgcsfx_table, fname);
++#endif /* USE_MGCSFX_PREPROCESSOR */
++    }
++
++    /* Read the personal MgcSfx table into the list overriding site entries */
++    if (home_dir = getenv ("HOME")){
++      sprintf (fname, "%s/%s", home_dir, MGCSFX_RC);
++      if(stat(fname, &st) == 0 && S_ISREG(st.st_mode)){
++#ifdef USE_MGCSFX_PREPROCESSOR
++	if((pp_fname = make_preprocessed_file(fname)) != NULL){
++	  read_mgcsfx (&mgcsfx_table, pp_fname);
++	}
++	unlink(pp_fname);
++#else
++	read_mgcsfx (&mgcsfx_table, fname);
++#endif /* USE_MGCSFX_PREPROCESSOR */
++      }
++    }
++
++    mgcsfx_setup_flag = 1;
++
++    nitem_mgcsfx = 0;
++    desc_width = 0;
++    for (entry = mgcsfx_table; entry; entry = entry->next){
++      nitem_mgcsfx ++;
++      len = strlen(entry->description);
++      if(len > desc_width) desc_width = len;
++      if(max_offset_mgcsfx < entry->offset) max_offset_mgcsfx = entry->offset;
++      if(entry->mgcsfx_type == T_MAGIC &&
++	 max_length_mgcsfx < entry->string_len)
++	max_length_mgcsfx = entry->string_len;
++    }
++    if(max_length_mgcsfx == 0) max_length_mgcsfx = sizeof(int32);
++    need_buf_size = max_offset_mgcsfx + max_length_mgcsfx + 1;/* 1 is safety */
++  }
++}
++
++/***************************************************/
++/* $B%^%8%C%/%J%s%P!<$rD4$Y$F!"Dj5A$7$F$$$k%F!<%V%k$r8!:w$9$k(B 
++   $B%^%8%C%/%J%s%P!<$N%F!<%V%k$rFI$_9~$s$G$$$J$$$J$iFI$_9~$`(B */
++static mgcsfxtab *find_mgcsfx (fname, buffer, buffer_size)
++     char           *fname;
++     unsigned char  *buffer;
++     int             buffer_size;
++{
++  mgcsfxtab *entry;
++  int16      buf16;
++  int32      buf32;
++  char      *suf;
++
++  if (mgcsfx_setup_flag == 0) init_mgcsfx ();
++
++  for (entry = mgcsfx_table; entry; entry = entry->next){
++    switch (entry->mgcsfx_type){
++    case T_BEINT16:
++      if ((buffer_size > 0) &&
++	  ((entry->offset + sizeof (int16)) <= buffer_size)){
++	buf16 = ((char)*(buffer + entry->offset) << 8) |
++	  ((char)*(buffer + entry->offset +1));
++	if(entry->dt.int16_data == buf16) return entry;
++      }
++      break;
++    case T_LEINT16:
++      if ((buffer_size > 0) &&
++	  ((entry->offset + sizeof (int16)) <= buffer_size)){
++	buf16 = ((char)*(buffer + entry->offset +1) << 8) |
++	  ((char)*(buffer + entry->offset));
++	if(entry->dt.int16_data == buf16) return entry;
++      }
++      break;
++    case T_BEINT32:
++      if ((buffer_size > 0) &&
++	  ((entry->offset + sizeof (int32)) <= buffer_size)){
++	buf32 = ((char)*(buffer + entry->offset) << 24) |
++	  ((char)*(buffer + entry->offset +1) << 16) |
++	  ((char)*(buffer + entry->offset +2) << 8) |
++	  ((char)*(buffer + entry->offset +3));
++	if(entry->dt.int32_data == buf32) return entry;
++      }
++      break;
++    case T_LEINT32:
++      if ((buffer_size > 0) &&
++	  ((entry->offset + sizeof (int32)) <= buffer_size)){
++	buf32 = ((char)*(buffer + entry->offset +3) << 24) |
++	  ((char)*(buffer + entry->offset +2) << 16) |
++	  ((char)*(buffer + entry->offset +1) << 8) |
++	  ((char)*(buffer + entry->offset));
++	if(entry->dt.int32_data == buf32) return entry;
++      }
++      break;
++    case T_MAGIC:
++      if ((buffer_size > 0) &&
++	  ((entry->offset + entry->string_len)
++	   <= buffer_size) &&
++	  !memcmp (entry->dt.string_data, buffer + entry->offset,
++		   entry->string_len ))
++	return entry;
++      break;
++    case T_SUFFIX:
++      if(fname != NULL && entry->suffix != NULL){
++	if(strlen(fname) - strlen(entry->suffix) > 0){
++	  suf = fname + (strlen(fname) - strlen(entry->suffix));
++	  if(!strcmp(suf, entry->suffix)) return entry;
++	}
++      }
++      break;
++    case T_UNKNOWN:
++    default:
++      return NULL;
++      break;
++    }
++  }
++  return NULL;
++}
++
++
++
++
++
++/***************************************************/
++/* $B%^%8%C%/%J%s%P!<$NDj5A$rD4$Y$F!"$=$l$K$"$o$;$?%3%^%s%I$r<B9T$9$k(B */
++/* if OK return 1, else if ERROR return 0 */
++int
++LoadMGCSFX(file_name, pinfo)
++     char    *file_name;
++     PICINFO *pinfo;
++{
++  unsigned char *buffer;
++  int            size;
++  mgcsfxtab     *magic;
++  mgcsfxtab     *magic_cur;
++  char          *ptr;
++  char           command[1024];
++  int            fd[2];
++  int            pid;
++  int            file;
++  char          *fname;
++  int            rv;
++  int            pst;
++
++  int            i_it;
++  char          *i_com;
++
++  WaitCursor();
++
++  fname = file_name;
++  if((file = open (fname, O_RDONLY))<0){
++    SetISTR(ISTR_WARNING, "Can't open %s",fname);
++    return 0;
++  }
++
++  if((buffer = (unsigned char *)calloc(need_buf_size, sizeof(char))) == NULL){
++    SetISTR(ISTR_WARNING, "Can't allocate memory");
++    return 0;
++  }
++
++  magic_cur = NULL;
++
++/*  do{ */
++    size = read (file, buffer, need_buf_size);
++
++    if (lseek (file, 0L, 0) < 0){ /* can't seek pipe !! */
++      fprintf (stderr, "Can't lseek %s\n", file_name);
++      close(file);
++      return 0;
++    }
++
++    magic = find_mgcsfx (fname, buffer, size);
++
++    if ((magic != NULL && magic->input_command) ||
++        (magic == NULL && mgcsfx && input_command_ex_flag)){
++
++      if(magic == NULL){
++	if (fname != NULL && (ptr = strstr(input_command_ex, "%s"))){
++	  sprintf (command, input_command_ex, fname);
++	}else{
++	  strcpy (command, input_command_ex);
++	  fname=NULL;
++	}
++      }else{
++	/* Use stdin or give file name */
++	if (fname != NULL && (ptr = strstr(magic->input_command, "%s"))){
++	  sprintf (command, magic->input_command, fname);
++	}else{
++	  strcpy (command, magic->input_command);
++	  fname=NULL;
++	}
++      }
++
++      /* Do the pipe/fork/exec here */
++      if (pipe (fd) < 0){
++	fprintf (stderr, "Can't pipe : %s\n", file_name);
++	close(file);
++	return 0;
++      }
++
++      if ((pid = vfork ()) < 0){
++	fprintf (stderr, "Can't vfork : %s\n", file_name);
++	close (fd[0]);
++	close (fd[1]);
++	close(file);
++	return 0;
++      }
++
++      if (!pid){
++	 close(0);
++	if (fname == NULL || (open ("/dev/null", O_RDONLY) < 0)){
++	   dup(file);
++	}
++	 close(file);
++	 close(1);
++	 dup(fd[1]);
++	 close(2);
++	 open("/dev/null", O_WRONLY);
++	 close(fd[0]);
++	 execl("/bin/sh", "/bin/sh", "-c", command, 0);
++	_exit(127);
++      }
++
++      close (fd[1]);
++      dup2(fd[0], file);
++      close (fd[0]);
++      fname = NULL;
++      magic_cur = magic;
++    }
++/*  } while(magic != NULL); */
++
++  free(buffer);
++
++  if(magic_cur == NULL && mgcsfx && input_command_ex_flag){
++    i_it  = IT_PNM;
++    i_com = input_command_ex;
++  }else{
++    i_it  = magic_cur->input_image_type;
++    i_com = magic_cur->input_command;
++  }
++
++  if((magic_cur != NULL && i_com) ||
++    (magic_cur == NULL && mgcsfx && input_command_ex_flag)){
++    switch(i_it){
++    case IT_PNM:
++    case IT_PPM:
++    case IT_PGM:
++    case IT_PBM:
++    case IT_PNM_RAW:
++    case IT_PPM_RAW:
++    case IT_PGM_RAW:
++    case IT_PBM_RAW:
++    case IT_PNM_ASCII:
++    case IT_PPM_ASCII:
++    case IT_PGM_ASCII:
++    case IT_PBM_ASCII:
++      rv = LoadPBM(file_name, pinfo, file);
++      break;
++    case IT_GIF:
++    case IT_JPEG:
++    case IT_TIFF:
++    case IT_JFIF:
++    case IT_XBM:
++    case IT_XPM:
++    case IT_BMP:
++    case IT_SUNRAS:
++    case IT_IRIS:
++    case IT_XWD:
++    case IT_MAG:
++    case IT_MAKI:
++    case IT_PI:
++    case IT_PIC:
++    case IT_PIC2:
++      SetISTR(ISTR_WARNING, "Yet supported input image type (from filter output)");
++      rv = 0;
++      break;
++    case IT_UNKNOWN:
++      SetISTR(ISTR_WARNING, "Unknown input image type (from filter output)");
++      rv = 0;
++      break;
++#ifdef HAVE_MGCSFX_AUTO
++    case IT_AUTO:
++#endif /* HAVE_MGCSFX_AUTO */
++    default:
++      SetISTR(ISTR_WARNING, "Error in input image type (from filter output)");
++      rv = 0;
++      break;
++    }
++  }else{
++    rv = 0;
++  }
++
++  while(wait(&pst) != pid);
++  if( *((char *)&pst) != 0 ) rv = 0;
++
++  input_command_ex_flag = 0;
++
++  return rv;
++
++  /* fclose(fp);  close in Load??? */
++  /* return 0; error */
++  /* return 1; ok */
++}
++
++
++
++
++
++/*--------------------------------------------------------------------------*/
++#ifndef MGCSFX_DEFAULT_INPUT_COMMAND
++#define MGCSFX_DEFAULT_INPUT_COMMAND  "tifftopnm"
++#endif
++#ifndef MGCSFX_DEFAULT_OUTPUT_COMMAND
++#define MGCSFX_DEFAULT_OUTPUT_COMMAND "pnmtotiff"
++#endif
++
++int MSWIDE  =  0;
++int MSHIGH  =  0;
++
++#define MS_NBUTTS 2
++#define MS_BOK    0
++#define MS_BCANC  1
++#define BUTTW    60  /* width of buttons (OK or Cancel) */
++#define BUTTH    24  /* height of buttons (OK or Cancel) */
++#define RBSIZE   15  /* width and height of RB button (select, ON or OFF)*/
++#define CWIDE    8   /* width of character */
++/* #define CHIGH        height of character      defined in xv.h */
++#define MARGIN    3  /* margin of button and label     SPACING */
++
++#define MSD_TITLE       "Save file with external command..."
++#define MSD_RBTITLE     "Type of Magic and Suffix"
++#define MSD_IC_TITLE    "input command"
++
++static BUTT  msbut[MS_NBUTTS];
++static RBUTT *typeRB;
++
++static char output_command_ex[1024];
++static int  output_command_ex_flag = 0;
++
++static int   colorType;
++
++static int   w_pid;
++static int   w_pstatus;
++
++#define MSNAMWIDE 252               /* width of 'file name' entry window */
++#define MAXFNLEN 256               /* max len of filename being entered */
++static char   DialogFileName[MAXFNLEN+100];   /* filename being entered */
++static int    curPos, stPos, enPos;     /* filename textedit stuff */
++
++
++static mgcsfxtab *get_mgcsfx PARM((int));
++static void changeSuffix PARM((int));
++
++static int WriteMGCSFX  PARM((FILE**,byte*,int,int,int,
++			    byte*,byte*,byte*,int,int,char*,
++			    int, int, char*));
++void  CreateMGCSFXW         PARM((void));
++void  MGCSFXDialog          PARM((int));
++int   MGCSFXCheckEvent      PARM((XEvent *));
++int   MGCSFXSaveParams      PARM((char *, int));
++
++static void drawMSD     PARM((int,int,int,int));
++static void clickMSD    PARM((int,int));
++static void doCmd       PARM((int));
++static int writeMGCSFX  PARM((void));
++
++static void changeSuffix   PARM((int));
++static void redrawNamMSD   PARM((void));
++static void showFNamMSD    PARM((void));
++static int keyinMSD        PARM((int));
++
++int getInputCom  PARM((void));
++int getOutputCom PARM((void));
++/*--------------------------------------------------------------------------*/
++
++/***************************************************/
++/* $B$I$l$rA*$s$@$+D4$Y$k!##0$O%3%^%s%I$rF~NO$9$k$b$N$H$9$k(B */
++static mgcsfxtab *get_mgcsfx(ms_type)
++     int ms_type;
++{
++  mgcsfxtab *magic;
++  int        i;
++
++  magic = NULL;
++  if(ms_type != 0){
++    i = 1;
++    for(magic = mgcsfx_table; (magic && i<ms_type); magic = magic->next){i++;}
++  }
++  return magic;
++}
++
++/***************************************************/
++/* $B30It%3%^%s%I$r<B9T$7$F!"$=$l$K=PNO$9$k(B */
++/* if OK return 0, else if ERROR return -1 */
++static
++int WriteMGCSFX(fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,file_name,
++		ms_type, file, comment)
++     FILE **fp;
++     byte  *pic;
++     int    ptype, w,h;
++     byte  *rmap, *gmap, *bmap;
++     int    numcols, colorstyle;
++     char  *file_name;
++     int    ms_type;
++     int    file; /* file descriptor */
++     char  *comment;
++{
++  mgcsfxtab *magic;
++
++  int        fd[2];
++  int        pid;
++  int        rv;
++
++  WaitCursor();
++
++#ifdef USE_SIGCHLD
++  w_p_fail = 1;
++#endif
++
++  magic = get_mgcsfx(ms_type);
++  if(ms_type != 0 && magic == NULL) return -1;
++
++  if ((ms_type == 0 && output_command_ex_flag) ||
++      (ms_type !=0 && magic != NULL && magic->output_command)){
++
++    /* Do the pipe/fork/exec here */
++    if (pipe (fd) < 0){
++      fprintf (stderr, "Can't pipe : %s\n", file_name);
++      return -1;
++    }
++
++    if ((pid = vfork ()) < 0){
++      fprintf (stderr, "Can't vfork : %s\n", file_name);
++      close (fd[0]);
++      close (fd[1]);
++      return -1;
++    }
++
++    if (!pid){
++      close(1);
++      dup(file);
++      close(file);
++      close(0);
++      dup(fd[0]);
++      close(2);
++      open("/dev/null", O_WRONLY);
++      close(fd[1]);
++      if(ms_type == 0){
++	execl("/bin/sh", "/bin/sh", "-c", output_command_ex, 0);
++      }else{
++	execl("/bin/sh", "/bin/sh", "-c", magic->output_command, 0);
++      }
++      _exit(127);
++    }
++
++    close (fd[0]);
++    dup2(fd[1], file);
++    close (fd[1]);
++
++  }else{
++    return -1;
++  }
++
++
++  *fp = fdopen(file, "w");
++
++  /* sleep(1); Best way is wait for checking SIGCHLD, but it's feel waist.*/
++
++#ifdef USE_SIGCHLD
++  if(w_p_fail != 2){
++#endif
++    if(ms_type == 0){
++      rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
++		    1, comment);
++    }else{
++      switch(magic -> output_image_type){
++      case IT_PNM:
++      case IT_PPM:
++      case IT_PGM:
++      case IT_PBM:
++      case IT_PNM_RAW:
++      case IT_PPM_RAW:
++      case IT_PGM_RAW:
++      case IT_PBM_RAW:
++	rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
++		      1, comment);
++	break;
++      case IT_PNM_ASCII:
++      case IT_PPM_ASCII:
++      case IT_PGM_ASCII:
++      case IT_PBM_ASCII:
++	rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
++		      0, comment);
++	break;
++      case IT_GIF:
++      case IT_JPEG:
++      case IT_TIFF:
++      case IT_JFIF:
++      case IT_XBM:
++      case IT_XPM:
++      case IT_BMP:
++      case IT_SUNRAS:
++      case IT_IRIS:
++      case IT_XWD:
++      case IT_MAG:
++      case IT_MAKI:
++      case IT_PI:
++      case IT_PIC:
++      case IT_PIC2:
++	SetISTR(ISTR_WARNING, "Yet supported output image type (to filter input)");
++	rv = -1;
++	break;
++      case IT_UNKNOWN:
++	SetISTR(ISTR_WARNING, "Unknown output image type (to filter input)");
++	rv = -1;
++	break;
++#ifdef HAVE_MGCSFX_AUTO
++      case IT_AUTO:
++#endif /* HAVE_MGCSFX_AUTO */
++      default:
++	SetISTR(ISTR_WARNING, "Error in output image type (to filter input)");
++	rv = -1;
++	break;
++      }
++    }
++#ifdef USE_SIGCHLD
++  }else{
++    rv = -1;
++  }
++#endif
++
++#ifdef USE_SIGCHLD
++  if(w_p_fail != 2){
++#endif
++    w_pid = pid;
++#ifdef USE_SIGCHLD
++    w_p_fail = 0;
++  }else{
++    rv = -1;
++  }
++#endif
++
++  output_command_ex_flag = 0;
++
++  return rv;
++
++  /* fclose(*fp);   close in CloseOutFile in writeMGCSFX */
++  /* return  0; ok */
++  /* return -1; error */
++}
++
++/***************************************************/
++void CreateMGCSFXW()
++{
++  int	     y;
++  int        type_num;
++  mgcsfxtab *entry;
++
++  if (mgcsfx_setup_flag == 0) init_mgcsfx ();
++
++  if(desc_width < strlen(MSD_IC_TITLE))  desc_width = strlen(MSD_IC_TITLE);
++  nitem_mgcsfx ++;
++
++  MSWIDE = desc_width * CWIDE + RBSIZE + 36; /* 36 is start of RB button */
++  MSHIGH = nitem_mgcsfx * (RBSIZE + MARGIN);
++
++  if(MSWIDE < strlen(MSD_TITLE) + 20) MSWIDE = strlen(MSD_TITLE) + 20;
++  if(MSWIDE < strlen(MSD_RBTITLE) + 16) MSWIDE = strlen(MSD_RBTITLE) + 16;
++  if(MSWIDE < MSNAMWIDE + 10) MSWIDE = MSNAMWIDE + 10;
++  if(MSWIDE <  BUTTW * 2 + 10) MSWIDE = BUTTW * 2 + 10;
++
++  MSHIGH += 55 + LINEHIGH + 10 + BUTTH + 10;
++
++  MSWIDE += 20; /* right side margin */
++  MSHIGH += 10; /* RB buttun down side margin */
++
++
++  mgcsfxW = CreateWindow("xv mgcsfx", "XVmgcsfx", NULL, 
++			 MSWIDE, MSHIGH, infofg, infobg, 0);
++  if (!mgcsfxW) FatalError("can't create mgcsfx window!");
++
++  XSelectInput(theDisp, mgcsfxW,
++	       ExposureMask | ButtonPressMask | KeyPressMask);
++
++  mgcsfxNameW = XCreateSimpleWindow(theDisp, mgcsfxW,
++				    10,  MSHIGH-LINEHIGH-10-BUTTH-10-1, 
++				    (u_int) MSNAMWIDE+6, (u_int) LINEHIGH+5, 
++				    1, infofg, infobg);
++  if (!mgcsfxNameW) FatalError("can't create mgcsfx name window");
++  XSelectInput(theDisp, mgcsfxNameW, ExposureMask);
++
++  /* Ok $B%\%?%s(B */
++  BTCreate(&msbut[MS_BOK], mgcsfxW,
++	   MSWIDE-BUTTW-10-BUTTW-10-1, MSHIGH-BUTTH-10-1,
++	   BUTTW, BUTTH, 
++	   "Ok", infofg, infobg, hicol, locol);
++  /* Cancel $B%\%?%s(B*/
++  BTCreate(&msbut[MS_BCANC], mgcsfxW,
++	   MSWIDE-BUTTW-10-1, MSHIGH-BUTTH-10-1,
++	   BUTTW, BUTTH,
++	   "Cancel", infofg, infobg, hicol, locol);
++
++  y = 55;
++  /* User should input command to exec external command */
++  typeRB = RBCreate(NULL, mgcsfxW, 36, y,          MSD_IC_TITLE,
++		    infofg, infobg,hicol,locol);
++  y += (RBSIZE + MARGIN); /* 18 */
++
++  type_num = 1;
++  for (entry = mgcsfx_table; entry; entry = entry->next){
++    RBCreate(typeRB, mgcsfxW, 36, y,            entry->description,
++	     infofg, infobg,hicol,locol);
++    y += (RBSIZE + MARGIN); /* 18 */
++    if(entry->output_command == NULL){
++      RBSetActive(typeRB, type_num, 0); /* if no command, off */
++    }
++    type_num++;
++  }
++
++  XMapSubwindows(theDisp, mgcsfxW);
++}
++
++
++/***************************************************/
++void MGCSFXDialog(vis)
++     int vis;
++{
++  if (vis) {
++    CenterMapWindow(mgcsfxW, msbut[MS_BOK].x + msbut[MS_BOK].w/2,
++		    msbut[MS_BOK].y + msbut[MS_BOK].h/2, MSWIDE, MSHIGH);
++  }
++  else     XUnmapWindow(theDisp, mgcsfxW);
++  mgcsfxUp = vis;
++}
++
++
++/***************************************************/
++int MGCSFXCheckEvent(xev)
++     XEvent *xev;
++{
++  /* check event to see if it's for one of our subwindows.  If it is,
++     deal accordingly, and return '1'.  Otherwise, return '0' */
++
++  int rv;
++  rv = 1;
++
++  if (!mgcsfxUp) return (0);
++
++  if (xev->type == Expose) {
++    int x,y,w,h;
++    XExposeEvent *e = (XExposeEvent *) xev;
++    x = e->x;  y = e->y;  w = e->width;  h = e->height;
++
++    if (e->window == mgcsfxW)       drawMSD(x, y, w, h);
++    else rv = 0;
++  }
++
++  else if (xev->type == ButtonPress) {
++    XButtonEvent *e = (XButtonEvent *) xev;
++    int x,y;
++    x = e->x;  y = e->y;
++
++    if (e->button == Button1) {
++      if      (e->window == mgcsfxW)     clickMSD(x,y);
++      else rv = 0;
++    }  /* button1 */
++    else rv = 0;
++  }  /* button press */
++
++  else if (xev->type == KeyPress) {
++    XKeyEvent *e = (XKeyEvent *) xev;
++    char buf[128];  KeySym ks;  XComposeStatus status;  
++    int stlen;
++
++    stlen = XLookupString(e,buf,128,&ks,&status);
++    buf[stlen] = '\0';
++
++    if (e->window == mgcsfxW) {
++      if (stlen) {
++	keyinMSD(buf[0]);
++      }
++    }
++    else rv = 0;
++  }
++  else rv = 0;
++
++  if (rv == 0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
++    XBell(theDisp, 50);
++    rv = 1;   /* eat it */
++  }
++
++  return (rv);
++}
++
++
++/***************************************************/
++int MGCSFXSaveParams(fname, col)
++     char *fname;
++     int col;
++{
++  colorType = col;
++  strcpy(DialogFileName, GetDirFName());
++  return (0);
++}
++
++/***************************************************/
++/* $B%@%$%"%m%0$rI=<($9$k$H$-$N=hM}(B */
++static void drawMSD(x,y,w,h)
++     int x,y,w,h;
++{
++  int        i;
++  XRectangle xr;
++
++  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
++  XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
++
++  XSetForeground(theDisp, theGC, infofg);
++  XSetBackground(theDisp, theGC, infobg);
++
++  for (i = 0; i < MS_NBUTTS; i++) BTRedraw(&msbut[i]);
++
++  ULineString(mgcsfxW, typeRB->x-16, typeRB->y-3-DESCENT,
++	      MSD_RBTITLE);
++  RBRedraw(typeRB, -1);
++
++  DrawString(mgcsfxW, 20, 29, MSD_TITLE);
++
++  XSetClipMask(theDisp, theGC, None);
++
++  showFNamMSD();
++}
++
++/***************************************************/
++/* $B%@%$%"%m%0$r%/%j%C%/$7$?$H$-$N=hM}(B */
++static void clickMSD(x,y)
++     int x,y;
++{
++  int   i;
++  BUTT *bp;
++
++  /* check BUTTs */
++
++  /* check the RBUTTS first, since they don't DO anything */
++  if ((i = RBClick(typeRB, x,y)) >= 0) { /* $BA*Br(B(type)$B%\%?%s$N=hM}(B */
++    (void) RBTrack(typeRB, i);  /* $BA*Br(B(type)$B%\%?%s$r2!$7$?$H$-(B */
++    changeSuffix(i);
++    return;
++  }
++
++  for (i = 0; i < MS_NBUTTS; i++) { /* Ok,Cancel $B%\%?%s$N=hM}(B */
++    bp = &msbut[i];
++    if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
++      break;
++  }
++  if (i < MS_NBUTTS)  /* found one */ /* Ok,Cancel $B%\%?%s$r2!$7$?$H$-(B */
++    if (BTTrack(bp)) doCmd(i);
++}
++
++/***************************************************/
++/* $B%\%?%s(B(Ok, Cancel) $B$N=hM}(B */
++static void doCmd(cmd)
++     int cmd;
++{
++  int rv;
++
++  switch (cmd) {
++  case MS_BOK: /* Ok button */ {
++    char *fullname;
++
++    rv = writeMGCSFX(); /* Save with filter(MGCSFX) */
++    MGCSFXDialog(0);
++
++    fullname = GetDirFullName();
++    if (!ISPIPE(fullname[0])) {
++      XVCreatedFile(fullname);
++      if(!rv) StickInCtrlList(0);
++    }
++  }
++    break;
++  case MS_BCANC: /* Cancel button */
++    DialogFileName[0] = '\0';
++    curPos = stPos = enPos = 0;
++    MGCSFXDialog(0);
++    break;
++  default:
++    break;
++  }
++}
++
++/*******************************************/
++static int writeMGCSFX()
++{
++  int   rv, type;
++  int   ptype, w, h, pfree, nc;
++  byte *inpix, *rmap, *gmap, *bmap;
++
++  FILE *fp = NULL;
++  int   file;
++  char *fullname;
++
++  rv = -1;
++  type = RBWhich(typeRB);
++
++  SetDirFName(DialogFileName); /* change filename in dir dialog */
++  fullname = GetDirFullName();
++
++  if(type == 0){
++    if(getOutputCom() == 0) return rv;
++  }
++
++  file = OpenOutFileDesc(fullname);
++  if(file < 0) return rv;
++
++  WaitCursor();
++  inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
++
++  rv = WriteMGCSFX(&fp, inpix, ptype, w, h,
++		   rmap, gmap, bmap, nc, colorType, fullname,
++		   type, file, picComments);
++
++  SetCursors(-1);
++
++  if (CloseOutFile(fp, fullname, rv) == 0) DirBox(0);
++
++  WaitCursor();
++#ifdef USE_SIGCHLD
++  if(w_p_fail == 0){
++#endif
++    while(wait(&w_pstatus) != w_pid);  /* if( *((char *)&w_pstatus) != 0 ) ; */
++#ifdef USE_SIGCHLD
++  }else{
++    w_p_fail = 0;
++  }
++#endif
++  w_pid = 0;
++  w_pstatus = 0;
++
++  if (pfree) free(inpix);
++  return rv;
++}
++
++
++/***************************************/
++static void changeSuffix(ms_type)
++     int ms_type;
++{
++  /* see if there's a common suffix at the end of the DialogFileName.  
++     if there is, remember what case it was (all caps or all lower), lop
++     it off, and replace it with a new appropriate suffix, in the
++     same case */
++
++  int allcaps;
++  char *suffix, *sp, *dp, lowsuf[512];
++  mgcsfxtab *magic;
++
++  /* find the last '.' in the DialogFileName */
++  suffix = (char *) rindex(DialogFileName, '.');
++  if (!suffix) return;
++  suffix++;  /* point to first letter of the suffix */
++
++  /* check for all-caposity */
++  for (sp = suffix, allcaps=1; *sp; sp++) 
++    if (islower(*sp)) allcaps = 0;
++
++  /* copy the suffix into an all-lower-case buffer */
++  for (sp=suffix, dp=lowsuf; *sp; sp++, dp++) {
++    *dp = (isupper(*sp)) ? tolower(*sp) : *sp;
++  }
++  *dp = '\0';
++
++
++  magic = get_mgcsfx(ms_type);
++  if(magic != NULL && magic->suffix != NULL){
++    strcpy(lowsuf,(magic->suffix)+1);
++
++    if (allcaps) {  /* upper-caseify lowsuf */
++      for (sp=lowsuf; *sp; sp++) 
++	*sp = (islower(*sp)) ? toupper(*sp) : *sp;
++    }
++    
++    /* one other case:  if the original suffix started with a single
++       capital letter, make the new suffix start with a single cap */
++    if (isupper(suffix[0])) lowsuf[0] = toupper(lowsuf[0]);
++
++    strcpy(suffix, lowsuf);   /* tack onto DialogFileName */
++    showFNamMSD();
++  }
++}
++
++/***************************************************/
++/* $B%@%$%"%m%0Fb$K%U%!%$%k%M!<%`$rI=<($9$k$H$-$N=hM}(B ($B2<@A$1(B)*/
++static void redrawNamMSD()
++{
++  int cpos;
++
++  /* draw substring DialogFileName[stPos:enPos] and cursor */
++
++  Draw3dRect(mgcsfxNameW, 0, 0, (u_int) MSNAMWIDE+5, (u_int) LINEHIGH+4, R3D_IN, 2, 
++	     hicol, locol, infobg);
++
++  XSetForeground(theDisp, theGC, infofg);
++
++  if (stPos>0) {  /* draw a "there's more over here" doowah */
++    XDrawLine(theDisp, mgcsfxNameW, theGC, 0,0,0,LINEHIGH+5);
++    XDrawLine(theDisp, mgcsfxNameW, theGC, 1,0,1,LINEHIGH+5);
++    XDrawLine(theDisp, mgcsfxNameW, theGC, 2,0,2,LINEHIGH+5);
++  }
++
++  if ((size_t) enPos < strlen(DialogFileName)) { 
++    /* draw a "there's more over here" doowah */
++    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+5,0,MSNAMWIDE+5,LINEHIGH+5);
++    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+4,0,MSNAMWIDE+4,LINEHIGH+5);
++    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+3,0,MSNAMWIDE+3,LINEHIGH+5);
++  }
++
++  XDrawString(theDisp, mgcsfxNameW, theGC,3,ASCENT+3,DialogFileName+stPos, enPos-stPos);
++
++  cpos = XTextWidth(mfinfo, &DialogFileName[stPos], curPos-stPos);
++  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2, 3+cpos, 2+CHIGH+1);
++  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2+CHIGH+1, 5+cpos, 2+CHIGH+3);
++  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2+CHIGH+1, 1+cpos, 2+CHIGH+3);
++}
++
++/***************************************************/
++/* $B%@%$%"%m%0Fb$K%U%!%$%k%M!<%`$rI=<($9$k(B */
++static void showFNamMSD()
++{
++  int len;
++  
++  len = strlen(DialogFileName);
++  
++  if (curPos<stPos) stPos = curPos;
++  if (curPos>enPos) enPos = curPos;
++  
++  if (stPos>len) stPos = (len>0) ? len-1 : 0;
++  if (enPos>len) enPos = (len>0) ? len-1 : 0;
++  
++  /* while substring is shorter than window, inc enPos */
++  
++  while (XTextWidth(mfinfo, &DialogFileName[stPos], enPos-stPos) < MSNAMWIDE
++	 && enPos<len) { enPos++; }
++
++  /* while substring is longer than window, dec enpos, unless enpos==curpos,
++     in which case, inc stpos */
++
++  while (XTextWidth(mfinfo, &DialogFileName[stPos], enPos-stPos) > MSNAMWIDE) {
++    if (enPos != curPos) enPos--;
++    else stPos++;
++  }
++
++
++  if (ctrlColor) XClearArea(theDisp, mgcsfxNameW, 2,2, (u_int) MSNAMWIDE+5-3, 
++			    (u_int) LINEHIGH+4-3, False);
++  else XClearWindow(theDisp, mgcsfxNameW);
++
++  redrawNamMSD();
++  BTSetActive(&msbut[MS_BOK], strlen(DialogFileName)!=0);
++}
++
++/***************************************************/
++/* $B%-!<F~NO$7$?$H$-$N=hM}(B */
++static int keyinMSD(c)
++     int c;
++{
++  /* got keypress in dirW.  stick on end of DialogFileName */
++  int len;
++
++  len = strlen(DialogFileName);
++  
++  if (c>=' ' && c<'\177') {             /* printable characters */
++    /* note: only allow 'piped commands' in savemode... */
++
++    /* only allow spaces in 'piped commands', not filenames */
++    if (c==' ' && (!ISPIPE(DialogFileName[0]) || curPos==0)) return (-1);
++
++    /* only allow vertbars in 'piped commands', not filenames */
++    if (c=='|' && curPos!=0 && !ISPIPE(DialogFileName[0])) return(-1);
++
++    if (len >= MAXFNLEN-1) return(-1);  /* max length of string */
++    xvbcopy(&DialogFileName[curPos], &DialogFileName[curPos+1], (size_t) (len-curPos+1));
++    DialogFileName[curPos]=c;  curPos++;
++  }
++
++  else if (c=='\010' || c=='\177') {    /* BS or DEL */
++    if (curPos==0) return(-1);          /* at beginning of str */
++    xvbcopy(&DialogFileName[curPos], &DialogFileName[curPos-1], (size_t) (len-curPos+1));
++    curPos--;
++  }
++
++  else if (c=='\025') {                 /* ^U: clear entire line */
++    DialogFileName[0] = '\0';
++    curPos = 0;
++  }
++
++  else if (c=='\013') {                 /* ^K: clear to end of line */
++    DialogFileName[curPos] = '\0';
++  }
++
++  else if (c=='\001') {                 /* ^A: move to beginning */
++    curPos = 0;
++  }
++
++  else if (c=='\005') {                 /* ^E: move to end */
++    curPos = len;
++  }
++
++  else if (c=='\004') {                 /* ^D: delete character at curPos */
++    if (curPos==len) return(-1);
++    xvbcopy(&DialogFileName[curPos+1], &DialogFileName[curPos], (size_t) (len-curPos));
++  }
++
++  else if (c=='\002') {                 /* ^B: move backwards char */
++    if (curPos==0) return(-1);
++    curPos--;
++  }
++
++  else if (c=='\006') {                 /* ^F: move forwards char */
++    if (curPos==len) return(-1);
++    curPos++;
++  }
++
++  else if (c=='\012' || c=='\015') {    /* CR(\r) or LF(\n) */
++    FakeButtonPress(&msbut[MS_BOK]);
++  }
++
++  else if (c=='\033') {                  /* ESC = Cancel */
++    FakeButtonPress(&msbut[MS_BCANC]);
++  }
++
++  else if (c=='\011') {                  /* tab = filename expansion */
++    if (1 /* !autoComplete() */) XBell(theDisp, 0);
++    else {
++      curPos = strlen(DialogFileName);
++    }
++  }
++
++  else return(-1);                      /* unhandled character */
++
++  showFNamMSD();
++
++  return(0);
++}
++
++
++/*******************************************/
++int getInputCom()
++{
++  static char *labels[] = { "\nOk", "\033Cancel" };
++  int i;
++
++  strcpy(input_command_ex, MGCSFX_DEFAULT_INPUT_COMMAND);
++  i = GetStrPopUp("Input External Command (Input is PNM):", labels, 2,
++		  input_command_ex, 1024, "",0);
++  if (i == 0 && strlen(input_command_ex) != 0){
++    input_command_ex_flag = 1;
++    return 1;
++  }else{
++    input_command_ex_flag = 0;
++    return 0;
++  }
++}
++
++int getOutputCom()
++{
++  static char *labels[] = { "\nOk", "\033Cancel" };
++  int i;
++
++  strcpy(output_command_ex, MGCSFX_DEFAULT_OUTPUT_COMMAND);
++  i = GetStrPopUp("Input External Command (Output is PNM_RAW):", labels, 2,
++		  output_command_ex, 1024, "",0);
++  if (i == 0 && strlen(output_command_ex) != 0){
++    output_command_ex_flag = 1;
++    return 1;
++  }else{
++    output_command_ex_flag = 0;
++    return 0;
++  }
++}
++
++#ifdef SVR4
++Sigfunc *
++xv_signal(signo, func)
++     int signo;
++     Sigfunc *func;
++{
++  struct sigaction act, oact;
++
++  act.sa_handler = func;
++  sigemptyset(&act.sa_mask);
++  act.sa_flags = 0;
++  act.sa_flags |= SA_RESTART;
++
++  if (sigaction(signo, &act, &oact) < 0)
++    return SIG_ERR;
++
++  return oact.sa_handler;
++}
++#endif
++
++#endif /* HAVE_MGCSFX */
+diff -urN xv-3.10a/xvmisc.c xv-3.10a-jp-extension-current/xvmisc.c
+--- xv-3.10a/xvmisc.c	Sat Jan 14 08:41:34 1995
++++ xv-3.10a-jp-extension-current/xvmisc.c	Wed Oct  9 20:36:21 1996
+@@ -497,6 +497,11 @@
+      as we have to keep the alloc'd colors around, but we don't want anything
+      else to stay */
+ 
++#ifdef AUTO_EXPAND
++  chdir(initdir);
++  Vdsettle();
++#endif
++
+   if (!theDisp) exit(i);   /* called before connection opened */
+ 
+   if (useroot && i==0) {   /* save the root info */
+@@ -520,6 +525,18 @@
+     if (tiffW) XDestroyWindow(theDisp, tiffW);
+ #endif
+ 
++#ifdef HAVE_PIC2
++    if (pic2W) XDestroyWindow(theDisp, pic2W);
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++    if (pcdW)  XDestroyWindow(theDisp, pcdW);
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++    if (mgcsfxW) XDestroyWindow(theDisp, mgcsfxW);
++#endif /* HAVE_MGCSFX */
++
+     /* if NOT using stdcmap for images, free stdcmap */
+     if (colorMapMode != CM_STDCMAP) { 
+       int j;
+@@ -716,6 +733,18 @@
+ #ifdef HAVE_TIFF
+   if (tiffW) XDefineCursor(theDisp, tiffW, otherc);
+ #endif
++
++#ifdef HAVE_PIC2
++  if (pic2W) XDefineCursor(theDisp, pic2W, otherc);
++#endif /* HAVE_PIC2 */
++
++#ifdef HAVE_PCD
++  if (pcdW)  XDefineCursor(theDisp, pcdW, otherc);
++#endif /* HAVE_PCD */
++
++#ifdef HAVE_MGCSFX
++  if (mgcsfxW) XDefineCursor(theDisp, mgcsfxW, otherc);
++#endif /* HAVE_MGCSFX */
+ }
+ 
+ 
+@@ -1000,6 +1029,9 @@
+ 	((rv=(char *) getenv("cwd"))==NULL)) rv = "./";
+     strcpy(buf, rv);
+   }
++#ifdef AUTO_EXPAND
++  Vdtodir(buf);
++#endif
+ }
+ 
+ 
+diff -urN xv-3.10a/xvml.c xv-3.10a-jp-extension-current/xvml.c
+--- xv-3.10a/xvml.c
++++ xv-3.10a-jp-extension-current/xvml.c	Tue Oct 22 18:17:25 1996
+@@ -0,0 +1,992 @@
++/*
++ * xvml.c  -  makes text item structure for multi-lingual textviewer.
++ *
++ * Entry Points:
++ *  struct ml_text *ml_draw_text()
++ *  struct context *ml_create_context()
++ *  int ml_set_charsets()
++ *  void get_monofont_size()
++ */
++
++#include "xv.h"
++#include <X11/Xresource.h>
++
++#ifdef TV_MULTILINGUAL	/* whole this file. */
++
++#include "xvml.h"
++#define HAVE_STRDUP 1
++#define USE_MULE_EXTENSION
++
++#ifndef __STDC__
++#define CHAR char
++#else
++#define CHAR int
++#endif
++
++#define CODE_SI  0x0e	/* LS0 */
++#define CODE_SO  0x0f	/* LS1 */
++#define CODE_SS2 ((unsigned char) 0x8e)
++#define CODE_SS3 ((unsigned char) 0x8f)
++
++int ml_tab_width = 64;	/* dots */
++
++struct charset {
++    int bpc;		/* bytes per char */
++    int noc;		/* number of chars */
++    char designator;
++    char *registry;
++    int bit7;
++    
++    int loaded;
++    char *fontname;
++    
++    XFontStruct *fs;
++} charset[] = {
++    { 1, 94, 'B', "iso8859-1",       0, 0, NULL, NULL},
++    { 1, 96, 'A', "iso8859-1",       1, 0, NULL, NULL},
++    { 1, 94, '0', "omron_udc_zh-0",  0, 0, NULL, NULL},
++    { 1, 94, '2', "mulearabic-0",    0, 0, NULL, NULL},
++    { 1, 94, '3', "mulearabic-1",    0, 0, NULL, NULL},
++    { 1, 94, '4', "mulearabic-2",    0, 0, NULL, NULL},
++    { 1, 94, 'J', "jisx0201.1976-0", 0, 0, NULL, NULL},
++    { 1, 96, '0', "muleipa-1",       1, 0, NULL, NULL},
++    { 1, 96, '1', "viscii1.1-1",     1, 0, NULL, NULL},
++    { 1, 96, '2', "viscii1.1-1",     1, 0, NULL, NULL},
++    { 1, 96, 'B', "iso8859-2",       1, 0, NULL, NULL},
++    { 1, 96, 'C', "iso8859-3",       1, 0, NULL, NULL},
++    { 1, 96, 'D', "iso8859-4",       1, 0, NULL, NULL},
++    { 1, 96, 'T', "tis620.1986-0",   1, 0, NULL, NULL},
++    { 1, 96, 'F', "iso8859-7",       1, 0, NULL, NULL},
++    { 1, 96, 'G', "iso8859-6",       1, 0, NULL, NULL},
++    { 1, 96, 'H', "iso8859-8",       1, 0, NULL, NULL},
++    { 1, 94, 'I', "jisx0201.1976-0", 1, 0, NULL, NULL},
++    { 1, 96, 'L', "iso8859-5",       1, 0, NULL, NULL},
++    { 1, 96, 'M', "iso8859-9",       1, 0, NULL, NULL},
++    { 2, 94, '2', "ethio-0",         0, 0, NULL, NULL},
++    { 2, 94, '@', "jisx0208.1978",   0, 0, NULL, NULL},
++    { 2, 94, 'A', "gb2312.1980-0",   0, 0, NULL, NULL},
++    { 2, 94, 'B', "jisx0208.1983-0", 0, 0, NULL, NULL},
++    { 2, 94, 'C', "ksc5601.1987-0",  0, 0, NULL, NULL},
++    { 2, 94, 'D', "jisx0212.1990-0", 0, 0, NULL, NULL},
++    { 2, 94, '0', "big5.eten-0",     0, 0, NULL, NULL},
++    { 2, 94, '1', "big5.hku-0",      0, 0, NULL, NULL},
++    /* End Mark */
++    { 0,  0,   0,        NULL,       0, 0, NULL, NULL},
++};
++#define NR_CHARSETS ((int) (sizeof charset / sizeof charset[0]))
++
++static struct charset *ascii = NULL;
++
++struct context {
++    struct charset *g[4];
++    struct charset **gl, **gr;
++    struct charset **ss;
++    int eol;		/* 0: \n,  1: \r\n,  2: \r,  3: any */
++    int valid[4];	/* g[i] is valid? */
++    int short_form;	/* allow shortened designator sequence? */
++    int lock_shift;	/* allow locking shift? */
++    
++    unsigned char *cbuf, *cbp;
++    struct ml_text text;
++    int line;
++    int delta;
++    int toolong;
++    
++    Display *dpy;
++    Screen *scr;
++    Window root_win;
++};
++#define DPY (context->dpy)
++#define SCR (context->scr)
++#define ROOT_WIN (context->root_win)
++
++static unsigned char *escape_sequence		PARM((unsigned char *));
++static unsigned char *designator_sequence	PARM((unsigned char *));
++static void locking_shift			PARM((unsigned CHAR));
++static void single_shift			PARM((unsigned CHAR));
++static void put_unknown_char			PARM((unsigned CHAR));
++static struct charset *search_charset		PARM((int, int, int));
++static void pack_string				PARM((struct charset *,
++						      unsigned char *, int));
++static void init_xrm				PARM((void));
++static void init_xrm_fonts			PARM((void));
++static void init_xrm_tab			PARM((void));
++#ifndef HAVE_STRDUP
++static char *strdup				PARM((char *));
++#endif
++
++static char *default_fonts[] = {		/* default for xrm_fonts */
++    "-sony-fixed-medium-r-normal--16-*-*-*-*-*-iso8859-1",
++    "-jis-fixed-medium-r-normal--16-*-*-*-*-*-jisx0208.1983-0",
++};
++static int xrm_nfonts;
++static char **xrm_fonts;
++
++static struct context *context;	/* current context */
++
++struct ml_text *ml_draw_text(ctx, string, len)
++    struct context *ctx;
++    char *string;
++    int len;
++{
++    unsigned char *str = (unsigned char *) string;
++    unsigned char *estr = str + len;
++    
++    context = ctx;
++    
++    if(ascii == NULL){
++	fputs("ml_draw_text: call ml_set_charsets, first.\n", stderr);
++	return NULL;
++    }
++    
++    if(!str)
++	return &context->text;
++    
++    WaitCursor();
++    
++    if (context->text.maxlines != 0) {
++	struct ml_text *tp = &context->text;
++	struct ml_line *lp;
++	int i;
++	for (i = tp->nlines, lp = tp->lines; i > 0; i--, lp++) {
++	    XTextItem16 *ip;
++	    int j;
++	    if (lp->maxitems != 0)
++		free((char *) lp->items);
++	}
++	free((char *) tp->lines);
++	tp->maxlines = tp->nlines = 0;
++    }
++    if (context->cbuf != NULL)
++	free((char *) context->cbuf);
++    context->cbp = (unsigned char *) malloc((size_t) len * 8);/* all \xxx */
++    context->cbuf = context->cbp;
++    context->line = 0;
++    context->delta = 0;
++    context->ss = NULL;
++    
++    while(str < estr){
++	if((*str & 0x80) == 0){				/* left half */
++	    struct charset *cs = context->ss ? *context->ss : *context->gl;
++	    unsigned char min_char, max_char;
++	    if (cs != NULL) {
++		if(cs->noc == 94){
++		    min_char = 0x21;
++		    max_char = 0x7e;
++		}else{
++		    min_char = 0x20;
++		    max_char = 0x7f;
++		}
++	    }
++	    
++	    if (cs == NULL)
++		put_unknown_char(*str++);
++	    else if(*str < min_char || *str > max_char){	/* C1 */
++		switch(*str){
++		case ' ':
++		    {
++			unsigned char *p = str + 1;
++			while (*p == ' ' && p < estr)
++			    p++;
++			pack_string(ascii, str, (int) (p - str));
++			str = p;
++		    }
++		    break;
++		    
++		case '\t':
++		    pack_string(ascii, str++, 0);
++		    break;
++		    
++		case '\n':
++		    switch (context->eol) {
++		    case 0:				/* unix type eol */
++			pack_string(ascii, str, 0);
++			WaitCursor();
++			str++;
++			break;
++		    case 1:				/* dos type eol */
++		    case 2:				/* mac type eol */
++			put_unknown_char('\n');
++			str++;
++			break;
++		    case 3:				/* any type eol */
++			pack_string(ascii, str++, 0);
++			while (*str == '\n' || *str == '\r')
++			    str++;
++			WaitCursor();
++			break;
++		    }
++		    break;
++		    
++		case '\r':
++		    switch (context->eol) {
++		    case 0:
++			put_unknown_char('\r');
++			str++;
++			break;
++		    case 1:
++			str++;
++			if (*str == '\n')
++			    pack_string(ascii, str++, 0);
++			else
++			    put_unknown_char('\r');
++			break;
++		    case 2:
++			pack_string(ascii, str, 0);
++			WaitCursor();
++			str++;
++			break;
++		    case 3:
++			pack_string(ascii, str++, 0);
++			while (*str == '\n' || *str == '\r')
++			    str++;
++			WaitCursor();
++			break;
++		    }
++		    break;
++		    
++		case '\033':
++		    {
++			unsigned char *p;
++			str++;
++			if((p = escape_sequence(str)) == str)
++			    put_unknown_char('\033');
++			else
++			    str = p;
++		    }
++		    break;
++		    
++		case CODE_SI:
++		case CODE_SO:
++		    if (!context->lock_shift)
++			put_unknown_char((unsigned int) *str++);
++		    else
++			locking_shift((unsigned int) *str++);
++		    break;
++		    
++		default:
++		    put_unknown_char((unsigned int) *str++);
++		}
++	    }else{					/* GL */
++		if (context->ss != NULL) {
++		    pack_string(cs, str, 1);
++		    str += cs->bpc;
++		    context->ss = NULL;
++		} else {
++		    int n;
++		    
++		    if (cs->bpc == 1) {
++			unsigned char *p = str;
++			for (n = 0; p < estr; n++) {
++			    if (*p < min_char || *p > max_char)
++				break;
++			    p++;
++			}
++			pack_string(cs, str, n);
++			str = p;
++		    } else {
++			unsigned char *p = str;
++			for (n = 0; p < estr - 1; n++) {
++			    if (*p < min_char || *p > max_char ||
++				    *(p + 1) < min_char || *(p + 1) > max_char)
++				break;
++			    p += 2;
++			}
++			if (n > 0)
++			    pack_string(cs, str, n);
++			else
++			    put_unknown_char(*p++);
++			str = p;
++		    }
++		}
++	    }
++	}else{						/* right half */
++	    struct charset *cs = context->ss ? *context->ss : *context->gr;
++	    unsigned char min_char, max_char;
++	    if (cs != NULL) {
++		if(cs->noc == 94){
++		    min_char = 0xa1;
++		    max_char = 0xfe;
++		}else{
++		    min_char = 0xa0;
++		    max_char = 0xff;
++		}
++	    }
++	    
++	    if (cs == NULL)
++		put_unknown_char(*str++);
++	    else if(*str < min_char || *str > max_char){	/* C2 */
++		unsigned char c = *str++;
++		switch(c){
++		case CODE_SS2:
++		case CODE_SS3:
++		    single_shift((unsigned CHAR) c);
++		    break;
++		default:
++		    put_unknown_char(c);
++		}
++	    }else{					/* GR */
++		if (context->ss != NULL) {
++		    pack_string(cs, str, 1);
++		    str += cs->bpc;
++		    context->ss = NULL;
++		} else {
++		    int n;
++		    
++		    if (cs->bpc == 1) {
++			unsigned char *p = str;
++			for (n = 0; p < estr; n++) {
++			    if (*p < min_char || *p > max_char)
++				break;
++			    p++;
++			}
++			pack_string(cs, str, n);
++			str = p;
++		    } else {
++			unsigned char *p = str;
++			for (n = 0; p < estr - 1; n++) {
++			    if (*p < min_char || *p > max_char ||
++				    *(p + 1) < min_char || *(p + 1) > max_char)
++				break;
++			    p += 2;
++			}
++			if (n > 0)
++			    pack_string(cs, str, n);
++			else
++			    put_unknown_char(*p++);
++			str = p;
++		    }
++		}
++	    }
++	}
++    }
++    
++    {
++	struct ml_text *tp = &context->text;
++	struct ml_line *lp;
++	int i;
++	
++	tp->width = 0;
++	tp->height = 0;
++	for (lp = tp->lines, i = tp->nlines; i > 0; lp++, i--) {
++	    if (lp->nitems == 0) {
++		lp->ascent  = ascii->fs->ascent;
++		lp->descent = ascii->fs->descent;
++	    }
++	    if (tp->width < lp->width)
++		tp->width = lp->width;
++	    tp->height += lp->ascent + lp->descent;
++	}
++    }
++    
++    SetCursors(-1);
++    return &context->text;
++}
++
++static unsigned char *escape_sequence(str)
++    unsigned char *str;
++{
++    unsigned char *p;
++    switch(*str){
++    case '$':
++    case '(': case ')': case '*': case '+':
++    case '-': case '.': case '/': case ',':
++	if((p = designator_sequence(str)) == NULL)
++	    return str;
++	return p;
++    case 'n': case 'o': case '~': case '}': case '|':
++	if (!context->lock_shift)
++	    return str;
++	locking_shift(*str);
++	return str + 1;
++    case 'N': case 'O':
++	single_shift(*str);
++	return str + 1;
++    }
++    return str;
++    
++}
++
++static unsigned char *designator_sequence(str)
++    unsigned char *str;
++{
++    unsigned char *p = str;
++    int noc, bpc, n_g, shortened;
++    unsigned char des;
++    struct charset *cs;
++    
++    if(*p == '$'){
++	bpc = 2;
++	p++;
++    }else
++	bpc = 1;
++    
++    switch(*p++){
++    case '(':	noc = 94; n_g = 0; des = *p++; shortened = 0; break;
++    case ')':	noc = 94; n_g = 1; des = *p++; shortened = 0; break;
++    case '*':	noc = 94; n_g = 2; des = *p++; shortened = 0; break;
++    case '+':	noc = 94; n_g = 3; des = *p++; shortened = 0; break;
++#ifdef USE_MULE_EXTENSION
++    case ',':	noc = 96; n_g = 0; des = *p++; shortened = 0; break;
++#endif
++    case '-':	noc = 96; n_g = 1; des = *p++; shortened = 0; break;
++    case '.':	noc = 96; n_g = 2; des = *p++; shortened = 0; break;
++    case '/':	noc = 96; n_g = 3; des = *p++; shortened = 0; break;
++    case '@':	noc = 94; n_g = 0; des = 'B';  shortened = 0; break;
++    case 'A':	noc = 94; n_g = 0; des = 'A';  shortened = 1; break;
++    case 'B':	noc = 94; n_g = 0; des = 'B';  shortened = 1; break;
++    default:	return NULL;
++    }
++    if (!context->short_form && shortened)
++	return NULL;
++    
++    if((cs = search_charset(bpc, noc, des)) == NULL){
++	if(DEBUG){
++	    fprintf(stderr, "designator_sequence: (%d,%d,%c) not found.\n",
++		    bpc, noc, des);
++	}
++	return NULL;
++    }
++    if (!context->valid[n_g])
++	return NULL;
++    context->g[n_g] = cs;
++    if(DEBUG){
++	fprintf(stderr,
++		"designator_sequence: G%d is `%s'.\n", n_g, cs->registry);
++    }
++    return p;
++}
++
++static void locking_shift(c)
++    unsigned CHAR c;
++{
++    switch((unsigned char) c){
++    case CODE_SI:	context->gl = &context->g[0]; break;
++    case CODE_SO:	context->gl = &context->g[1]; break;
++    case 'n':		context->gl = &context->g[2]; break;
++    case 'o':		context->gl = &context->g[3]; break;
++    case '~':		context->gr = &context->g[1]; break;
++    case '}':		context->gr = &context->g[2]; break;
++    case '|':		context->gr = &context->g[3]; break;
++    }
++    if(DEBUG){
++	fprintf(stderr, "locking_shift: (%d,%d).\n",
++		(int)(context->gl - context->g),
++		(int)(context->gr - context->g));
++    }
++}
++
++static void single_shift(c)
++    unsigned CHAR c;
++{
++    switch((unsigned char) c){
++    case CODE_SS2:	context->ss = &context->g[2]; break;
++    case CODE_SS3:	context->ss = &context->g[3]; break;
++    }
++}
++
++
++static void put_unknown_char(chr)
++    unsigned CHAR chr;
++{
++    unsigned char c = chr;
++    
++    if(c < 0x20){
++	unsigned char buf[2];
++	buf[0] = '^';
++	buf[1] = c + 0x40;
++	pack_string(ascii, buf, 2);
++    }else{
++	unsigned char buf[4];
++	buf[0] = '\\';
++	buf[1] =  ((c >> 6) & 07) + '0';
++	buf[2] =  ((c >> 3) & 07) + '0';
++	buf[3] =  ((c     ) & 07) + '0';
++	pack_string(ascii, buf, 4);
++    }
++}
++
++struct context *ml_create_context(s)
++    Screen *s;
++{
++    context = (struct context *) malloc(sizeof *context);
++    
++    context->g[0] = NULL;
++    context->g[1] = NULL;
++    context->g[2] = NULL;
++    context->g[3] = NULL;
++    context->gl = NULL;
++    context->gr = NULL;
++    context->ss = NULL;
++    
++    context->cbuf = NULL;
++    context->text.maxlines = context->text.nlines = 0;
++    context->line = 0;
++    context->delta = 0;
++    context->toolong = 0;
++    
++    DPY = DisplayOfScreen(s);
++    SCR = s;
++    ROOT_WIN = RootWindowOfScreen(s);
++    
++    return context;
++}
++
++
++int ml_set_charsets(ctx, sys)
++    struct context *ctx;
++    struct coding_system *sys;
++{
++    int retval = 0;
++    int i;
++    
++    context = ctx;
++    
++    if(ascii == NULL){
++	init_xrm();
++	if((ascii = search_charset(1, 94, 'B')) == NULL){
++	    fputs("ml_set_charsets: ascii charset not found.\n", stderr);
++	    Quit(1);
++	}
++	if (ascii->fs == NULL) {
++	    fputs("ml_set_charsets: iso8859-1 font not found.\n", stderr);
++	    Quit(1);
++	}
++    }
++    for(i = 0; i < 4; i++){
++	struct charset *spec;
++	switch(sys->design[i].bpc){
++	case -1:	/* make G[i] invalid */
++	    context->valid[i] = 0;
++	    break;
++	    
++	case 0:		/* don't change */
++	    break;
++	    
++	case 1: case 2:	/* change it */
++	    if((context->g[i] = search_charset(sys->design[i].bpc,
++					       sys->design[i].noc,
++					       sys->design[i].des)) == NULL){
++		fputs("ml_set_charsets: ", stderr);
++		fprintf(stderr, "(%d,%d,%c) is specified as G%d, ",
++			sys->design[i].bpc, sys->design[i].noc,
++			sys->design[i].des, i);
++		fputs("but not found. using `iso8859-1'.\n", stderr);
++		context->g[i] = ascii;
++		retval++;
++	    }
++	    context->valid[i] = 1;
++	    break;
++	    
++	default:	/* error */
++	    fprintf(stderr,"ml_set_charsets: bad arguments of G%d. ", i);
++	    fputs("using `iso8859-1'.\n", stderr);
++	    context->g[i] = ascii;
++	    retval++;
++	}
++    }
++    if((unsigned int) sys->gl < 4)
++	context->gl = &context->g[sys->gl];
++    else{
++	fprintf(stderr, "ml_set_charsets: bad number as GL. using G0.\n");
++	context->gl = &context->g[0];
++    }
++    if((unsigned int) sys->gr < 4)
++	context->gr = &context->g[sys->gr];
++    else{
++	fprintf(stderr, "ml_set_charsets: bad number as GR. using G0.\n");
++	context->gr = &context->g[0];
++    }
++    context->eol = sys->eol;
++    context->short_form = sys->short_form;
++    context->lock_shift = sys->lock_shift;
++    return retval;
++}
++
++static struct charset *search_charset(bpc, noc, des)
++    int bpc, noc;
++    int des;
++{
++    struct charset *cset;
++    for(cset = charset; cset->bpc != 0; cset++){
++	if(cset->bpc == bpc &&
++	   cset->noc == noc &&
++	   cset->designator == (char) des){
++	    if(!cset->loaded){
++#if 0
++		int i, l;
++		l = strlen(cset->registry);
++		for (i = 0; i < xrm_nfonts; i++) {
++		    int li = strlen(xrm_fonts[i]);
++		    if (li > l) {
++			if (xrm_fonts[i][li - l - 1] == '-' &&
++				strcmp(xrm_fonts[i] + li - l,
++				       cset->registry) == 0) {
++			    if ((cset->fs = XLoadQueryFont(DPY, xrm_fonts[i]))
++				    != NULL) {
++				if (DEBUG) {
++				    fprintf(stderr, "%s for %s\n",
++					    xrm_fonts[i], cset->registry);
++				}
++				cset->fontname = xrm_fonts[i];
++				break;
++			    } else
++				SetISTR(ISTR_WARNING,
++					"%s: font not found.", xrm_fonts[i]);
++			}
++		    }
++		}
++#else
++		int i, l;
++		l = strlen(cset->registry);
++		for (i = 0; i < xrm_nfonts && cset->fs == NULL; i++) {
++		    int j, nfnts = 0;
++		    char **fnts = XListFonts(DPY, xrm_fonts[i],
++					     65535, &nfnts);
++		    for (j = 0 ; j < nfnts; j++) {
++			int ll = strlen(fnts[j]);
++			if (*(fnts[j] + ll - l - 1) == '-' &&
++			    strcmp(fnts[j] + ll - l, cset->registry)== 0) {
++			    if ((cset->fs = XLoadQueryFont(DPY, fnts[j]))
++				!= NULL) {
++				if (DEBUG) {
++				    fprintf(stderr, "%s for %s\n",
++					    fnts[j], cset->registry);
++				}
++				cset->fontname = strdup(fnts[j]);
++				break;
++			    } else
++				SetISTR(ISTR_WARNING,
++					"%s: font not found", fnts[j]);
++			}
++		    }
++		    if (fnts != NULL)
++			XFreeFontNames(fnts);
++		}
++#endif
++		if(cset->fs == NULL){
++		    SetISTR(ISTR_WARNING,
++			    "font for %s not found.\nusing ascii font.",
++			    cset->registry);
++		    if (ascii != NULL)
++			cset->fs = ascii->fs;
++		}
++		
++		cset->loaded = 1;
++	    }
++	    return cset;
++	}
++    }
++    return NULL;
++}
++
++static void pack_string(cs, str, len)
++    struct charset *cs;
++    unsigned char *str;
++    int len;	/* number of chars(not bytes) */
++{
++    struct ml_text *mt = &context->text;
++    struct ml_line *lp;
++    XTextItem16 *ip;
++    
++    if (context->line == mt->maxlines) {
++	int oldmax = mt->maxlines;
++	if (mt->maxlines < 1)
++	    mt->maxlines = 1;
++	else
++	    mt->maxlines = 2 * mt->maxlines;
++	if (oldmax == 0)
++	    mt->lines = (struct ml_line *)
++				malloc(sizeof(struct ml_line) * mt->maxlines);
++	else {
++	    mt->lines = (struct ml_line *)
++				realloc(mt->lines,
++					sizeof(struct ml_line) * mt->maxlines);
++	}
++    }
++    lp = &mt->lines[context->line];
++    if (mt->nlines == context->line) {
++	mt->nlines++;
++	lp->maxitems = 0;
++	lp->nitems = 0;
++	lp->width = 0;
++	lp->ascent = lp->descent = 0;
++    }
++    
++    if (len == 0) {
++	switch (*str) {
++	case '\n':
++	    context->line++;
++	    context->delta = 0;
++	    context->toolong = 0;
++	    break;
++	case '\t':
++	    {
++		int nx, x = lp->width + context->delta;
++		nx = (x + ml_tab_width) / ml_tab_width * ml_tab_width;
++		context->delta += nx - x;
++	    }
++	    break;
++	}
++	return;
++    }
++    
++    if (context->toolong)
++	return;
++    if (lp->width > 30000) {
++	context->toolong = 1;
++	cs = ascii;
++	str = (unsigned char *) "...";
++	len = 3;
++    }
++    
++    if (lp->nitems == lp->maxitems) {
++	int oldmax = lp->maxitems;
++	if (lp->maxitems < 1)
++	    lp->maxitems = 1;
++	else
++	    lp->maxitems = 2 * lp->maxitems;
++	if (oldmax == 0)
++	    lp->items = (XTextItem16 *)
++				malloc(sizeof(XTextItem16) * lp->maxitems);
++	else
++	    lp->items = (XTextItem16 *)
++				realloc(lp->items,
++					sizeof(XTextItem16) * lp->maxitems);
++    }
++    ip = &lp->items[lp->nitems++];
++    ip->chars = (XChar2b *) context->cbp;
++    ip->nchars = len;
++    ip->delta = context->delta;
++    ip->font = cs->fs->fid;
++    context->cbp += 2 * len;
++    context->delta = 0;
++    
++    if (cs->bpc == 1) {
++	XChar2b *p;
++	unsigned char b7 = cs->bit7 ? 0x80 : 0;
++	int i;
++	for (i = len, p = ip->chars; i > 0; i--, p++) {
++	    p->byte1 = '\0';
++	    p->byte2 = (*str++ & 0x7f) | b7;
++	}
++    } else {
++	XChar2b *p;
++	unsigned char b7 = cs->bit7 ? 0x80 : 0;
++	int i;
++	for (i = len, p = ip->chars; i > 0; i--, p++) {
++	    p->byte1 = (*str++ & 0x7f) | b7;
++	    p->byte2 = (*str++ & 0x7f) | b7;
++	}
++    }
++    
++    lp->width += XTextWidth16(cs->fs, ip->chars, ip->nchars);
++    if (lp->ascent < cs->fs->ascent)
++	lp->ascent = cs->fs->ascent;
++    if (lp->descent < cs->fs->descent)
++	lp->descent = cs->fs->descent;
++}
++
++void get_monofont_size(wide, high)
++    int *wide, *high;
++{
++    if (ascii == NULL) {
++	fputs("ml_draw_text: call ml_set_charsets, first.\n", stderr);
++	return;
++    }
++    *wide = ascii->fs->max_bounds.width;
++    *high = ascii->fs->ascent + ascii->fs->descent;
++}
++
++static void init_xrm()
++{
++    init_xrm_fonts();
++    init_xrm_tab();
++}
++
++static void init_xrm_fonts()
++{
++    char *p, *fns = XGetDefault(theDisp, "xv", "fontSet");
++    int n;
++    if (fns == NULL) {
++	xrm_fonts = default_fonts;
++	xrm_nfonts = sizeof default_fonts / sizeof *default_fonts;
++	return;
++    }
++    while(*fns == ' ' || *fns == '\t')
++	fns++;
++    if (*fns == '\0') {
++	xrm_fonts = default_fonts;
++	xrm_nfonts = sizeof default_fonts / sizeof *default_fonts;
++	return;
++    }
++    fns = strdup(fns);
++    
++    n = 1;
++    for (p = fns; *p != '\0'; p++) {
++	if (*p == ',')
++	    n++;
++    }
++    xrm_nfonts = n;
++    xrm_fonts = (char **) malloc(sizeof (char *) * xrm_nfonts);
++    for (n = 0, p = fns; n < xrm_nfonts && *p != '\0'; ) {
++	while (*p == ' ' || *p == '\t')
++	    p++;
++	xrm_fonts[n++] = p;
++	while (1) {
++	    char *q;
++	    while (*p != ' ' && *p != '\t' && *p != ',' && *p != '\0')
++		p++;
++	    q = p;
++	    while (*q == ' ' || *q == '\t')
++		q++;
++	    if (*q == ',' || *q == '\0') {
++		*p = '\0';
++		p = q + 1;
++		break;
++	    } else
++		p = q;
++	}
++    }
++    for ( ; n < xrm_nfonts; n++)
++	xrm_fonts[n] = "";
++}
++
++static void init_xrm_tab()
++{
++    char *ts = XGetDefault(theDisp, "xv", "tabWidth");
++    unsigned short tab;
++    if (ts == NULL)
++	tab = 64;
++    else {
++	char *ep;
++	long t;
++	int bad = 0;
++	t = strtol(ts, &ep, 0);
++	tab = (unsigned short) t;
++	if (ep != NULL) {
++	    while (*ep == ' ' && *ep == '\t')
++		ep++;
++	    if (*ep != '\0')
++		bad = 1;
++	}
++	if (tab != (long) (unsigned long) t)
++	    bad = 1;
++	if (bad) {
++	    SetISTR(ISTR_WARNING, "bad tab width.");
++	    tab = 64;
++	}
++    }
++    ml_tab_width = tab;
++}
++
++
++#ifndef HAVE_STRDUP
++static char *strdup(str)
++    char *str;
++{
++    return strcpy(malloc(strlen(str) + 1), str);
++}
++#endif
++
++char *lookup_registry(d, b7)
++    struct design d;
++    int *b7;
++{
++    int i;
++    for (i = 0; i < NR_CHARSETS; i++) {
++	if (charset[i].bpc == d.bpc && charset[i].noc == d.noc &&
++	    charset[i].designator == d.des) {
++	    *b7 = charset[i].bit7;
++	    return charset[i].registry;
++	}
++    }
++    return NULL;
++}
++
++struct design lookup_design(registry, b7)
++    char *registry;
++    int b7;
++{
++    struct design d;
++    int i;
++    d.bpc = 0;
++    d.noc = 0;
++    d.des = '\0';
++    for (i = 0; i < NR_CHARSETS; i++) {
++	if (strcmp(charset[i].registry, registry) == 0 &&
++		charset[i].bit7 == b7) {
++	    d.bpc = charset[i].bpc;
++	    d.noc = charset[i].noc;
++	    d.des = charset[i].designator;
++	    break;
++	}
++    }
++    return d;
++}
++
++char *sjis_to_jis(orig, len, newlen)
++    char *orig;
++    int len, *newlen;
++{
++    unsigned char *new;
++    unsigned char *p, *q, *endp;
++    if (len == 0) {
++	*newlen = 0;
++	return (char *) malloc((size_t) 1);
++    }
++    new = (unsigned char *) malloc((size_t) len * 4);	/* enough big */
++    for (p = (unsigned char *) orig, endp = p + len, q = new; p < endp; ) {
++	if ((*p & 0x80) == 0)			/* 1 byte char */
++	    *q++ = *p++;
++	else if (*p >= 0x81 && *p <= 0x9f) {	/* kanji 1st byte */
++	    unsigned char c1 = *p++;
++	    unsigned char c2 = *p++;
++	    if (c2 < 0x40 || c2 > 0xfc) {		/* bad 2nd byte */
++		*q++ = CODE_SS2;
++		*q++ = c1;
++		*q++ = CODE_SS2;
++		*q++ = c2;
++	    } else {					/* right 2nd byte */
++		if (c2 <= 0x9e) {
++		    if (c2 > 0x7f)
++			c2--;
++		    c1 = (c1 - 0x81) * 2 + 1 + 0xa0;
++		    c2 = (c2 - 0x40)     + 1 + 0xa0;
++		} else {
++		    c1 = (c1 - 0x81) * 2 + 2 + 0xa0;
++		    c2 = (c2 - 0x9f)     + 1 + 0xa0;
++		}
++		*q++ = c1;
++		*q++ = c2;
++	    }
++	} else if (*p >= 0xe0 && *p <= 0xef) {	/* kanji 1st byte */
++	    unsigned char c1 = *p++;
++	    unsigned char c2 = *p++;
++	    if (c2 < 0x40 || c2 > 0xfc) {		/* bad 2nd byte */
++		*q++ = CODE_SS2;
++		*q++ = c1;
++		*q++ = CODE_SS2;
++		*q++ = c2;
++	    } else {					/* right 2nd byte */
++		if (c2 <= 0x9e) {
++		    c1 = (c1 - 0xe0) * 2 + 63 + 0xa0;
++		    c2 = (c2 - 0x40)     +  1 + 0xa0;
++		} else {
++		    c1 = (c1 - 0xe0) * 2 + 64 + 0xa0;
++		    c2 = (c2 - 0x9f)     +  1 + 0xa0;
++		}
++		*q++ = c1;
++		*q++ = c2;
++	    }
++	} else {				/* katakana or something */
++	    *q++ = CODE_SS2;
++	    *q++ = *p++;
++	}
++    }
++    *newlen = q - new;
++    
++    return (char *) realloc(new, (size_t) *newlen);
++}
++
++#endif /* TV_MULTILINGUAL */
+diff -urN xv-3.10a/xvml.h xv-3.10a-jp-extension-current/xvml.h
+--- xv-3.10a/xvml.h
++++ xv-3.10a-jp-extension-current/xvml.h	Mon Oct 14 15:01:47 1996
+@@ -0,0 +1,96 @@
++#ifndef MLVIEW_H
++#define MLVIEW_H
++
++/*
++ * What is this?
++ *
++ *  It is a package to show multi-lingual text.
++ * 
++ * How to use?
++ * 
++ *  1. Call ml_set_screen(Screen *scr);
++ *	Tell this package the screen you use.
++ *
++ *  2. Call ml_set_charsets(struct char_spec spec[4], int gl, int gr);
++ *	Tell this package the initial charsets.
++ *	Gn is set to the charset specified by spec[n], respectively.
++ *	GL and GR are set to G[gl] and G[gr], respectively.
++ *	If first call, iso8859-1 font is loaded.
++ *
++ *  3. Call ml_draw_text(char *string);
++ *	It Creates a bitmap, and returns it to you.
++ *	If something goes wrong, it returns None.
++ *	DON'T free the returned pixmaps!!
++ *
++ * BUGS:
++ *  - Amharic and Tigrigna characters are strange.
++ *  - Big5 is not supported.
++ *  - Reverse direction is not supported.
++ *  - Composing is not supported.
++ *  - Cantonese can't be shown.
++ *  - Texts which have many lines are buggy.
++ *
++ * NOTE:
++ *  - Shifted JIS and Shifted GB must be converted to iso2022 in advance.
++ *
++ * Example of parameters to ml_set_charsets:
++ *  - EUC-Japan
++ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
++ *		 {2, 94, 'B'},		G1 is JIS X0208
++ *		 {1, 94, 'J'},		G2 is (right-half of)JIS X0201
++ *		 {2, 94, 'D'} };	G3 is JIS X0212
++ *	gl = 0;				GL is G0
++ *	gr = 1;				GR is G1
++ *
++ *  - Compound Text
++ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
++ *		 {1, 96, 'A'},		G1 is Latin-1
++ *		 {1, 94, 'B'},		G2 is US-ASCII (maybe unused)
++ *		 {1, 94, 'B'} };	G3 is US-ASCII (maybe unused)
++ *	gl = 0;				GL is G0
++ *	gr = 1;				GR is G1
++ *
++ *  - Korean Mail
++ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
++ *		 {2, 94, 'C'},		G1 is KSC5601
++ *		 {1, 94, 'B'},		G2 is US-ASCII (maybe unused)
++ *		 {1, 94, 'B'} };	G3 is US-ASCII (maybe unused)
++ *	gl = 0;				GL is G0
++ *	gl = 1;				GR is G1
++ */
++
++struct coding_system {
++    struct design {
++	int bpc;	/* byte per char if 1 or 2,
++			   don't touch if 0, or
++			   don't use if -1.*/
++	int noc;	/* number of chars (94 or 96) */
++	char des;	/* designator ('A', 'B', ...) */
++    } design[4];
++    int gl, gr;
++    int eol;
++    int short_form;
++    int lock_shift;
++};
++
++struct ml_text {
++    int maxlines, nlines;
++    struct ml_line {
++	int maxitems, nitems;
++	int width, ascent, descent;
++	XTextItem16 *items;
++    } *lines;
++    int width, height;
++};
++
++struct context;
++struct ml_text *ml_draw_text		PARM((struct context *, char *, int));
++struct context *ml_create_context	PARM((Screen *));
++int ml_set_charsets			PARM((struct context *,
++					      struct coding_system *));
++void get_monofont_size			PARM((int *, int *));
++char *sjis_to_jis			PARM((char *, int, int *));
++char *lookup_registry			PARM((struct design, int *));
++struct design lookup_design		PARM((char *, int));
++
++#endif
+diff -urN xv-3.10a/xvpbm.c xv-3.10a-jp-extension-current/xvpbm.c
+--- xv-3.10a/xvpbm.c	Wed Jan  4 06:23:44 1995
++++ xv-3.10a-jp-extension-current/xvpbm.c	Wed Oct  9 20:36:24 1996
+@@ -38,10 +38,83 @@
+ 
+ static char *bname;
+ 
++
++#ifdef HAVE_MGCSFX
++/*
++ * When file read or file write is fail, probably it's caused by
++ * reading from pipe which has no data yet, or writing to pipe
++ * which is not ready yet.
++ * Then, we can use systemcall select to descriptor of pipe and wait.
++ * if you want, change 'undef' to 'define' in the following line.
++ * This feature is performance killer.
++ */
++#undef FIX_PIPE_ERROR
++
++#ifdef __osf__
++#ifdef __alpha
++#define FIX_PIPE_ERROR
++#endif /* __alpha */
++#endif /* __osf__ */
++
++#endif /* HAVE_MGCSFX */
++
++
++#ifdef FIX_PIPE_ERROR
++
++int pipefdr;
++
++struct timeval timeout;
++int    width;
++fd_set fds;
++
++static void ready_read()
++{
++  if(pipefdr < 0) return; /* if file descriptor is not pipe, OK */
++  WaitCursor();
++
++reselect:
++  /* setting of timeout */
++  timeout.tv_sec = 1;  /* 1 sec */
++  timeout.tv_usec = 0; /* 0 usec */
++
++  FD_ZERO(&fds);     /* clear bits */
++  FD_SET(pipefdr, &fds); /* set bit of fd in fds */
++
++  /* number of file descriptor to want check (0 $B!A(B width-1) */
++  width = pipefdr + 1;
++
++  /* select returns number of file descriptors */
++  if (select(width, &fds, NULL, NULL, &timeout) < 0){
++    if(DEBUG){
++      fprintf(stderr, "No file descriptors can't selected, waiting...\n");
++    }
++    goto reselect;
++  }
++
++  if (FD_ISSET(pipefdr, &fds)){
++    /* Now, descriptor of pipe is ready to read */
++    return;
++  }else{
++    if(DEBUG){
++      fprintf(stderr, "Can't read from pipe yet, waiting...\n");
++    }
++    goto reselect;
++  }
++
++}
++#endif /* FIX_PIPE_ERROR */
++
+ /*******************************************/
++#ifdef HAVE_MGCSFX
++int LoadPBM(fname, pinfo, fd)
++     char    *fname;
++     PICINFO *pinfo;
++     int      fd;
++#else
+ int LoadPBM(fname, pinfo)
+      char    *fname;
+      PICINFO *pinfo;
++#endif /* HAVE_MGCSFX */
+ /*******************************************/
+ {
+   /* returns '1' on success */
+@@ -50,6 +123,10 @@
+   int    c, c1;
+   int    maxv, rv;
+ 
++#ifdef FIX_PIPE_ERROR
++  pipefdr = fd;
++#endif /* FIX_PIPE_ERROR */
++
+   garbage = maxv = rv = 0;
+   bname = BaseName(fname);
+ 
+@@ -57,6 +134,22 @@
+   pinfo->comment = (char *) NULL;
+ 
+ 
++#ifdef HAVE_MGCSFX
++  if(fd < 0){
++    /* open the file */
++    fp = xv_fopen(fname,"r");
++    if (!fp) return (pbmError(bname, "can't open file"));
++
++    /* compute file length */
++    fseek(fp, 0L, 2);
++    filesize = ftell(fp);
++    fseek(fp, 0L, 0);
++  }else{
++    fp = fdopen(fd, "r");
++    if (!fp) return (pbmError(bname, "can't open file"));
++    filesize = 0; /* dummy */
++  }
++#else
+   /* open the file */
+   fp = xv_fopen(fname,"r");
+   if (!fp) return (pbmError(bname, "can't open file"));
+@@ -65,6 +158,7 @@
+   fseek(fp, 0L, 2);
+   filesize = ftell(fp);
+   fseek(fp, 0L, 0);
++#endif /* HAVE_MGCSFX */
+ 
+ 
+   /* read the first two bytes of the file to determine which format
+@@ -236,7 +330,20 @@
+       }
+     }
+     else {
++#ifdef FIX_PIPE_ERROR
++  reread:
++      numgot += fread(pic8 + numgot, (size_t) 1, (size_t) w*h - numgot, fp); /* read raw data */
++      if(errno == EINTR){
++        if(DEBUG){
++	  fprintf(stderr,
++	  "Can't read all data from pipe, call select and waiting...\n");
++	}
++	ready_read();
++	goto reread;
++      }
++#else
+       numgot = fread(pic8, (size_t) 1, (size_t) w*h, fp);  /* read raw data */
++#endif /* FIX_PIPE_ERROR */
+     }
+   }
+ 
+@@ -297,7 +404,20 @@
+       }
+     }
+     else {
++#ifdef FIX_PIPE_ERROR
++  reread:
++      numgot += fread(pic24 + numgot, (size_t) 1, (size_t) w*h*3 - numgot, fp);  /* read data */
++      if(errno == EINTR){
++        if(DEBUG){
++	  fprintf(stderr,
++	  "Can't read all data from pipe, call select and waiting...\n");
++	}
++	ready_read();
++	goto reread;
++      }
++#else
+       numgot = fread(pic24, (size_t) 1, (size_t) w*h*3, fp);  /* read data */
++#endif /* FIX_PIPE_ERROR */
+     }
+   }
+   
+diff -urN xv-3.10a/xvpcd.c xv-3.10a-jp-extension-current/xvpcd.c
+--- xv-3.10a/xvpcd.c
++++ xv-3.10a-jp-extension-current/xvpcd.c	Wed Oct  9 20:37:20 1996
+@@ -0,0 +1,1029 @@
++/*
++ * xvpcd.c - load routine for 'PhotoCD' format pictures
++ *
++ * LoadPCD(fname, pinfo, size)  -  loads a PhotoCD file
++ *
++ * This routine will popup a choice of which of the 5 available resolutions
++ * the user wants to choose, then load it as a 24 bit image.
++ *
++ * Copyright 1993 David Clunie, Melbourne, Australia.
++ *
++ * The outline of this is shamelessly derived from xvpbm.c to read the
++ * file, and xvtiffwr.c to handle the popup window and X stuff (X never
++ * has been my forte !), and the PhotoCD format information (though not
++ * the code) was found in Hadmut Danisch's (danisch@ira.uka.de) hpcdtoppm
++ * program in which he has reverse engineered the format by studying
++ * hex dumps of PhotoCDs ! After all who can afford the Kodak developer's
++ * kit, which none of us have seen yet ? Am I even allowed to mention these
++ * words (Kodak, PhotoCD) ? I presume they are registered trade marks.
++ *
++ * PS. I have no idea how Halmut worked out the YCC <-> RGB conversion
++ * factors, but I have calculated them from his tables and the results
++ * look good enough to me.
++ *
++ * Added size parameter to allow the schnautzer to create thumnails
++ * without requesting the size every time.
++ */
++
++#define trace (void)
++#define HAVE_PCD_DIALOG
++
++#include "xv.h"
++#include <memory.h>
++
++#ifdef HAVE_PCD
++
++/* comments on error handling:
++   a truncated file is not considered a Major Error.  The file is loaded, the
++   rest of the pic is filled with 0's.
++
++   not being able to malloc is a Fatal Error.  The program is aborted. */
++
++
++static void magnify                   PARM((int,int,int,int,int,byte*));
++static int pcdError                   PARM((char*,char*));
++static int gethuffdata                PARM((byte*,byte*,byte*,int,int));
++
++#define wcurfactor 16		/* Call WaitCursor() every n rows */
++
++static char *bname;
++
++static int size;                /* Set by window routines */
++
++static int leaveitup;		/* Cleared by docmd() when OK or CANCEL pressed */
++static int goforit;             /* Set to 1 if OK or 0 if CANCEL */
++
++static FILE  *fp;
++
++
++/*******************************************/
++int LoadPCD(fname, pinfo,theSize)
++     char    *fname;
++     PICINFO *pinfo;
++	 int	theSize;
++/* The size should be -1 for the popup to ask otherwise fast is assumed */
++/*******************************************/
++{
++  /* returns '1' on success */
++
++  int    rv;
++  long   offset;
++  int    mag;
++
++  byte *pic24, *luma, *chroma1, *chroma2, *ptr, *lptr, *c1ptr, *c2ptr;
++  int   w, h;
++  int   row, col;
++
++  int   huffplanes;
++
++  bname = BaseName(fname);
++
++  pinfo->pic     = (byte *) NULL;
++  pinfo->comment = (char *) NULL;
++
++
++  /* open the file */
++  fp=fopen(fname,"r");
++  if (!fp) return (pcdError(bname, "can't open file"));
++
++/* base/16
++	- plain data starts at sector 1+2+1=4
++	  (numbered from 0, ie. the 5th sector)
++	- luma 192*128 = 24576 bytes (12 sectors)
++	  + chroma1 96*64 = 6144 bytes (3 sectors)
++	  + chroma2 96*64 = 6144 bytes (3 sectors)
++	  = total 18 sectors
++
++	- NB. "Plain" data is interleaved - 2 luma rows 192 wide,
++	  then 1 of each of the chroma rows 96 wide !
++
++   base/4
++	- plain data starts at sector 1+2+1+18+1=23
++	- luma 384*256 = 98304 bytes (48 sectors)
++	  + chroma1 192*128 = 24576 bytes (12 sectors)
++	  + chroma2 192*128 = 24576 bytes (12 sectors)
++	  = total 72 sectors
++
++	- NB. "Plain" data is interleaved - 2 luma rows 384 wide,
++	  then 1 of each of the chroma rows 192 wide !
++
++   base
++	- plain data starts at sector 1+2+1+18+1+72+1=96
++
++	- luma 768*512 = 393216 bytes (192 sectors)
++	  + chroma1 384*256 = 98304 bytes (48 sectors)
++	  + chroma2 384*256 = 98304 bytes (48 sectors)
++	  = total 288 sectors
++
++	- NB. "Plain" data is interleaved - 2 luma rows 768 wide,
++	  then 1 of each of the chroma rows 384 wide !
++
++   4base
++	- plain data for base is read
++	- luma data interpolated *2
++	- chroma data interpolated *4
++
++	- cd_offset is 1+2+1+18+1+72+1+288=384
++	- at cd_offset+4 (388) is huffman table
++	- at cd_offset+5 (389) is 4base luma plane
++
++	(the sector at cd_offset+3 seems to contain 256 words each of
++	which is an offset presumably to the sector containing certain
++	rows ? rows/4 given 1024 possible rows. The rest of this sector
++	is filled with zeroes)
++
++
++   16base
++	- plain data for base is read
++	- luma data interpolated *2
++	- chroma data interpolated *4
++
++	- cd_offset is 1+2+1+18+1+72+1+288=384
++	- at cd_offset+4 (388) is huffman table for 4 base
++	- at cd_offset+5 (389) is 4base luma plane
++	- luma plane interpolated *2
++
++	- cd_offset is set to current position (should be start of sector)
++	- at cd_offset+12 is huffman table for 16 base
++	- at cd_offset+14 is 16 base luma & 2 chroma planes which are read
++          (note that the luma plane comes first, with a sync pattern
++           announcing each row from 0 to 2047, then the two chroma planes
++           are interleaved by row, the row # being even from 0 to 2046, with
++           each row containing 1536 values, the chroma1 row coming first,
++           finally followed by a sync pattern with a row of 2048 announcing
++           the end (its plane seems to be set to 3, ie. chroma2)
++	- chroma planes interpolated *2
++
++	(the sector at cd_offset+10 & 11 seem to contain 1024 pairs of words
++        the first for luma and the second for chroma, each of
++	which is an offset presumably to the sector containing certain
++	rows ? rows/2 given 2048 possible rows)
++
++Not yet implemented:
++
++In order to do overskip for base and 4base, one has to reach the chroma
++data for 16 base:
++
++	- for 4base, after reading the 4base luma plane (and presumably
++	  skipping the chroma planes) one sets cd_offset to the start of
++	  the "current" sector
++
++	- for base, one has to skip the 4base data first:
++	- cd_offset is set to 384
++	- at (cd_offset+3 sectors)[510] is a 16 bit word high byte 1st
++	  containing an offset to the beginning of the 16base stuff
++	  though there is then a loop until >30 0xff's start a sector !
++
++	- being now positioned after the end of the 4base stuff,
++	- at (cd_offset+10 sectors)[2] is a 16 bit word high byte 1st
++	  containing an offset to the chroma planes.
++	- at cd_offset+12 is the set of huffman tables
++
++	- for base, the 16base chroma planes are then halved
++*/
++
++#ifdef HAVE_PCD_DIALOG
++    PCDSetParamOptions(bname);
++	if (theSize == -1)
++	{
++    	PCDDialog(1);                   /* Open PCD Dialog box */
++    	SetCursors(-1);                 /* Somebody has already set it to wait :( */
++    	leaveitup=1;
++    	goforit=0;
++    	/* block until the popup window gets closed */
++    	while (leaveitup) {
++      	int i;
++      	XEvent event;
++      	XNextEvent(theDisp, &event);
++      	HandleEvent(&event, &i);
++    	}
++    	/* At this point goforit and size will have been set */
++    	if (!goforit) {
++      		/* nothing allocated so nothing needs freeing */
++      		return 0;
++    	}
++    	WaitCursor();
++	}
++	else 
++	{
++		size = theSize;
++		goforit = 1;
++	}
++#else /* HAVE_PCD_DIALOG */
++  {
++    static char *sizeoptions[3] = { "0192*128", "1384*256","2768*512" };
++    size=PopUp("Which of the stored resolutions would you like ?",sizeoptions,3);
++  }
++#endif /* HAVE_PCD_DIALOG */
++
++  switch (size) {
++  case 0:
++    pinfo->w=192;
++    pinfo->h=128;
++    offset=4*0x800;
++    mag=1;
++    huffplanes=0;
++    sprintf(pinfo->fullInfo, "PhotoCD, base/16 resolution");
++    break;
++  case 1:
++    pinfo->w=384;
++    pinfo->h=256;
++    offset=23*0x800;
++    mag=1;
++    huffplanes=0;
++    sprintf(pinfo->fullInfo, "PhotoCD, base/4 resolution");
++    break;
++  case 2:
++  default:
++    pinfo->w=768;
++    pinfo->h=512;
++    offset=96*0x800;
++    mag=1;
++    huffplanes=0;
++    sprintf(pinfo->fullInfo, "PhotoCD, base resolution");
++    break;
++  case 3:
++    pinfo->w=1536;
++    pinfo->h=1024;
++    offset=96*0x800;
++    mag=2;
++    huffplanes=1;
++    sprintf(pinfo->fullInfo, "PhotoCD, 4base resolution");
++    break;
++  case 4:
++    pinfo->w=3072;
++    pinfo->h=2048;
++    offset=96*0x800;
++    mag=4;
++    huffplanes=2;
++    sprintf(pinfo->fullInfo, "PhotoCD, 16base resolution");
++    break;
++  }
++
++  /* allocate 24-bit image */
++  pinfo->pic = (byte *) calloc(pinfo->w*pinfo->h*3,1);
++  if (!pinfo->pic) FatalError("couldn't malloc '24 bit rgb plane'");
++
++  pinfo->type = PIC24;
++  sprintf(pinfo->shrtInfo, "%dx%d PhotoCD.", pinfo->w, pinfo->h);
++  pinfo->colType = F_FULLCOLOR;
++  pinfo->frmType = -1;
++
++  if (fseek(fp,offset,0) == -1)
++    return pcdError(bname,"Can't find start of data.");
++
++  w = pinfo->w;  h = pinfo->h;
++  pic24 = pinfo->pic;
++
++  luma=(byte *) calloc(w*h,1);
++  if (!luma) FatalError("couldn't malloc 'luma plane'");
++  chroma1=(byte *) calloc(w*h/4,1);
++  if (!chroma1) FatalError("couldn't malloc 'chroma1 plane'");
++  chroma2=(byte *) calloc(w*h/4,1);
++  if (!chroma2) FatalError("couldn't malloc 'chroma2 plane'");
++
++  /* Read 2 luma rows length w, then one of each chroma rows w/2 */
++  /* If a mag factor is active, the small image is read into the */
++  /* top right hand corner of the larger allocated image */
++
++  for (row=0,lptr=luma,c1ptr=chroma1,c2ptr=chroma2; row <h/mag;
++       row+=2,lptr+=w*2,c1ptr+=w/2,c2ptr+=w/2) {
++    if (fread(lptr, 1, w/mag, fp) != w/mag) {
++      pcdError(bname,"Luma plane too short.");
++      break;
++    }
++    if (fread(lptr+w, 1, w/mag, fp) != w/mag) {
++      pcdError(bname,"Luma plane too short.");
++      break;
++    }
++    if (fread(c1ptr, 1, w/2/mag, fp) != w/2/mag) {
++      pcdError(bname,"Chroma1 plane too short.");
++      break;
++    }
++    if (fread(c2ptr, 1, w/2/mag, fp) != w/2/mag) {
++      pcdError(bname,"Chroma2 plane too short.");
++      break;
++    }
++    if (row%wcurfactor == 0) WaitCursor();
++  }
++
++  if (huffplanes) {
++    if (fseek(fp,388*0x800,0) == -1) {
++      return pcdError(bname,"Can't find start of huffman tables.");
++    }
++    magnify(2,h/mag,w/mag,h,w,luma);
++    magnify(2,h/2/mag,w/2/mag,h/2,w/2,chroma1);
++    magnify(2,h/2/mag,w/2/mag,h/2,w/2,chroma2);
++
++    /* doesn't really touch the chroma planes which aren't present in 4base */
++    gethuffdata(luma,chroma1,chroma2,w,h/mag*2);
++    /* if only doing 4base should probably fetch 16bases chroma planes here */
++
++    if (huffplanes == 2) {
++      /* This depends on gethuffdata() having grabbed things in 0x800 sectors */
++      /* AND still being positioned in the "last" sector of the data */
++      /* (cf. Hadmut's code which is positioned at start of the next sector) */
++      long offset=ftell(fp)/0x800+13;
++      trace(stderr,"New offset=%ld\n",(long)offset);
++      if (fseek(fp,offset*0x800,0) == -1) {
++        return pcdError(bname,"Can't find start of huffman tables.");
++      }
++      magnify(2,h/2,w/2,h,w,luma);
++      magnify(2,h/4,w/4,h/2,w/2,chroma1);
++      magnify(2,h/4,w/4,h/2,w/2,chroma2);
++
++      gethuffdata(luma,chroma1,chroma2,w,h);
++    }
++  }
++
++  ptr=pic24; lptr=luma; c1ptr=chroma1; c2ptr=chroma2;
++  for (row=0; row < h; row++) {
++    byte *rowc1ptr, *rowc2ptr;
++    rowc1ptr=c1ptr;
++    rowc2ptr=c2ptr;
++    for (col=0; col < w; col++) {
++      int r,g,b;
++      int y =*lptr++;
++      int c1=*c1ptr;
++      int c2=*c2ptr;
++
++      r = (5564 * y + 2048 + 7461 * c2 - 1022138)/4096;
++      g = (5564 * y + 2048 + 274934 - 1762 * c1 + 520268 - 3798 * c2)/4096; 
++      b = (5564 * y + 2048 + 9085 * c1 - 1417185)/4096;
++
++      if (r > 255) r=255;
++      if (r < 0 ) r=0;
++      if (g > 255) g=255;
++      if (g < 0 ) g=0;
++      if (b > 255) b=255;
++      if (b < 0 ) b=0;
++
++      *ptr++=r;
++      *ptr++=g;
++      *ptr++=b;
++      if (col%2) { ++c1ptr; ++c2ptr; }
++    }
++    if (row%2 == 0) { c1ptr=rowc1ptr; c2ptr=rowc2ptr; }
++    if (row%wcurfactor == 0) WaitCursor();
++  }
++
++  free(luma); free(chroma1); free(chroma2);
++
++  rv = 1;
++
++  fclose(fp);
++
++  if (!rv) {
++    if (pinfo->pic) free(pinfo->comment);
++    if (pinfo->comment) free(pinfo->comment);
++    pinfo->pic     = (byte *) NULL;
++    pinfo->comment = (char *) NULL;
++  }
++
++  return rv;
++}  
++
++
++/*******************************************/
++
++/* derived from Hadmut Danisch's interpolate() */
++
++static void
++magnify(mag,h,w,mh,mw,p)
++int mag;	/* power of 2 by which to magnify in place */
++int h,w;	/* the "start" unmag'd dimensions of the data in the array */
++int mh,mw;	/* the real (maximum) dimensions of the array */
++unsigned char *p;	/* pointer to the data */
++{
++  int x,y,yi;
++  unsigned char *optr,*nptr,*uptr;  /* MUST be unsigned, else averaging fails */
++
++  while (mag > 1) {
++
++    /* create every 2nd new row from 0 */
++    /*  even pixels being equal to the old, odd ones averaged with successor */
++    /*  special case being the last column which is just set equal to the */
++    /*  second last) ... */
++
++    for(y=0;y<h;y++) {
++      yi=h-1-y;
++      optr=p+  yi*mw + (w-1);	          /* last pixel of an old row */
++      nptr=p+2*yi*mw + (2*w - 2);         /* last pixel of a new row */
++
++      nptr[0]=nptr[1]=optr[0];            /* special cases */
++
++      for(x=1;x<w;x++) {
++        optr--; nptr-=2;                  /* next lower pixel(s) */
++        nptr[0]=optr[0];                  /* even pixels duped */
++        nptr[1]=(((int)optr[0])+
++                 ((int)optr[1])+1)>>1;    /* odd averaged */
++      }
++    }
++
++    /* Fill in odd rows, as average of prior & succeeding rows, with */
++    /* even pixels average of one column, odd pixels average of two */
++
++    for(y=0;y<h-1;y++) {                  /* all but the last old row */
++      optr=p + 2*y*mw;                    /* start of the new "even" rows */
++      nptr=optr+mw;                       /* start of the next empty row */
++      uptr=nptr+mw;                       /* start of the next again (even) */
++
++      for(x=0;x<w-1;x++) {                /* for all cols except the last */
++        nptr[0]=(((int)optr[0])+
++                 ((int)uptr[0])+1)>>1;    /* even pixels */
++        nptr[1]=(((int)optr[0])+
++                 ((int)optr[2])+
++                 ((int)uptr[0])+
++                 ((int)uptr[2])+2)>>2;    /* odd pixels */
++        nptr+=2; optr+=2; uptr+=2;
++      }
++      *(nptr++)=(((int)*(optr++))+
++                 ((int)*(uptr++))+1)>>1;  /* 2nd last pixel */
++      *(nptr++)=(((int)*(optr++))+
++                 ((int)*(uptr++))+1)>>1;  /* last pixel */
++    }
++
++    xvbcopy((char *) (p + (2*h-2)*mw),    /* 2nd last row */
++            (char *) (p + (2*h-1)*mw),    /* the last row */
++            (size_t) (2*w));              /* length of a new row */
++
++    h*=2; w*=2;
++    mag>>=1;	/* Obviously mag must be a power of 2 ! */
++  }
++}
++
++
++/*******************************************/
++static int pcdError(fname, st)
++     char *fname, *st;
++{
++  SetISTR(ISTR_WARNING, "%s:  %s", fname, st);
++  return 0;
++}
++
++
++/**** Stuff for PCDDialog box ****/
++
++#define TWIDE 380
++#define THIGH 160
++#define T_NBUTTS 2
++#define T_BOK    0
++#define T_BCANC  1
++#define BUTTH    24
++
++static void drawTD                    PARM((int,int,int,int));
++static void clickTD                   PARM((int,int));
++static void doCmd                     PARM((int));
++static void PCDSetParams              PARM((void));
++
++
++/* local variables */
++static BUTT  tbut[T_NBUTTS];
++static RBUTT *resnRB;
++
++
++
++/***************************************************/
++void CreatePCDW()
++{
++  int	     y;
++
++  pcdW = CreateWindow("xv pcd", "XVpcd", NULL, 
++		       TWIDE, THIGH, infofg, infobg, 0);
++  if (!pcdW) FatalError("can't create pcd window!");
++
++  XSelectInput(theDisp, pcdW, ExposureMask | ButtonPressMask | KeyPressMask);
++
++  BTCreate(&tbut[T_BOK], pcdW, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH, 
++	   "Ok", infofg, infobg, hicol, locol);
++
++  BTCreate(&tbut[T_BCANC], pcdW, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH, 
++	   "Cancel", infofg, infobg, hicol, locol);
++
++  y = 55;
++  resnRB = RBCreate(NULL, pcdW, 36, y,   "192*128   Base/16",
++           infofg, infobg,hicol,locol);
++  RBCreate(resnRB, pcdW, 36, y+18,       "384*256   Base/4",
++           infofg, infobg,hicol,locol);
++  RBCreate(resnRB, pcdW, 36, y+36,       "768*512   Base",
++           infofg, infobg, hicol, locol);
++  RBCreate(resnRB, pcdW, TWIDE/2, y,     "1536*1024 4Base",
++           infofg, infobg, hicol, locol);
++  RBCreate(resnRB, pcdW, TWIDE/2, y+18,  "3072*2048 16Base",
++           infofg, infobg, hicol, locol);
++#ifdef CRAP
++  RBCreate(resnRB, pcdW, TWIDE/2, y+36,  "Other",
++           infofg, infobg, hicol, locol);
++#endif
++
++  XMapSubwindows(theDisp, pcdW);
++}
++  
++
++/***************************************************/
++void PCDDialog(vis)
++int vis;
++{
++  if (vis) {
++    CenterMapWindow(pcdW, tbut[T_BOK].x + tbut[T_BOK].w/2,
++		    tbut[T_BOK].y + tbut[T_BOK].h/2, TWIDE, THIGH);
++  }
++  else     XUnmapWindow(theDisp, pcdW);
++  pcdUp = vis;
++}
++
++
++/***************************************************/
++int PCDCheckEvent(xev)
++XEvent *xev;
++{
++  /* check event to see if it's for one of our subwindows.  If it is,
++     deal accordingly, and return '1'.  Otherwise, return '0' */
++
++  int rv;
++  rv = 1;
++
++  if (!pcdUp) return 0;
++
++  if (xev->type == Expose) {
++    int x,y,w,h;
++    XExposeEvent *e = (XExposeEvent *) xev;
++    x = e->x;  y = e->y;  w = e->width;  h = e->height;
++
++    if (e->window == pcdW)       drawTD(x, y, w, h);
++    else rv = 0;
++  }
++
++  else if (xev->type == ButtonPress) {
++    XButtonEvent *e = (XButtonEvent *) xev;
++    int x,y;
++    x = e->x;  y = e->y;
++
++    if (e->button == Button1) {
++      if      (e->window == pcdW)     clickTD(x,y);
++      else rv = 0;
++    }  /* button1 */
++    else rv = 0;
++  }  /* button press */
++
++
++  else if (xev->type == KeyPress) {
++    XKeyEvent *e = (XKeyEvent *) xev;
++    char buf[128];  KeySym ks;  XComposeStatus status;  
++    int stlen;
++	
++    stlen = XLookupString(e,buf,128,&ks,&status);
++    buf[stlen] = '\0';
++
++    if (e->window == pcdW) {
++      if (stlen) {
++	if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
++	  FakeButtonPress(&tbut[T_BOK]);
++	}
++	else if (buf[0] == '\033') {            /* ESC */
++	  FakeButtonPress(&tbut[T_BCANC]);
++	}
++      }
++    }
++    else rv = 0;
++  }
++  else rv = 0;
++
++  if (rv==0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
++    XBell(theDisp, 50);
++    rv = 1;   /* eat it */
++  }
++
++  return rv;
++}
++
++
++/***************************************************/
++void PCDSetParamOptions(fname)
++char *fname;
++{
++  int cur;
++  cur = RBWhich(resnRB);
++
++  RBSetActive(resnRB,0,1);
++  RBSetActive(resnRB,1,1);
++  RBSetActive(resnRB,2,1);
++  RBSetActive(resnRB,3,1);
++  RBSetActive(resnRB,4,1);
++  RBSetActive(resnRB,5,0);
++}
++
++
++/***************************************************/
++static void drawTD(x,y,w,h)
++int x,y,w,h;
++{
++  char *title  = "Load PhotoCD file...";
++  int  i;
++  XRectangle xr;
++
++  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
++  XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
++
++  XSetForeground(theDisp, theGC, infofg);
++  XSetBackground(theDisp, theGC, infobg);
++
++  for (i=0; i<T_NBUTTS; i++) BTRedraw(&tbut[i]);
++
++  ULineString(pcdW, resnRB->x-16, resnRB->y-10-DESCENT, "Resolution");
++  RBRedraw(resnRB, -1);
++
++  DrawString(pcdW, 20, 19, title);
++
++  XSetClipMask(theDisp, theGC, None);
++}
++
++
++/***************************************************/
++static void clickTD(x,y)
++int x,y;
++{
++  int i;
++  BUTT *bp;
++
++  /* check BUTTs */
++
++  /* check the RBUTTS first, since they don't DO anything */
++  if ( (i=RBClick(resnRB, x,y)) >= 0) { 
++    (void) RBTrack(resnRB, i);
++    return;
++  }
++
++
++  for (i=0; i<T_NBUTTS; i++) {
++    bp = &tbut[i];
++    if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
++  }
++
++  if (i<T_NBUTTS) {  /* found one */
++    if (BTTrack(bp)) doCmd(i);
++  }
++}
++
++
++
++/***************************************************/
++static void doCmd(cmd)
++int cmd;
++{
++  leaveitup=0;
++  goforit=0;
++  switch (cmd) {
++  case T_BOK:  	PCDSetParams();
++                goforit=1;
++  case T_BCANC:	PCDDialog(0);
++                break;
++
++  default:	break;
++  }
++}
++
++
++/*******************************************/
++static void PCDSetParams()
++{
++  switch (RBWhich(resnRB)) {
++  case 0: size = 0;      break;
++  case 1: size = 1;      break;
++  case 2: size = 2;      break;
++  case 3: size = 3;      break;
++  case 4: size = 4;      break;
++  case 5: size = 0;      break;
++  default: size = 0;     break;
++  }
++}
++
++typedef char schar;  /* signed char */
++
++typedef int ihufftab;  /* Must be signed */
++
++static ihufftab *hufftable[3];
++static int hufflength[3];
++
++/*
++
++Read the Huffman tables which consist of an unsigned byte # of entries
++(less 1) followed by up to 256 entries, each of which is a series of 4
++unsigned bytes - length, highseq, lowseq, and key.
++
++Store the huffman table into tree type structure:
++
++	int ihufftab[n of entries*2]
++
++Each entry consists of two words (the 1st for zero and the 2nd for one).
++
++If the word is negative, then subtract it from the current pointer to
++get the next entry (ie. it is the negative offset from the current
++position*2 in order to skip entries not words) with which to make a decision.
++
++If the word is not negative, then the low 8 bits contain the value (which
++is supposed to be a signed char) and the rest of the word is zero.
++
++*/
++
++static ihufftab *
++gethufftable(alength)
++int *alength;
++{
++  unsigned num,i,offset;
++
++  ihufftab *hufftab,*huffptr,*hufftop;
++
++  num=fgetc(fp)+1;
++
++  trace(stderr,"gethufftable: hufftab length %u\n",num);
++
++  if ((hufftab=(ihufftab *)malloc(2*num*sizeof(ihufftab))) == 0) {
++    fprintf(stderr,"Can't allocate hufftab length %u\n",num);
++    exit(1);
++  }
++  for (i=0,huffptr=hufftab; i<2*num; i++)
++    *huffptr++=0;  /* Fill value is zero */
++
++  hufftop=hufftab;
++
++  for (i=0,offset=1; i<num; i++,offset+=4){
++    unsigned length=fgetc(fp);
++    unsigned msbseq=fgetc(fp);
++    unsigned lsbseq=fgetc(fp);
++    unsigned codeword=msbseq<<8|lsbseq;
++    unsigned value =fgetc(fp);
++    {
++      unsigned j;
++      huffptr=hufftab;
++      for (j=0; j<16; j++) {
++        int bit=codeword & 0x8000;
++        codeword<<=1;
++
++        if (j == length) {
++          if (bit) *++huffptr=value;
++          else *huffptr=value;
++        }
++        else {
++          if (j < length) {
++            if (bit) {
++              ++huffptr;
++            }
++            if (*huffptr >= 0) {
++              hufftop+=2;
++              if (hufftop-hufftab >2*num) {
++                fprintf(stderr,"Table overflow\n");
++                exit(1);
++              }
++              *huffptr=-(hufftop-huffptr);
++            }
++            huffptr-=*huffptr;
++          }
++        }
++      }
++    }
++  }
++
++  *alength=num;
++  return hufftab;
++}
++
++/* WORDTYPE & char buffer must be unsigned else */
++/* fills with sign bit not 0 on right shifts */
++typedef unsigned int WORDTYPE;
++typedef int SWORDTYPE;
++#define WORDSIZE sizeof(WORDTYPE)
++#define NBYTESINBUF 0x800
++
++static unsigned char buffer[NBYTESINBUF];
++static int bitsleft=0;
++static int bytesleft=0;
++static unsigned char *bufptr;
++static WORDTYPE word;
++
++/* assume WORDTYPE is 32 bit word */
++#define issync()  ((word & 0xffffff00) == 0xfffffe00)
++#define skiptosync()  { while (!issync()) (void)getbit(); }
++
++static void
++dumpbuffer()
++{
++  int i,left;
++  unsigned char *ptr=buffer;
++
++  fprintf(stderr,"dumpbuffer: bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++  for (left=NBYTESINBUF; left>0; left-=16) {
++    fprintf(stderr,"%05d  ",left);
++    for (i=0; i<8; i++) {
++      fprintf(stderr,"%02x",*ptr++);
++      fprintf(stderr,"%02x ",*ptr++);
++    }
++    fprintf(stderr,"\n");
++  }
++}
++
++static void
++loadbuffer()
++{
++  trace(stderr,"loadbuffer: start at sector %ld\n",(long)ftell(fp)/0x800
++);
++  if ((bytesleft=fread(buffer,1,NBYTESINBUF,fp)) == 0) {
++    fprintf(stderr,"Truncation error\n");
++    exit(1);
++  }
++  bufptr=buffer;
++  trace(stderr,"loadbuffer: Loaded buffer with %d bytes\n",bytesleft);
++  /* dumpbuffer(); */
++}
++
++static void
++loadbyte()
++{
++  trace(stderr,"loadbyte: start bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++  if (bytesleft <= 0) loadbuffer();
++  --bytesleft;
++  word|=(WORDTYPE)(*bufptr++)<<(sizeof(WORDTYPE)*8-8-bitsleft);
++  bitsleft+=8;
++  trace(stderr,"loadbyte: done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++}
++
++static int
++getbit()
++{
++  int bit;
++
++  trace(stderr,"getbit:   start bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++
++  while (bitsleft <= 0) loadbyte();
++  --bitsleft;
++  bit=(SWORDTYPE)(word)<0;  /* assumes word is signed */
++  /* bit=word>>(sizeof(WORDTYPE)*8-1); */
++  word<<=1;
++
++  trace(stderr,"getbit:   done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++  trace(stderr,"getbit:   done  bit=%d\n",bit);
++
++  return bit;
++}
++
++static WORDTYPE
++getnn(nn)
++int nn;
++{
++  WORDTYPE value;
++
++  trace(stderr,"getnn:    start nn=%d\n",nn);
++  trace(stderr,"getnn:    start bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++
++  while (bitsleft <= nn) loadbyte();
++  bitsleft-=nn;
++  value=word>>(sizeof(WORDTYPE)*8-nn);
++  word<<=nn;
++
++  trace(stderr,"getnn:    done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++  trace(stderr,"getnn:    done  value=0x%08lx\n",(unsigned long)value);
++
++  return value;
++}
++
++static WORDTYPE
++isnn(nn)
++int nn;
++{
++  WORDTYPE value;
++
++  trace(stderr,"isnn:     start nn=%d\n",nn);
++  trace(stderr,"isnn:     start bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++
++  while (bitsleft <= nn) loadbyte();
++  value=word>>(sizeof(WORDTYPE)*8-nn);
++
++  trace(stderr,"isnn:     done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++  trace(stderr,"isnn:     done  value=0x%08lx\n",(unsigned long)value);
++
++  return value;
++}
++
++static void
++skipnn(nn)
++int nn;
++{
++  trace(stderr,"skipnn:   start nn=%d\n",nn);
++  trace(stderr,"skipnn:   start bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++
++  while (bitsleft <= nn) loadbyte();
++  bitsleft-=nn;
++  word<<=nn;
++
++  trace(stderr,"skipnn:   done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
++    bytesleft,bitsleft,(unsigned long)word);
++}
++
++#define get1()    (getbit())
++#define get2()    (getnn(2))
++#define get8()    (getnn(8))
++#define get13()    (getnn(13))
++#define get16()    (getnn(16))
++#define get24()    (getnn(24))
++
++#define is8()    (isnn(8))
++#define is16()    (isnn(16))
++#define is24()    (isnn(24))
++
++#define skip1()    (skipnn(1))
++#define skip8()    (skipnn(8))
++#define skip16()  (skipnn(16))
++#define skip24()  (skipnn(24))
++
++static int
++gethuffdata(luma,chroma1,chroma2,realrowwidth,maxrownumber)
++byte *luma, *chroma1, *chroma2;
++int realrowwidth;
++int maxrownumber;
++{
++    int row,plane,charcount;
++    int i;
++
++    trace(stderr,"gethuffdata: start\n");
++
++    /* should really only look for luma plane for 4base, but the */
++    /* there are zeroes in the rest of the sector that give both */
++    /* chroma tables 0 length */
++
++    for (i=0; i<3; i++) hufftable[i]=gethufftable(&hufflength[i]);
++
++    while (is24() != 0xfffffe) {
++      (void)get24();
++      trace(stderr,"Skipping for sync\n");
++    }
++    for (;;) {
++      ihufftab *huffstart;
++      schar    *pixelptr;
++
++      if (is24() == 0xfffffe) {
++        skip24();
++        trace(stderr,"Charcount=%d\n",charcount);
++        charcount=0;
++        plane=get2();
++        row=get13();
++        skip1();
++        trace(stderr,"Plane %d Row %d\n",plane,row);
++        if (row>=maxrownumber) {
++          trace(stderr,"Stopping at row %d\n",row);
++          break;
++        }
++        switch (plane) {
++          case 0:    huffstart=hufftable[0];
++                     pixelptr=(schar *) (luma+row*realrowwidth);
++                     trace(stderr,"Setting luma plane\n");
++                     break;
++          case 2:    huffstart=hufftable[1];
++                     pixelptr=(schar *) (chroma1+row/2*realrowwidth/2);
++                     trace(stderr,"Setting chroma1 plane\n");
++                     break;
++          case 3:    huffstart=hufftable[2];
++                     pixelptr=(schar *) (chroma2+row/2*realrowwidth/2);
++                     trace(stderr,"Setting chroma2 plane\n");
++                     break;
++          default:   fprintf(stderr,"Bad plane %d\n",plane);
++                     exit(1);
++        }
++        WaitCursor();
++      }
++      else {
++        ihufftab *huffptr=huffstart;
++        for (;;) {
++          int bit;
++          bit=get1();    /* never fails :) */
++          huffptr+=bit;    /* select entry 0 or entry 1 */
++          if (*huffptr < 0) {  /* flag to choose next entry */
++            huffptr-=*huffptr;
++          }
++          else {      /* found the value for the code */
++            schar value = *huffptr;
++            (*(pixelptr+charcount))+=value;  /* in lower 8 bits */
++            /* probably don't need to mask with 0xff */
++            ++charcount;
++            trace(stderr,"[%d]=%d\n",charcount,(int)value);
++            break;
++          }
++        }
++      }
++    }
++    trace(stderr,"Out ... \n");
++
++    for (i=0; i<3; i++) if (hufftable[i]) free(hufftable[i]);
++
++    return 1;
++}
++#endif /* HAVE_PCD */
+diff -urN xv-3.10a/xvpi.c xv-3.10a-jp-extension-current/xvpi.c
+--- xv-3.10a/xvpi.c
++++ xv-3.10a-jp-extension-current/xvpi.c	Wed Oct  9 20:37:20 1996
+@@ -0,0 +1,1060 @@
++/*
++ * xvpi.c - load routine for `Pi' format pictures.
++ *
++ * The `Pi' format is made by Yanagisawa.
++ * It is common among many Japanese personal computer users.
++ * 
++ */
++
++#include "xv.h"
++#include <setjmp.h>
++
++#ifdef HAVE_PI
++
++typedef unsigned short data16;
++typedef unsigned int data32;
++
++struct pi_info {
++    jmp_buf jmp;
++    FILE *fp;
++    struct {
++	int rest;
++	byte cur;
++    }bs;
++    long fsize;
++    byte mode;
++    int width, height;
++    float aspect;
++    int cbits;
++    int numcols;
++    byte *cmap;
++    struct ct_t{
++	struct elt_t *top;
++	struct elt_t{
++	    struct elt_t *old, *recent;
++	    byte val;
++	} *elt;
++    }*ct;
++    int defcmap;
++    int writing_grey;
++};
++
++static void pi_open_file         PARM((struct pi_info*, char*));
++static void pi_read_header       PARM((struct pi_info*, char**));
++static void pi_check_id          PARM((struct pi_info*));
++static void pi_read_comment      PARM((struct pi_info*, char**));
++static void pi_read_palette      PARM((struct pi_info*));
++static void pi_expand            PARM((struct pi_info*, byte**));
++static byte pi_read_color        PARM((struct pi_info*, int));
++static int pi_read_position      PARM((struct pi_info*));
++static data32 pi_read_length     PARM((struct pi_info*));
++static int pi_copy_pixels        PARM((struct pi_info*,
++				     byte*, int, int, data32));
++
++static void pi_write_header      PARM((struct pi_info*,
++				       char*, byte*, byte*, byte*));
++static void pi_write_id          PARM((struct pi_info*));
++static void pi_write_comment     PARM((struct pi_info*, char*));
++static void pi_write_palette     PARM((struct pi_info*, byte*, byte*, byte*));
++static void pi_compress          PARM((struct pi_info*, byte*));
++static void pi_write_gabage      PARM((struct pi_info*));
++static void pi_write_color       PARM((struct pi_info*, int, int));
++static int pi_test_matching      PARM((struct pi_info*,
++				       byte*, int, int, data32*));
++static void pi_write_position    PARM((struct pi_info*, int));
++static void pi_write_length      PARM((struct pi_info*, data32));
++
++static void pi_table_create      PARM((struct pi_info*));
++static byte pi_table_get_value   PARM((struct pi_info*, int, int));
++static int pi_table_lookup_value PARM((struct pi_info*, int, int));
++static data32 pi_read_bits       PARM((struct pi_info*, int));
++static void pi_write_bits        PARM((struct pi_info*, data32, int));
++static void pi_init_pi_info      PARM((struct pi_info*));
++static void pi_cleanup_pi_info   PARM((struct pi_info*, int));
++static void pi_cleanup_pinfo     PARM((PICINFO*));
++static void pi_memory_error      PARM((char*, char*));
++static void pi_error             PARM((struct pi_info*, int));
++static void pi_file_error        PARM((struct pi_info*, int));
++static void pi_file_warning      PARM((struct pi_info*, int));
++static void pi_show_pi_info      PARM((struct pi_info*));
++static void *pi_malloc           PARM((size_t, char*));
++static void *pi_realloc          PARM((void*, size_t, char*));
++
++
++static char *pi_id = "Pi";
++static char *pi_msgs[] = {
++    NULL,
++#define PI_OPEN 1
++    "couldn't open.",
++#define PI_CORRUPT 2
++    "file corrupted.",
++#define PI_FORMAT 3
++    "not PI format.",
++#define PI_PLANES 4
++    "bad number of planes.",
++#define PI_WRITE 5
++    "write failed.",
++};
++
++
++/* The main routine of `Pi' loader. */
++int LoadPi(fname, pinfo)
++    char *fname;
++    PICINFO *pinfo;
++{
++    struct pi_info pi;
++    int e;
++    int i;
++    if(DEBUG) fputs("LoadPi:\n", stderr);
++    
++    pinfo->comment = NULL;
++    pi_init_pi_info(&pi);
++    if((e = setjmp(pi.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	pi_cleanup_pi_info(&pi, 0);
++	pi_cleanup_pinfo(pinfo);
++	if(DEBUG) fputs("\n", stderr);
++	return 0;
++    }
++    
++    pi_open_file(&pi, fname);
++    pi_read_header(&pi, &pinfo->comment);
++    pi_expand(&pi, &pinfo->pic);
++    
++    pinfo->normw = pinfo->w = pi.width;
++    pinfo->normh = pinfo->h = pi.height;
++    pinfo->type = PIC8;
++    if(pi.numcols > 256)	/* shouldn't happen. */
++	pi.numcols = 256;
++    for(i = 0; i < pi.numcols; i++){
++	pinfo->r[i] = pi.cmap[i * 3    ];
++	pinfo->g[i] = pi.cmap[i * 3 + 1];
++	pinfo->b[i] = pi.cmap[i * 3 + 2];
++    }
++    pinfo->frmType = F_PI;
++    pinfo->colType = F_FULLCOLOR;
++    sprintf(pinfo->fullInfo, "Pi, %d colors (%ld bytes)",
++	    pi.numcols, pi.fsize);
++    sprintf(pinfo->shrtInfo, "%dx%d Pi.", pi.width, pi.height);
++    normaspect = pi.aspect;
++    
++    pi_cleanup_pi_info(&pi, 0);
++    if(DEBUG) fputs("\n", stderr);
++    return 1;
++}
++
++static void pi_open_file(pi, fname)
++    struct pi_info *pi;
++    char *fname;
++{
++    if((pi->fp = fopen(fname, "rb")) == NULL)
++	pi_file_error(pi, PI_OPEN);
++    fseek(pi->fp, (size_t) 0, SEEK_END);
++    pi->fsize = ftell(pi->fp);
++    fseek(pi->fp, (size_t) 0, SEEK_SET);
++}
++
++static void pi_read_header(pi, comm)
++    struct pi_info *pi;
++    char **comm;
++{
++    byte buf[10];
++    int mda;
++    int i;
++    
++    pi_check_id(pi);
++    pi_read_comment(pi, comm);
++    
++    if(fread(buf, (size_t) 10, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_CORRUPT);
++    
++    pi->mode = buf[0];
++    pi->defcmap = pi->mode & 0x80;
++    if(buf[1] != 0 && buf[2] != 0)
++	pi->aspect = (float) buf[2] / (int) buf[1];
++    pi->cbits = buf[3];
++    pi->numcols = 1 << pi->cbits;
++    
++    if(pi->cbits != 4 && pi->cbits != 8)
++	pi_error(pi, PI_PLANES);
++    
++    mda = (int) buf[8] << 8 | (int) buf[9];
++    for(i = 0; i < mda; i++){
++	if(fgetc(pi->fp) == EOF)
++	    pi_file_error(pi, PI_CORRUPT);
++    }
++    
++    if(fread(buf, (size_t) 4, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_CORRUPT);
++    pi->width  = (int) buf[0] << 8 | (int) buf[1];
++    pi->height = (int) buf[2] << 8 | (int) buf[3];
++    
++    pi_read_palette(pi);
++    
++    if(DEBUG) pi_show_pi_info(pi);
++}
++
++static void pi_check_id(pi)
++    struct pi_info *pi;
++{
++    char buf[2];
++    
++    if(fread(buf, (size_t) 2, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_CORRUPT);
++    if(strncmp(buf, pi_id, (size_t) 2) != 0)
++	pi_error(pi, PI_FORMAT);
++}
++
++static void pi_read_comment(pi, comm)
++    struct pi_info *pi;
++    char **comm;
++{
++/*
++ * The comment format is like:
++ *   comment string `^Z' dummy string `\0'
++ */
++    int max = -1, i = 0;
++    int c;
++    
++    while(1){
++	if((c = fgetc(pi->fp)) == EOF)
++	    pi_file_error(pi, PI_CORRUPT);
++	if(c == '\032')		/* 0x1a, '^Z' */
++	    break;
++	if(max < i){
++	    max += 32;
++	    *comm = pi_realloc(*comm, (size_t) max + 1, "pi_read_comment(1)");
++	}
++	(*comm)[i++] = c;
++    }
++    if(max < i){
++	max++;
++	*comm = pi_realloc(*comm, (size_t) max + 1, "pi_read_comment(2)");
++    }
++    (*comm)[i] = '\0';
++    
++    while((c = fgetc(pi->fp)) != '\0'){		/* skip the dummy area */
++	if(c == EOF)
++	    pi_file_error(pi, PI_CORRUPT);
++    }
++}
++
++static void pi_read_palette(pi)
++    struct pi_info *pi;
++{
++    pi->cmap = pi_malloc((size_t) pi->numcols * 3, "pi_read_palette");
++    if(pi->mode & 0x80){
++	if(pi->numcols == 16){
++	    int i;
++	    byte on;
++	    
++	    on = 0x77;
++	    for(i = 0; i < 8; i++){
++		pi->cmap[i * 3    ] = i & 2 ? on : 0;
++		pi->cmap[i * 3 + 1] = i & 4 ? on : 0;
++		pi->cmap[i * 3 + 2] = i & 1 ? on : 0;
++	    }
++	    on = 0xff;
++	    for(; i < 16; i++){
++		pi->cmap[i * 3    ] = i & 2 ? on : 0;
++		pi->cmap[i * 3 + 1] = i & 4 ? on : 0;
++		pi->cmap[i * 3 + 2] = i & 1 ? on : 0;
++	    }
++	}else{	/* pi->numcols == 256 */
++	    int i;
++	    byte r, g, b;
++	    r = g = b = 0;
++	    for(i = 0; i < 256; i++){
++		pi->cmap[i * 3    ] = r;
++		pi->cmap[i * 3 + 1] = g;
++		pi->cmap[i * 3 + 2] = b;
++		if((b += 0x40) == 0){
++		    if((r += 0x20) == 0)
++			g += 0x20;
++		}
++	    }
++	}
++    }else{
++	if(fread(pi->cmap, (size_t) pi->numcols * 3, (size_t) 1, pi->fp) != 1)
++	    pi_file_error(pi, PI_CORRUPT);
++    }
++}
++
++/* The main routine to expand `Pi' file. */
++static void pi_expand(pi, pic)
++    struct pi_info *pi;
++    byte **pic;
++{
++    byte prev_col = 0;
++    int prev_pos = -1;
++    int cnt = 0, max_cnt = pi->width * pi->height;
++    
++    *pic = pi_malloc((size_t) max_cnt, "pi_expand");
++    
++    pi_table_create(pi);
++    
++    if(pi->width > 2){
++	(*pic)[0] = pi_read_color(pi, 0);
++	(*pic)[1] = pi_read_color(pi, (*pic)[0]);
++	
++	while(cnt < max_cnt){
++	    int pos = pi_read_position(pi);
++	    if(pos != prev_pos){
++		data32 len = pi_read_length(pi);
++		cnt = pi_copy_pixels(pi, *pic, cnt, pos, len);
++		prev_col = (*pic)[cnt - 1];
++		prev_pos = pos;
++	    }else{
++		do{
++		    prev_col = pi_read_color(pi, (int) prev_col);
++		    (*pic)[cnt++] = prev_col;
++		    prev_col = pi_read_color(pi, (int) prev_col);
++		    (*pic)[cnt++] = prev_col;
++		}while(pi_read_bits(pi, 1) == 1);
++		
++		prev_pos = -1;
++	    }
++	}
++    }else{
++	while(cnt < max_cnt){
++	    prev_col = pi_read_color(pi, (int) prev_col);
++	    (*pic)[cnt++] = prev_col;
++	}
++    }
++}
++
++static byte pi_read_color(pi, prev)
++    struct pi_info *pi;
++    int prev;
++{
++    byte n;
++    if(pi->cbits == 4){
++	if(pi_read_bits(pi, 1) == 1)
++	    n = pi_read_bits(pi, 1);			/* 1x */
++	else{
++	    if(pi_read_bits(pi, 1) == 0)
++		n = pi_read_bits(pi, 1) + 2;		/* 00x */
++	    else{
++		if(pi_read_bits(pi, 1) == 0)
++		    n = pi_read_bits(pi, 2) + 4;	/* 010xx */
++		else
++		    n = pi_read_bits(pi, 3) + 8;	/* 011xxx */
++	    }
++	}
++    }else{	/* cbits == 8 */
++	if(pi_read_bits(pi, 1) == 1)
++	    n = pi_read_bits(pi, 1);
++	else{
++	    int bits = 0;
++	    byte base = 2;
++	    while(bits < 6){
++		if(pi_read_bits(pi, 1) == 0)
++		    break;
++		bits++;
++		base <<= 1;
++	    }
++	    n = pi_read_bits(pi, bits + 1) + base;
++	}
++    }
++    
++    return pi_table_get_value(pi, prev, (int) n);
++}
++
++static int pi_read_position(pi)
++    struct pi_info *pi;
++{
++    byte r;
++    if((r = pi_read_bits(pi, 2)) != 3)
++	return (int) r;
++    else
++	return (int) pi_read_bits(pi, 1) + 3;
++}
++
++static data32 pi_read_length(pi)
++    struct pi_info *pi;
++{
++    data32 r = 1;
++    int bits = 0;
++    while(pi_read_bits(pi, 1) == 1){
++	r <<= 1;
++	bits++;
++    }
++    if(bits > 0)
++	return r + pi_read_bits(pi, bits);
++    return 1;
++}
++
++static int pi_copy_pixels(pi, pic, cnt, pos, len)
++    struct pi_info *pi;
++    byte *pic;
++    int cnt, pos;
++    data32 len;
++{
++    int s = 0, d = cnt;
++    int max = pi->width * pi->height;
++    switch(pos){
++    case 0:
++	if(cnt < 2){
++	    if(pic[0] == pic[1])
++		s = cnt - 2;
++	    else
++		s = cnt - 4;
++	}else{
++	    if(pic[cnt - 2] == pic[cnt - 1])
++		s = cnt - 2;
++	    else
++		s = cnt - 4;
++	}
++	break;
++    case 1:
++	s = cnt - pi->width;
++	break;
++    case 2:
++	s = cnt - pi->width * 2;
++	break;
++    case 3:
++	s = cnt - pi->width + 1;
++	break;
++    case 4:
++	s = cnt - pi->width - 1;
++    }
++    
++    len *= 2;
++    while(s < 0 && len != 0 && d < max){
++	pic[d++] = pic[-(s++) % 2];
++	len--;
++    }
++    while(len != 0 && d < max){
++	pic[d++] = pic[s++];
++	len--;
++    }
++    return d;
++}
++
++/* The main routine of `Pi' saver. */
++int WritePi(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
++	    comment)
++    FILE *fp;
++    byte *pic;
++    int ptype, w, h;
++    byte *rmap, *gmap, *bmap;
++    int numcols, colorstyle;
++    char *comment;
++{
++    byte rtemp[256], gtemp[256], btemp[256];
++    struct pi_info pi;
++    int e;
++    
++    if(DEBUG) fputs("WritePi\n", stderr);
++    pi_init_pi_info(&pi);
++    pi.fp = fp;
++    pi.width  = w;
++    pi.height = h;
++    pi.writing_grey = (colorstyle == F_GREYSCALE);
++    if(ptype == PIC24){
++	if(!(pic = Conv24to8(pic, w, h, 256, rtemp, gtemp, btemp)))
++	    pi_memory_error("Conv24to8", "WritePi");
++	rmap = rtemp;
++	gmap = gtemp;
++	bmap = btemp;
++	numcols = 256;
++    }
++    
++    if((e = setjmp(pi.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	pi_cleanup_pi_info(&pi, 1);
++	if(DEBUG) fputs("\n", stderr);
++	return -1;
++    }
++    
++    pi.numcols = numcols;
++    pi_write_header(&pi, comment,  rmap, gmap, bmap);
++    pi_compress(&pi, pic);
++    pi_write_gabage(&pi);
++    
++    pi_cleanup_pi_info(&pi, 1);
++    if(DEBUG) fputs("\n", stderr);
++    return 0;
++}
++
++static void pi_write_header(pi, comm, r, g, b)
++    struct pi_info *pi;
++    char *comm;
++    byte *r, *g, *b;
++{
++    byte buf[14];
++    
++    if(DEBUG) pi_show_pi_info(pi);
++    
++    pi_write_id(pi);
++    pi_write_comment(pi, comm);
++    
++    buf[0] = buf[1] = buf[2] = 0;
++    buf[3] = pi->cbits = pi->numcols > 16 ? 8 : 4;
++    buf[4] = 'X';
++    buf[5] = 'V';
++    buf[6] = ' ';
++    buf[7] = ' ';
++    buf[8] = buf[9] = 0;
++    buf[10] = pi->width >> 8;
++    buf[11] = pi->width;
++    buf[12] = pi->height >> 8;
++    buf[13] = pi->height;
++    if(fwrite(buf, (size_t) 14, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_WRITE);
++    
++    pi_write_palette(pi, r, g, b);
++}
++
++static void pi_write_id(pi)
++    struct pi_info *pi;
++{
++    if(fwrite(pi_id, (size_t) 2, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_WRITE);
++}
++
++static void pi_write_comment(pi, comm)
++    struct pi_info *pi;
++    char *comm;
++{
++    if(comm){
++	int i;
++	for(i = 0; comm[i]; i++){
++	    if(comm[i] == '\032')	/* 0x1a, '^Z' */
++		comm[i] = ' ';
++	}
++	if(i > 0){
++	    if(fwrite(comm, (size_t) i, (size_t) 1, pi->fp) != 1)
++		pi_file_error(pi, PI_WRITE);
++	}
++    }
++    
++    if(fwrite("\032\0", (size_t) 2, (size_t) 1, pi->fp) != 1)
++	pi_file_error(pi, PI_WRITE);
++}
++
++static void pi_write_palette(pi, r, g, b)
++    struct pi_info *pi;
++    byte *r, *g, *b;
++{
++    int i;
++    int pinum = 1 << pi->cbits;
++    char buf[3];
++    
++    for(i = 0; i < pi->numcols; i++){
++	buf[0] = *r++;
++	buf[1] = *g++;
++	buf[2] = *b++;
++	if(pi->writing_grey)
++	    buf[0] = buf[1] = buf[2] = MONO(buf[0], buf[1], buf[2]);
++	if(fwrite(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
++	    pi_file_error(pi, PI_WRITE);
++    }
++    for( ; i < pinum; i++){
++	if(fwrite(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
++	    pi_file_error(pi, PI_WRITE);
++    }
++    pi->numcols = pinum;
++}
++
++/* The main routine to compress `Pi' format. */
++static void pi_compress(pi, pic)
++    struct pi_info *pi;
++    byte *pic;
++{
++    byte prev_col = 0;
++    int prev_pos = -1;
++    int cnt = 0, max_cnt = pi->width * pi->height;
++    pi_table_create(pi);
++    
++    if(pi->width > 2){
++	int pos;
++	data32 len;
++	
++	pi_write_color(pi, 0,      pic[0]);
++	pi_write_color(pi, pic[0], pic[1]);
++	pos = pi_test_matching(pi, pic, prev_pos, cnt, &len);
++	while(cnt < max_cnt){
++	    if(pos >= 0){
++		pi_write_position(pi, pos);
++		pi_write_length(pi, len);
++		if((cnt += len * 2) >= max_cnt)
++		    break;
++		prev_col = pic[cnt - 1];
++		prev_pos = pos;
++		pos = pi_test_matching(pi, pic, prev_pos, cnt, &len);
++	    }else{
++		pi_write_position(pi, prev_pos);
++		prev_pos = -1;
++		while(pos < 0){
++		    pi_write_color(pi, (int) prev_col, pic[cnt]);
++		    prev_col = pic[cnt];
++		    if(++cnt >= max_cnt)
++			break;
++		    pi_write_color(pi, (int) prev_col, pic[cnt]);
++		    prev_col = pic[cnt];
++		    if(++cnt >= max_cnt)
++			break;
++		    pos = pi_test_matching(pi, pic, -1, cnt, &len);
++		    if(pos < 0)
++			pi_write_bits(pi, 1, 1);
++		    else
++			pi_write_bits(pi, 0, 1);
++		}
++	    }
++	}
++    }else{
++	while(cnt < max_cnt){
++	    pi_write_color(pi, (int) prev_col, pic[cnt]);
++	    prev_col = pic[cnt++];
++	}
++    }
++}
++
++static void pi_write_gabage(pi)
++    struct pi_info *pi;
++{
++    pi_write_bits(pi, 0, 32);
++}
++
++static void pi_write_color(pi, prev, col)
++    struct pi_info *pi;
++    int prev, col;
++{
++    int n = pi_table_lookup_value(pi, prev, col);
++    
++    if(pi->cbits == 4){
++	if(n < 2)
++	    pi_write_bits(pi, (data32) n | 2, 2);
++	else if(n < 4)
++	    pi_write_bits(pi, (data32) n - 2, 3);
++	else if(n < 8)
++	    pi_write_bits(pi, (data32) (n - 4) | 8, 5);
++	else
++	    pi_write_bits(pi, (data32) (n - 8) | 24, 6);
++    }else{	/* cbits == 8 */
++	if(n < 2){
++	    pi_write_bits(pi, (data32) n | 2, 2);
++	}else{
++	    int bits = 0;
++	    byte base = 2;
++	    while(bits < 6){
++		if(n < (int) base * 2)
++		    break;
++		bits++;
++		base <<= 1;
++	    }
++	    pi_write_bits(pi, 0, 1);
++	    if(bits > 0)
++		pi_write_bits(pi, 0xffffffff, bits);
++	    if(bits < 6)
++		pi_write_bits(pi, 0, 1);
++	    pi_write_bits(pi, (data32) n - base, bits + 1);
++	}
++    }
++}
++
++static int pi_test_matching(pi, pic, prev, cnt, len)
++    struct pi_info *pi;
++    byte *pic;
++    int prev, cnt;
++    data32 *len;
++{
++    data32 lens[5];
++    int pos, p;
++    int s, d = 0;
++    int max = pi->width * pi->height;
++    
++    for(pos = 0; pos < 5; pos++){
++	switch(pos){
++	case 0:
++	    if(cnt < 2){
++		if(pic[0] == pic[1])
++		    d = cnt - 2;
++		else
++		    d = cnt - 4;
++	    }else{
++		if(pic[cnt - 2] == pic[cnt - 1])
++		    d = cnt - 2;
++		else
++		    d = cnt - 4;
++	    }
++	    break;
++	case 1:
++	    d = cnt - pi->width;
++	    break;
++	case 2:
++	    d = cnt - pi->width * 2;
++	    break;
++	case 3:
++	    d = cnt - pi->width + 1;
++	    break;
++	case 4:
++	    d = cnt - pi->width - 1;
++	}
++	s = cnt;
++	lens[pos] = 0;
++	
++	if(prev == 0 && pos == 0)
++	    continue;
++	
++	while(d < max){
++	    if(pic[(d < 0) ? (-d) % 2 : d] != pic[s])
++		break;
++	    lens[pos]++;
++	    d++;
++	    s++;
++	}
++	
++    }
++    
++    for(pos = 0, p = 1; p < 5; p++){
++	if(lens[p] >= lens[pos])
++	    pos = p;
++    }
++    
++    if(lens[pos] / 2 == 0)
++	return -1;
++    *len = lens[pos] / 2;
++    return pos;
++}
++
++static void pi_write_position(pi, pos)
++    struct pi_info *pi;
++    int pos;
++{
++    switch(pos){
++    case 0:
++	pi_write_bits(pi, 0, 2);
++	break;
++    case 1:
++	pi_write_bits(pi, 1, 2);
++	break;
++    case 2:
++	pi_write_bits(pi, 2, 2);
++	break;
++    case 3:
++	pi_write_bits(pi, 6, 3);
++	break;
++    case 4:
++	pi_write_bits(pi, 7, 3);
++	break;
++    }
++}
++
++static void pi_write_length(pi, len)
++    struct pi_info *pi;
++    data32 len;
++{
++    int bits = 0;
++    data32 base = 1;
++    
++    while(len >= base * 2){
++	bits++;
++	base <<= 1;
++    }
++    if(bits > 0){
++	pi_write_bits(pi, 0xffffffff, bits);
++	pi_write_bits(pi, 0, 1);
++	pi_write_bits(pi, len - base, bits);
++    }else
++	pi_write_bits(pi, 0, 1);
++}
++
++/*
++ * These pi_table_* functions manipulate the color table.
++ * pi_table_create:
++ *	allocates and initializes a color table.
++ * pi_table_get_value:
++ *	get the specified value, and move it to the top of the list.
++ * pi_table_lookup_value:
++ *	look up the specified value, and move it to the top of the list.
++ */
++static void pi_table_create(pi)
++    struct pi_info *pi;
++{
++    struct ct_t *t;
++    int i;
++    byte mask = pi->numcols - 1;
++    pi->ct = pi_malloc(sizeof *pi->ct * pi->numcols, "pi_table_create(1)");
++    for(i = 0, t = pi->ct; i < pi->numcols; i++, t++){
++	int j;
++	byte v = i;
++	t->elt = pi_malloc(sizeof *t->elt * pi->numcols, "pi_table_create(2)");
++	t->top = &t->elt[pi->numcols - 1];
++	for(j = 0; j < pi->numcols; j++){
++	    v = (v + 1) & mask;
++	    if(j > 0)
++		t->elt[j].old    = &t->elt[j - 1];
++	    else
++		t->elt[0].old    = t->top;
++	    if(j < pi->numcols - 1)
++		t->elt[j].recent = &t->elt[j + 1];
++	    else
++		t->elt[j].recent = &t->elt[0];
++	    t->elt[j].val    = v;
++	}
++	t->elt[0].old = t->top;
++	t->top->recent = &t->elt[0];
++    }
++}
++
++static byte pi_table_get_value(pi, left, num)
++    struct pi_info *pi;
++    int left, num;
++{
++    struct ct_t *t = &pi->ct[left];
++    struct elt_t *e = t->top;
++    if(left >= pi->numcols || num >= pi->numcols)
++	abort();
++    if(num != 0){
++	do {
++	    e = e->old;
++	}while(--num != 0);
++	
++	e->old->recent = e->recent;
++	e->recent->old = e->old;
++	
++	e->recent = t->top->recent;
++	e->recent->old = e;
++	e->old = t->top;
++	t->top->recent = e;
++	
++	t->top = e;
++    }
++    return e->val;
++}
++
++static int pi_table_lookup_value(pi, left, v)
++    struct pi_info *pi;
++    int left, v;
++{
++    struct ct_t *t = &pi->ct[left];
++    struct elt_t *e = t->top;
++    int num = 0;
++    
++    if(left >= pi->numcols || v >= pi->numcols)
++	abort();
++    
++    while(e->val != v){
++	e = e->old;
++	num++;
++    }
++    
++    if(num != 0){
++	e->old->recent = e->recent;
++	e->recent->old = e->old;
++	
++	e->recent = t->top->recent;
++	e->recent->old = e;
++	e->old = t->top;
++	t->top->recent = e;
++	
++	t->top = e;
++    }
++    
++    return num;
++}
++
++/*
++ * These 2 functions read or write to a bit stream.
++ * pi_read_bits:
++ *	reads a specified-bit data from the bit stream.
++ * pi_write_bits:
++ *	writes a specified-bit data to the bit stream.
++ */
++static data32 pi_read_bits(pi, numbits)
++    struct pi_info *pi;
++    int numbits;
++{
++    data32 r = 0;
++    
++    while(numbits > 0){
++	while(pi->bs.rest > 0 && numbits > 0){
++	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
++	    pi->bs.cur <<= 1;
++	    pi->bs.rest--;
++	    numbits--;
++	}
++	if(numbits > 0){
++	    int c;
++	    if((c = fgetc(pi->fp)) == EOF)
++		pi_file_warning(pi, PI_CORRUPT);
++	    pi->bs.cur  = c;
++	    pi->bs.rest = 8;
++	}
++    }
++    
++    return r;
++}
++
++static void pi_write_bits(pi, dat, bits)
++    struct pi_info *pi;
++    data32 dat;
++    int bits;
++{
++    data32 dat_mask = 1 << (bits - 1);
++    while(bits > 0){
++	while(pi->bs.rest < 8 && bits > 0){
++	    pi->bs.cur <<= 1;
++	    if(dat & dat_mask)
++		pi->bs.cur |= 1;
++	    pi->bs.rest++;
++	    bits--;
++	    dat_mask >>= 1;
++	}
++	if(pi->bs.rest >= 8){
++	    if(fputc((int)pi->bs.cur, pi->fp) == EOF)
++		pi_file_error(pi, PI_WRITE);
++	    pi->bs.cur  = 0;
++	    pi->bs.rest = 0;
++	}
++    }
++}
++
++/*
++ * The routines to initialize or clean up.
++ * pi_inif_pi_info:
++ *	initializes a pi_info structure.
++ * pi_cleanup_pi_info:
++ *	cleanup pi_info structure. It frees allocated memories.
++ * pi_cleanup_pinfo:
++ *	cleanup PICINFO structure when an error occurs.
++ */
++static void pi_init_pi_info(pi)
++    struct pi_info *pi;
++{
++    pi->fp = NULL;
++    pi->bs.rest = 0;
++    pi->bs.cur = 0;
++    pi->fsize = 0;
++    pi->mode = 0;
++    pi->width = pi->mode = 0;
++    pi->aspect = 1.0;
++    pi->cbits = 0;
++    pi->numcols = 0;
++    pi->cmap = NULL;
++    pi->ct = NULL;
++    pi->defcmap = 0;
++    pi->writing_grey = 0;
++}
++
++static void pi_cleanup_pi_info(pi, writing)
++    struct pi_info *pi;
++    int writing;
++{
++    if(pi->fp && !writing){
++	fclose(pi->fp);
++	pi->fp = NULL;
++    }
++    if(pi->cmap){
++	free(pi->cmap);
++	pi->cmap = NULL;
++    }
++    if(pi->ct){
++	int i;
++	for(i = 0; i < pi->numcols; i++)
++	    free(pi->ct[i].elt);
++	free(pi->ct);
++	pi->ct = NULL;
++    }
++}
++
++static void pi_cleanup_pinfo(pinfo)
++    PICINFO *pinfo;
++{
++    if(pinfo->pic){
++	free(pinfo->pic);
++	pinfo->pic = NULL;
++    }
++    if(pinfo->comment){
++	free(pinfo->comment);
++	pinfo->comment = NULL;
++    }
++}
++
++/*
++ * Error handling routins.
++ * pi_memory_error:
++ *	shows a error message, and terminates.
++ * pi_error:
++ *	shows a non-file error message.
++ * pi_file_error:
++ *	shows a file error message.
++ */
++static void pi_memory_error(scm, fn)
++    char *scm, *fn;
++{
++    char buf[128];
++    sprintf(buf, "%s: couldn't allocate memory. (%s)", scm ,fn);
++    FatalError(buf);
++}
++
++static void pi_error(pi, mn)
++    struct pi_info *pi;
++    int mn;
++{
++    SetISTR(ISTR_WARNING, "%s", pi_msgs[mn]);
++    longjmp(pi->jmp, 1);
++}
++
++static void pi_file_error(pi, mn)
++    struct pi_info *pi;
++    int mn;
++{
++    if(feof(pi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", pi_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", pi_msgs[mn], ERRSTR(errno));
++    longjmp(pi->jmp, 1);
++}
++
++static void pi_file_warning(pi, mn)
++    struct pi_info *pi;
++    int mn;
++{
++    if(feof(pi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", pi_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", pi_msgs[mn], ERRSTR(errno));
++}
++
++static void pi_show_pi_info(pi)
++    struct pi_info *pi;
++{
++    fprintf(stderr, "  file size: %ld.\n", pi->fsize);
++    fprintf(stderr, "  mode: 0x%02x.\n", pi->mode);
++    fprintf(stderr, "  image size: %dx%d.\n", pi->width, pi->height);
++    fprintf(stderr, "  aspect: %f.\n", pi->aspect);
++    fprintf(stderr, "  number of color bits: %d.\n", pi->cbits);
++    fprintf(stderr, "  number of colors: %d.\n", pi->numcols);
++    fprintf(stderr, "  using default colormap: %s.\n",
++	    pi->defcmap ? "true" : "false");
++    fprintf(stderr, "  writing greyscale image: %s.\n",
++	    pi->writing_grey ? "true" : "false");
++}
++
++/*
++ * Memory related routines.  If failed, they calls pi_memory_error.
++ */
++static void *pi_malloc(n, fn)
++    size_t n;
++    char *fn;
++{
++    void *r = (void *) malloc(n);
++    if(r == NULL)
++	pi_memory_error("malloc", fn);
++    return r;
++}
++
++static void *pi_realloc(p, n, fn)
++    void *p;
++    size_t n;
++    char *fn;
++{
++    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
++    if(r == NULL)
++	pi_memory_error("realloc", fn);
++    return r;
++}
++#endif /* HAVE_PI */
+diff -urN xv-3.10a/xvpic.c xv-3.10a-jp-extension-current/xvpic.c
+--- xv-3.10a/xvpic.c
++++ xv-3.10a-jp-extension-current/xvpic.c	Wed Oct  9 20:37:21 1996
+@@ -0,0 +1,1285 @@
++/*
++ * xvpic.c - load routine for `PIC' format pictures.
++ *
++ * The `PIC' format is used by many Japanese personal computer users.
++ */
++
++#include "xv.h"
++#include <setjmp.h>
++
++#ifdef HAVE_PIC
++
++typedef unsigned short data16;
++typedef unsigned int data32;
++
++struct pic_info {
++    jmp_buf jmp;
++    FILE *fp;
++    struct {
++	int rest;
++	byte cur;
++    }bs;
++    long fsize;
++    int type, mode;
++    int width, height;
++    float aspect;
++    int cbits;
++    int cmapped;
++    byte *cmap;
++    int cached;
++    struct cache_t {
++	int newest;
++	struct cachenode_t {
++	    data32 dat;
++	    int newer, older;
++	} *node;
++    } cache;
++    int g_bits, r_bits, b_bits, i_bits;
++    int inv_gr;
++    int tiled256;
++    int numcols;
++    int writing_grey;
++    data32 *data;
++};
++
++static void pic_open_file              PARM((struct pic_info*,char*));
++static void pic_check_id               PARM((struct pic_info*));
++static void pic_read_comment           PARM((struct pic_info*, char**));
++static void pic_read_header            PARM((struct pic_info*));
++static void pic_expand_data            PARM((struct pic_info*));
++static int pic_expanding_read_len      PARM((struct pic_info*));
++static data32 pic_expanding_read_color PARM((struct pic_info*));
++static void pic_expanding_read_chain
++			PARM((struct pic_info*, int, int, data32));
++static void pic_make_xvpic
++			PARM((struct pic_info*, byte**, byte*, byte*, byte*));
++
++static void pic_write_id               PARM((struct pic_info*));
++static void pic_write_comment          PARM((struct pic_info*, char*));
++static void pic_write_header           PARM((struct pic_info*));
++static void pic_write_palette
++			PARM((struct pic_info*, byte*, byte*, byte*));
++static void pic_make_sparse_data       PARM((struct pic_info*, byte*));
++static void pic_write_data             PARM((struct pic_info*));
++static void pic_write_length           PARM((struct pic_info*, data32));
++static void pic_write_color            PARM((struct pic_info*, data32));
++static void pic_write_chain
++			PARM((struct pic_info*, int, int, data32));
++
++static data32 pic_read_rgb             PARM((struct pic_info*));
++static data32 pic_read_color_code      PARM((struct pic_info*));
++static void pic_write_rgb              PARM((struct pic_info*, data32));
++static void pic_write_color_code       PARM((struct pic_info*, data32));
++
++static void pic_cache_init             PARM((struct pic_info*));
++static data32 pic_cache_get_value      PARM((struct pic_info*, int));
++static void pic_cache_add_value        PARM((struct pic_info*, data32));
++static int pic_cache_lookup            PARM((struct pic_info*, data32));
++
++static data32 pic_read_bits            PARM((struct pic_info*, int));
++static void pic_write_bits             PARM((struct pic_info*, data32, int));
++static byte pic_pad_bit                PARM((int, data32));
++
++static void pic_init_info              PARM((struct pic_info*));
++static void pic_cleanup_pic_info       PARM((struct pic_info*, int));
++static void pic_cleanup_pinfo          PARM((PICINFO*));
++static void pic_memory_error           PARM((char*, char*));
++static void pic_error                  PARM((struct pic_info*, int));
++static void pic_file_error             PARM((struct pic_info*, int));
++static void pic_file_warning           PARM((struct pic_info*, int));
++static void pic_show_pic_info          PARM((struct pic_info*));
++static void *pic_malloc                PARM((size_t, char*));
++static void *pic_realloc               PARM((void*, size_t, char*));
++
++
++static char *pic_id = "PIC";
++
++/* Error Messages */
++static char *pic_msgs[] = {
++    NULL,
++#define PIC_OPEN 1
++    "can't open file.",
++#define PIC_CORRUPT 2
++    "file corrupted.",
++#define PIC_FORMAT 3
++    "not PIC format.",
++#define PIC_SUPPORT 4
++    "unsupported type.",
++#define PIC_COMMENT 5
++    "can't read comment.",
++#define PIC_TYPE 6
++    "bad machine type.",
++#define PIC_MODE 7
++    "bad machine-dependent mode.",
++#define PIC_NUM_COLORS 8
++    "bad number of colors.",
++#define PIC_SIZE 9
++    "bad size.",
++#define PIC_ASPECT 10
++    "bad aspect.",
++#define PIC_WRITE 11
++    "write failed.",
++};
++
++#define H4(b) (((b) >> 4) & 0x0f)
++#define L4(b) ( (b)       & 0x0f)
++
++
++/* The main routine to load a PIC file. */
++int LoadPIC(fname, pinfo)
++    char *fname;
++    PICINFO *pinfo;
++{
++    int e;
++    struct pic_info pic;
++    char buf[128];
++    
++    if(DEBUG) fputs("LoadPIC:\n", stderr);
++    
++    pic_init_info(&pic);
++    
++    pinfo->comment = NULL;
++    if((e = setjmp(pic.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	pic_cleanup_pic_info(&pic, 0);
++	pic_cleanup_pinfo(pinfo);
++	if(DEBUG) fputs("\n", stderr);
++	return 0;
++    }
++    
++    pic_open_file(&pic, fname);
++    pic_check_id(&pic);
++    pic_read_comment(&pic, &pinfo->comment);
++    pic_read_header(&pic);
++    pic_expand_data(&pic);
++    pic_make_xvpic(&pic, &pinfo->pic, pinfo->r, pinfo->g, pinfo->b);
++    
++    pinfo->w = pic.width;
++    if(pic.tiled256)
++	pinfo->h = pic.height * 2;
++    else
++	pinfo->h = pic.height;
++    pinfo->normw = pinfo->w;
++    pinfo->normh = pinfo->h;
++    pinfo->type = pic.cmapped ? PIC8 : PIC24;
++    pinfo->frmType = F_PIC;
++    pinfo->colType = F_FULLCOLOR;
++    strcpy(pinfo->fullInfo, "PIC");
++    switch(pic.type){
++    case 0x0:
++	strcat(pinfo->fullInfo, ", X68k");
++	break;
++    case 0x1:
++	strcat(pinfo->fullInfo, ", PC-88VA");
++	if(pic.mode & 1)
++	    strcat(pinfo->fullInfo, ", HR");
++	if(pic.mode & 2)
++	    strcat(pinfo->fullInfo, ", tiled 256");
++	break;
++    case 0x2:
++	strcat(pinfo->fullInfo, ", FM-TOWNS");
++	if(pic.mode == 0x5){
++	    strcat(pinfo->fullInfo, ", low-resolution");
++	}else{
++	    strcat(pinfo->fullInfo, ", high-resolution");
++	}
++	break;
++    case 0x3:
++	strcat(pinfo->fullInfo, ", Machintosh");
++	break;
++    case 0xf:
++	;
++    }
++    sprintf(buf, " (%ld bytes)", pic.fsize);
++    strcat(pinfo->fullInfo, buf);
++    sprintf(pinfo->shrtInfo, "%dx%d(aspect %4.2f) PIC.",
++	    pinfo->w, pinfo->h, pic.aspect);
++    if (!nopicadjust)
++	normaspect = pic.aspect;
++    
++    pic_cleanup_pic_info(&pic, 0);
++    if(DEBUG) fputs("\n", stderr);
++    return 1;
++}
++
++static void pic_open_file(pi, fname)
++    struct pic_info *pi;
++    char *fname;
++{
++    if((pi->fp = fopen(fname, "rb")) == NULL)
++	pic_file_error(pi, PIC_OPEN);
++    fseek(pi->fp, (size_t) 0, SEEK_END);
++    pi->fsize = ftell(pi->fp);
++    fseek(pi->fp, (size_t) 0, SEEK_SET);
++}
++
++static void pic_check_id(pi)
++    struct pic_info *pi;
++{
++    char buf[3];
++    if(fread(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
++	pic_file_error(pi, PIC_CORRUPT);
++    if(strncmp(buf, pic_id, (size_t) 3) != 0)
++	pic_error(pi, PIC_FORMAT);
++}
++
++static void pic_read_comment(pi, comm)
++    struct pic_info *pi;
++    char **comm;
++{
++    /* The comment field is like:
++     * comment-string ^Z dummy \0 \0
++     */
++    int max = -1, i = 0;
++    int c;
++    
++    while(1){
++	if((c = fgetc(pi->fp)) == EOF)
++	    pic_file_error(pi, PIC_CORRUPT);
++	if(c == '\032')			/* 0x1a, '^Z' */
++	    break;
++	if(max < i){
++	    max += 32;
++	    *comm = pic_realloc(*comm, (size_t) max + 1, "pic_read_comment#1");
++	}
++	(*comm)[i++] = c;
++    }
++    
++    if(max < i){
++	max++;
++	*comm = pic_realloc(*comm, (size_t) max + 1, "pic_read_comment#2");
++    }
++    (*comm)[i] = '\0';
++    
++    while((c = fgetc(pi->fp)) != '\0'){	/* skip the dummy area */
++	if(c == EOF)
++	    pic_file_error(pi, PIC_CORRUPT);
++    }
++    
++    if(fgetc(pi->fp) != '\0')		/* check the reserved byte */
++	pic_error(pi, PIC_SUPPORT);
++}
++
++static void pic_read_header(pi)
++    struct pic_info *pi;
++{
++    pi->mode   = pic_read_bits(pi, 4);
++    pi->type   = pic_read_bits(pi, 4);
++    pi->cbits  = pic_read_bits(pi, 16);
++    pi->width  = pic_read_bits(pi, 16);
++    pi->height = pic_read_bits(pi, 16);
++    
++    /* machine dependent setups. */
++    switch(pi->type){
++    case 0x0:				/* X68K */
++	if(pi->mode != 0)
++	    pic_error(pi, PIC_MODE);
++	switch(pi->cbits){
++	case 4:
++	    pi->aspect = 1.0;
++	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
++	    pi->i_bits = 1;
++	    pi->cmapped = 1;
++	    break;
++	    
++	case 8:
++	    pi->aspect = 4.0 / 3.0;
++	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
++	    pi->i_bits = 1;
++	    pi->cmapped = 1;
++	    break;
++	    
++	case 15:
++	    pi->aspect = 4.0 / 3.0;
++	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
++	    pi->cached = 1;
++	    break;
++	    
++	case 16:
++	    pi->aspect = 4.0 / 3.0;
++	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
++	    pi->i_bits = 1;
++	    pi->cached = 1;
++	    break;
++	    
++	default:
++	    pic_error(pi, PIC_NUM_COLORS);
++	}
++	break;
++	
++    case 0x1:				/* PC-88VA */
++	if(pi->height > 1000)
++	    pic_error(pi, PIC_SIZE);
++	switch(pi->width * 1000 + pi->height){
++	case 640400:
++	case 640204:
++	case 640200:
++	case 320408:
++	case 320400:
++	case 320200:
++	    break;
++	default:
++	    pic_error(pi, PIC_SIZE);
++	}
++	pi->aspect = 400.0 / pi->height;
++	pi->aspect *= pi->width / 640.0;
++	if(pi->mode & 0x1)		/* HR mode */
++	    pi->aspect *= 2.0;
++	if(pi->mode & 0x2){		/* tiled 256 format */
++	    if(pi->cbits != 16)
++		pic_error(pi, PIC_NUM_COLORS);
++	    pi->tiled256 = 1;
++	}
++	switch(pi->cbits){
++	case 8:
++	    pi->g_bits = pi->r_bits = 3;
++	    pi->b_bits = 2;
++	    break;
++	    
++	case 12:
++	    pi->g_bits = pi->r_bits = pi->b_bits = 4;
++	    pi->cached = 1;
++	    break;
++	    
++	case 16:
++	    pi->g_bits = 6;
++	    pi->r_bits = pi->b_bits = 5;
++	    pi->cached = 1;
++	    break;
++	    
++	default:
++	    pic_error(pi, PIC_NUM_COLORS);
++	}
++	break;
++	
++    case 0x2:				/* FM-TOWNS */
++	if(pi->cbits != 15)
++	    pic_error(pi, PIC_NUM_COLORS);
++	switch(pi->mode){	
++	case 0x5:
++	case 0xc:
++	    break;
++	default:
++	    pic_error(pi, PIC_MODE);
++	}
++	pi->g_bits = pi->r_bits = pi->b_bits = 5;
++	pi->cached = 1;
++	break;
++	
++    case 0x3:				/* MAC */
++	if(pi->cbits != 15)
++	    pic_error(pi, PIC_NUM_COLORS);
++	pi->r_bits = pi->g_bits = pi->b_bits = 5;
++	pi->inv_gr = 1;
++	break;
++	
++    case 0xf:				/* misc */
++	{
++	    byte ah, al;
++	    
++	    switch(pi->mode){
++	    case 0x0:
++		break;
++	    case 0x1:
++		pi->aspect = 4.0 / 3.0;
++		break;
++	    case 0xf:
++		break;
++	    default:
++		pic_error(pi, PIC_MODE);
++	    }
++	    pic_read_bits(pi, 16);	/* x */
++	    pic_read_bits(pi, 16);	/* y */
++	    ah = pic_read_bits(pi, 8);
++	    al = pic_read_bits(pi, 8);
++	    if(ah > 0 && al > 0)
++		pi->aspect = (float) al / (int) ah;
++	    else if(pi->mode == 0xf)
++		pic_error(pi, PIC_ASPECT);
++	    switch(pi->cbits){
++	    case 4:
++	    case 8:
++		pi->g_bits = pi->r_bits = pi->b_bits = pic_read_bits(pi, 8);
++		pi->cmapped = 1;
++		break;
++		
++	    case 12:
++		pi->g_bits = pi->r_bits = pi->b_bits = 4;
++		pi->cached = 1;
++		break;
++		
++	    case 15:
++		pi->g_bits = pi->r_bits = pi->b_bits = 5;
++		pi->cached = 1;
++		break;
++		
++	    case 16:
++		pi->g_bits = pi->r_bits = pi->b_bits = 5;
++		pi->i_bits = 1;
++		pi->cached = 1;
++		break;
++		
++	    case 24:
++		pi->g_bits = pi->r_bits = pi->b_bits = 8;
++		pi->cached = 1;
++		break;
++		
++	    case 32:
++		pic_error(pi, PIC_SUPPORT);
++		break;
++		
++	    default:
++		pic_error(pi, PIC_NUM_COLORS);
++	    }
++	}
++	break;
++	
++    default:
++	pic_error(pi, PIC_TYPE);
++    }
++    
++    pi->numcols = 1 << pi->cbits;
++    
++    /* read palette data */
++    if(pi->cmapped){
++	int i;
++	pi->cmap = pic_malloc((size_t) 3 * pi->numcols, "pic_read_header#1");
++	for(i = 0; i < pi->numcols; i++){
++	    data32 c = pic_read_rgb(pi);
++	    pi->cmap[i * 3    ] = c >> 16 & 0xff;
++	    pi->cmap[i * 3 + 1] = c >>  8 & 0xff;
++	    pi->cmap[i * 3 + 2] = c       & 0xff;
++	}
++    }
++    
++    /* setup color code cache */
++    if(pi->cached)
++	pic_cache_init(pi);
++    
++    
++    pi->data = pic_malloc(sizeof(data32) * pi->width * pi->height,
++			  "pic_read_header#2");
++    {
++	int i;
++	for(i = 0; i < pi->width * pi->height; i++)
++	    pi->data[i] = 0xffffffff;
++    }
++    
++    if(DEBUG)
++	pic_show_pic_info(pi);
++}
++
++/* The main routine to expand a PIC file. */
++static void pic_expand_data(pi)
++    struct pic_info *pi;
++{
++    int cnt;
++    data32 c;
++    pi->data[0] = c = 0;
++    for(cnt = -1; cnt < pi->width * pi->height; ){
++	int len = pic_expanding_read_len(pi);
++	cnt += len;
++	if(cnt < pi->width * pi->height){
++	    int x = cnt % pi->width;
++	    int y = cnt / pi->width;
++	    data32 c = pic_expanding_read_color(pi);
++	    pic_expanding_read_chain(pi, x, y, c);
++	}
++    }
++}
++
++static int pic_expanding_read_len(pi)
++    struct pic_info *pi;
++{
++    int len;
++    byte bits;
++    for(len = 2, bits = 1; pic_read_bits(pi, 1) == 1; bits++)
++	len <<= 1;
++    return len - 1 + pic_read_bits(pi, bits);
++}
++
++static data32 pic_expanding_read_color(pi)
++    struct pic_info *pi;
++{
++    if(pi->cached){
++	byte b = pic_read_bits(pi, 1);
++	if(b){
++	    return pic_cache_get_value(pi, (int) pic_read_bits(pi, 7));
++	}else{
++	    data32 c = pic_read_color_code(pi);
++	    pic_cache_add_value(pi, c);
++	    return c;
++	}
++    }
++    return pic_read_color_code(pi);
++}
++
++static void pic_expanding_read_chain(pi, x, y, c)
++    struct pic_info *pi;
++    int x, y;
++    data32 c;
++{
++    pi->data[y * pi->width + x] = c;
++    if(pic_read_bits(pi, 1) == 1){
++	int fin = 0;
++	while(!fin){
++	    switch(pic_read_bits(pi, 2)){
++	    case 1:	/* left */
++		pi->data[(++y) * pi->width + (--x)] = c;
++		break;
++	    case 2:	/* middle */
++		pi->data[(++y) * pi->width +    x ] = c;
++		break;
++	    case 3:	/* right */
++		pi->data[(++y) * pi->width + (++x)] = c;
++		break;
++	    case 0:	/* far or nothing */
++		if(pic_read_bits(pi, 1) == 0)
++		    fin = 1;
++		else{
++		    if(pic_read_bits(pi, 1) == 0)
++			pi->data[(++y) * pi->width + (x -= 2)] = c;
++		    else
++			pi->data[(++y) * pi->width + (x += 2)] = c;
++		}
++	    }
++	}
++    }
++}
++
++/*
++ * Make a picture from the expanded data.
++ */
++static void pic_make_xvpic(pi, xp, rp, gp, bp)
++    struct pic_info *pi;
++    byte **xp, *rp, *gp, *bp;
++{
++    if(pi->cmapped){
++	if(pi->tiled256)
++	    *xp = pic_malloc((size_t) pi->width * pi->height * 2,
++			     "pic_make_xvpic#1");
++	else
++	    *xp = pic_malloc((size_t) pi->width * pi->height,
++			     "pic_make_xvpic#2");
++    }else
++	*xp = pic_malloc((size_t) pi->width * pi->height * 3,
++			 "pic_make_xvpic#3");
++    
++    if(pi->cmapped){
++	int i;
++	
++	for(i = 0; i < pi->numcols; i++){
++	    rp[i] = pi->cmap[i * 3    ];
++	    gp[i] = pi->cmap[i * 3 + 1];
++	    bp[i] = pi->cmap[i * 3 + 2];
++	}
++	
++	if(pi->tiled256){
++	    int pic_idx = 0, dat_idx;
++	    data16 col = 0;
++	    for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
++		if(pi->data[dat_idx] != 0xffffffff)
++		    col = pi->data[dat_idx];
++		(*xp)[pic_idx++] = col      & 0xff;
++		(*xp)[pic_idx++] = col >> 8 & 0xff;
++		dat_idx++;
++	    }
++	}else{
++	    int pic_idx = 0, dat_idx;
++	    byte col = 0;
++	    for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
++		if(pi->data[dat_idx] != 0xffffffff)
++		    col = pi->data[dat_idx];
++		(*xp)[pic_idx++] = col;
++	    }
++	}
++    }else{
++	int pic_idx = 0, dat_idx;
++	byte r, g, b;
++	for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
++	    if(pi->data[dat_idx] != 0xffffffff){
++		data32 col = pi->data[dat_idx];
++		r = col >> 16 & 0xff;
++		g = col >>  8 & 0xff;
++		b = col       & 0xff;
++	    }
++	    (*xp)[pic_idx++] = r;
++	    (*xp)[pic_idx++] = g;
++	    (*xp)[pic_idx++] = b;
++	}
++    }
++}
++
++
++/* The main routine to write PIC file. */
++int WritePIC(fp, pic0, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
++	     comment)
++    FILE *fp;
++    byte *pic0;
++    int ptype, w, h;
++    byte *rmap, *gmap, *bmap;
++    int numcols, colorstyle;
++    char *comment;
++{
++    struct pic_info pic;
++    int e;
++    
++    if(DEBUG) fputs("WritePIC:\n", stderr);
++    
++    pic_init_info(&pic);
++    pic.fp = fp;
++    pic.width  = w;
++    pic.height = h;
++    pic.writing_grey = (colorstyle == F_GREYSCALE);
++    if(ptype != PIC24){		/* PIC8  */
++	pic.cmapped = 1;
++	pic.cached  = 0;
++	pic.cbits   = 8;
++	pic.g_bits  =
++	pic.r_bits  =
++	pic.b_bits  = 8;
++	pic.i_bits  = 0;
++	pic.numcols = numcols;
++    }else{			/* PIC24 */
++	pic.cmapped = 0;
++	pic.cached  = 1;
++	pic.cbits   = 24;
++	pic.g_bits  =
++	pic.r_bits  =
++	pic.b_bits  = 8;
++	pic.i_bits  = 0;
++	pic.numcols = 1 << 24;
++	pic_cache_init(&pic);
++    }
++    
++    if((e = setjmp(pic.jmp)) != 0){
++	/* When an error occurs while writing, comes here. */
++	pic_cleanup_pic_info(&pic, 1);
++	if(DEBUG) fputs("\n", stderr);
++	return -1;
++    }
++    
++    pic_write_id(&pic);
++    pic_write_comment(&pic, comment);
++    pic_write_header(&pic);
++    if(pic.cmapped)
++	pic_write_palette(&pic, rmap, gmap, bmap);
++    pic_make_sparse_data(&pic, pic0);
++    pic_write_data(&pic);
++    pic_write_bits(&pic, 0, 8);
++    
++    pic_cleanup_pic_info(&pic, 1);
++    if(DEBUG) fputs("\n", stderr);
++    return 0;
++}
++
++static void pic_write_id(pi)
++    struct pic_info *pi;
++{
++    if(fwrite("PIC", (size_t) 3, (size_t) 1, pi->fp) != 1)
++	pic_file_error(pi, PIC_WRITE);
++}
++
++static void pic_write_comment(pi, comm)
++    struct pic_info *pi;
++    char *comm;
++{
++    if(comm){
++	while(*comm){
++	    int c = *comm;
++	    if(c == '\032')
++		c = ' ';
++	    if(fputc(*comm, pi->fp) == EOF)
++		pic_file_error(pi, PIC_WRITE);
++	    comm++;
++	}
++    }
++    /* write ^Z, 0, and reserved. */
++    if(fwrite("\032\0\0", (size_t)3, (size_t) 1, pi->fp) != 1)
++	pic_file_error(pi, PIC_WRITE);
++}
++
++static void pic_write_header(pi)
++    struct pic_info *pi;
++{
++    if(DEBUG) pic_show_pic_info(pi);
++    pic_write_bits(pi, (data32) 0, 4);			/* mode:  1:1 */
++    pic_write_bits(pi, (data32) 0xf, 4);		/* type: misc */
++    pic_write_bits(pi, (data32) pi->cbits, 16);		/* bits */
++    pic_write_bits(pi, (data32) pi->width, 16);		/* width */
++    pic_write_bits(pi, (data32) pi->height, 16);	/* height */
++    pic_write_bits(pi, (data32) 0xffff, 16);		/* x: unused */
++    pic_write_bits(pi, (data32) 0xffff, 16);		/* y: unused */
++    pic_write_bits(pi, (data32) 0x0101, 16);		/* real aspect */
++}
++
++static void pic_write_palette(pi, r, g, b)
++    struct pic_info *pi;
++    byte *r, *g, *b;
++{
++    int i;
++    data32 rgb = 0;
++    pic_write_bits(pi, (data32) pi->g_bits, 8);
++    for(i = 0; i < pi->numcols; i++){
++	rgb = (data32) *r++ << 16 | (data32) *g++ << 8 | (data32) *b++;
++	pic_write_rgb(pi, rgb);
++    }
++    for( ; i < 256; i++)
++	pic_write_rgb(pi, rgb);
++}
++
++static void pic_make_sparse_data(pi, dat)
++    struct pic_info *pi;
++    byte *dat;
++{
++    int i;
++    data32 c;
++    
++    pi->data = pic_malloc(sizeof(data32) * pi->width * pi->height,
++			  "pic_make_sparse_data");
++    
++    if(pi->cmapped){
++	c = 0;
++	for(i = 0; i < pi->width * pi->height; i++){
++	    if(c != dat[i])
++		c = pi->data[i] = dat[i];
++	    else
++		pi->data[i] = 0xffffffff;
++	}
++    }else{
++	int j = 0;
++	c = 0;
++	for(i = 0; i < pi->width * pi->height; i++){
++	    data32 r, g, b, t;
++	    r = dat[j++];
++	    g = dat[j++];
++	    b = dat[j++];
++	    t = r << 16 | g << 8 | b;
++	    if(c != t)
++		c = pi->data[i] = t;
++	    else
++		pi->data[i] = 0xffffffff;
++	}
++    }
++}
++
++static void pic_write_data(pi)
++    struct pic_info *pi;
++{
++    int i;
++    int max = pi->width * pi->height;
++    data32 c = 0;
++    
++    i = -1;
++    while(i < max){
++	int j;
++	for(j = i + 1; j < max; j++){
++	    if(pi->data[j] != 0xffffffff)
++		break;
++	}
++	pic_write_length(pi, (data32) j - i);
++	i = j;
++	if(i < max){
++	    pic_write_color(pi, c = pi->data[i]);
++	    pic_write_chain(pi, i % pi->width, i / pi->width, c);
++	}
++    }
++}
++
++static void pic_write_length(pi, len)
++    struct pic_info *pi;
++    data32 len;
++{
++    int bits = 0;	/* leading 1's */
++    int max = 2;
++    
++    while(len > max){
++	max = (max + 1) * 2;
++	bits++;
++    }
++    pic_write_bits(pi, 0xffffffff, bits);
++    pic_write_bits(pi, 0, 1);
++    pic_write_bits(pi, len - max / 2, bits + 1);
++}
++
++static void pic_write_color(pi, c)
++    struct pic_info *pi;
++    data32 c;
++{
++    if(pi->cached){
++	int idx = pic_cache_lookup(pi, c);
++	if(idx < 0){	/* not found */
++	    pic_write_bits(pi, 0, 1);
++	    pic_write_color_code(pi, c);
++	    pic_cache_add_value(pi, c);
++	}else{		/* found */
++	    pic_write_bits(pi, (data32) 0xffffffff, 1);
++	    pic_write_bits(pi, (data32) idx, 7);
++	}
++    }else
++	pic_write_color_code(pi, c);
++}
++
++static void pic_write_chain(pi, x, y, c)
++    struct pic_info *pi;
++    int x, y;
++    data32 c;
++{
++    int ctr = (y + 1) * pi->width + x;
++    
++    if(y < pi->height - 1 &&
++       (                      pi->data[ctr    ] == c  ||
++	(x > 0             && pi->data[ctr - 1] == c) ||
++	(x < pi->width - 1 && pi->data[ctr + 1] == c) ||
++	(x > 1             && pi->data[ctr - 2] == c) ||
++	(x < pi->width - 2 && pi->data[ctr + 2] == c))){
++	pic_write_bits(pi, 1, 1);
++	while(++y < pi->height){
++	    if(pi->data[ctr] == c){				  /* center */
++		pic_write_bits(pi, 2, 2);
++		pi->data[ctr] = 0xffffffff;
++		ctr += pi->width;
++	    }else if(x > 0 && pi->data[ctr - 1] == c){		  /* left */
++		pic_write_bits(pi, 1, 2);
++		pi->data[ctr - 1] = 0xffffffff;
++		ctr += pi->width - 1;
++	    }else if(x < pi->width - 1 && pi->data[ctr + 1] == c){/* right */
++		pic_write_bits(pi, 3, 2);
++		pi->data[ctr + 1] = 0xffffffff;
++		ctr += pi->width + 1;
++	    }else if(x > 1 && pi->data[ctr - 2] == c){		  /* 2-left */
++		pic_write_bits(pi, 2, 4);
++		pi->data[ctr - 2] = 0xffffffff;
++		ctr += pi->width - 2;
++	    }else if(x < pi->width - 2 && pi->data[ctr + 2] == c){/* 2-right */
++		pic_write_bits(pi, 3, 4);
++		pi->data[ctr + 2] = 0xffffffff;
++		ctr += pi->width + 2;
++	    }else						  /* nothing */
++		break;
++	}
++	pic_write_bits(pi, 0, 3);
++    }else
++	pic_write_bits(pi, 0, 1);
++}
++
++
++/*
++ * These 4 functions reads or writes a color.
++ *
++ * pic_read_rgb:
++ *	reads an RGB. Each bit length is [rgb]_bits, but
++ *	it is expanded to 8bits when returned.
++ *
++ * pic_read_color_code:
++ *	reads a color code, whose length is cbits.
++ *	It is the index to the colormap or RGB itself.
++ *
++ * pic_write_rgb:
++ *	writes an RGB value.
++ *
++ * pic_write_color_code:
++ *	writes a color code.
++ */
++static data32 pic_read_rgb(pi)
++    struct pic_info *pi;
++{
++    int rb = pi->r_bits, gb = pi->g_bits, bb = pi->b_bits;
++    byte r, g, b;
++    if(pi->inv_gr){
++	r = pic_read_bits(pi, rb);
++	g = pic_read_bits(pi, gb);
++    }else{
++	g = pic_read_bits(pi, gb);
++	r = pic_read_bits(pi, rb);
++    }
++    b = pic_read_bits(pi, bb);
++    if(pi->i_bits){
++	byte i;
++	i = pic_read_bits(pi, pi->i_bits);
++	r = r << pi->i_bits | i;
++	g = g << pi->i_bits | i;
++	b = b << pi->i_bits | i;
++	rb += pi->i_bits;
++	gb += pi->i_bits;
++	bb += pi->i_bits;
++    }
++    r = pic_pad_bit(rb, r);
++    g = pic_pad_bit(gb, g);
++    b = pic_pad_bit(bb, b);
++    
++    return (data32) r << 16 | (data32) g << 8 | (data32) b;
++}
++
++static data32 pic_read_color_code(pi)
++    struct pic_info *pi;
++{
++    if(pi->cmapped)
++	return pic_read_bits(pi, pi->cbits);
++    return pic_read_rgb(pi);
++}
++
++static void pic_write_rgb(pi, rgb)
++    struct pic_info *pi;
++    data32 rgb;
++{
++    byte r = rgb >> 16;
++    byte g = rgb >> 8;
++    byte b = rgb;
++    if(pi->writing_grey)
++	r = g = b = MONO(r, g, b);
++    pic_write_bits(pi, g, pi->g_bits);
++    pic_write_bits(pi, r, pi->r_bits);
++    pic_write_bits(pi, b, pi->b_bits);
++}
++
++static void pic_write_color_code(pi, code)
++    struct pic_info *pi;
++    data32 code;
++{
++    if(pi->cmapped){
++	pic_write_bits(pi, code, pi->cbits);
++    }else{
++	pic_write_rgb(pi, code);
++    }
++}
++
++
++/*
++ * These pic_cache_* functions are an implementation of the color cache.
++ *
++ * pic_cache_init:
++ *	initializes the cache.
++ *	
++ * pic_cache_get_value:
++ *	gets a color indexed by the argument `idx'.
++ *	It updates the `most recently used' time.
++ *	
++ * pic_cache_add_value:
++ *	adds a color to the top of the cache list.
++ */
++static void pic_cache_init(pi)
++    struct pic_info *pi;
++{
++    int i;
++    pi->cache.node = pic_malloc(sizeof(struct cachenode_t) * 128,
++				"pic_cache_init");
++    for(i = 0; i < 128; i++){
++	pi->cache.node[i].newer = i + 1;
++	pi->cache.node[i].older = i - 1;
++	pi->cache.node[i].dat = 0;
++    }
++    pi->cache.node[  0].older = 127;
++    pi->cache.node[127].newer = 0;
++    pi->cache.newest = 0;
++}
++
++static data32 pic_cache_get_value(pi, idx)
++    struct pic_info *pi;
++    int idx;
++{
++    struct cachenode_t *p = pi->cache.node;
++    int n = pi->cache.newest;
++    if(n != idx){
++	p[p[idx].newer].older = p[idx].older;
++	p[p[idx].older].newer = p[idx].newer;
++	
++	p[p[n].newer].older = idx;
++	p[idx].newer = p[n].newer;
++	p[n].newer = idx;
++	p[idx].older = n;
++	
++	pi->cache.newest = idx;
++    }
++    return pi->cache.node[idx].dat;
++}
++
++static void pic_cache_add_value(pi, dat)
++    struct pic_info *pi;
++    data32 dat;
++{
++    pi->cache.newest = pi->cache.node[pi->cache.newest].newer;
++    pi->cache.node[pi->cache.newest].dat = dat;
++}
++
++static int pic_cache_lookup(pi, dat)
++    struct pic_info *pi;
++    data32 dat;
++{
++    int i;
++    for(i = 0; i < 128; i++){
++	if(pi->cache.node[i].dat == dat){
++	    pic_cache_get_value(pi, i);
++	    return i;
++	}
++    }
++    return -1;
++}
++
++
++/*
++ * These pic_{read,write}_bits functions access the bit stream.
++ * pic_read_bits:
++ *	reads the specified bits from the file.
++ *
++ * pic_write_bits:
++ *	writes the specified bits to the file.
++ */
++static data32 pic_read_bits(pi, bits)
++    struct pic_info *pi;
++    int bits;
++{
++    data32 r = 0;
++    
++    while(bits > 0){
++	while(pi->bs.rest > 0 && bits > 0){
++	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
++	    pi->bs.cur <<= 1;
++	    pi->bs.rest--;
++	    bits--;
++	}
++	if(bits > 0){
++	    int c;
++	    if((c = fgetc(pi->fp)) == EOF){
++		pic_file_warning(pi, PIC_CORRUPT);
++		c = 0;
++	    }
++	    pi->bs.cur  = c;
++	    pi->bs.rest = 8;
++	}
++    }
++    
++    return r;
++}
++
++static void pic_write_bits(pi, dat, bits)
++    struct pic_info *pi;
++    data32 dat;
++    int bits;
++{
++    data32 dat_mask = 1 << (bits - 1);
++    while(bits > 0){
++	while(pi->bs.rest < 8 && bits > 0){
++	    pi->bs.cur <<= 1;
++	    if(dat & dat_mask)
++		pi->bs.cur |= 1;
++	    pi->bs.rest++;
++	    bits--;
++	    dat_mask >>= 1;
++	}
++	if(pi->bs.rest >= 8){
++	    if(fputc((int)pi->bs.cur, pi->fp) == EOF)
++		pic_error(pi, PIC_WRITE);
++	    pi->bs.cur  = 0;
++	    pi->bs.rest = 0;
++	}
++    }
++}
++
++
++/*
++ * This function extends a some-bit data to the 8-bit data.
++ */
++static byte pic_pad_bit(bits, dat)
++    int bits;
++    data32 dat;
++{
++    switch(bits){
++    case 1:
++	if(dat & 1)
++	    dat = 0xff;
++	else
++	    dat = 0;
++	break;
++    case 2:
++	dat = dat << 6 | dat << 4 | dat << 2 | dat;
++	break;
++    case 3:
++	dat = dat << 5 | dat << 2 | dat >> 1;
++	break;
++    case 4:
++	dat = dat << 4 | dat;
++	break;
++    case 5:
++	dat = dat << 3 | dat >> 2;
++	break;
++    case 6:
++	dat = dat << 2 | dat >> 4;
++	break;
++    case 7:
++	dat = dat << 1 | dat >> 6;
++    }
++    
++    return dat;
++}
++
++/*
++ * These functions initialize or clean up structures.
++ * pic_init_info:
++ *	initializes a pic_info structure.
++ * pic_cleanup_pic_info:
++ *	cleans up a pic_info structure.
++ * pic_cleanup_pinfo:
++ *	cleans up a PICINFO structure.
++ */
++static void pic_init_info(pi)
++    struct pic_info *pi;
++{
++    pi->fp = NULL;
++    pi->bs.rest = 0;
++    pi->bs.cur = '\0';
++    pi->type = pi->mode = 0;
++    pi->width = pi->height = 0;
++    pi->aspect = 1.0;
++    pi->cbits = 0;
++    pi->cmapped = pi->cached = 0;
++    pi->cache.node = NULL;
++    pi->cmap = NULL;
++    pi->g_bits = pi->r_bits = pi->b_bits = pi->i_bits = 0;
++    pi->inv_gr = 0;
++    pi->tiled256 = 0;
++    pi->numcols = 0;
++    pi->writing_grey = 0;
++}
++
++static void pic_cleanup_pic_info(pi, writing)
++    struct pic_info *pi;
++    int writing;
++{
++    if(!writing && pi->fp)
++	fclose(pi->fp);
++    if(pi->cmap)
++	free(pi->cmap);
++    if(pi->cache.node)
++	free(pi->cache.node);
++    if(pi->data)
++	free(pi->data);
++    pi->fp = NULL;
++    pi->cmap = NULL;
++    pi->cache.node = NULL;
++    pi->data = NULL;
++}
++
++static void pic_cleanup_pinfo(pinfo)
++    PICINFO *pinfo;
++{
++    if(pinfo->pic){
++	free(pinfo->pic);
++	pinfo->pic = NULL;
++    }
++    if(pinfo->comment){
++	free(pinfo->comment);
++	pinfo->comment = NULL;
++    }
++}
++
++/*
++ * Error Handlers.
++ * pic_memory_error:
++ *	shows an error message, and terminates.
++ * pic_error:
++ *	shows an non-file error message, and jumps to the entry for errors.
++ * pic_file_error:
++ *	shows an file error message, and jumps to the entry for errors.
++ * pic_file_warning:
++ *	shows an file warning message.
++ */
++static void pic_memory_error(scm, fn)
++    char *scm, *fn;
++{
++    char buf[128];
++    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
++    FatalError(buf);
++}
++
++static void pic_error(pi, mn)
++    struct pic_info *pi;
++    int mn;
++{
++    SetISTR(ISTR_WARNING, "%s", pic_msgs[mn]);
++    longjmp(pi->jmp, 1);
++}
++
++static void pic_file_error(pi, mn)
++    struct pic_info *pi;
++    int mn;
++{
++    if(feof(pi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", pic_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", pic_msgs[mn], ERRSTR(errno));
++    longjmp(pi->jmp, 1);
++}
++
++static void pic_file_warning(pi, mn)
++    struct pic_info *pi;
++    int mn;
++{
++    if(feof(pi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", pic_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", pic_msgs[mn], ERRSTR(errno));
++}
++
++static void pic_show_pic_info(pi)
++    struct pic_info *pi;
++{
++    fprintf(stderr, "  file size: %ld.\n", pi->fsize);
++    
++    fputs("  machine: ", stderr);
++    switch(pi->type){
++    case 0x0:
++	fputs("X68k", stderr);
++	break;
++    case 0x1:
++	fputs("PC-88VA", stderr);
++	if(pi->mode & 1)
++	    fputs(",HR", stderr);
++	if(pi->mode & 2)
++	    fputs(",tiled256", stderr);
++	break;
++    case 0x2:
++	fprintf(stderr,
++		"FM-TOWNS,%s-resolution", pi->mode == 5 ? "low" : "high");
++	break;
++    case 0x3:
++	fputs("Machintosh", stderr);
++	break;
++    case 0xf:
++	fputs("misc", stderr);
++    }
++    fputs("\n", stderr);
++    
++    fprintf(stderr, "  image size: %dx%d\n", pi->width, pi->height);
++    fprintf(stderr, "  aspect: %f\n", pi->aspect);
++    fprintf(stderr, "  cache: %s\n", pi->cached ? "on" : "off");
++    fprintf(stderr, "  colormap: %s\n", pi->cmapped ? "on" : "off");
++    fprintf(stderr, "  number of color bits: %d\n", pi->cbits);
++    fprintf(stderr, "  number of RGB bits: R%d,G%d,B%d,I%d\n",
++	   pi->r_bits, pi->g_bits, pi->b_bits, pi->i_bits);
++    fprintf(stderr, "  inverted G&R: %s\n", pi->inv_gr ? "true" : "false");
++    fprintf(stderr, "  number of colors: %d\n", pi->numcols);
++}
++
++/* Memory related routines. */
++static void *pic_malloc(n, fn)
++    size_t n;
++    char *fn;
++{
++    void *r = (void *) malloc(n);
++    if(r == NULL)
++	pic_memory_error("malloc", fn);
++    return r;
++}
++
++static void *pic_realloc(p, n, fn)
++    void *p;
++    size_t n;
++    char *fn;
++{
++    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
++    if(r == NULL)
++	pic_memory_error("realloc", fn);
++    return r;
++}
++#endif /* HAVE_PIC */
+diff -urN xv-3.10a/xvpic2.c xv-3.10a-jp-extension-current/xvpic2.c
+--- xv-3.10a/xvpic2.c
++++ xv-3.10a-jp-extension-current/xvpic2.c	Wed Oct  9 20:37:21 1996
+@@ -0,0 +1,3598 @@
++/*
++ * $Id: xvpic2.c,v 2.9.1.14 1995/04/24 15:34:15 ikeyan Exp $
++ * xvpic2.c - load and save routines for `PIC2' format pictures.
++ *
++ *
++ * Outline
++ * =======
++ * xvpic2.c supports the PIC2 format image file. It is used some
++ * Japanese personal computer users.
++ *
++ * The PIC2 format is designed by A.Yanagisawa. It is very excellent
++ * format except for it's encode/decode speed ;-)
++ *
++ * The features of the PIC2 format:
++ * - Powerful header information (included author, filename, title,
++ *   saver, product number, created date and comment).
++ * - Reversible compression, and very high compression ratio (In a lot
++ *   of case, keep higher compression ratio than the JPEG compression.
++ *   Especially, because of it's compression method, PIC2 is good at
++ *   pictures like cell animation).
++ * - Can handle full coloer(24 bits) image.
++ * - Can include multi image blocks into one PIC2 file.
++ * - Have four different block format (P2SS, P2SF, P2BM and
++ *   P2BI). P2SS format uses arithmetric compression for storeing
++ *   data. P2SF uses normal run length compression. P2BM and P2BI is
++ *   raw image format. Select any one accoding to the situation.
++ *
++ * Explanation of the PIC2 compression:
++
++ * - In the first place, try to record pixel color, uses color caches
++ *   which keep some recent colors, and formed accding to color's
++ *   frequency.  PIC2 has some color cache spaces that are switched by
++ *   upper pixel value of current pixel.  If cache is hit, record
++ *   that.
++ * - Unfortunately, in the case of color cache didn't hit, record the
++ *   difference from the value estimated with the value of upper and
++ *   left pixel of current pixel
++ * - And extract image's color chain if exist, and record that (It
++ *   results in image's outline).
++ * - In all time of recording values, it is pressed with arithmetric
++ *   compression method which produce the ideal compression ratio in
++ *   theory(P2SS).
++ *
++ * Features
++ * ========
++ * - Support 3,6,9,12,15,18,21,24bit PIC2 format (Load/Save).
++ * - Support all image block formats of PIC2 (Load/Save).
++ * - Support multi block PIC2 file (Load/Save).
++ *
++ *
++ * Bugs
++ * ====
++ * - Unsupport 8bit PIC2 image file.
++ *
++ * If you find other bugs (surely exist :-)), send me bug-report.
++ *
++ *
++ * Author
++ * ======
++ * IKEMOTO Masahiro <ikeyan@airlab.cs.ritsumei.ac.jp>
++ */
++
++#define PIC2_IGNORE_UNUSED_FUNCTIONS
++#define NEEDSDIR
++
++#include "xv.h"
++#include <setjmp.h>
++
++#ifdef HAVE_PIC2
++
++typedef unsigned long pixel;
++
++#define pic2_cextoshort(addr) ( \
++    (((short) (((byte *) addr)[0])) <<  8) | \
++    ( (short) (((byte *) addr)[1])) \
++)
++#define pic2_cextolong(addr) ( \
++    (((long)  (((byte *) addr)[0])) << 24) | \
++    (((long)  (((byte *) addr)[1])) << 16) | \
++    (((long)  (((byte *) addr)[2])) <<  8) | \
++    ( (long)  (((byte *) addr)[3])) \
++)
++#define pic2_shorttocex(addr, n) { \
++    ((byte *) addr)[0] = (((unsigned short) (n) >>  8) & 0xff); \
++    ((byte *) addr)[1] = ( (unsigned short) (n)        & 0xff); \
++}
++#define pic2_longtocex(addr, n) { \
++    ((byte *) addr)[0] = (((unsigned long)  (n) >> 24) & 0xff); \
++    ((byte *) addr)[1] = (((unsigned long)  (n) >> 16) & 0xff); \
++    ((byte *) addr)[2] = (((unsigned long)  (n) >>  8) & 0xff); \
++    ((byte *) addr)[3] = ( (unsigned long)  (n)        & 0xff); \
++}
++#define pic2_shift_bits(b, n) (((n) > 0) ? ((b) << (n)) : ((b) >> -(n)))
++
++#define PIC2_READ_MODE		0
++#define PIC2_WRITE_MODE		1
++
++#define PIC2_ARITH_CACHE	32
++#define PIC2_ARITH_CONTEXT	128
++#define PIC2_FAST_CACHE		64
++
++#define PIC2_HEADER_SIZE	124
++#define PIC2_BLOCK_HEADER_SIZE	26
++
++struct pic2_header {
++    char magic[4];
++    char name[18];
++    char subtitle[8];
++    char crlf0[2];
++    char title[30];
++    char crlf1[2];
++    char saver[30];
++    char crlf2[2];
++    char eof[1];
++    char reserve0[1];
++    short flag;
++    short no;
++    long time;
++    long size;
++    short depth;
++    short x_aspect;
++    short y_aspect;
++    short x_max;
++    short y_max;
++    long reserve1;
++};
++
++struct pic2_block {
++    char id[4];
++    long size;
++    short flag;
++    short x_wid;
++    short y_wid;
++    short x_offset;
++    short y_offset;
++    long opaque;
++    long reserve;
++};
++
++struct pic2_info {
++    jmp_buf jmp;
++    FILE *fp;
++    struct {
++	int rest;
++	byte cur;
++	int bits;
++	char zero;
++    }bs;
++    long fsize;
++    struct pic2_header *header;
++    struct pic2_block *block;
++    int n_pal;
++    int pal_bits;
++    byte pal[256][3];
++    char *comment;
++    char mode;
++    long next_pos;
++    long block_pos;
++    short x_max;
++    short y_max;
++    int ynow;
++    byte *buf;
++    pixel *vram_prev;
++    pixel *vram_now;
++    pixel *vram_next;
++    short *flag_now;
++    short *flag_next;
++    short *flag2_now;
++    short *flag2_next;
++    short *flag2_next2;
++    pixel (*cache)[PIC2_ARITH_CACHE];
++    unsigned short *cache_pos;
++    unsigned short *mulu_tab;
++    long aa;
++    long cc;
++    long dd;
++    char cache_hit_c;
++    int (*next_line) PARM((struct pic2_info *, pixel **));
++    char writing_grey;
++    char pagebname[64];
++    int pnum;
++};
++
++static void pic2_open_file             PARM((struct pic2_info*,char*));
++static void pic2_read_header           PARM((struct pic2_info*));
++static void pic2_read_block_header1    PARM((struct pic2_info*));
++static void pic2_read_block_header2    PARM((struct pic2_info*));
++static short pic2_arith_decode_bit     PARM((struct pic2_info*,int));
++static short pic2_arith_decode_nn      PARM((struct pic2_info*,int));
++static void pic2_arith_expand_chain    PARM((struct pic2_info*,int,int,pixel));
++static short pic2_arith_get_number     PARM((struct pic2_info*,int,int));
++static pixel pic2_arith_read_color     PARM((struct pic2_info*,int));
++static int pic2_arith_expand_line      PARM((struct pic2_info*,pixel**));
++static int pic2_arith_loader_init      PARM((struct pic2_info*));
++static int pic2_fast_read_length       PARM((struct pic2_info*));
++static void pic2_fast_expand_chain     PARM((struct pic2_info*,int,pixel));
++static pixel pic2_fast_read_color      PARM((struct pic2_info*,pixel));
++static int pic2_fast_expand_line       PARM((struct pic2_info*,pixel**));
++static int pic2_fast_loader_init       PARM((struct pic2_info*));
++static int pic2_beta_expand_line       PARM((struct pic2_info*,pixel**));
++static int pic2_beta_loader_init       PARM((struct pic2_info*));
++static void pic2_make_xvpic            PARM((struct pic2_info*,byte**,
++					     byte*,byte*,byte*));
++static void pic2_make_pagefile         PARM((struct pic2_info*,char*,int));
++static void pic2_setup_pic2_info       PARM((struct pic2_info*,
++					     char*,char*,char*,char*,
++					     int,int,int,int,int,int,char *));
++static void pic2_append                PARM((struct pic2_info*));
++static void pic2_write_header1         PARM((struct pic2_info*));
++static void pic2_write_header2         PARM((struct pic2_info*));
++static void pic2_write_block_header    PARM((struct pic2_info*));
++static void pic2_arith_write_zero_bit  PARM((struct pic2_info*));
++static void pic2_arith_flush_bit_buf   PARM((struct pic2_info*));
++static void pic2_arith_carry_bit       PARM((struct pic2_info*));
++static void pic2_arith_encode_bit      PARM((struct pic2_info*,int,int));
++static void pic2_arith_encode_nbyte    PARM((struct pic2_info*,int,int,int));
++static void pic2_arith_encode_nn       PARM((struct pic2_info*,int,int));
++static void pic2_arith_press_chain     PARM((struct pic2_info*,int));
++static void pic2_arith_put_number      PARM((struct pic2_info*,int,int,int));
++static void pic2_arith_write_color     PARM((struct pic2_info*,int));
++static void pic2_arith_press_line2     PARM((struct pic2_info*));
++static int pic2_arith_press_line       PARM((struct pic2_info*,pixel**));
++static int pic2_arith_saver_init       PARM((struct pic2_info*,pixel**));
++static void pic2_fast_write_length     PARM((struct pic2_info*,int));
++static void pic2_fast_press_chain      PARM((struct pic2_info*,int));
++static void pic2_fast_press_chain2     PARM((struct pic2_info*,int));
++static void pic2_fast_flush_chain      PARM((struct pic2_info*));
++static void pic2_fast_write_color      PARM((struct pic2_info*,int));
++static void pic2_fast_press_line2      PARM((struct pic2_info*));
++static int pic2_fast_press_line        PARM((struct pic2_info*,pixel**));
++static int pic2_fast_saver_init        PARM((struct pic2_info*,pixel**));
++static int pic2_beta_press_line        PARM((struct pic2_info*,pixel**));
++static int pic2_beta_saver_init        PARM((struct pic2_info*,pixel**));
++static void pic2_write_data            PARM((struct pic2_info*,byte*,
++					     int,int,int,int,int,
++					     byte*,byte*,byte*,int,int));
++static int pic2_next_line              PARM((struct pic2_info*,pixel**));
++static int pic2_next_block             PARM((struct pic2_info*));
++static int pic2_find_block             PARM((struct pic2_info*));
++static int pic2_load_block             PARM((struct pic2_info*));
++static int pic2_save_block             PARM((struct pic2_info*,pixel**,
++					     int,int,int,int,char*,pixel));
++#ifndef PIC2_IGNORE_UNUSED_FUNCTIONS
++static void pic2_read_palette          PARM((struct pic2_info*,
++					     byte*,byte*,byte*));
++static void pic2_write_palette         PARM((struct pic2_info*,int,int,
++					     byte*,byte*,byte*));
++#endif /* !PIC2_IGNORE_UNUSED_FUNCTIONS */
++static byte pic2_convert_color_bits    PARM((int,int,int));
++static byte pic2_pad_color_bits        PARM((int,int,int));
++static byte pic2_reduce_color_bits     PARM((int,int,int));
++static pixel pic2_exchange_rg          PARM((pixel,int));
++static void pic2_handle_para           PARM((struct pic2_info*,int));
++static int pic2_alloc_buffer           PARM((struct pic2_info*));
++static void pic2_free_buffer           PARM((struct pic2_info*));
++static long pic2_seek_file             PARM((struct pic2_info*,long,int));
++static long pic2_tell_file             PARM((struct pic2_info*));
++static int pic2_read_file              PARM((struct pic2_info*,void*,size_t));
++static long pic2_read_long             PARM((struct pic2_info*));
++static short pic2_read_short           PARM((struct pic2_info*));
++static char pic2_read_char             PARM((struct pic2_info*));
++static int pic2_write_file             PARM((struct pic2_info*,void*,size_t));
++static int pic2_write_long             PARM((struct pic2_info*,long));
++static int pic2_write_short            PARM((struct pic2_info*,int));
++static int pic2_write_char             PARM((struct pic2_info*,int));
++static unsigned long pic2_read_bits    PARM((struct pic2_info*,int));
++static void pic2_write_bits            PARM((struct pic2_info*,
++					     unsigned long,int));
++static void pic2_flush_bits            PARM((struct pic2_info*));
++static void pic2_memory_error          PARM((char*,char*));
++static void pic2_error                 PARM((struct pic2_info*,int));
++static void pic2_file_error            PARM((struct pic2_info*,int));
++static void pic2_init_info             PARM((struct pic2_info*));
++static void pic2_cleanup_pic2_info     PARM((struct pic2_info*,int));
++static void pic2_cleanup_pinfo         PARM((PICINFO*));
++static void pic2_show_pic2_info        PARM((struct pic2_info*));
++static char *pic2_strncpy              PARM((char*,char*,size_t));
++static void *pic2_malloc               PARM((size_t,char*));
++static void *pic2_new                  PARM((size_t,char*));
++
++static int WritePIC2                   PARM((FILE*,byte*,int,int,int,
++					     byte*,byte*,byte*,int,int,char*,
++					     int,int,int,int,int,char*));
++
++static char *pic2_id = "P2DT";
++
++/* Error Messages */
++static char *pic2_msgs[] = {
++    NULL,
++#define PIC2_OPEN 1
++    "can't open file.",
++#define PIC2_CORRUPT 2
++    "file corrupted.",
++#define PIC2_FORMAT 3
++    "not PIC2 format.",
++#define PIC2_DEPTH 4
++    "not support the depth which cannot be divided with 3.",
++#define PIC2_TMPFILE 5
++    "unable to create temporary filename???",
++#define PIC2_PAGE 6
++    "couldn't load the page.",
++#define PIC2_APPEND 7
++    "cannot append.",
++#define PIC2_WRITE 8
++    "write failed.",
++};
++
++struct _form_tab {
++    char *id;
++    int (*loader_init) PARM((struct pic2_info *));
++    int (*saver_init) PARM((struct pic2_info *, pixel **));
++} form_tab[] = {
++	{ "P2SS", pic2_arith_loader_init, pic2_arith_saver_init},
++	{ "P2SF", pic2_fast_loader_init, pic2_fast_saver_init},
++	{ "P2BM", pic2_beta_loader_init, pic2_beta_saver_init},
++	{ "P2BI", pic2_beta_loader_init, pic2_beta_saver_init},
++};
++#define	n_form_tab (sizeof(form_tab) / sizeof(struct _form_tab))
++#define P2SS 0
++#define P2SF 1
++#define P2BM 2
++#define P2BI 3
++
++/* The main routine to load a PIC2 file. */
++int LoadPIC2(fname, pinfo, quick)
++char *fname;
++PICINFO *pinfo;
++int quick;
++{
++    int e, i, block;
++    struct pic2_info pic2;
++    
++    if (DEBUG)
++	fputs("LoadPIC2:\n", stderr);
++
++    pic2_init_info(&pic2);
++    
++    if ((e = setjmp(pic2.jmp)) != 0){
++	/* When an error occurs, comes here. */
++	pic2_free_buffer(&pic2);
++	pic2_cleanup_pic2_info(&pic2, 0);
++	pic2_cleanup_pinfo(pinfo);
++	if (pic2split)
++	    KillPageFiles(pic2.pagebname, pic2.pnum);
++	SetCursors(-1);
++	if (DEBUG)
++	    fputs("\n", stderr);
++	return (0);
++    }
++    pic2_open_file(&pic2, fname);
++    pic2_read_header(&pic2);
++
++    if ((i = pic2_find_block(&pic2)) == 0)
++	pic2_file_error(&pic2, PIC2_CORRUPT);
++
++    block = 1;
++    while(i == 2) {
++	SetISTR(ISTR_WARNING, "unknown or invalid block #%d.", block);
++	i = pic2_next_block(&pic2);
++	block++;
++    }
++
++    if (pic2split && !quick) {
++	char firstpage[512];
++	struct stat st;
++
++#ifndef VMS
++	sprintf(pic2.pagebname, "%s/xvpic2XXXXXX", tmpdir);
++#else
++	sprintf(pic2.pagebname, "Sys$Scratch:xvpic2XXXXXX");
++#endif /* VMS */
++	mktemp(pic2.pagebname);
++	if (pic2.pagebname[0] == '\0')
++	    pic2_error(&pic2, PIC2_TMPFILE);
++	strcat(pic2.pagebname, ".");
++
++	sprintf(firstpage, "%s%d", pic2.pagebname, 1);
++	if (stat(firstpage, &st)) {
++	    for (pic2.pnum = 1; i >= 1; pic2.pnum++) {
++		pic2_load_block(&pic2);
++		pic2_make_pagefile(&pic2, pic2.pagebname, pic2.pnum);
++		while(block++, (i = pic2_next_block(&pic2)) == 2)
++		    SetISTR(ISTR_WARNING,
++			    "unknown or invalid block #%d.", block);
++	    }
++            pinfo->numpages = --pic2.pnum;
++            if (!LoadPIC2(firstpage, pinfo, 1))
++		pic2_error(&pic2, PIC2_PAGE);
++	    if (pic2.pnum == 1)
++		unlink(firstpage);
++	    else
++		strcpy(pinfo->pagebname, pic2.pagebname);
++	} else
++            if (!LoadPIC2(fname, pinfo, 1))
++		pic2_error(&pic2, PIC2_PAGE);
++    } else {
++	char buf[128], format[64];
++	int j;
++
++	pinfo->w = pic2.x_max;
++	pinfo->h = pic2.y_max;
++	pinfo->normw = pinfo->w;
++	pinfo->normh = pinfo->h;
++	pinfo->type = PIC24;
++	for (j = 0; j < n_form_tab; j++) {
++	    if (xvbcmp(pic2.block->id, form_tab[j].id, (size_t) 4) == 0)
++		break;
++	}
++	pinfo->frmType = F_PIC2;
++	pinfo->colType = F_FULLCOLOR;
++	pinfo->comment = pic2.comment;
++
++	if (pic2split) {
++	    pic2_make_xvpic(&pic2, &pinfo->pic, pinfo->r, pinfo->g, pinfo->b);
++	    strcpy(format, form_tab[j].id);
++	} else {
++	    for (pic2.pnum = 1; i >= 1; pic2.pnum++) {
++		SetISTR(ISTR_INFO, "composing block #%d", block);
++		pic2_make_xvpic(&pic2, &pinfo->pic,
++				pinfo->r, pinfo->g, pinfo->b);
++		while(block++, (i = pic2_next_block(&pic2)) == 2)
++		    SetISTR(ISTR_WARNING,
++			    "unknown or invalid block #%d.", block);
++	    }
++	    if (--block > 1)
++		if (block != --pic2.pnum)
++		    sprintf(format, "MultiBlock[%d/%d]", block, pic2.pnum);
++		else
++		    sprintf(format, "MultiBlock[%d]", block);
++	    else
++		strcpy(format, form_tab[j].id);
++	}
++	sprintf(buf, "PIC2(%s). %d colors (%ld bytes)", format,
++		(int) 1 << pic2.header->depth, pic2.fsize);
++	strcat(pinfo->fullInfo, buf);
++	sprintf(pinfo->shrtInfo, "%dx%d(aspect %4.2f) PIC2(%s).",
++		pinfo->w, pinfo->h,
++		(float) pic2.header->x_aspect / (float) pic2.header->y_aspect,
++		format);
++	if (!nopicadjust)
++	    normaspect = (float) pic2.header->x_aspect
++			 / (float) pic2.header->y_aspect;
++    }
++    pic2_cleanup_pic2_info(&pic2, 0);
++    SetCursors(-1);
++    if (DEBUG)
++	fputs("\n", stderr);
++    return (1);
++}
++
++/*
++ * This function opens the file, and set its size.
++ */
++static void pic2_open_file(pi, fname)
++    struct pic2_info *pi;
++    char *fname;
++{
++    if ((pi->fp = fopen(fname, "rb")) == NULL)
++	pic2_file_error(pi, PIC2_OPEN);
++    fseek(pi->fp, (size_t) 0, SEEK_END);
++    pi->fsize = ftell(pi->fp);
++    fseek(pi->fp, (size_t) 0, SEEK_SET);
++}
++
++/*
++ * These functions read the PIC2 header informations.
++ * pic2_read_header:
++ *	reads the PIC2 header.
++ * pic2_read_block_header1:
++ *	reads the id number of block header and the size of block.
++ * pic2_read_block_header2:
++ *	reads the rest of block header.
++ */
++static void pic2_read_header(pi)
++struct pic2_info *pi;
++{
++    long s_comment;
++
++    pi->mode = PIC2_READ_MODE;
++
++    /* read header image */
++    pic2_read_file(pi, pi->header->magic, 4);
++    pic2_read_file(pi, pi->header->name, 18);
++    pic2_read_file(pi, pi->header->subtitle, 8);
++    pic2_read_file(pi, pi->header->crlf0, 2);
++    pic2_read_file(pi, pi->header->title, 30);
++    pic2_read_file(pi, pi->header->crlf1, 2);
++    pic2_read_file(pi, pi->header->saver, 30);
++    pic2_read_file(pi, pi->header->crlf2, 2);
++    pic2_read_file(pi, pi->header->eof, 1);
++    pic2_read_file(pi, pi->header->reserve0, 1);
++    pi->header->flag = pic2_read_short(pi);
++    pi->header->no = pic2_read_short(pi);
++    pi->header->time = pic2_read_long(pi);
++    pi->header->size = pic2_read_long(pi);
++    pi->header->depth = pic2_read_short(pi);
++    pi->header->x_aspect = pic2_read_short(pi);
++    pi->header->y_aspect = pic2_read_short(pi);
++    pi->header->x_max = pic2_read_short(pi);
++    pi->header->y_max = pic2_read_short(pi);
++    pi->header->reserve1 = pic2_read_long(pi);
++
++    /* check magic number */
++    if (strncmp(pi->header->magic, pic2_id, (size_t) 4) != 0)
++        pic2_error(pi, PIC2_FORMAT);
++
++    /* read palette data, if exists */
++    if (pi->header->flag & 1) {
++	pi->pal_bits = pic2_read_char(pi);
++	pi->n_pal = pic2_read_short(pi);
++	pic2_read_file(pi, pi->pal, (size_t) (pi->n_pal * 3));
++    }
++
++    /* read comments */
++    s_comment = pi->header->size - pic2_tell_file(pi);
++    pi->comment = pic2_new(s_comment + 1, "pic2_read_header");
++    pic2_read_file(pi, pi->comment, (size_t) s_comment);
++    pi->comment[s_comment] = '\0';
++
++    pi->x_max = pi->header->x_max;
++    pi->y_max = pi->header->y_max;
++
++    /* set initial block point */
++    pi->next_pos = pic2_tell_file(pi);
++}
++
++static void pic2_read_block_header1(pi)
++struct pic2_info *pi;
++{
++    pic2_read_file(pi, pi->block->id, 4);
++    pi->block->size = pic2_read_long(pi);
++}
++
++static void pic2_read_block_header2(pi)
++struct pic2_info *pi;
++{
++    pi->block->flag = pic2_read_short(pi);
++    pi->block->x_wid = pic2_read_short(pi);
++    pi->block->y_wid = pic2_read_short(pi);
++    pi->block->x_offset = pic2_read_short(pi);
++    pi->block->y_offset = pic2_read_short(pi);
++    pi->block->opaque = pic2_read_long(pi);
++    pi->block->reserve = pic2_read_long(pi);
++}
++
++/*
++ * These functions are arithmetric pic2 format extractor.
++ */
++static short pic2_arith_decode_bit(pi, c)
++struct pic2_info *pi;
++int c;
++{
++    unsigned short pp;
++
++    pp = pi->mulu_tab[(pi->aa & 0x7f00) / 2 + c];
++    if (pi->dd >= (int) pp) {
++	pi->dd -= pp;
++	pi->aa -= pp;
++
++	while ((short) pi->aa >= 0) {
++	    pi->dd *= 2;
++	    if (pic2_read_bits(pi, 1))
++		pi->dd++;
++	    pi->aa *= 2;
++	}
++	return (1);
++    } else {
++	pi->aa = pp;
++
++	while ((short) pi->aa >= 0) {
++	    pi->dd *= 2;
++	    if (pic2_read_bits(pi, 1))
++		pi->dd++;
++	    pi->aa *= 2;
++	}
++	return (0);
++    }
++}
++
++static short pic2_arith_decode_nn(pi, c)
++struct pic2_info *pi;
++int c;
++{
++    int n;
++
++    if (pic2_arith_decode_bit(pi, c)) {
++	/* n < 1 */
++	n = 0;
++    } else if (pic2_arith_decode_bit(pi, c + 1)) {
++	/* n < 1 + 2 */
++	n = 1;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++    } else if (pic2_arith_decode_bit(pi, c + 2)) {
++	/* n < 1 + 2 + 4 */
++	n = 1 + 2;
++	if (pic2_arith_decode_bit(pi,  c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi,  c + 9))
++	    n += 2;
++    } else if (pic2_arith_decode_bit(pi, c + 3)) {
++	/* n < 1 + 2 + 4 + 8 */
++	n = 1 + 2 + 4;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi, c + 9))
++	    n += 2;
++	if (pic2_arith_decode_bit(pi, c + 10))
++	    n += 4;
++    } else if (pic2_arith_decode_bit(pi, c + 4)) {
++	/* n < 1 + 2 + 4 + 8 + 16 */
++	n = 1 + 2 + 4 + 8;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi, c + 9))
++	    n += 2;
++	if (pic2_arith_decode_bit(pi, c + 10))
++	    n += 4;
++	if (pic2_arith_decode_bit(pi, c + 11))
++	    n += 8;
++    } else if (pic2_arith_decode_bit(pi,  c + 5)) {
++	/* n < 1 + 2 + 4 + 8 + 16 + 32 */
++	n = 1 + 2 + 4 + 8 + 16;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi, c + 9))
++	    n += 2;
++	if (pic2_arith_decode_bit(pi, c + 10))
++	    n += 4;
++	if (pic2_arith_decode_bit(pi, c + 11))
++	    n += 8;
++	if (pic2_arith_decode_bit(pi, c + 12))
++	    n += 16;
++
++    } else if (pic2_arith_decode_bit(pi, c + 6)) {
++	/* n < 1 + 2 + 4 + 8 + 16 + 32 + 64 */
++	n = 1 + 2 + 4 + 8 + 16 + 32;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi, c + 9))
++	    n += 2;
++	if (pic2_arith_decode_bit(pi, c + 10))
++	    n += 4;
++	if (pic2_arith_decode_bit(pi, c + 11))
++	    n += 8;
++	if (pic2_arith_decode_bit(pi, c + 12))
++	    n += 16;
++	if (pic2_arith_decode_bit(pi, c + 13))
++	    n += 32;
++
++    } else if (pic2_arith_decode_bit(pi, c + 7)) {
++	/* n < 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 */
++	n = 1 + 2 + 4 + 8 + 16 + 32 + 64;
++	if (pic2_arith_decode_bit(pi, c + 8))
++	    n += 1;
++	if (pic2_arith_decode_bit(pi, c + 9))
++	    n += 2;
++	if (pic2_arith_decode_bit(pi, c + 10))
++	    n += 4;
++	if (pic2_arith_decode_bit(pi, c + 11))
++	    n += 8;
++	if (pic2_arith_decode_bit(pi, c + 12))
++	    n += 16;
++	if (pic2_arith_decode_bit(pi, c + 13))
++	    n += 32;
++	if (pic2_arith_decode_bit(pi, c + 14))
++	    n += 64;
++
++    } else {
++	n = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128;
++    }
++    return (n);
++}
++
++static void pic2_arith_expand_chain(pi, x, y, cc)
++struct pic2_info *pi;
++int x, y;
++pixel cc;
++{
++    static const unsigned short c_tab[] = {
++	80 + 6 * 5,	/* -5 */
++	80 + 6 * 4,
++	80 + 6 * 3,
++	80 + 6 * 2,
++	80 + 6 * 1,
++	80 + 6 * 0,	/* 0  */
++	80 + 6 * 0,	/* 1  */
++    };
++    unsigned short b;
++
++    b = c_tab[pi->flag_now[x] + 5];
++    if (!pic2_arith_decode_bit(pi, b++)) {
++	if (pic2_arith_decode_bit(pi, b++))      {	/* down */
++	    pi->vram_next[x    ] = cc;
++	    pi->flag_next[x    ] = -1;
++	} else if (pic2_arith_decode_bit(pi, b++)) {	/* left */
++	    pi->vram_next[x - 1] = cc;
++	    pi->flag_next[x - 1] = -2;
++	} else if (pic2_arith_decode_bit(pi, b++)) {	/* right */
++	    pi->vram_next[x + 1] = cc;
++	    pi->flag_next[x + 1] = -3;
++	} else if (pic2_arith_decode_bit(pi, b++)) {	/* left2 */
++	    pi->vram_next[x - 2] = cc;
++	    pi->flag_next[x - 2] = -4;
++	} else {					/* right2 */
++	    pi->vram_next[x + 2] = cc;
++	    pi->flag_next[x + 2] = -5;
++	}
++    }
++}
++
++static short pic2_arith_get_number(pi, c, bef)
++struct pic2_info *pi;
++int c, bef;
++{
++    unsigned short n;
++    byte maxcol;
++
++    maxcol = 0xff >> (8 - pi->header->depth / 3);
++
++    n = pic2_arith_decode_nn(pi, c);
++    if (bef > ((int) maxcol >> 1)) {
++	if (n > ((int) maxcol - bef) * 2)
++	    n = maxcol - n;
++	else if (n & 1)
++	    n = n / 2 + bef + 1;
++	else
++	    n = bef - n / 2;
++    } else {
++	if ((int) n > (bef * 2))
++	    n = n;
++	else if (n & 1)
++	    n = n / 2 + bef + 1;
++	else
++	    n = bef - n / 2;
++    }
++    return (n);
++}
++
++static pixel pic2_arith_read_color(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    pixel c1, c2, cc;
++    unsigned short i, j, k, m;
++    short r, g, b, r0, g0, b0;
++    short colbits;
++    pixel rmask, gmask, bmask;
++    byte maxcol;
++
++    colbits = pi->header->depth / 3;
++    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
++    gmask = (0xff >> (8 - colbits)) <<  colbits;
++    bmask = (0xff >> (8 - colbits));
++    maxcol = (byte) bmask;
++
++    c1 = pi->vram_prev[x];
++    k = ((c1 >> ((colbits - 3) * 3)) & 0x1c0)
++      | ((c1 >> ((colbits - 3) * 2)) & 0x038)
++      | ((c1 >>  (colbits - 3)     ) & 0x007);
++    if (colbits == 5)
++	k = pic2_exchange_rg(k, 3);
++
++    if (pic2_arith_decode_bit(pi, pi->cache_hit_c)) {	/* ouch */
++	pi->cache_hit_c = 16;
++
++        c2 = pi->vram_now[x - 1];
++	r = ((c1 & rmask) + (c2 & rmask)) >> (colbits * 2 + 1);
++	g = ((c1 & gmask) + (c2 & gmask)) >> (colbits     + 1);
++	b = ((c1 & bmask) + (c2 & bmask)) >> (              1);
++
++	g0 = pic2_arith_get_number(pi, 32, g);
++        r = r + g0 - g;
++	if (r > (short) maxcol)
++	    r = maxcol;
++	else if (r < 0)
++	    r = 0;
++
++        b = b + g0 - g;
++	if (b > (short) maxcol)
++	    b = maxcol;
++	else if (b < 0)
++	    b = 0;
++
++	r0 = pic2_arith_get_number(pi, 48, r);
++	b0 = pic2_arith_get_number(pi, 64, b);
++
++	pi->cache_pos[k] = j = (pi->cache_pos[k] - 1) & (PIC2_ARITH_CACHE - 1);
++	pi->cache[k][j] = cc = (r0 << (colbits * 2)) | (g0 << colbits) | b0;
++    } else {
++	pi->cache_hit_c = 15;
++
++	j = pic2_arith_decode_nn(pi, 17);
++	m = pi->cache_pos[k];
++	i = (m + j / 2) & (PIC2_ARITH_CACHE - 1);
++	j = (m + j) & (PIC2_ARITH_CACHE - 1);
++
++	cc = pi->cache[k][j];
++	pi->cache[k][j] = pi->cache[k][i];
++	pi->cache[k][i] = pi->cache[k][m];
++	pi->cache[k][m] = cc;
++    }
++    return (cc);
++}
++
++static int pic2_arith_expand_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int ymax;
++    int x, xw;
++    pixel cc;
++
++    pic2_handle_para(pi, 0);
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid - 1;
++
++    if (pi->ynow > ymax)
++	return (-2);					/* end */
++
++    /* set right end of previous line before left end of current line. */
++    if (pi->ynow == 0) {
++	cc = 0;
++    } else
++	cc = pi->vram_prev[xw - 1];
++    pi->vram_now[-1] = cc;
++
++    /* clear flag for change point */
++    xvbzero((char *) pi->flag_next, xw * sizeof(pi->flag_next[0]));
++
++    /* clear flag for position probability space */
++    xvbzero((char *) pi->flag2_next2, xw * sizeof(pi->flag2_next2[0]));
++
++    for (x = 0; x < xw; x++) {
++	if (pi->flag_now[x] < 0) {
++	    cc = pi->vram_now[x];
++	    if (pi->ynow < ymax)
++		pic2_arith_expand_chain(pi, x, pi->ynow, cc);
++	} else if (pic2_arith_decode_bit(pi, pi->flag2_now[x])) {
++	    /* ajust probability space around of change point */
++	    pi->flag2_now  [x + 1]++;
++	    pi->flag2_now  [x + 2]++;
++	    pi->flag2_next [x - 1]++;
++	    pi->flag2_next [x    ]++;
++	    pi->flag2_next [x + 1]++;
++	    pi->flag2_next2[x - 1]++;
++	    pi->flag2_next2[x    ]++;
++	    pi->flag2_next2[x + 1]++;
++
++	    pi->vram_now[x] = cc = pic2_arith_read_color(pi, x);
++	    if (pi->ynow < ymax)
++		pic2_arith_expand_chain(pi, x, pi->ynow, cc);
++	} else
++	    pi->vram_now[x] = cc;
++    }
++    if (line != NULL)
++	*line = pi->vram_now;
++    pi->ynow++;
++
++    pic2_handle_para(pi, 1);
++
++    return (pi->ynow - 1);
++}
++
++static int pic2_arith_loader_init(pi)
++struct pic2_info *pi;
++{
++    unsigned short p2b[256];
++    int i, xw;
++
++    pi->ynow = 0;
++
++    /* check the color depth */
++    if (pi->header->depth % 3)
++	pic2_error(pi, PIC2_DEPTH);
++
++    /* set function for extract next line */
++    pi->next_line = pic2_arith_expand_line;
++
++    /* clear cache and flags */
++    xw = pi->block->x_wid;
++    xvbzero((char *) pi->cache, 8 * 8 * 8 * sizeof(pi->cache[0]));
++    xvbzero((char *) pi->cache_pos, 8 * 8 * 8 * sizeof(pi->cache_pos[0]));
++
++    xvbzero((char *) pi->flag_now, xw * sizeof(pi->flag_now[0]));
++    xvbzero((char *) pi->flag2_now, 8 + xw * sizeof(pi->flag2_now[0]));
++    xvbzero((char *) pi->flag2_next, 8 + xw * sizeof(pi->flag2_next[0]));
++
++    /* go to picture data field */
++    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++
++    /* clear bit field marker */
++    pi->bs.rest = 0;
++    pi->bs.cur = 0;
++
++    /* read probability table */
++    for (i = 0; i < PIC2_ARITH_CONTEXT; i++)
++	p2b[i] = pic2_read_short(pi);
++
++    /* make multiplication table */
++    for (i = 0; i < 16384; i++) {
++	pi->mulu_tab[i] = (long) (i / 128 + 128) * (int) p2b[i & 127] / 256;
++	if (pi->mulu_tab[i] == 0) pi->mulu_tab[i] = 1;
++    }
++    /* initialize some valuables */
++    pi->aa = 0xffff;
++    pi->dd = 0;
++    for (i = 0; i < 16; i++) {
++	pi->dd *= 2;
++	if (pic2_read_bits(pi, 1))
++	    pi->dd |= 1;
++    }
++    pi->cache_hit_c = 16;
++
++    return (0);
++}
++
++/*
++ * These functions are fast pic2 compression extractor.
++ */
++static int pic2_fast_read_length(pi)
++struct pic2_info *pi;
++{
++    int a;
++	
++    a = 0;
++    while (pic2_read_bits(pi, 1)) {
++	a++;
++    }
++    if (a == 0)
++	return (0);
++    return (pic2_read_bits(pi, a) + (1 << a) - 1);
++}
++
++static void pic2_fast_expand_chain(pi, x, cc)
++struct pic2_info *pi;
++int x;
++pixel cc;
++{
++    if (pic2_read_bits(pi, 1) != 0) {
++	if (pic2_read_bits(pi, 1) != 0) {		/* down */
++	    pi->vram_next[x] = cc;
++	    pi->flag_next[x] = -1;
++	} else if (pic2_read_bits(pi, 1) != 0) {
++	    if (pic2_read_bits(pi, 1) == 0) {		/* left2down */
++		pi->vram_next[x - 2] = cc;
++		pi->flag_next[x - 2] = -1;
++	    } else {					/* left1down */
++		pi->vram_next[x - 1] = cc;
++		pi->flag_next[x - 1] = -1;
++	    }
++	} else {
++	    if (pic2_read_bits(pi, 1) == 0) {		/* right2down */
++		pi->vram_next[x + 2] = cc;
++		pi->flag_next[x + 2] = -1;
++	    } else {					/* left1down */
++		pi->vram_next[x + 1] = cc;
++		pi->flag_next[x + 1] = -1;
++	    }
++	}
++    }
++}
++
++static pixel pic2_fast_read_color(pi, bc)
++struct pic2_info *pi;
++pixel bc;
++{
++    pixel cc;
++    unsigned short j, k, m;
++    short depth, colbits;
++    pixel (*cache)[PIC2_FAST_CACHE];
++
++    depth = pi->header->depth;
++    colbits = depth / 3;
++    cache = (pixel (*)[PIC2_FAST_CACHE]) pi->cache;
++
++    bc = pic2_exchange_rg(bc, colbits);
++    k = pic2_shift_bits(bc, 8 - depth);
++    if (pic2_read_bits(pi, 1) == 0) {
++	pi->cache_pos[k] = m = (pi->cache_pos[k] - 1) & (PIC2_FAST_CACHE - 1);
++	cc = pic2_read_bits(pi, depth);
++	cc = pic2_exchange_rg(cc, colbits);
++	cache[k][m] = cc;
++    } else {
++	j = pic2_read_bits(pi, 6);		/* 6= log2(PIC2_FAST_CACHE) */
++	m = pi->cache_pos[k];
++	cc = cache[k][(m + j) & (PIC2_FAST_CACHE - 1)];
++    }
++    return (cc);
++}
++
++static int pic2_fast_expand_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int ymax;
++    int x, xw;
++    pixel cc;
++
++    pic2_handle_para(pi, 0);
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid - 1;
++
++    if (pi->ynow > ymax)
++	return (-2);
++
++    if (pi->ynow == 0) {
++	pi->dd = 0;
++	pi->aa = pic2_fast_read_length(pi);
++	if (pi->aa == 1023)
++	    pi->dd = 1023;
++	else if (pi->aa > 1023)
++	    pi->aa--;
++	cc = 0;
++    } else
++	cc = pi->vram_prev[xw - 1];
++
++    xvbzero((char *) pi->flag_next, xw * sizeof(pi->flag_next[0]));
++
++    for (x = 0; x < xw; x++) {
++	if (pi->dd > 0) {
++	    if (pi->flag_now[x] < 0) {			/* on chain ? */
++		cc = pi->vram_now[x];
++		pic2_fast_expand_chain(pi, x, cc);
++		if (--pi->dd == 0) {
++		    pi->aa = pic2_fast_read_length(pi);
++		    if (pi->aa == 1023)
++			pi->dd = 1023;
++		    else if (pi->aa > 1023)
++			pi->aa--;
++		}
++	    } else
++		pi->vram_now[x] = cc;
++	} else {
++	    if (pi->flag_now[x] < 0) {			/* on chain ? */
++		cc = pi->vram_now[x];
++		pic2_fast_expand_chain(pi, x, cc);
++	    } else if (--pi->aa < 0) {
++		cc = pi->vram_now[x] = pic2_fast_read_color(pi, cc);
++		pic2_fast_expand_chain(pi, x, cc);
++		pi->aa = pic2_fast_read_length(pi);
++		if (pi->aa == 1023)
++		    pi->dd = 1023;
++		else if (pi->aa > 1023)
++		    pi->aa--;
++	    } else
++		pi->vram_now[x] = cc;
++	}
++    }
++    if (line != NULL)
++	*line = pi->vram_now;
++    pi->ynow++;
++
++    pic2_handle_para(pi, 1);
++
++    return (pi->ynow - 1);
++}
++
++static int pic2_fast_loader_init(pi)
++struct pic2_info *pi;
++{
++    int xw;
++
++    pi->ynow = 0;
++
++    /* check the color depth */
++    if (pi->header->depth % 3)
++	pic2_error(pi, PIC2_DEPTH);
++
++    /* set function for extract next line */
++    pi->next_line = pic2_fast_expand_line;
++
++    /* clear cache and flags */
++    xw = pi->block->x_wid;
++    xvbzero((char *) pi->cache, sizeof(pi->cache[0]) * 256);
++    xvbzero((char *) pi->cache_pos, sizeof(pi->cache_pos[0]) * 8 * 8 * 8);
++    xvbzero((char *) pi->flag_now, (xw + 8) * sizeof(pi->flag_now[0]));
++    xvbzero((char *) pi->flag_next, (xw + 8) * sizeof(pi->flag_next[0]));
++
++    /* go to picture data field */
++    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++
++    /* clear bit field marker */
++    pi->bs.rest = 0;
++    pi->bs.cur = 0;
++
++    return (0);
++}
++
++/*
++ * These functions are beta pic2 format extractor.
++ */
++static int pic2_beta_expand_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int i, xw, ymax;
++    byte a, b, c, *p;
++    pixel *pc;
++    short depth, pixbyte, colbits;
++
++    depth = pi->header->depth;
++    pixbyte = depth / 8 + ((depth % 8) > 0);
++    colbits = depth / 3;
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid - 1;
++
++    if (pi->ynow > ymax)
++	return (-2);					/* end */
++
++    pc = pi->vram_now;
++    p = (byte *) pi->vram_prev;
++    if (pixbyte == 3) {
++	pic2_read_file(pi, pi->vram_prev, (size_t) (xw * pixbyte));
++	for (i = 0; i < xw; i++, pc++) {
++	    a = *p++;
++	    b = *p++;
++	    c = *p++;
++	    *pc = ((pixel) a << 16) | ((pixel) b << 8) | (pixel) c;
++	}
++    } else if (pixbyte == 2) {
++	pic2_read_file(pi, pi->vram_prev, (size_t) (xw * 2));
++	if (strncmp(pi->block->id, "P2BM", 4) == 0) {
++	    for (i = 0; i < xw; i++, pc++) {
++		a = *p++;
++		b = *p++;
++		*pc = ((pixel) a << 8) | (pixel) b;
++		if (colbits == 5) {
++		    *pc >>= 1;
++		    *pc = pic2_exchange_rg(*pc, colbits);
++		}
++	    }
++	} else {
++	    for (i = 0; i < xw; i++, pc++) {
++		a = *p++;
++		b = *p++;
++		*pc = ((pixel) b << 8) | (pixel) a;
++		if (colbits == 5) {
++		    *pc >>= 1;
++		    *pc = pic2_exchange_rg(*pc, colbits);
++		}
++	    }
++	}
++    } else {
++	pic2_read_file(pi, pi->vram_prev, (size_t) xw);
++	for (i = 0; i < xw; i++)
++	    *pc++ = *p++;
++    }
++    if (line != NULL)
++	*line = pi->vram_now;
++
++    pc = pi->vram_prev;
++    pi->vram_prev = pi->vram_now;
++    pi->vram_now = pi->vram_next;
++    pi->vram_next = pc;
++
++    pi->ynow++;
++    return (pi->ynow - 1);
++}
++
++static int pic2_beta_loader_init(pi)
++struct pic2_info *pi;
++{
++    pi->ynow = 0;
++    pi->next_line = pic2_beta_expand_line;
++    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++    return (0);
++}
++
++/*
++ * Make a picture from the expanded data.
++ */
++static void pic2_make_xvpic(pi, xp, rp, gp, bp)
++struct pic2_info *pi;
++byte **xp, *rp, *gp, *bp;
++{
++    int line, i;
++    pixel *linep, opaque;
++    short colbits;
++    byte colmask;
++
++    if (*xp == NULL)
++	*xp = pic2_new((size_t) pi->x_max * pi->y_max * 3, "pic2_make_xvpic");
++
++    if (pi->block->flag & 1)
++	opaque = pi->block->opaque;
++    else
++	opaque = 0xffffffff;
++
++    colbits = pi->header->depth / 3;
++    colmask = 0xff >> (8 - colbits);
++
++    line = pic2_load_block(pi);
++    for (;;) {
++	int pic_idx;
++
++	line = pic2_next_line(pi, &linep);
++	if (line < 0)
++	    break;
++	pic_idx = ((line + pi->block->y_offset) * pi->x_max
++		   + pi->block->x_offset) * 3;
++
++	for (i = 0; i < pi->block->x_wid; i++, linep++) {
++	    byte r, g, b;
++
++	    if (*linep != opaque) {
++		r = ((*linep >> (colbits * 2)) & colmask);
++		r = pic2_convert_color_bits(r, colbits, 8);
++		g = ((*linep >>  colbits     ) & colmask);
++		g = pic2_convert_color_bits(g, colbits, 8);
++		b = ( *linep                   & colmask);
++		b = pic2_convert_color_bits(b, colbits, 8);
++		(*xp)[pic_idx++] = r;
++		(*xp)[pic_idx++] = g;
++		(*xp)[pic_idx++] = b;
++	    } else
++	        pic_idx += 3;
++
++	    WaitCursor();
++	}
++    }
++}
++
++/*
++ * This function splits multi block PIC2 file to several pages.
++ */
++static void pic2_make_pagefile(pi, pagebname, pnum)
++struct pic2_info *pi;
++char *pagebname;
++int pnum;
++{
++    struct pic2_info pic2;
++    FILE *fp;
++    char pagefile[64], *buf;
++    size_t imagesize;
++
++    sprintf(pagefile, "%s%d", pagebname, pnum);
++    if ((fp = fopen(pagefile, "wb")) == NULL)
++	pic2_error(pi, PIC2_WRITE);
++
++    xvbcopy((char *) pi, (char *) &pic2, sizeof(struct pic2_info));
++    pic2.fp = fp;
++
++    pic2_write_header1(&pic2);
++
++    pic2_write_block_header(&pic2);
++
++    imagesize = pi->block->size - PIC2_BLOCK_HEADER_SIZE;
++    buf = (char *) pic2_malloc(imagesize, "pic2_make_pagefile");
++
++    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++    if (fread(buf, (size_t) 1, imagesize, pi->fp) < imagesize) {
++	free(buf);
++	pic2_file_error(pi, PIC2_CORRUPT);
++    }
++    if (fwrite(buf, (size_t) 1, imagesize, fp) < imagesize) {
++	free(buf);
++	pic2_error(pi, PIC2_WRITE);
++    }
++    free(buf);
++
++    pic2.next_pos = pic2_tell_file(&pic2);
++    pic2_write_header2(&pic2);
++
++    fclose(fp);
++}
++
++/* The main routine to save a PIC2 file. */
++static int WritePIC2(fp, pic0, ptype, w, h, rmap, gmap, bmap, numcols,
++		     colorstyle, fname, type, depth, x_offset, y_offset,
++		     append, comment)
++FILE *fp;
++byte *pic0;
++int ptype, w, h;
++byte *rmap, *gmap, *bmap;
++int numcols, colorstyle;
++char *fname;
++int type, depth;
++int x_offset, y_offset;
++int append;
++char *comment;
++{
++    struct pic2_info pic2;
++    char creator[256], title[256], saver[256];
++    int e;
++    
++    if (DEBUG)
++	fputs("WritePIC2:\n", stderr);
++
++    pic2_init_info(&pic2);
++    pic2.fp = fp;
++    pic2.writing_grey = (colorstyle == F_GREYSCALE);
++
++    if ((e = setjmp(pic2.jmp)) != 0){
++	/* When an error occurs while writing, comes here. */
++	pic2_free_buffer(&pic2);
++	pic2_cleanup_pic2_info(&pic2, 1);
++	SetCursors(-1);
++	if (DEBUG)
++	    fputs("\n", stderr);
++	return (-1);
++    }
++    sprintf(creator, "XV Version %s", VERSTR);
++    pic2_strncpy(title, comment, 30);
++    sprintf(saver, "XV %s/UNIX/Bradley", VERSTR);
++
++    if (!append) {
++	pic2_setup_pic2_info(&pic2, creator, fname, title, saver,
++			     0, depth, 1, 1, w, h, comment);
++	pic2_write_header1(&pic2);
++    } else {
++	pic2_read_header(&pic2);
++	pic2_append(&pic2);
++	free(pic2.comment);
++	pic2_setup_pic2_info(&pic2, creator, fname, title, saver,
++			     0, depth, 1, 1, w, h, comment);
++    }
++
++    pic2_write_data(&pic2, pic0, ptype, x_offset, y_offset, w, h,
++		    rmap, gmap, bmap, type, depth);
++    pic2_write_header2(&pic2);
++
++    pic2_cleanup_pic2_info(&pic2, 1);
++    SetCursors(-1);
++    if (DEBUG)
++	fputs("\n", stderr);
++    return (0);
++}
++
++/*
++ * This function initializes pic2_info.
++ */
++static void pic2_setup_pic2_info(pi, name, fname, title, saver, no, depth,
++			      x_aspect, y_aspect, x_max, y_max, comment)
++struct pic2_info *pi;
++char *name, *fname, *title, *saver;
++int no, depth;
++int x_aspect, y_aspect;
++int x_max, y_max;
++char *comment;
++{
++    char basename[256], *suffix;
++
++    pi->mode = PIC2_WRITE_MODE;
++
++    /* set magic number */
++    strncpy(pi->header->magic, pic2_id, 4);
++
++    /* set creator's name */
++    pic2_strncpy(pi->header->name, (char *) name, 18);
++
++    /* set title and subtitle */
++    pic2_strncpy(pi->header->title, (char *) title, 30);
++    strcpy(basename, BaseName(fname));
++    suffix = (char *) rindex(basename, '.');
++    if (suffix) {
++	suffix++;
++	if (!strcmp(suffix, "p2") || !strcmp(suffix, "P2"))
++	    *(suffix - 1) = '\0';
++    }
++    pic2_strncpy(pi->header->subtitle, basename, 8);
++    
++    /* set saver */
++    pic2_strncpy(pi->header->saver, saver, 30);
++
++    /* set picture number */
++    pi->header->no = no;
++
++    /* import comment */
++    pi->comment = comment;
++
++    /* set some picture's info */
++    pi->header->depth = depth;
++    pi->header->x_aspect = x_aspect;
++    pi->header->y_aspect = y_aspect;
++    pi->header->x_max = x_max;
++    pi->header->y_max = y_max;
++
++    /* set some gaps */
++    pi->header->crlf0[0] = pi->header->crlf1[0] = pi->header->crlf2[0] = 0x0d;
++    pi->header->crlf0[1] = pi->header->crlf1[1] = pi->header->crlf2[1] = 0x0a;
++
++    pi->header->eof[0] = 0x1a;
++    pi->header->reserve0[0] = 0;
++    pi->header->reserve1 = 0;
++
++    /* set palettes */
++    if (pi->n_pal > 0)
++	pi->header->flag = 1;
++    else
++	pi->header->flag = 0;
++}
++
++/*
++ * This function appends to existing pic2 file.
++ */
++static void pic2_append(pi)
++struct pic2_info *pi;
++{
++    int block;
++
++    block = pic2_find_block(pi);
++    while (block > 0)
++	block = pic2_next_block(pi);
++
++    if (block != 0)
++	pic2_error(pi, PIC2_APPEND);
++}
++
++/*
++ * These functions write the PIC2 header.
++ * pic2_write_header1:
++ *	write palette data and comment.
++ * pic2_write_header2:
++ *	write the terminate block and rest header.
++ * pic2_write_block_header:
++ *	write the block header.
++ */
++static void pic2_write_header1(pi)
++struct pic2_info *pi;
++{
++    char *comment;
++
++    /* seek to block start position */
++    pic2_seek_file(pi, PIC2_HEADER_SIZE, SEEK_SET);
++
++    /* write palette */
++    if (pi->n_pal > 0) {
++	pic2_write_char(pi, pi->pal_bits);
++	pic2_write_short(pi, pi->n_pal);
++	pic2_write_file(pi, pi->pal, (size_t) (pi->n_pal * 3));
++    }
++    /* save comment */
++    comment = pi->comment;
++    if (pi->comment != NULL) {
++	for (comment = pi->comment; *comment; comment++) {
++	    if (*comment == '\n') {
++		pic2_write_char(pi, '\r');
++		pic2_write_char(pi, '\n');
++	    } else if (*comment != '\r')
++		pic2_write_char(pi, *comment);
++	}
++	pic2_write_char(pi, 0);
++    }
++    /* set the next block position */
++    pi->next_pos = pic2_tell_file(pi);
++    pi->header->size = pi->next_pos;
++}
++
++static void pic2_write_header2(pi)
++struct pic2_info *pi;
++{
++    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
++
++    /* write terminate block */
++    pic2_write_long(pi, 0);
++    pic2_write_long(pi, 0);
++
++    /* set some header information */
++    if (pi->header->x_max < pi->x_max)
++	pi->header->x_max = pi->x_max;
++    if (pi->header->y_max < pi->x_max)
++	pi->header->y_max = pi->y_max;
++
++    pi->header->time = time(NULL);
++    pic2_seek_file(pi, 0, SEEK_SET);
++
++    /* write header image */
++    pic2_write_file(pi, pi->header->magic, 4);
++    pic2_write_file(pi, pi->header->name, 18);
++    pic2_write_file(pi, pi->header->subtitle, 8);
++    pic2_write_file(pi, pi->header->crlf0, 2);
++    pic2_write_file(pi, pi->header->title, 30);
++    pic2_write_file(pi, pi->header->crlf1, 2);
++    pic2_write_file(pi, pi->header->saver, 30);
++    pic2_write_file(pi, pi->header->crlf2, 2);
++    pic2_write_file(pi, pi->header->eof, 1);
++    pic2_write_file(pi, pi->header->reserve0, 1);
++    pic2_write_short(pi, pi->header->flag);
++    pic2_write_short(pi, pi->header->no);
++    pic2_write_long(pi, pi->header->time);
++    pic2_write_long(pi, pi->header->size);
++    pic2_write_short(pi, pi->header->depth);
++    pic2_write_short(pi, pi->header->x_aspect);
++    pic2_write_short(pi, pi->header->y_aspect);
++    pic2_write_short(pi, pi->header->x_max);
++    pic2_write_short(pi, pi->header->y_max);
++    pic2_write_long(pi, pi->header->reserve1);
++}
++
++static void pic2_write_block_header(pi)
++struct pic2_info *pi;
++{
++    pic2_write_file(pi, pi->block->id, 4);
++    pic2_write_long(pi, pi->block->size);
++    pic2_write_short(pi, pi->block->flag);
++    pic2_write_short(pi, pi->block->x_wid);
++    pic2_write_short(pi, pi->block->y_wid);
++    pic2_write_short(pi, pi->block->x_offset);
++    pic2_write_short(pi, pi->block->y_offset);
++    pic2_write_long(pi, pi->block->opaque);
++    pic2_write_long(pi, pi->block->reserve);
++}
++
++/*
++ * These functions are arithmetric format compressor.
++ */
++#define	pic2_arith_write_one_bit(pi)	(pi->bs.bits++)
++
++static void pic2_arith_write_zero_bit(pi)
++struct pic2_info *pi;
++{
++    if (pi->bs.zero)
++	pic2_write_bits(pi, 0, 1);
++
++    while (pi->bs.bits--)
++	pic2_write_bits(pi, 1, 1);
++
++    pi->bs.bits = 0;
++    pi->bs.zero = 1;
++}
++
++static void pic2_arith_flush_bit_buf(pi)
++struct pic2_info *pi;
++{
++    int	i;
++
++    for (i = 0; i < 16; i++) {
++	if (pi->cc & 0x8000)
++	    pic2_arith_write_one_bit(pi);
++	else
++	    pic2_arith_write_zero_bit(pi);
++	pi->cc <<= 1;
++    }
++    pic2_arith_write_zero_bit(pi);
++    pic2_flush_bits(pi);
++}
++
++static void pic2_arith_carry_bit(pi)
++struct pic2_info *pi;
++{
++    pic2_write_bits(pi, 1, 1);
++
++    if (pi->bs.bits == 0) {
++	pi->bs.zero = 0;
++    } else {
++	while (--pi->bs.bits)
++	    pic2_write_bits(pi, 0, 1);
++	pi->bs.zero = 1;
++    }
++}
++
++static void pic2_arith_encode_bit(pi, n, c)
++struct pic2_info *pi;
++int n, c;
++{
++    int	pp;
++    long *c_sum, *c_0_sum;
++
++    c_sum = (long *) pi->mulu_tab;
++    c_0_sum = c_sum + PIC2_ARITH_CONTEXT + 1;
++
++    if (pi->dd  == 0) {
++	c_sum[c]++;
++	if (n == 0)
++	    c_0_sum[c]++;
++	return;
++    }
++    pp = pi->mulu_tab[(pi->aa & 0x7f00) / 2 + c];
++    if (n != 0) {
++	pi->cc = pi->cc + pp;
++	if (pi->cc > 0xffff) {
++	    pic2_arith_carry_bit(pi);
++	    pi->cc = pi->cc & 0xffff;
++	}
++	pi->aa = pi->aa - pp;
++	while (pi->aa < 0x8000) {
++	    if (pi->cc & 0x8000)
++		pic2_arith_write_one_bit(pi);
++	    else
++		pic2_arith_write_zero_bit(pi);
++	    pi->cc = (pi->cc * 2) & 0xffff;
++	    pi->aa = pi->aa * 2;
++	}
++    } else {
++	pi->aa = pp;
++
++	while (pi->aa < 0x8000) {
++	    if (pi->cc & 0x8000)
++		pic2_arith_write_one_bit(pi);
++	    else
++		pic2_arith_write_zero_bit(pi);
++	    pi->cc = (pi->cc * 2) & 0xffff;
++	    pi->aa = pi->aa * 2;
++	}
++    }
++}
++
++static void pic2_arith_encode_nbyte(pi, n, c, max)
++struct pic2_info *pi;
++int n, c, max;
++{
++    short i;
++
++    for (i = 0; i < n; i++) {
++	pic2_arith_encode_bit(pi, 0, c + i);
++    }
++    if (n < max) 
++	pic2_arith_encode_bit(pi, 1, c + n);
++}
++
++static void pic2_arith_encode_nn(pi, n, c)
++struct pic2_info *pi;
++int n, c;
++{
++    if (n < 1) {
++	pic2_arith_encode_bit(pi, 1, c);
++    } else if (n < 1 + 2) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 1, c + 1);
++	n -= 1;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++    } else if (n < 1 + 2 + 4) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 1, c + 2);
++	n -= 1 + 2;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++    } else if (n < 1 + 2 + 4 + 8) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 1, c + 3);
++	n -= 1 + 2 + 4;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++	pic2_arith_encode_bit(pi, n & 4, c + 10);
++    } else if (n < 1 + 2 + 4 + 8 + 16) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 0, c + 3);
++	pic2_arith_encode_bit(pi, 1, c + 4);
++	n -= 1 + 2 + 4 + 8;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++	pic2_arith_encode_bit(pi, n & 4, c + 10);
++	pic2_arith_encode_bit(pi, n & 8, c + 11);
++    } else if (n < 1 + 2 + 4 + 8 + 16 + 32) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 0, c + 3);
++	pic2_arith_encode_bit(pi, 0, c + 4);
++	pic2_arith_encode_bit(pi, 1, c + 5);
++	n -= 1 + 2 + 4 + 8 + 16;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++	pic2_arith_encode_bit(pi, n & 4, c + 10);
++	pic2_arith_encode_bit(pi, n & 8, c + 11);
++	pic2_arith_encode_bit(pi, n & 16, c + 12);
++    } else if (n < 1 + 2 + 4 + 8 + 16 + 32 + 64) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 0, c + 3);
++	pic2_arith_encode_bit(pi, 0, c + 4);
++	pic2_arith_encode_bit(pi, 0, c + 5);
++	pic2_arith_encode_bit(pi, 1, c + 6);
++	n -= 1 + 2 + 4 + 8 + 16 + 32;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++	pic2_arith_encode_bit(pi, n & 4, c + 10);
++	pic2_arith_encode_bit(pi, n & 8, c + 11);
++	pic2_arith_encode_bit(pi, n & 16, c + 12);
++	pic2_arith_encode_bit(pi, n & 32, c + 13);
++    } else if (n < 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128) {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 0, c + 3);
++	pic2_arith_encode_bit(pi, 0, c + 4);
++	pic2_arith_encode_bit(pi, 0, c + 5);
++	pic2_arith_encode_bit(pi, 0, c + 6);
++	pic2_arith_encode_bit(pi, 1, c + 7);
++	n -= 1 + 2 + 4 + 8 + 16 + 32 + 64;
++	pic2_arith_encode_bit(pi, n & 1, c + 8);
++	pic2_arith_encode_bit(pi, n & 2, c + 9);
++	pic2_arith_encode_bit(pi, n & 4, c + 10);
++	pic2_arith_encode_bit(pi, n & 8, c + 11);
++	pic2_arith_encode_bit(pi, n & 16, c + 12);
++	pic2_arith_encode_bit(pi, n & 32, c + 13);
++	pic2_arith_encode_bit(pi, n & 64, c + 14);
++    } else {
++	pic2_arith_encode_bit(pi, 0, c);
++	pic2_arith_encode_bit(pi, 0, c + 1);
++	pic2_arith_encode_bit(pi, 0, c + 2);
++	pic2_arith_encode_bit(pi, 0, c + 3);
++	pic2_arith_encode_bit(pi, 0, c + 4);
++	pic2_arith_encode_bit(pi, 0, c + 5);
++	pic2_arith_encode_bit(pi, 0, c + 6);
++	pic2_arith_encode_bit(pi, 0, c + 7);
++    }
++}
++
++static void pic2_arith_press_chain(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    int b, d;
++    pixel c;
++
++    b = -(pi->flag_now[x]);
++    c = pi->vram_now[x];
++    d = 0;
++
++    if (b < 0)
++	b = 0;
++
++    if (pi->flag_next[x] == 1 && pi->vram_next[x] == c) {
++	d = 1;
++	pi->flag_next[x] = -1;
++    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == c) {
++	d = 2;
++	pi->flag_next[x - 1] = -2;
++    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == c) {
++	d = 3;
++	pi->flag_next[x + 1] = -3;
++    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == c) {
++	d = 4;
++	pi->flag_next[x - 2] = -4;
++    } else if (pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == c) {
++	if ((pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == c)
++	    || (pi->flag_now[x + 1] != 0 && pi->vram_now[x + 1] == c)
++	    || (pi->flag_now[x + 3] != 0 && pi->vram_now[x + 3] == c)) {
++	    pic2_arith_encode_nbyte(pi, 0, 80 + 6 * b, 5);
++	    return;
++	}
++	d = 5;
++	pi->flag_next[x + 2] = -5;
++    }
++    pic2_arith_encode_nbyte(pi, d, 80 + 6 * b, 5);
++}
++
++static void pic2_arith_put_number(pi, xn, xa, xb)
++struct pic2_info *pi;
++int xn, xa, xb;
++{
++    short n;
++    byte maxcol;
++
++    maxcol = 0xff >> (8 - pi->header->depth / 3);
++
++    if (xa > ((int) maxcol >> 1)) {
++	if (xb > xa)
++	    n = (xb - xa) * 2 - 1;
++	else if (xa - ((int) maxcol - xa)  > xb)
++	    n = maxcol - xb;
++	else
++	    n = (xa - xb) * 2;
++    } else {
++	if (xb <= xa)
++	    n = (xa - xb) * 2;
++	else if (2 * xa < xb)
++	    n = xb;
++ 	else
++	    n = (xb - xa) * 2 - 1;
++    }
++    pic2_arith_encode_nn(pi, n, xn);
++}
++
++static void pic2_arith_write_color(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    pixel c1, c2, cc;
++    short g0, r0, b0, r, g, b;
++    int i, j;
++    unsigned short k;
++    pixel *p, *pp;
++    short colbits;
++    pixel rmask, gmask, bmask;
++    byte maxcol;
++
++    colbits = pi->header->depth / 3;
++    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
++    gmask = (0xff >> (8 - colbits)) <<  colbits;
++    bmask = (0xff >> (8 - colbits));
++    maxcol = (byte) bmask;
++
++    cc = pi->vram_now[x];
++    c1 = pi->vram_prev[x];
++    k = ((c1 >> ((colbits - 3) * 3)) & 0x1c0)
++      | ((c1 >> ((colbits - 3) * 2)) & 0x038)
++      | ((c1 >>  (colbits - 3)     ) & 0x007);
++    if (colbits == 5)
++	k = pic2_exchange_rg(k, 3);
++
++    p = pi->cache[k];
++    for (i = 0; i < (PIC2_ARITH_CACHE - 1); i++) {
++	if (cc == *p++)
++	    break;
++    }
++    if (i == (PIC2_ARITH_CACHE - 1)) {
++	pp = p - 1;
++	for (j = i; j > 0; j--) {
++	    *--p = *--pp;
++	}
++	pi->cache[k][0] = cc;
++	pic2_arith_encode_bit(pi, 1, pi->cache_hit_c);
++	pi->cache_hit_c = 16;
++
++	c2 = pi->vram_now[x - 1];
++	r = ((c1 & rmask) + (c2 & rmask)) >> (colbits * 2 + 1);
++	g = ((c1 & gmask) + (c2 & gmask)) >> (colbits     + 1);
++	b = ((c1 & bmask) + (c2 & bmask)) >> (              1);
++
++	r0 = (cc >> (colbits * 2)) & maxcol;
++	g0 = (cc >>  colbits     ) & maxcol;
++	b0 =  cc                   & maxcol;
++
++	r = r + g0 - g;
++	if (r < 0)
++	    r = 0;
++	else if (r > (short) maxcol)
++	    r = maxcol;
++
++	b = b + g0 - g;
++	if (b < 0)
++	    b = 0;
++	else if (b > (short) maxcol)
++	    b = maxcol;
++
++	pic2_arith_put_number(pi, 32, g, g0);
++	pic2_arith_put_number(pi, 48, r, r0);
++	pic2_arith_put_number(pi, 64, b, b0);
++    } else {
++	*--p = pi->cache[k][i / 2];
++	pi->cache[k][i / 2] = pi->cache[k][0];
++	pi->cache[k][0] = cc;
++
++	pic2_arith_encode_bit(pi, 0, pi->cache_hit_c);
++	pi->cache_hit_c = 15;
++	pic2_arith_encode_nn(pi, i, 17);
++    }
++}
++
++static void pic2_arith_press_line2(pi)
++struct pic2_info *pi;
++{
++    int x, xw, ymax;
++    pixel cc;
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid -1;
++    cc = pi->vram_now[xw - 1];			/* last color */
++    pi->vram_next[-1] = cc;
++
++    /* mark change point */
++    for (x = 0; x < xw; x++)
++	if (cc != pi->vram_next[x]) {
++	    pi->flag_next[x] = 1;
++	    cc = pi->vram_next[x];
++	} else
++	    pi->flag_next[x] = 0;
++
++    for (x = 0; x < xw; x++) {
++	if (pi->flag_now[x] == 1) {			/* change point */
++	    pi->flag2_now  [x + 1]++;
++	    pi->flag2_now  [x + 2]++;
++	    pi->flag2_next [x - 1]++;
++	    pi->flag2_next [x    ]++;
++	    pi->flag2_next [x + 1]++;
++	    pi->flag2_next2[x - 1]++;
++	    pi->flag2_next2[x    ]++;
++	    pi->flag2_next2[x + 1]++;
++
++	    /* write change point */
++	    pic2_arith_encode_bit(pi, 1, pi->flag2_now[x]);
++
++	    /* write color */
++	    pic2_arith_write_color(pi, x);
++
++	    /* if not last line, write chain */
++	    if (pi->ynow - 1 < ymax)
++		pic2_arith_press_chain(pi, x);
++	} else if (pi->flag_now[x] == 0)		/* not on chain */
++	    /* write change point */
++	    pic2_arith_encode_bit(pi, 0, pi->flag2_now[x]);
++	else				/* on chain */
++	     /* if not on last line, write next chain */
++	     if (pi->ynow - 1 < ymax)
++		 pic2_arith_press_chain(pi, x);
++    }
++}
++
++static int pic2_arith_press_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int i, xw, ymax;
++    long *c_sum, *c_0_sum;
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid -1;
++    c_sum = (long *) pi->mulu_tab;
++    c_0_sum = c_sum + PIC2_ARITH_CONTEXT +1;
++
++    pic2_handle_para(pi, 0);
++
++    xvbzero((char *) pi->flag2_next2 - 4,
++	    (8 + xw) * sizeof(pi->flag2_next2[0]));
++
++    if (pi->ynow == 0) {			/* first line */
++	int x;
++	pixel cc = 0;
++
++	if (pi->dd != 0) {			/* compress pass */
++	    unsigned short c_tab[PIC2_ARITH_CONTEXT];
++
++	    for (i = 0; i < PIC2_ARITH_CONTEXT; i++) {
++		unsigned long a, b;
++		a = c_0_sum[i];
++		b = c_sum[i];
++		while (a > 32767) {
++		    a /= 2;
++		    b /= 2;
++		}
++		if (a == b)
++		    c_tab[i] = 0xffff;		/* b==0 here, too */
++		else
++		    c_tab[i] = (65536 * a) / b; /* a < b, so less 65536 */
++	    }
++	    for (i = 0; i < 16384; i++) {
++		pi->mulu_tab[i] = (long) (i / 128 + 128) * (int) c_tab[i & 127] / 256;
++		if (pi->mulu_tab[i] == 0)
++		    pi->mulu_tab[i] = 1;	/* 0 is wrong */
++	    }
++	    for (i = 0; i < PIC2_ARITH_CONTEXT; i++)
++		pic2_write_short(pi, c_tab[i]);
++
++	    xvbzero((char *) pi->vram_now, xw * sizeof(pi->vram_now[0]));
++	} else {				/* statistical pass */
++	    xvbzero((char *) c_0_sum, PIC2_ARITH_CONTEXT * sizeof(c_0_sum[0]));
++	    xvbzero((char *) c_sum, PIC2_ARITH_CONTEXT * sizeof(c_sum[0]));
++	}
++    
++	/* initialize flags */
++	xvbzero((char *) pi->cache, 8 * 8 * 8 * sizeof(pi->cache[0]));
++	xvbzero((char *) pi->cache_pos, 8 * 8 * 8 * sizeof(pi->cache_pos[0]));
++
++	xvbzero((char *) pi->flag2_next - 4,
++		(8 + xw) * sizeof(pi->flag2_next[0]));
++	xvbzero((char *) pi->flag2_next2 - 4,
++		(8 + xw) * sizeof(pi->flag2_next2[0]));
++
++	pi->vram_next[-1] = cc;
++	for (x = 0; x < xw; x++)
++	    if (cc != pi->vram_next[x]) {
++		pi->flag_next[x] = 1;
++		cc = pi->vram_next[x];
++	    } else
++		pi->flag_next[x] = 0;
++
++	pi->aa = 0xffff;
++	cc = 0;
++	pi->cache_hit_c = 16;
++    } else					/* after second line */
++	pic2_arith_press_line2(pi);
++
++    if (pi->ynow ==  ymax) {
++	pi->ynow++;
++	pic2_handle_para(pi, 1);
++	pic2_handle_para(pi, 0);
++	pic2_arith_press_line2(pi);
++    }
++    /* line buffer for next data */
++    if (line != NULL)
++	*line = pi->vram_prev;
++
++    pi->ynow++;
++
++    if (pi->ynow - 1 < ymax) {
++	pic2_handle_para(pi, 1);
++	return (pi->ynow);
++    } else {					/* end */
++	if (pi->dd == 0) {			/* statistical pass */
++	    pi->dd = 1;
++	    pi->ynow = 0;
++	    pic2_handle_para(pi, 1);
++	    return (0);
++	} else {
++	    pic2_handle_para(pi, 1);
++	    pic2_arith_flush_bit_buf(pi);
++	    return (-2);			/* end */
++	}
++    }
++}
++
++static int pic2_arith_saver_init(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    pi->ynow = 0;
++
++    /* check the color depth */
++    if (pi->header->depth % 3)
++	pic2_error(pi, PIC2_DEPTH);
++
++    /* set next line function */
++    pi->next_line = pic2_arith_press_line;
++
++    if (line != NULL)
++	*line = pi->vram_next + 4;
++
++    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++
++    /* clear bit field marker */
++    pi->bs.rest = 0;
++    pi->bs.cur = 0;
++    pi->bs.zero = 0;
++    pi->bs.bits = 0;
++
++    return (0);
++}
++
++/*
++ * These functions are fast pic2 format compressor.
++ */
++static void pic2_fast_write_length(pi, n)
++struct pic2_info *pi;
++int n;
++{
++    int	a, b;
++    static const unsigned short len_data[8][2] = {
++	{1, 0},
++	{1, 0},
++	{3, 4},
++	{3, 5},
++	{5, 24},
++	{5, 25},
++	{5, 26},
++	{5, 27},
++    };
++
++    n++;
++    if (n < 8)
++	pic2_write_bits(pi, len_data[n][1], len_data[n][0]);
++    else {
++	a = 0;
++	b = 2;
++	while (n > b - 1) {
++	    a = a + 1;
++	    b = b * 2;
++	}
++	pic2_write_bits(pi, 0xfffffffe, a + 1);
++	if (a > 0)
++	    pic2_write_bits(pi, n - b / 2, a);
++    }
++}
++
++static void pic2_fast_press_chain(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    int ymax;
++    pixel cc;
++
++    ymax = pi->block->y_wid -1;
++    cc = pi->vram_now[x];
++
++    if (pi->ynow - 1 == ymax) {
++	pic2_write_bits(pi, 0, 1);
++	return;
++    }
++    if (pi->flag_next[x] == 1 && pi->vram_next[x] == cc) {
++	pi->flag_next[x] = -1;
++	pic2_write_bits(pi, 3, 2);
++    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == cc) {
++	pi->flag_next[x - 1] = -1;
++	pic2_write_bits(pi, 11, 4);
++    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == cc) {
++	pi->flag_next[x + 1] = -1;
++	pic2_write_bits(pi, 9, 4);
++    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == cc) {
++	pi->flag_next[x - 2] = -1;
++	pic2_write_bits(pi, 10, 4);
++    } else if ((pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == cc)
++		&& !(pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == cc)) {
++	pi->flag_next[x + 2] = -1;
++	pic2_write_bits(pi, 8, 4);
++    } else
++	pic2_write_bits(pi, 0, 1);
++}
++
++static void pic2_fast_press_chain2(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    int ymax;
++    pixel cc;
++    char *chain_buff;
++
++    ymax = pi->block->y_wid -1;
++    chain_buff = (char *) pi->mulu_tab;
++    cc = pi->vram_now[x];
++
++    if (pi->ynow - 1 == ymax) {
++	chain_buff[pi->cc++] = 0;
++	return;
++    }
++    if (pi->flag_next[x] == 1 && pi->vram_next[x] == cc) {
++	pi->flag_next[x] = -1;
++	chain_buff[pi->cc++] = 1;
++    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == cc) {
++	pi->flag_next[x - 1] = -1;
++	chain_buff[pi->cc++] = 2;
++    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == cc) {
++	pi->flag_next[x + 1] = -1;
++	chain_buff[pi->cc++] = 3;
++    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == cc) {
++	pi->flag_next[x - 2] = -1;
++	chain_buff[pi->cc++] = 4;
++    } else if ((pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == cc)
++	       && !(pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == cc)) {
++	pi->flag_next[x + 2] = -1;
++	chain_buff[pi->cc++] = 5;
++    } else
++	chain_buff[pi->cc++] = 0;
++}
++
++static void pic2_fast_flush_chain(pi)
++struct pic2_info *pi;
++{
++    int i;
++    char *chain_buf;
++
++    chain_buf = (char *) pi->mulu_tab;
++    for (i = 0; i < pi->cc; i++){
++	switch (chain_buf[i]) {
++	case 0:
++	    pic2_write_bits(pi, 0, 1);
++	    break;
++	case 1:
++	    pic2_write_bits(pi, 3, 2);
++	    break;
++	case 2:
++	    pic2_write_bits(pi, 11, 4);
++	    break;
++	case 3:
++	    pic2_write_bits(pi, 9, 4);
++	    break;
++	case 4:
++	    pic2_write_bits(pi, 10, 4);
++	    break;
++	case 5:
++	    pic2_write_bits(pi, 8, 4);
++	    break;
++	}
++    }
++    pi->cc = 0;
++}
++
++static void pic2_fast_write_color(pi, x)
++struct pic2_info *pi;
++int x;
++{
++    pixel cc, bc;
++    unsigned short j, k, m;
++    short depth, colbits;
++    pixel (*cache)[PIC2_FAST_CACHE];
++
++    depth = pi->header->depth;
++    colbits = depth / 3;
++    cache = (pixel (*)[PIC2_FAST_CACHE]) pi->cache;
++
++    bc = pi->vram_now[x - 1];
++    bc = pic2_exchange_rg(bc, colbits);
++    k = pic2_shift_bits(bc, 8 - depth);
++    cc = pi->vram_now[x];
++    m = pi->cache_pos[k];
++
++    for (j = 0; j < PIC2_FAST_CACHE; j++)
++	if (cache[k][(m + j) & (PIC2_FAST_CACHE - 1)] == cc)
++	    break;
++
++    if (j == PIC2_FAST_CACHE) {
++	m = (m - 1) & (PIC2_FAST_CACHE - 1);
++	pi->cache_pos[k] = m;
++	cache[k][m] = cc;
++
++	cc = pic2_exchange_rg(cc, colbits);
++	pic2_write_bits(pi, 0, 1);
++	pic2_write_bits(pi, cc, depth);
++    } else {
++	pic2_write_bits(pi, 1, 1);
++	pic2_write_bits(pi, j, 6);
++    }
++}
++
++static void pic2_fast_press_line2(pi)
++struct pic2_info *pi;
++{
++    int x, xw;
++    pixel cc;
++
++    xw = pi->block->x_wid;
++    cc = pi->vram_now[xw - 1];			/* last color */
++    pi->vram_next[-1] = cc;
++
++    /* mark change point */
++    for (x = 0; x < xw; x++)
++	if (cc != pi->vram_next[x]) {
++	    pi->flag_next[x] = 1;
++	    cc = pi->vram_next[x];
++	} else
++	    pi->flag_next[x] = 0;
++
++    for (x = 0; x < xw; x++)
++	if (pi->flag_now[x] == 1) {			/* change point */
++	    if (pi->aa >= 1023)
++		pi->aa++;
++	    pic2_fast_write_length(pi, pi->aa);
++	    pic2_fast_flush_chain(pi);
++	    pi->aa = 0;
++	    pic2_fast_write_color(pi, x);
++	    pic2_fast_press_chain(pi, x);
++	} else if (pi->flag_now[x] == 0) {
++	    pi->aa++;
++	} else {
++	    pic2_fast_press_chain2(pi, x);
++	    if (pi->cc == 1023) {
++		pic2_fast_write_length(pi, 1023);
++		pic2_fast_flush_chain(pi);
++		pi->aa = 0;
++	    }
++	}
++}
++
++static int pic2_fast_press_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int xw, ymax;
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid -1;
++
++    pic2_handle_para(pi, 0);
++
++    if (pi->ynow == 0) {			/* first line */
++	int x;
++	pixel cc = 0;
++
++	/* initialize flags */
++	xvbzero((char *) pi->cache, 256 * sizeof(pi->cache[0]));
++	xvbzero((char *) pi->cache_pos,
++		PIC2_FAST_CACHE * sizeof(pi->cache_pos[0]));
++
++	/* mark change point */
++	pi->vram_next[-1] = cc;
++	for (x = 0; x < xw; x++)
++	    if (cc != pi->vram_next[x]) {
++		pi->flag_next[x] = 1;
++		cc = pi->vram_next[x];
++	    } else
++		pi->flag_next[x] = 0;
++
++	pi->cc = 0;
++	pi->aa = 0;
++    } else					/* after second line */
++	pic2_fast_press_line2(pi);
++
++    if (pi->ynow ==  ymax) {
++	pi->ynow++;
++	pic2_handle_para(pi, 1);
++	pic2_handle_para(pi, 0);
++	pic2_fast_press_line2(pi);
++    }
++    /* line buffer for next data */
++    if (line != NULL)
++	*line = pi->vram_prev;
++
++    pi->ynow++;
++
++    if (pi->ynow - 1 < ymax) {
++	pic2_handle_para(pi, 1);
++	return (pi->ynow);
++    } else {					/* end */
++	pic2_handle_para(pi, 1);
++	if (pi->aa >= 1023)
++	    pi->aa++;
++	pic2_fast_write_length(pi, pi->aa);
++	pic2_fast_flush_chain(pi);
++	return (-2);				/* end */
++    }
++}
++
++static int pic2_fast_saver_init(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    pi->ynow = 0;
++
++    /* check the color depth */
++    if (pi->header->depth % 3)
++	pic2_error(pi, PIC2_DEPTH);
++
++    /* set next line function */
++    pi->next_line = pic2_fast_press_line;
++    if (line != NULL)
++	*line = pi->vram_next + 4;
++
++    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++
++    /* clear bit field marker */
++    pi->bs.rest = 0;
++    pi->bs.cur = 0;
++
++    return (0);
++}
++
++/*
++ * These functions are beta pic2 format compressor.
++ */
++static int pic2_beta_press_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int i, xw, ymax;
++    byte *p;
++    pixel *pc;
++    short depth, pixbyte, colbits;
++
++    depth = pi->header->depth;
++    pixbyte = depth / 8 + ((depth % 8) > 0);
++    colbits = depth / 3;
++
++    xw = pi->block->x_wid;
++    ymax = pi->block->y_wid - 1;
++
++    pc = pi->vram_now;
++    p = (byte *) pi->vram_prev;
++    if (pixbyte == 3) {
++	for (i = 0; i < xw; i++, pc++) {
++	    *p++ = *pc >> 16;
++	    *p++ = *pc >>  8;
++	    *p++ = *pc;
++	}
++	pic2_write_file(pi, pi->vram_prev, (size_t) (xw * 3));
++    } else if (pixbyte == 2) {
++	if (strncmp(pi->block->id, "P2BM", 4) == 0)
++	    for (i = 0; i < xw; i++, pc++) {
++		if (colbits == 5) {
++		    *pc = pic2_exchange_rg(*pc, colbits);
++		    *pc <<= 1;
++		}
++		*p++ = *pc >> 8;
++		*p++ = *pc;
++	    }
++	else
++	    for (i = 0; i < xw; i++, pc++) {
++		if (colbits == 5) {
++		    *pc = pic2_exchange_rg(*pc, colbits);
++		    *pc <<= 1;
++		}
++		*p++ = *pc;
++		*p++ = *pc >> 8;
++	    }
++	pic2_write_file(pi, pi->vram_prev, (size_t) (xw * 2));
++    } else {
++	for (i = 0; i < xw; i++, pc++)
++	    *p++ = *pc;
++	pic2_write_file(pi, pi->vram_prev, (size_t) xw);
++    }
++    if (line != NULL)
++	*line = pi->vram_now;
++
++    pi->ynow++;
++    if (pi->ynow > ymax)
++	return (-2);
++    return (pi->ynow);
++}
++
++static int pic2_beta_saver_init(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    pi->ynow = 0;
++
++    *line = pi->vram_now;
++    pi->next_line = pic2_beta_press_line;
++    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
++    return (0);
++}
++
++/*
++ * This function saves compressed data.
++ */
++static void pic2_write_data(pi, data, ptype, x_offset, y_offset, w, h,
++			    rmap, gmap, bmap, type, depth)
++struct pic2_info *pi;
++byte *data;
++int ptype;
++int x_offset, y_offset;
++int w, h;
++byte *rmap, *gmap, *bmap;
++int type, depth;
++{
++    int i, line;
++    pixel *linep;
++    short colbits;
++
++    colbits = pi->header->depth / 3;
++
++    line = pic2_save_block(pi, &linep, x_offset, y_offset, w, h,
++			   form_tab[type].id, 0xffffffff);
++    while (line >= 0) {
++	byte r, g, b;
++	int pic_idx;
++
++	pic_idx = line * w * ((ptype == PIC24) ? 3 : 1);
++
++	for (i = 0; i < w; i++) {
++	    if (ptype != PIC24) {
++		r = rmap[data[pic_idx]];
++		g = gmap[data[pic_idx]];
++		b = bmap[data[pic_idx]];
++		pic_idx++;
++	    } else {
++		r = data[pic_idx++];
++		g = data[pic_idx++];
++		b = data[pic_idx++];
++	    }
++	    if (pi->writing_grey)
++		r = g = b = MONO(r, g, b);
++
++	    r = pic2_convert_color_bits(r, 8, colbits);
++	    g = pic2_convert_color_bits(g, 8, colbits);
++	    b = pic2_convert_color_bits(b, 8, colbits);
++	    
++	    linep[i] = ((pixel) r << (colbits * 2))
++		     | ((pixel) g <<  colbits     )
++		     | ((pixel) b                 );
++	}
++	line = pic2_next_line(pi, &linep);
++	WaitCursor();
++    }
++}
++
++/*
++ * This function compress/extract one line buffer.
++ */
++static int pic2_next_line(pi, line)
++struct pic2_info *pi;
++pixel **line;
++{
++    int res;
++
++    res = pi->next_line(pi, line);
++    if (res == -2) {
++	if (pi->mode == PIC2_WRITE_MODE) {
++	    long new_pos;
++
++	    new_pos = pic2_tell_file(pi);
++	    pi->block->size = new_pos - pi->next_pos;
++	    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
++	    pic2_write_block_header(pi);
++	    pi->next_pos = new_pos;
++	    if (DEBUG)
++		pic2_show_pic2_info(pi);
++	}
++	pic2_free_buffer(pi);
++    }
++    return (res);
++}
++
++/*
++ * These functions find the pic2 image block.
++ * pic2_next_block:
++ *	moves the file pointer to the next image block.
++ * pic2_find_block:
++ *	find the first image block and move the file pointer to there.
++ */
++static int pic2_next_block(pi)
++struct pic2_info *pi;
++{
++    int i;
++
++    if (pi->mode != PIC2_READ_MODE)
++	return (-1);
++
++    /* go to block for read */
++    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
++
++    /* read the head of block header */
++    pic2_read_block_header1(pi);
++
++    /* end block ? */
++    if (pi->block->id[0] == 0)
++	return (0);
++
++    /* set current block */
++    pi->block_pos = pi->next_pos;
++
++    /* set next block */
++    pi->next_pos += pi->block->size;
++
++   /* check block id */
++    for (i = 0; i < n_form_tab; i++) {
++	if (xvbcmp(pi->block->id, form_tab[i].id, (size_t) 4) == 0)
++	    break;
++    }
++    if (i == n_form_tab)
++	return (2);
++
++    /* read the rest of block header */
++    pic2_read_block_header2(pi);
++
++    if (pi->block->x_offset + pi->block->x_wid > pi->x_max)
++	pi->x_max = pi->block->x_offset + pi->block->x_wid;
++
++    if (pi->block->y_offset + pi->block->y_wid > pi->y_max)
++	pi->y_max = pi->block->y_offset + pi->block->y_wid;
++
++    if (DEBUG)
++	pic2_show_pic2_info(pi);
++    return (1);
++}
++
++static int pic2_find_block(pi)
++struct pic2_info *pi;
++{
++    if (pi->mode != PIC2_READ_MODE)
++	return (-1);
++
++    pi->next_pos = pi->header->size;
++    return (pic2_next_block(pi));
++}
++
++/*
++ * These functions load/save the pic2 image block.
++ * pic2_load_block:
++ *	initializes loader informations by current block information.
++ * pic2_save_block:
++ *	initializes saver informations.
++ */
++static int pic2_load_block(pi)
++struct pic2_info *pi;
++{
++    int i;
++
++    for (i = 0; i < n_form_tab; i++) {
++	if (xvbcmp(pi->block->id, form_tab[i].id, (size_t) 4) == 0)
++	    break;
++    }
++    if (i == n_form_tab)
++	return (2);
++
++    pic2_alloc_buffer(pi);
++    return (form_tab[i].loader_init(pi));
++}
++
++static int pic2_save_block(pi, line, x, y, xw, yw, id, opaque)
++struct pic2_info *pi;
++pixel **line;
++int x, y, xw, yw;
++char *id;
++pixel opaque;
++{
++    int i;
++
++    for (i = 0; i < n_form_tab; i++) {
++	if (xvbcmp(id, form_tab[i].id, (size_t) 4) == 0)
++	    break;
++    }
++    if (i == n_form_tab)
++	return (2);
++
++    strncpy(pi->block->id, id, 4);
++    pi->block->x_wid = xw;
++    pi->block->y_wid = yw;
++    pi->block->x_offset = x;
++    pi->block->y_offset = y;
++    pi->block->reserve = 0;
++
++    if (x < 0)
++	x = 0;
++    if (y < 0)
++	y = 0;
++    if (x + xw > pi->x_max)
++	pi->x_max = x + xw;
++    if (y + yw > pi->y_max)
++	pi->y_max = y + yw;
++
++    if (opaque != 0xffffffff) {
++	pi->block->flag = 1;
++	pi->block->opaque = opaque;
++    } else {
++	pi->block->flag = 0;
++	pi->block->opaque = 0;
++    }
++    pic2_alloc_buffer(pi);
++
++    return (form_tab[i].saver_init(pi, line));
++}
++
++/*
++ * These functions set/get palettes.
++ * pic2_read_palette:
++ *	copy the palettes from pic2_info to PICINFO.
++ * pic2_write_palette:
++ *	copy the palettes from PICINFO to pic2_info.
++ */
++#ifndef PIC2_IGNORE_UNUSED_FUNCTIONS
++static void pic2_read_palette(pi, r, g, b)
++struct pic2_info *pi;
++byte *r, *g, *b;
++{
++    int i;
++
++    if (pi->n_pal > 256)
++	pi->n_pal = 256;
++
++    if (pi->pal_bits > 8)
++	pi->pal_bits = 8;
++
++    for (i = 0; i < pi->n_pal; i++) {
++	*r++ =pic2_convert_color_bits(pi->pal[i][0] >> (8 - pi->pal_bits),
++				      pi->pal_bits, 8);
++	*g++ =pic2_convert_color_bits(pi->pal[i][1] >> (8 - pi->pal_bits),
++				      pi->pal_bits, 8);
++	*b++ =pic2_convert_color_bits(pi->pal[i][2] >> (8 - pi->pal_bits),
++				      pi->pal_bits, 8);
++    }
++}
++
++static void pic2_write_palette(pi, n_pal, pal_bits, r, g, b)
++struct pic2_info *pi;
++int n_pal, pal_bits;
++byte *r, *g, *b;
++{
++    int i;
++
++    if (n_pal > 256)
++	pi->n_pal = 256;
++    else
++	pi->n_pal = n_pal;
++
++    if (pal_bits > 8)
++	pi->pal_bits = 8;
++    else
++	pi->pal_bits = pal_bits;
++
++    for (i = 0; i < n_pal; i++) {
++	pi->pal[i][0] = pic2_convert_color_bits(*r++, 8, pal_bits)
++	    << (8 - pal_bits);
++	pi->pal[i][1] = pic2_convert_color_bits(*g++, 8, pal_bits)
++	    << (8 - pal_bits);
++	pi->pal[i][2] = pic2_convert_color_bits(*b++, 8, pal_bits)
++	    << (8 - pal_bits);
++    }
++}
++#endif /* PIC2_IGNORE_UNUSED_FUNCTIONS */
++
++/*
++ * These function handle color bit.
++ * pic2_convert_color_bits:
++ *	converts color bits.
++ * pic2_pad_color_bits:
++ *	pads color bits.
++ * pic2_reduce_color_bits:
++ *	reduces color bits.
++ * pic2_exchange_rg:
++ *      exchanges red and green value.
++ */
++static byte pic2_convert_color_bits(c, from, to)
++int c, from, to;
++{
++    if (from == to)
++	return ((byte) c);
++    else if (from < to)
++	return (pic2_pad_color_bits(c, from, to));
++    else
++	return (pic2_reduce_color_bits(c, from, to));
++}
++
++static byte pic2_pad_color_bits(c, from, to)
++int c, from, to;
++{
++    byte p = 0;
++
++    do {
++	to -= from;
++	p |= pic2_shift_bits(c, to);
++    } while (to >= 0);
++    return (p);
++}
++
++static byte pic2_reduce_color_bits(c, from, to)
++int c, from, to;
++{
++    return ((byte) (c >> (from - to)));
++}
++
++static pixel pic2_exchange_rg(p, colbits)
++pixel p;
++int colbits;
++{
++    pixel rmask, gmask, bmask;
++
++    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
++    gmask = (0xff >> (8 - colbits)) <<  colbits;
++    bmask = (0xff >> (8 - colbits));
++
++    p = ((p << colbits) & rmask)
++      | ((p >> colbits) & gmask)
++      | ( p             & bmask);
++    return (p);
++}
++
++/*
++ * This function handles work memory buffer.
++ */
++static void pic2_handle_para(pi, mode)
++struct pic2_info *pi;
++int mode;
++{
++    static pixel *vram_prev, *vram_now, *vram_next;
++    static short *flag_now, *flag_next;
++    static short *flag2_now, *flag2_next, *flag2_next2;
++
++    switch (mode) {
++    case 0:
++	vram_prev = pi->vram_prev;
++	vram_now = pi->vram_now;
++	vram_next = pi->vram_next;
++	flag_now = pi->flag_now;
++	flag_next = pi->flag_next;
++	flag2_now = pi->flag2_now;
++	flag2_next = pi->flag2_next;
++	flag2_next2 = pi->flag2_next2;
++	pi->vram_prev += 4;
++	pi->vram_now += 4;
++	pi->vram_next += 4;
++	pi->flag_now += 4;
++	pi->flag_next += 4;
++	pi->flag2_now += 4;
++	pi->flag2_next += 4;
++	pi->flag2_next2 += 4;
++	break;
++    case 1:
++	pi->vram_prev = vram_now;
++	pi->vram_now = vram_next;
++	pi->vram_next = vram_prev;
++	pi->flag_now = flag_next;
++	pi->flag_next = flag_now;
++	pi->flag2_now = flag2_next;
++	pi->flag2_next = flag2_next2;
++	pi->flag2_next2 = flag2_now;
++	break;
++    }
++}
++
++/*
++ * These functions alloc/free work memory.
++ * pic2_alloc_buffer:
++ *	alloc work memory buffer.
++ * pic2_free_buffer:
++ *	free work memory buffer.
++ */
++static int pic2_alloc_buffer(pi)
++struct pic2_info *pi;
++{
++    int wid;
++    byte *p;
++
++    if (pi->buf != NULL)
++	return (-1);
++
++    wid = pi->block->x_wid;
++
++    p = pi->buf = (byte *) pic2_new((wid + 8) * sizeof(pixel) * 3
++				    + sizeof(pi->cache[0]) * 8 * 8 * 8
++				    + sizeof(pi->cache_pos[0]) * 8 * 8 * 8
++				    + sizeof(pi->mulu_tab[0]) * 16384
++				    + sizeof(pi->flag_now[0]) * ((wid+8) * 5),
++				    "pic2_alloc_buffer");
++
++    pi->vram_prev = (pixel *) p;
++    p += (wid + 8) * sizeof(pixel);
++    pi->vram_now = (pixel *) p;
++    p += (wid + 8) * sizeof(pixel);
++    pi->vram_next = (pixel *) p;
++    p += (wid + 8) * sizeof(pixel);
++    pi->cache = (pixel (*)[PIC2_ARITH_CACHE]) p;
++    p += sizeof(pi->cache[0]) * 8 * 8 * 8;
++    pi->cache_pos = (unsigned short *) p;
++    p += sizeof(pi->cache_pos[0]) * 8 * 8 * 8;
++    pi->mulu_tab = (unsigned short *) p;
++    p += sizeof(pi->mulu_tab[0]) * 16384;
++    pi->flag_now = (short *) p;
++    p += sizeof(pi->flag_now[0]) * (wid + 8);
++    pi->flag_next = (short *) p;
++    p += sizeof(pi->flag_next[0]) * (wid + 8);
++    pi->flag2_now = (short *) p;
++    p += sizeof(pi->flag2_now[0]) * (wid + 8);
++    pi->flag2_next = (short *) p;
++    p += sizeof(pi->flag2_next[0]) * (wid + 8);
++    pi->flag2_next2 = (short *) p;
++    p += sizeof(pi->flag2_next2[0]) * (wid + 8);
++    return (0);
++}
++
++static void pic2_free_buffer(pi)
++struct pic2_info *pi;
++{
++    free(pi->buf);
++    pi->buf = NULL;
++}
++
++/*
++ * These functions handle the file pointer.
++ * pic2_seek_file:
++ *	moves the file pointer.
++ * pic2_tell_file:
++ *	tells a location of the file pointer.
++ */
++static long pic2_seek_file(pi, offset, whence)
++struct pic2_info *pi;
++long offset;
++int whence;
++{
++    long n;
++
++    n = fseek(pi->fp, offset, whence);
++    if (n < 0)
++	pic2_file_error(pi, PIC2_CORRUPT);
++
++    return (n);
++}
++
++static long pic2_tell_file(pi)
++struct pic2_info *pi;
++{
++    return (ftell(pi->fp));
++}
++
++/*
++ * These functions handle file.
++ * pic2_read_file:
++ *	reads data from the file.
++ * pic2_read_long:
++ *	reads long word data from the file and converts to internal expression.
++ * pic2_read_short:
++ *	reads word data from the file and converts to internal expression.
++ * pic2_read_char:
++ *	reads byte data from the file.
++ * pic2_write_file:
++ *	writes data to the file.
++ * pic2_write_long:
++ *	converts long word data to common expression and writes to the file.
++ * pic2_write_short:
++ *	converts word data to common expression and writes to the file.
++ * pic2_write_char:
++ *	writes byte data to the file.
++ */
++static int pic2_read_file(pi, buf, size)
++struct pic2_info *pi;
++void *buf;
++size_t size;
++{
++    if (fread(buf, (size_t) 1, size, pi->fp) < size)
++	pic2_file_error(pi, PIC2_CORRUPT);
++    return (0);
++}
++
++static long pic2_read_long(pi)
++struct pic2_info *pi;
++{
++    byte buf[4];
++
++    if (fread(buf, (size_t) 4, (size_t) 1, pi->fp) < 1)
++	pic2_file_error(pi, PIC2_CORRUPT);
++    return (pic2_cextolong(buf));
++}
++
++static short pic2_read_short(pi)
++struct pic2_info *pi;
++{
++    byte buf[2];
++
++    if (fread(buf, (size_t) 2, (size_t) 1, pi->fp) < 1)
++	pic2_file_error(pi, PIC2_CORRUPT);
++    return (pic2_cextoshort(buf));
++}
++
++static char pic2_read_char(pi)
++struct pic2_info *pi;
++{
++    int c;
++
++    if ((c = fgetc(pi->fp)) == EOF)
++	pic2_file_error(pi, PIC2_CORRUPT);
++    return ((char) c);
++}
++
++static int pic2_write_file(pi, buf, size)
++struct pic2_info *pi;
++void *buf;
++size_t size;
++{
++    if (fwrite(buf, (size_t) 1, size, pi->fp) < size)
++	pic2_error(pi, PIC2_WRITE);
++    return (0);
++}
++
++static int pic2_write_long(pi, n)
++struct pic2_info *pi;
++long n;
++{
++    byte buf[4];
++
++    pic2_longtocex(buf, n);
++    if (fwrite(buf, (size_t) 4, (size_t) 1, pi->fp) < 1)
++	pic2_error(pi, PIC2_WRITE);
++    return (0);
++}
++
++static int pic2_write_short(pi, n)
++struct pic2_info *pi;
++int n;
++{
++    byte buf[2];
++
++    pic2_shorttocex(buf, n);
++    if (fwrite(buf, (size_t) 2, (size_t) 1, pi->fp) < 1)
++	pic2_error(pi, PIC2_WRITE);
++    return (0);
++}
++
++static int pic2_write_char(pi, c)
++struct pic2_info *pi;
++int c;
++{
++    if (fputc(c, pi->fp) == EOF)
++	pic2_error(pi, PIC2_WRITE);
++    return (0);
++}
++
++/*
++ * These  functions access the bit stream.
++ * pic2_read_bits:
++ *	reads the specified bits from the file.
++ * pic2_write_bits:
++ *	writes the specified bits to the file.
++ * pic2_flush_bits:
++ *	flushes bit buffer to the file.
++ */
++static unsigned long pic2_read_bits(pi, bits)
++struct pic2_info *pi;
++int bits;
++{
++    unsigned long r = 0;
++
++    while (bits > 0) {
++	while (pi->bs.rest > 0 && bits > 0) {
++	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
++	    pi->bs.cur <<= 1;
++	    pi->bs.rest--;
++	    bits--;
++	}
++	if (bits > 0) {
++	    int c;
++	    if ((c = fgetc(pi->fp)) == EOF)
++		pic2_file_error(pi, PIC2_CORRUPT);
++	    pi->bs.cur  = (byte) c;
++	    pi->bs.rest = 8;
++	}
++    }
++    return r;
++}
++
++static void pic2_write_bits(pi, dat, bits)
++struct pic2_info *pi;
++unsigned long dat;
++int bits;
++{
++    unsigned long dat_mask = 1 << (bits - 1);
++
++    while (bits > 0) {
++	while (pi->bs.rest < 8 && bits > 0) {
++	    pi->bs.cur <<= 1;
++	    if (dat & dat_mask)
++		pi->bs.cur |= 1;
++	    pi->bs.rest++;
++	    bits--;
++	    dat_mask >>= 1;
++	}
++	if (pi->bs.rest >= 8) {
++	    if ((fputc((int) pi->bs.cur, pi->fp)) == EOF)
++		pic2_error(pi, PIC2_WRITE);
++	    pi->bs.cur  = 0;
++	    pi->bs.rest = 0;
++	}
++    }
++}
++
++static void pic2_flush_bits(pi)
++struct pic2_info *pi;
++{
++    if (pi->bs.rest < 8) {
++	pi->bs.cur <<= 8 - pi->bs.rest;
++	if (fputc((int) pi->bs.cur, pi->fp) == EOF)
++		pic2_error(pi, PIC2_WRITE);
++	pi->bs.cur  = 0;
++	pi->bs.rest = 0;
++    }
++}
++
++/*
++ * These functions initialize or clean up structures.
++ * pic2_init_info:
++ *	initializes a pic2_info structure.
++ * pic2_cleanup_pic2_info:
++ *	cleans up a pic_info structure.
++ * pic2_cleanup_pinfo:
++ *	cleans up a PICINFO structure.
++ */
++static void pic2_init_info(pi)
++struct pic2_info *pi;
++{
++    xvbzero((char *) pi, sizeof(struct pic2_info));
++    pi->header = pic2_new(sizeof(struct pic2_header), "pic2_init_info#1");
++    pi->block = pic2_new(sizeof(struct pic2_block), "pic2_init_info#2");
++}
++
++static void pic2_cleanup_pic2_info(pi, writing)
++struct pic2_info *pi;
++int writing;
++{
++    if (!writing && pi->fp)
++	fclose(pi->fp);
++    if (pi->header)
++	free(pi->header);
++    if (pi->block)
++	free(pi->block);
++    pi->fp = NULL;
++    pi->header = NULL;
++    pi->block = NULL;
++    pi->comment = NULL;
++}
++
++static void pic2_cleanup_pinfo(pinfo)
++PICINFO *pinfo;
++{
++    if (pinfo->pic){
++	free(pinfo->pic);
++	pinfo->pic = NULL;
++    }
++    if (pinfo->comment){
++	free(pinfo->comment);
++	pinfo->comment = NULL;
++    }
++}
++
++/*
++ * Error Handlers.
++ * pic2_memory_error:
++ *	shows an error message, and terminates.
++ * pic2_error:
++ *	shows an non-file error message, and jumps to the entry for errors.
++ * pic2_file_error:
++ *	shows an file error message, and jumps to the entry for errors.
++ */
++static void pic2_memory_error(scm, fn)
++char *scm, *fn;
++{
++    char buf[128];
++    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
++    FatalError(buf);
++}
++
++static void pic2_error(pi, mn)
++struct pic2_info *pi;
++int mn;
++{
++    SetISTR(ISTR_WARNING, "%s", pic2_msgs[mn]);
++    longjmp(pi->jmp, 1);
++}
++
++static void pic2_file_error(pi, mn)
++    struct pic2_info *pi;
++    int mn;
++{
++    if (feof(pi->fp))
++	SetISTR(ISTR_WARNING, "%s (end of file)", pic2_msgs[mn]);
++    else
++	SetISTR(ISTR_WARNING, "%s (%s)", pic2_msgs[mn], ERRSTR(errno));
++    longjmp(pi->jmp, 1);
++}
++
++static void pic2_show_pic2_info(pi)
++    struct pic2_info *pi;
++{
++    fprintf(stderr, "file size: %ld.\n", pi->fsize);
++    fprintf(stderr, "full image size: %dx%d\n", pi->x_max, pi->y_max);
++    fprintf(stderr, "number of palettes: %d\n", pi->n_pal);
++    fprintf(stderr, "depth of palettes: %d\n", pi->pal_bits);
++    fprintf(stderr, "current block position: %d\n", pi->block_pos);
++    fprintf(stderr, "next block position: %d\n\n", pi->next_pos);
++
++    fprintf(stderr, "header flag: %x\n", pi->header->flag);
++    fprintf(stderr, "header size: %d\n", pi->header->size);
++    fprintf(stderr, "x_aspect: %d, y_aspect: %d\n",
++	    pi->header->x_aspect, pi->header->y_aspect);
++    fprintf(stderr, "number of color bits: %d\n\n", pi->header->depth);
++
++    fprintf(stderr, "image block id: %s\n", pi->block->id);
++    fprintf(stderr, "image block size: %d\n", pi->block->size);
++    fprintf(stderr, "block flag: %x\n", pi->block->flag);
++
++    fprintf(stderr, "block image size: %dx%d\n",
++	    pi->block->x_wid, pi->block->y_wid);
++    fprintf(stderr, "x_offset: %d\n", pi->block->x_offset);
++    fprintf(stderr, "y_offset: %d\n", pi->block->y_offset);
++    fprintf(stderr, "opaque color: %x\n\n", pi->block->opaque);
++}
++
++/*
++ * This function is simular to strncpy.
++ * But this fills whitespaces after the null charactor.
++ */
++static char *pic2_strncpy(dest, src, n)
++char *dest, *src;
++size_t n;
++{
++    char *r;
++
++    r = dest;
++    while (n--)
++	if ((src != NULL) && (*src != '\r') && (*src != '\n') && *src)
++	    *dest++ = *src++;
++	else
++	    *dest++ = ' ';
++    return (r);
++}
++
++/*
++ * These function create memory block.
++ */
++static void *pic2_malloc(size, fn)
++size_t size;
++char *fn;
++{
++    void *p;
++
++    p = (void *) malloc(size);
++    if (p == NULL)
++	pic2_memory_error("malloc", fn);
++    return (p);
++}
++
++static void *pic2_new(size, fn)
++size_t size;
++char *fn;
++{
++    void *p;
++
++    p = (void *) pic2_malloc(size, fn);
++    xvbzero((char *) p, size);
++    return (p);
++}
++
++
++
++
++/**** Stuff for PIC2Dialog box ****/
++
++#define TWIDE    320
++#define THIGH	 178
++#define T_NBUTTS 2
++#define T_BOK    0
++#define T_BCANC  1
++#define BUTTH    24
++
++static void drawTD    PARM((int,int,int,int));
++static void clickTD   PARM((int,int));
++static void doCmd     PARM((int));
++static void writePIC2 PARM((void));
++
++/* local variables */
++static FILE  *fp;
++static char  *filename;
++static int   colorType;
++static int   append;
++static int   x_offset;
++static int   y_offset;
++static BUTT  tbut[T_NBUTTS];
++static RBUTT *typeRB;
++static RBUTT *depthRB;
++
++
++
++/***************************************************/
++void CreatePIC2W()
++{
++    int	     y;
++
++    pic2W = CreateWindow("xv pic2", "XVpic2", NULL, 
++			TWIDE, THIGH, infofg, infobg, 0);
++    if (!pic2W)
++	FatalError("can't create pic2 window!");
++
++    XSelectInput(theDisp, pic2W,
++		 ExposureMask | ButtonPressMask | KeyPressMask);
++
++    BTCreate(&tbut[T_BOK], pic2W, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH, 
++	     "Ok", infofg, infobg, hicol, locol);
++
++    BTCreate(&tbut[T_BCANC], pic2W, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH, 
++	     "Cancel", infofg, infobg, hicol, locol);
++
++    y = 55;
++    typeRB = RBCreate(NULL, pic2W, 36, y,          "P2SS",
++		      infofg, infobg,hicol,locol);
++    RBCreate(typeRB, pic2W, 36, y+18,              "P2SF",
++	     infofg, infobg,hicol,locol);
++    RBCreate(typeRB, pic2W, 36, y+36,              "P2BM",
++	     infofg, infobg, hicol, locol);
++    RBCreate(typeRB, pic2W, 36, y+54,              "P2BI",
++	     infofg, infobg, hicol, locol);
++
++    depthRB = RBCreate(NULL, pic2W, TWIDE/2-16, y, "  3bit",
++		       infofg, infobg,hicol,locol);
++    RBCreate(depthRB, pic2W, TWIDE/2-16, y+18,     "  6bit",
++	     infofg, infobg,hicol,locol);
++    RBCreate(depthRB, pic2W, TWIDE/2-16, y+36,     "  9bit",
++	     infofg, infobg, hicol, locol);
++    RBCreate(depthRB, pic2W, TWIDE/2-16, y+54,     "12bit",
++	     infofg, infobg, hicol, locol);
++    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y,      "15bit",
++	     infofg, infobg, hicol, locol);
++    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+18,   "18bit",
++	     infofg, infobg, hicol, locol);
++    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+36,   "21bit",
++	     infofg, infobg, hicol, locol);
++    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+54,   "24bit",
++	     infofg, infobg, hicol, locol);
++
++    XMapSubwindows(theDisp, pic2W);
++}
++
++
++/***************************************************/
++void PIC2Dialog(vis)
++int vis;
++{
++    if (vis) {
++	CenterMapWindow(pic2W, tbut[T_BOK].x + tbut[T_BOK].w/2,
++			tbut[T_BOK].y + tbut[T_BOK].h/2, TWIDE, THIGH);
++    }
++    else     XUnmapWindow(theDisp, pic2W);
++    pic2Up = vis;
++}
++
++
++/***************************************************/
++int PIC2CheckEvent(xev)
++XEvent *xev;
++{
++    /* check event to see if it's for one of our subwindows.  If it is,
++       deal accordingly, and return '1'.  Otherwise, return '0' */
++
++    int rv;
++    rv = 1;
++
++    if (!pic2Up)
++	return (0);
++
++    if (xev->type == Expose) {
++	int x,y,w,h;
++	XExposeEvent *e = (XExposeEvent *) xev;
++	x = e->x;  y = e->y;  w = e->width;  h = e->height;
++
++	if (e->window == pic2W)       drawTD(x, y, w, h);
++	else rv = 0;
++    }
++
++    else if (xev->type == ButtonPress) {
++	XButtonEvent *e = (XButtonEvent *) xev;
++	int x,y;
++	x = e->x;  y = e->y;
++
++	if (e->button == Button1) {
++	    if      (e->window == pic2W)     clickTD(x,y);
++	    else rv = 0;
++	}  /* button1 */
++	else rv = 0;
++    }  /* button press */
++
++
++    else if (xev->type == KeyPress) {
++	XKeyEvent *e = (XKeyEvent *) xev;
++	char buf[128];  KeySym ks;  XComposeStatus status;  
++	int stlen;
++	
++	stlen = XLookupString(e,buf,128,&ks,&status);
++	buf[stlen] = '\0';
++
++	if (e->window == pic2W) {
++	    if (stlen) {
++		if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
++		    FakeButtonPress(&tbut[T_BOK]);
++		}
++		else if (buf[0] == '\033') {            /* ESC */
++		    FakeButtonPress(&tbut[T_BCANC]);
++		}
++	    }
++	}
++	else rv = 0;
++    }
++    else rv = 0;
++
++    if (rv == 0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
++	XBell(theDisp, 50);
++	rv = 1;   /* eat it */
++    }
++
++    return (rv);
++}
++
++
++/***************************************************/
++int PIC2SaveParams(fname, col)
++char *fname;
++int col;
++{
++    filename = fname;
++    colorType = col;
++
++    /* see if we can open the output file before proceeding */
++    fp = pic2_OpenOutFile(filename, &append);
++    if (!fp)
++	return (-1);
++
++    RBSetActive(typeRB,0,1);
++    RBSetActive(typeRB,1,1);
++    RBSetActive(typeRB,2,1);
++    RBSetActive(typeRB,3,1);
++    RBSelect(typeRB,0);
++
++
++    if (append) {
++	struct pic2_info pic2;
++
++	pic2_init_info(&pic2);
++	pic2.fp = fp;
++	pic2_read_header(&pic2);
++
++	RBSetActive(depthRB,0,0);
++	RBSetActive(depthRB,1,0);
++	RBSetActive(depthRB,2,0);
++	RBSetActive(depthRB,3,0);
++	RBSetActive(depthRB,4,0);
++	RBSetActive(depthRB,5,0);
++	RBSetActive(depthRB,6,0);
++	RBSetActive(depthRB,7,0);
++
++	switch (pic2.header->depth) {
++	case  3:
++	    RBSetActive(depthRB,0,1);
++	    RBSelect(depthRB,0);
++	    RBSetActive(typeRB,3,0);
++	    break;
++	case  6:
++	    RBSetActive(depthRB,1,1);
++	    RBSelect(depthRB,1);
++	    RBSetActive(typeRB,3,0);
++	    break;
++	case  9:
++	    RBSetActive(depthRB,2,1);
++	    RBSelect(depthRB,2);
++	    break;
++	case 12:
++	    RBSetActive(depthRB,3,1);
++	    RBSelect(depthRB,3);
++	    break;
++	case 15:
++	    RBSetActive(depthRB,4,1);
++	    RBSelect(depthRB,4);
++	    break;
++	case 18:
++	    RBSetActive(depthRB,5,1);
++	    RBSelect(depthRB,5);
++	    RBSetActive(typeRB,3,0);
++	    break;
++	case 21:
++	    RBSetActive(depthRB,6,1);
++	    RBSelect(depthRB,6);
++	    RBSetActive(typeRB,3,0);
++	    break;
++	case 24:
++	    RBSetActive(depthRB,7,1);
++	    RBSelect(depthRB,7);
++	    RBSetActive(typeRB,3,0);
++	    break;
++	default: {
++	    char str[512];
++	    sprintf(str, "unsupported PIC2 file '%s'.", filename);
++	    ErrPopUp(str, "\nBummer");
++	    CloseOutFile(fp, filename, 0);
++	    fp = OpenOutFile(fname);
++	    if (!fp)
++		return (-1);
++	    break;
++	}
++	}
++	pic2_seek_file(&pic2, 0, SEEK_SET);
++	pic2_cleanup_pic2_info(&pic2, 1);
++    } else {
++	RBSetActive(depthRB,0,1);
++	RBSetActive(depthRB,1,1);
++	RBSetActive(depthRB,2,1);
++	RBSetActive(depthRB,3,1);
++	RBSetActive(depthRB,4,1);
++	RBSetActive(depthRB,5,1);
++	RBSetActive(depthRB,6,1);
++	RBSetActive(depthRB,7,1);
++	RBSelect(depthRB,7);
++	RBSetActive(typeRB,3,0);
++    }
++    return (0);
++}
++
++
++/***************************************************/
++static void drawTD(x,y,w,h)
++int x,y,w,h;
++{
++    char *title  = "Save PIC2 file...";
++    int  i;
++    XRectangle xr;
++
++    xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
++    XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
++
++    XSetForeground(theDisp, theGC, infofg);
++    XSetBackground(theDisp, theGC, infobg);
++
++    for (i = 0; i < T_NBUTTS; i++)
++	BTRedraw(&tbut[i]);
++
++    ULineString(pic2W, typeRB->x-16, typeRB->y-3-DESCENT,   "FormatType");
++    ULineString(pic2W, depthRB->x-16, depthRB->y-3-DESCENT, "ColorDepth");
++    RBRedraw(typeRB, -1);
++    RBRedraw(depthRB, -1);
++
++    DrawString(pic2W, 20, 29, title);
++
++    XSetClipMask(theDisp, theGC, None);
++}
++
++static void clickTD(x,y)
++int x,y;
++{
++    int i;
++    BUTT *bp;
++
++    /* check BUTTs */
++
++    /* check the RBUTTS first, since they don't DO anything */
++    if ((i = RBClick(typeRB, x,y)) >= 0) { 
++	(void) RBTrack(typeRB, i);
++	return;
++    } else if ((i = RBClick(depthRB, x,y)) >= 0) { 
++	(void) RBTrack(depthRB, i);
++	if ((2 <= i) && (i <= 4))
++	    RBSetActive(typeRB,3,1);
++	else {
++	    RBSetActive(typeRB,3,0);
++	    if (RBWhich(typeRB) == 3)
++		RBSelect(typeRB,0);
++	return;
++	}
++    }
++    for (i = 0; i < T_NBUTTS; i++) {
++	bp = &tbut[i];
++	if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
++	    break;
++    }
++    if (i < T_NBUTTS)  /* found one */
++	if (BTTrack(bp))
++	    doCmd(i);
++}
++
++
++
++/***************************************************/
++static void doCmd(cmd)
++int cmd;
++{
++    switch (cmd) {
++    case T_BOK: {
++	char *fullname;
++	char buf[64], *x_offsetp, *y_offsetp;
++	static char *labels[] = { "\nOk", "\033Cancel" };
++        XEvent event;
++	int i;
++
++	strcpy(buf, "0,0");
++	i = GetStrPopUp("Enter offset (x,y):", labels, 2, buf, 64,
++			"01234567890,", 1);
++
++	if (i)
++	    return;
++	if (strlen(buf)==0)
++	    return;
++
++	x_offsetp = buf;
++	y_offsetp = index(buf, ',');
++	if (!y_offsetp)
++	    return;
++	*(y_offsetp++) = '\0';
++	if ((*x_offsetp == '\0') || (*y_offsetp == '\0'))
++	    return;
++	x_offset = atoi(x_offsetp);
++	y_offset = atoi(y_offsetp);
++
++        XNextEvent(theDisp, &event);
++	HandleEvent(&event, &i);
++
++	writePIC2();
++	PIC2Dialog(0);
++
++	fullname = GetDirFullName();
++	if (!ISPIPE(fullname[0])) {
++	    XVCreatedFile(fullname);
++	    StickInCtrlList(0);
++	}
++    }
++	break;
++    case T_BCANC:
++	pic2_KillNullFile(fp);
++	PIC2Dialog(0);
++	break;
++    default:
++	break;
++    }
++}
++
++
++/*******************************************/
++static void writePIC2()
++{
++    int   w, h, nc, rv, type, depth, ptype, pfree;
++    byte *inpix, *rmap, *gmap, *bmap;
++
++
++    WaitCursor();
++    inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
++
++    if (colorType == F_REDUCED)
++	colorType = F_FULLCOLOR;
++
++    switch (RBWhich(typeRB)) {
++    case 0: type = P2SS;  break;
++    case 1: type = P2SF;  break;
++    case 2: type = P2BM;  break;
++    case 3: type = P2BI;  break;
++    default: type = P2SS; break;
++    }
++    switch (RBWhich(depthRB)) {
++    case 0: depth =  3;  break;
++    case 1: depth =  6;  break;
++    case 2: depth =  9;  break;
++    case 3: depth = 12;  break;
++    case 4: depth = 15;  break;
++    case 5: depth = 18;  break;
++    case 6: depth = 21;  break;
++    case 7: depth = 24;  break;
++    default: depth = 24; break;
++    }
++    rv = WritePIC2(fp, inpix, ptype, w, h,
++		   rmap, gmap, bmap, nc, colorType, filename,
++		   type, depth, x_offset, y_offset, append, picComments);
++
++    if (CloseOutFile(fp, filename, rv) == 0)
++	DirBox(0);
++
++    if (pfree)
++	free(inpix);
++}
++#endif /* HAVE_PIC2 */
+diff -urN xv-3.10a/xvtext.c xv-3.10a-jp-extension-current/xvtext.c
+--- xv-3.10a/xvtext.c	Sat Jan 14 08:46:28 1995
++++ xv-3.10a-jp-extension-current/xvtext.c	Thu Nov 21 16:38:20 1996
+@@ -19,9 +19,13 @@
+ #include "copyright.h"
+ 
+ #include "xv.h"
+-
++#ifdef TV_MULTILINGUAL
++#include "xvml.h"
++#endif
+ 
+-#define BUTTW 80
++#define BUTTW1 80
++#define BUTTW2 60
++#define BUTTW3 110
+ #define BUTTH 24
+ 
+ #define TOPMARGIN 30       /* from top of window to top of text window */
+@@ -36,11 +40,28 @@
+ #define TV_ASCII    0
+ #define TV_HEX      1
+ #define TV_CLOSE    2
+-#define TV_NBUTTS   3
++
++#define TV_E_NBUTTS 3
++
++#ifdef TV_L10N
++#  define TV_RESCAN   3
++#  define TV_USASCII  4
++#  define TV_JIS      5
++#  define TV_EUCJ     6
++#  define TV_MSCODE   7
+ 
++#  define TV_J_NBUTTS 8
++#endif
+ 
+ #define TITLELEN 128
+ 
++#ifdef TV_MULTILINGUAL
++struct coding_spec {
++    struct coding_system coding_system;
++    char *(*converter)PARM((char *, int, int *));
++};
++#endif
++
+ /* data needed per text window */
+ typedef struct {  Window win, textW;
+ 		  int    vis, wasvis;
+@@ -57,16 +78,89 @@
+ 		  int    chwide, chhigh;   /* size of textW, in chars */
+ 		  int    hexmode;          /* true if disp Hex, else Ascii */
+ 		  SCRL   vscrl, hscrl;
+-		  BUTT   but[TV_NBUTTS], nopBut;
++#ifdef TV_L10N
++		  int    code;         /* current charactor code */
++		  BUTT   but[TV_J_NBUTTS], nopBut;
++#else
++		  BUTT   but[TV_E_NBUTTS], nopBut;
++#endif
++#ifdef TV_MULTILINGUAL
++/*		  int    codeset; */
++                  struct coding_spec ccs;	/* current coding_spec */
++		  BUTT   csbut;
++		  char *cv_text;
++		  int cv_len;
++		  struct context *ctx;
++		  struct ml_text *txt;
++		  struct csinfo_t *cs;
++#endif
+ 		} TVINFO;
+ 
+ 
+ static TVINFO   tinfo[MAXTVWIN];
+ static int      hasBeenSized = 0;
+ static int      haveWindows  = 0;
++static int      nbutts;		/* # of buttons */
+ static int      mfwide, mfhigh, mfascent;   /* size of chars in mono font */
+ static int     *event_retP, *event_doneP;   /* used in tvChkEvent() */
+-
++#ifdef TV_MULTILINGUAL
++# define TV_PLAIN          0
++# define TV_ISO_8859_1     1
++# define TV_ISO_2022_JP    2
++# define TV_EUC_JAPAN      3
++# define TV_ISO_2022_INT_1 4
++# define TV_ISO_2022_KR    5
++# define TV_EUC_KOREA      6
++# define TV_ISO_2022_SS2_8 7
++# define TV_ISO_2022_SS2_7 8
++# define TV_SHIFT_JIS      9
++# define TV_NCSS          10
++static char *codeSetNames[TV_NCSS] = {
++    "plain",
++    "iso-8859-1",
++    "iso-2022-jp",
++    "euc-japan",
++    "iso-2022-int-1",
++    "iso-2022-kr",
++    "euc-korea",
++    "iso-2022-ss2-8",
++    "iso-2022-ss2-7",
++    "Shift JIS",
++};
++static struct coding_spec coding_spec[TV_NCSS] = {
++    /* --- G0 ---   --- G1 ---   --- G2 ---   --- G3 ---  GL GR EOL SF LS */
++    /* plain */
++    {{{{ 1,94,'B'}, { 1,94,'B'}, { 1,94,'B'}, { 1,94,'B'}}, 0, 0,  0, 1, 1},
++     NULL},
++    /* iso-8859-1 */
++    {{{{ 1,94,'B'}, { 1,96,'A'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
++     NULL},
++    /* iso-2022-jp */
++    {{{{ 1,94,'B'}, {-1,94,'B'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 0,  0, 1, 0},
++     NULL},
++    /* euc-japan */
++    {{{{ 1,94,'B'}, { 2,94,'B'}, { 1,94,'J'}, { 2,94,'D'}}, 0, 1,  0, 1, 0},
++     NULL},
++    /* iso-2022-int-1 */
++    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 1, 1},
++     NULL},
++    /* iso-2022-kr */
++    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 1},
++     NULL},
++    /* euc-korea */
++    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
++     NULL},
++    /* iso-2022-ss2-8 */
++    {{{{ 1,94,'B'}, {-1,94,'C'}, { 0,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
++     NULL},
++    /* iso-2022-ss2-7 */
++    {{{{ 1,94,'B'}, {-1,94,'C'}, { 0,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 1, 0},
++     NULL},
++    /* shift jis */
++    {{{{ 1,94,'B'}, { 2,94,'B'}, { 1,94,'J'}, { 2,94,'D'}}, 0, 1,  1, 1, 0},
++     sjis_to_jis},
++};
++#endif
+ 
+ static void closeText       PARM((TVINFO *));
+ static int  tvChkEvent      PARM((TVINFO *, XEvent *));
+@@ -82,7 +176,15 @@
+ static void textKey         PARM((TVINFO *, int));
+ static void doHexAsciiCmd   PARM((TVINFO *, int));
+ static void computeText     PARM((TVINFO *));
+-
++#ifdef TV_L10N
++static int  selectCodeset         PARM((TVINFO *));
++#endif
++#ifdef TV_MULTILINGUAL
++static void setCodingSpec   PARM((TVINFO *, struct coding_spec *));
++static void createCsWins    PARM((char *));
++static void openCsWin       PARM((TVINFO *));
++static void closeCsWin      PARM((TVINFO *));
++#endif
+ 
+ /* HEXMODE output looks like this:
+ 0x00000000: 00 11 22 33 44 55 66 77 - 88 99 aa bb cc dd ee ff  0123456789abcdef
+@@ -99,11 +201,51 @@
+   XSetWindowAttributes  xswa;
+   TVINFO               *tv;
+   int                   gx,gy,gw,gh,gset,gx1,gy1;
+-  
++#ifdef TV_MULTILINGUAL
++  int			default_codeset;
++#endif
++
++#ifdef TV_L10N  
++  if (!xlocale) {
++#endif
++      mfwide = monofinfo->max_bounds.width;
++      mfhigh = monofinfo->ascent + monofinfo->descent;
++      mfascent = monofinfo->ascent;
++
++      nbutts = TV_E_NBUTTS;	/* # of buttons */
++#ifdef TV_L10N
++  }
++  else {
++      mfwide = monofsetinfo->max_logical_extent.width / 2;	/* shit! */
++      mfhigh = monofsetinfo->max_logical_extent.height + 1;
++      mfascent = mfhigh;
++
++      nbutts = TV_J_NBUTTS;	/* # of buttons */
++  }
++#endif
+ 
+-  mfwide = monofinfo->max_bounds.width;
+-  mfhigh = monofinfo->ascent + monofinfo->descent;
+-  mfascent = monofinfo->ascent;
++#ifdef TV_MULTILINGUAL
++  {
++    char *dc = XGetDefault(theDisp, "xv", "codeSet");
++    if (dc == NULL) 
++      default_codeset = TV_DEFAULT_CODESET;
++    else {
++      for (i = 0; i < TV_NCSS; i++) {
++	if (strcmp(dc, codeSetNames[i]) == 0)
++	  break;
++      }
++      if (i >= TV_NCSS) {
++        if (strcmp(dc, "iso-2022") == 0)
++	  default_codeset = TV_PLAIN;
++	else {
++	  SetISTR(ISTR_WARNING, "%s: unknown codeset.", dc);
++	  default_codeset = TV_PLAIN;
++	}
++      } else
++	default_codeset = i;
++    }
++  }
++#endif
+ 
+   /* compute default size of textview windows.  should be big enough to
+      hold an 80x24 text window */
+@@ -119,6 +261,14 @@
+   for (i=0; i<MAXTVWIN; i++) {
+     tv = &tinfo[i];
+ 
++#ifdef TV_MULTILINGUAL
++    tv->ctx = ml_create_context(ScreenOfDisplay(theDisp, theScreen));
++    tv->txt = NULL;
++    tv->cv_text = NULL;
++    tv->cv_len = 0;
++    ml_set_charsets(tv->ctx, &coding_spec[TV_PLAIN].coding_system);
++#endif
++
+     tv->win = CreateWindow((i<CMTWIN) ? "xv text viewer" : "xv image comments",
+ 			   "XVtextview", 
+ 			   (i<CMTWIN) ? geom : cmtgeom, 
+@@ -163,24 +313,56 @@
+     XSelectInput(theDisp, tv->textW, ExposureMask | ButtonPressMask);
+ 
+     
+-    BTCreate(&(tv->but[TV_ASCII]), tv->win, 0,0,BUTTW,BUTTH,
++    BTCreate(&(tv->but[TV_ASCII]), tv->win, 0,0,BUTTW1,BUTTH,
+ 	     "Ascii",infofg,infobg,hicol,locol);
+-    BTCreate(&(tv->but[TV_HEX]), tv->win, 0,0,BUTTW,BUTTH,
++    BTCreate(&(tv->but[TV_HEX]), tv->win, 0,0,BUTTW1,BUTTH,
+ 	     "Hex",infofg,infobg,hicol,locol);
+-    BTCreate(&(tv->but[TV_CLOSE]), tv->win, 0,0,BUTTW,BUTTH,
++    BTCreate(&(tv->but[TV_CLOSE]), tv->win, 0,0,BUTTW1,BUTTH,
+ 	     "Close",infofg,infobg,hicol,locol);
+ 
++#ifdef TV_L10N
++    if (xlocale) {
++	BTCreate(&(tv->but[TV_RESCAN]), tv->win, 0,0,BUTTW2,BUTTH,
++		 "RESCAN",infofg,infobg,hicol,locol);
++	BTCreate(&(tv->but[TV_USASCII]), tv->win, 0,0,BUTTW2,BUTTH,
++		 "ASCII",infofg,infobg,hicol,locol);
++	BTCreate(&(tv->but[TV_JIS]), tv->win, 0,0,BUTTW2,BUTTH,
++		 "JIS",infofg,infobg,hicol,locol);
++	BTCreate(&(tv->but[TV_EUCJ]), tv->win, 0,0,BUTTW2,BUTTH,
++		 "EUC-j",infofg,infobg,hicol,locol);
++	BTCreate(&(tv->but[TV_MSCODE]), tv->win, 0,0,BUTTW2,BUTTH,
++		 "MS Kanji",infofg,infobg,hicol,locol);
++    }
++#endif
++
+     BTCreate(&(tv->nopBut), tv->win, 0,0, (u_int) tv->vscrl.tsize+1,
+ 	     (u_int) tv->vscrl.tsize+1, "", infofg, infobg, hicol, locol);
+     tv->nopBut.active = 0;
+ 
+     XMapSubwindows(theDisp, tv->win);
+ 
++#ifdef TV_MULTILINGUAL
++    BTCreate(&tv->csbut, tv->win, 0, 0, BUTTW1, BUTTH, "Code Sets",
++	     infofg, infobg, hicol, locol);
++#endif
++
+     tv->text = (char *) NULL;
+     tv->textlen = 0;
+     tv->title[0] = '\0';
++#ifdef TV_L10N
++      tv->code = (xlocale ? LOCALE_DEFAULT : 0);
++#endif
++#ifdef TV_MULTILINGUAL
++    tv->ccs = coding_spec[default_codeset];
++#endif
+   }
+-
++#ifdef TV_MULTILINGUAL
++  get_monofont_size(&mfwide, &mfhigh);
++  /* recalculate sizes. */
++  defwide = 80 * mfwide + 2*LRMARGINS + 8 + 20;   /* -ish */
++  defhigh = 24 * mfhigh + TOPMARGIN + BOTMARGIN + 8 + 20;   /* ish */
++  cmthigh = 6  * mfhigh + TOPMARGIN + BOTMARGIN + 8 + 20;   /* ish */
++#endif
+ 
+   for (i=0; i<MAXTVWIN; i++) {
+     resizeText(&tinfo[i], defwide, (i<CMTWIN) ? defhigh : cmthigh);
+@@ -190,7 +372,10 @@
+   }
+ 
+   hasBeenSized = 1;  /* we can now start looking at textview events */
+-
++  
++#ifdef TV_MULTILINGUAL
++  createCsWins("+100+100");
++#endif
+ }
+ 
+ 
+@@ -205,19 +390,27 @@
+   char *text, buf[512], title[128], rfname[MAXPATHLEN+1];
+   char *basefname[128];  /* just current fname, no path */
+   FILE *fp;
++  char filename[MAXPATHLEN+1];
++
++  strcpy(filename, fname);
++
++#ifdef AUTO_EXPAND
++  Mkvdir(filename);
++  Dirtovd(filename);
++#endif
+ 
+   basefname[0] = '\0';
+-  strcpy(rfname, fname);
++  strcpy(rfname, filename);
+ 
+   /* see if this file is compressed.  if it is, uncompress it, and view
+      the uncompressed version */
+ 
+-  if (ReadFileType(fname) == RFT_COMPRESS) {
++  if (ReadFileType(filename) == RFT_COMPRESS) {
+ #ifndef VMS
+-    if (!UncompressFile(fname, rfname)) return;    /* failed to uncompress */
++    if (!UncompressFile(filename, rfname)) return;    /* failed to uncompress */
+ #else
+     /* chop off trailing '.Z' from friendly displayed basefname, if any */
+-    strcpy (basefname, fname);
++    strcpy (basefname, filename);
+     *rindex (basefname, '.') = '\0';
+     if (!UncompressFile(basefname, rfname)) return;/* failed to uncompress */
+ #endif
+@@ -244,7 +437,7 @@
+     return;
+   }
+ 
+-  text = (char *) malloc((size_t) textlen);
++  text = (char *) malloc((size_t) textlen + 1);
+   if (!text) {
+     sprintf(buf, "Couldn't malloc %ld bytes to read file '%s'", 
+ 	    textlen, rfname);
+@@ -258,6 +451,9 @@
+ 	    rfname);
+     ErrPopUp(buf, "\nHmm...");
+   }
++#ifdef TV_MULTILINGUAL
++  text[textlen] = '\0';
++#endif
+ 
+   fclose(fp);
+ 
+@@ -507,6 +703,10 @@
+   tv->text  = (char *) NULL;  
+   tv->lines = (char **) NULL;
+   tv->numlines = tv->textlen = tv->hexmode = 0;
++
++#ifdef TV_MULTILINGUAL
++  closeCsWin(tv);
++#endif
+ }
+ 
+ 
+@@ -636,7 +836,9 @@
+   int        i, maxw, maxh, hmax, hpage, vmax, vpage;
+   XSizeHints hints;
+ 
++#ifndef TV_MULTILINGUAL
+   if (tv->wide == w && tv->high == h) return;  /* no change in size */
++#endif
+ 
+   if (XGetNormalHints(theDisp, tv->win, &hints)) {
+     hints.width  = w;
+@@ -660,10 +862,23 @@
+   XMoveResizeWindow(theDisp, tv->textW, LRMARGINS, TOPMARGIN, 
+ 		    (u_int) tv->twWide, (u_int) tv->twHigh);
+ 
+-  for (i=0; i<TV_NBUTTS; i++) {
+-    tv->but[i].x = tv->wide - (TV_NBUTTS-i) * (BUTTW+5);
++  for (i=0; i<TV_E_NBUTTS; i++) {
++    tv->but[i].x = tv->wide - (TV_E_NBUTTS-i) * (BUTTW1+5);
+     tv->but[i].y = tv->high - BUTTH - 5;
+   }
++#ifdef TV_MULTILINGUAL
++  tv->csbut.x = 5;
++  tv->csbut.y = tv->high - BUTTH - 5;
++#endif
++
++#ifdef TV_L10N
++  if (xlocale) {
++    for (; i<TV_J_NBUTTS; i++) {
++      tv->but[i].x = 5 + (i-TV_E_NBUTTS) * (BUTTW2+5);
++      tv->but[i].y = tv->high - BUTTH - 5;
++    }
++  }
++#endif
+ 
+   computeScrlVals(tv);
+ 
+@@ -714,6 +929,29 @@
+   case TV_CLOSE:   if (tv == &tinfo[CMTWIN]) CloseCommentText();
+                    else closeText(tv);
+                    break;
++
++#ifdef TV_L10N
++  case TV_RESCAN:
++    tv->code = selectCodeset(tv);
++    drawTextW(0, &tv->vscrl);
++    break;
++  case TV_USASCII:
++    tv->code = LOCALE_USASCII;
++    drawTextW(0, &tv->vscrl);
++    break;
++  case TV_JIS:
++    tv->code = LOCALE_JIS;
++    drawTextW(0, &tv->vscrl);
++    break;
++  case TV_EUCJ:
++    tv->code = LOCALE_EUCJ;
++    drawTextW(0, &tv->vscrl);
++    break;
++  case TV_MSCODE:
++    tv->code = LOCALE_MSCODE;
++    drawTextW(0, &tv->vscrl);
++    break;
++#endif	/* TV_L10N */
+   }
+ }
+ 
+@@ -748,8 +986,10 @@
+   drawNumLines(tv);
+ 
+   /* draw the buttons */
+-  for (i=0; i<TV_NBUTTS; i++) BTRedraw(&(tv->but[i]));
+-
++  for (i=0; i<nbutts; i++) BTRedraw(&(tv->but[i]));
++#ifdef TV_MULTILINGUAL
++  BTRedraw(&tv->csbut);
++#endif
+   BTRedraw(&tv->nopBut);
+ }
+ 
+@@ -820,6 +1060,10 @@
+      SCRL *sptr;
+ {
+   int     i, j, lnum, hpos, cpos, extrach, lwide;
++#ifdef TV_L10N
++  int     desig_stat;	/* for ISO 2022-JP */
++	      /* 0: ASCII,  1: JIS X 0208,  2: GL is JIS X 0201 kana */
++#endif
+   TVINFO *tv;
+   char    linestr[512];
+   u_char  *sp, *ep, *lp;
+@@ -846,6 +1090,31 @@
+ 
+   /* draw text */
+   if (!tv->hexmode) {     /* ASCII mode */
++#ifdef TV_MULTILINGUAL
++    XClearArea(theDisp, tv->textW, 0, 0,
++	       (u_int) tv->twWide, (u_int) tv->twHigh, False);
++    if(tv->txt == NULL)
++      return;
++    else {
++	int i;
++	int y;
++	struct ml_text *tp = tv->txt;
++	struct ml_line *lp;
++	
++	XSetFunction(theDisp, theGC, GXcopy);
++	XSetClipMask(theDisp, theGC, None);
++	y = 3;
++	for (lp = &tp->lines[tv->vscrl.val], i = tp->nlines - tv->vscrl.val;
++		i > 0; lp++, i--) {
++	    XDrawText16(theDisp, tv->textW, theGC,
++			-mfwide * hpos + 3, y + lp->ascent,
++			lp->items, lp->nitems);
++	    y += lp->ascent + lp->descent;
++	    if (y > tv->twHigh)
++		break;
++	}
++    }
++#else
+     for (i=0; i<tv->chhigh; i++) {    /* draw each line */
+       lnum = i + tv->vscrl.val;
+       if (lnum < tv->numlines-1) {
+@@ -868,7 +1137,13 @@
+ 	      cpos--;  sp++;
+ 	    }
+ 	    else if (*sp < 32) extrach = 1;
++
++#ifdef TV_L10N
++	    else if (!tv->code && *sp > 127) extrach = 3;
++#else
+ 	    else if (*sp > 127) extrach = 3;
++#endif
++
+ 	    else sp++;
+ 	  }
+ 	  else {
+@@ -884,6 +1159,10 @@
+ 
+ 	/* build up the linestr buffer, which is the current line, padded
+ 	   with blanks to a width of exactly tv->chwide chars */
++#ifdef TV_L10N
++	desig_stat = 0;		/* for ISO 2022-JP */
++	      /* 0: ASCII,  1: JIS X 0208,  2: GL is JIS X 0201 kana */
++#endif
+ 	for (cpos=0, lp=(byte *) linestr; cpos<lwide; cpos++, lp++) {
+ 	  if (sp>=ep) *lp = ' ';
+ 	  else {
+@@ -897,13 +1176,117 @@
+ 	      cpos--;  lp--;  sp++;
+ 	    }
+ 
++#ifdef TV_L10N
++	    else if (*sp < 32 && !(tv->code == LOCALE_JIS && *sp == 0x1b)) {
++#else
+ 	    else if (*sp < 32) {
++#endif
+ 	      if (!extrach) extrach = 2;
+ 	      if      (extrach == 2) *lp = '^';
+ 	      else if (extrach == 1) *lp = *sp + 64;
+ 	    }
+-      
++
++#ifdef TV_L10N
++	    /* convert to EUC-Japan */
++	    else if (tv->code == LOCALE_JIS) {
++	      if (*sp == 0x1b) {	/* ESC */
++		if (*(sp+1) == '$') {
++		  if (*(sp+2) == 'B' || *(sp+2) == 'A' || *(sp+2) == '@') {
++		    /* ESC $ B,  ESC $ A,  ESC $ @ */
++		    desig_stat = 1;
++		    sp += 3;  cpos--;  lp--;
++		  }
++		  else if (*(sp+2) == '(' && *(sp+3) == 'B') {
++		    /* ESC $ ( B */
++		    desig_stat = 1;
++		    sp += 4;  cpos--;  lp--;
++		  }
++		}
++		else if (*(sp+1) == '(') {
++		  if (*(sp+2) == 'B' || *(sp+2) == 'J' || *(sp+2) == 'H') {
++		    /* ESC ( B,  ESC ( J,  ESC ( H */
++		    desig_stat = 0;
++		    sp += 3;  cpos--;  lp--;
++		  }
++		  else if (*(sp+2) == 'I') {
++		    /* ESC ( I */
++		    desig_stat = 2;
++		    sp += 3;  cpos--;  lp--;
++		  }
++		}
++		else if (*(sp+1) == ')' && *(sp+2) == 'I') {
++		  /* ESC ) I */
++		  desig_stat = 2;
++		  sp += 3;  cpos--;  lp--;
++		}
++		else {	/* error */
++		  *lp = ' ';  sp++;
++		}
++	      }
++
++	      else {
++		switch (desig_stat) {
++		case 0:		/* ASCII */
++		  *lp = *sp++;
++		  break;
++		case 1:		/* JIS X 0208 */
++		  *lp++ = *sp++ | 0x80;
++		  *lp   = *sp++ | 0x80;
++		  cpos++;
++		  break;
++		case 2:		/* JIS X 0201 kana */
++#if defined(__osf__) && !defined(X_LOCALE)
++		  *lp   = '=';  sp++;
++#else
++		  *lp++ = 0x8e;	/* ^N | 0x80 */
++		  *lp   = *sp++ | 0x80;
++#endif
++		  break;
++		default:	/* error */
++		  *lp = *sp++;
++		  break;
++		}
++	      }
++	    }
++
++	    else if (tv->code == LOCALE_MSCODE) {
++	      if ((*sp >= 0x81 && *sp <= 0x9f)
++			 || (*sp >= 0xe0 && *sp <= 0xef)) {
++		static u_char c1, c2;
++
++/*fprintf(stderr, "(%x,%x)->", *sp, *(sp+1));*/
++		c1 = ((*sp - ((*sp>=0xe0) ? 0xb0 : 0x70)) << 1)
++			- ((*(sp+1)<=0x9e) ? 1 : 0);
++		c2 = *(sp+1);
++		if      (c2 >= 0x9f)  c2 -= 0x7e;	/* 0x9F - 0xFC */
++		else if (c2 >= 0x80)  c2 -= 0x20;	/* 0x80 - 0x9E */
++		else		      c2 -= 0x1f;	/* 0x40 - 0x7E */
++
++		*lp++ = c1 | 0x80;
++		*lp   = c2 | 0x80;
++		sp += 2;
++/*fprintf(stderr, "(%x %x) ", c1 | 0x80, c2 | 0x80);*/
++		cpos++;
++	      }
++
++	      else if (*sp >= 0xa1 && *sp <= 0xdf) {	/* JIS X 0201 kana */
++#if defined(__osf__) && !defined(X_LOCALE)
++		*lp   = '=';  sp++;
++#else
++		*lp++ = 0x8e;	/* ^N | 0x80 */
++		*lp   = *sp++;
++#endif
++	      }
++
++	      else *lp = *sp++;
++	    }
++#endif	/* TV_L10N */
++
++#ifdef TV_L10N
++	    else if (!tv->code && *sp > 127) {
++#else
+ 	    else if (*sp > 127) {
++#endif
+ 	      if (!extrach) extrach = 4;
+ 	      if      (extrach == 4) *lp = '\\';
+ 	      else if (extrach == 3) *lp = ((u_char)(*sp & 0700) >> 6) + '0';
+@@ -919,6 +1302,9 @@
+ 	    }
+ 	  }
+ 	}
++#ifdef TV_L10N
++	*lp = '\0';	/* terminate linestr */
++#endif
+       }
+ 
+       else {  /* below bottom of file.  Just build a blank str */
+@@ -926,9 +1312,16 @@
+       }
+ 
+       /* draw the line */
+-      XDrawImageString(theDisp, tv->textW, theGC, 
+-		       3, i*mfhigh + 3 + mfascent, linestr, lwide);
++#ifdef TV_L10N
++      if (xlocale)
++	XmbDrawImageString(theDisp, tv->textW, monofset, theGC,
++		3, i*mfhigh + 1 + mfascent, linestr, strlen(linestr));
++      else
++#endif
++	XDrawImageString(theDisp, tv->textW, theGC, 
++			 3, i*mfhigh + 3 + mfascent, linestr, lwide);
+     }  /* for i ... */
++#endif /* TV_MULTILINGUAL */
+   }  /* if hexmode */
+ 
+ 
+@@ -960,7 +1353,11 @@
+ 
+ 	for (j=0; j<16; j++) {
+ 	  if (sp+j < ep) {
++#ifdef TV_L10N
++	    if (sp[j] >= 32 && (sp[j] <= 127 || tv->code)) *lp++ = sp[j];
++#else
+ 	    if (sp[j] >= 32 && sp[j] <= 127) *lp++ = sp[j];
++#endif
+ 	    else *lp++ = '.';
+ 	  }
+ 	  else *lp++ = ' ';
+@@ -1008,14 +1405,21 @@
+   int   i;
+   BUTT *bp;
+ 
+-  for (i=0, bp=tv->but; i<TV_NBUTTS; i++, bp++) {
++  for (i=0, bp=tv->but; i<nbutts; i++, bp++) {
+     if (PTINRECT(x,y,bp->x,bp->y,bp->w,bp->h)) break;
+   }
+ 
+-  if (i<TV_NBUTTS) {
++  if (i<nbutts) {
+     if (BTTrack(bp)) doCmd(tv, i);
+     return;
+   }
++
++#ifdef TV_MULTILINGUAL
++  if (PTINRECT(x, y, tv->csbut.x, tv->csbut.y, tv->csbut.w, tv->csbut.h)) {
++    if (BTTrack(&tv->csbut))
++      openCsWin(tv);
++  }
++#endif
+ }
+ 
+ 
+@@ -1045,13 +1449,38 @@
+ 
+   /* keyboard equivalents */
+   switch (buf[0]) {
+-  case '\001': doCmd(tv, TV_ASCII);   break;      /* ^A = Ascii */
+-  case '\010': doCmd(tv, TV_HEX);     break;      /* ^H = Hex   */
+-
+-  case '\033': doCmd(tv, TV_CLOSE);   break;      /* ESC = Close window */
++  case '\001':  case 'a':  case 'A':
++    doCmd(tv, TV_ASCII);   break;      /* ^A = Ascii */
++  case '\010':  case 'h':  case 'H':
++    doCmd(tv, TV_HEX);     break;      /* ^H = Hex   */
++
++  case '\021':  case 'q':  case 'Q':
++  case '\003':  case 'c':  case 'C':
++  case '\033':
++    doCmd(tv, TV_CLOSE);   break;      /* ESC = Close window */
+ 
+   default:     break;
+   }
++
++#ifdef TV_L10N
++  if (xlocale) {
++    switch (buf[0]) {
++    case '\022':  case 'r':  case 'R':
++      doCmd(tv, TV_RESCAN);   break;
++    case '\012':  case 'j':  case 'J':
++      doCmd(tv, TV_JIS);      break;
++    case '\005':  case 'e':  case 'E':
++    case '\025':  case 'u':  case 'U':
++      doCmd(tv, TV_EUCJ);     break;
++    case '\015':  case 'm':  case 'M':
++    case '\023':  case 's':  case 'S':
++      doCmd(tv, TV_MSCODE);  break;
++
++    default:  break;
++    }
++  }
++#endif	/* TV_L10N */
++
+ }
+ 
+ 
+@@ -1114,7 +1543,20 @@
+     if (i<tv->numlines-1) SCSetVal(&tv->vscrl, i);
+   }
+ 
++#ifdef TV_L10N
++  /* redraw text */
++  if (xlocale) {
++    XClearArea(theDisp, tv->textW, 0, 0,
++	       (u_int) tv->twWide, (u_int) tv->twHigh, False);
++
++    drawTextW(0, &tv->vscrl);
++  }
++#endif
++#ifdef TV_MULTILINGUAL
++  XClearArea(theDisp, tv->textW, 0, 0,
++	     (u_int) tv->twWide, (u_int) tv->twHigh, False);
+   drawTextW(0, &tv->vscrl);
++#endif
+ }
+ 
+ 
+@@ -1127,9 +1569,22 @@
+   int   i,j,wide,maxwide,space;
+   byte *sp;
+ 
++#ifdef TV_L10N
++  /* select code-set */
++  if (xlocale)
++    tv->code = selectCodeset(tv);
++#endif	/* TV_L10N */
++
+   if (!tv->text) { 
+     tv->numlines = tv->hexlines = 0;  
+     tv->lines = (char **) NULL; 
++#ifdef TV_MULTILINGUAL
++    if (tv->cv_text != NULL) {
++	free(tv->cv_text);
++	tv->cv_text = NULL;
++    }
++    tv->txt = NULL;
++#endif
+     return;
+   }
+ 
+@@ -1177,17 +1632,134 @@
+ 	wide += space;
+       }
+       else if (*sp <  32) wide += 2;
++#ifdef TV_L10N
++      else if (*sp > 127 && !tv->code) wide += 4;
++#else
+       else if (*sp > 127) wide += 4;
++#endif
+       else wide++;
+     }
+     if (wide > maxwide) maxwide = wide;
+   }
+   tv->maxwide = maxwide;
+ 
++#ifdef TV_MULTILINGUAL
++  ml_set_charsets(tv->ctx, &tv->ccs.coding_system);
++  if (tv->cv_text != NULL) {
++      free(tv->cv_text);
++      tv->cv_text = NULL;
++  }
++  if (tv->ccs.converter == NULL) {
++      tv->txt = ml_draw_text(tv->ctx, tv->text, tv->textlen);
++  } else {
++      tv->cv_text = (*tv->ccs.converter)(tv->text, tv->textlen, &tv->cv_len);
++      tv->txt = ml_draw_text(tv->ctx, tv->cv_text, tv->cv_len);
++  }
++  tv->maxwide = tv->txt->width / mfwide;
++  tv->numlines = tv->txt->height / mfhigh + 1;
++#endif
++
+   tv->hexlines = (tv->textlen + 15) / 16;
+ }
+ 
+ 
++/***************************************************/
++#ifdef TV_L10N
++static int selectCodeset(tv)
++     TVINFO *tv;
++{
++  u_char *sp;
++  int i, len;
++  int code;
++
++  len = tv->textlen;
++
++  /* select code-set */
++  if (xlocale) {
++    code = LOCALE_USASCII;	/* == 0 */
++
++    sp = (u_char *) tv->text;  i = 0;
++    while (i < len - 1) {
++      if (*sp == 0x1b &&
++	  (*(sp+1) == '$' || *(sp+1) == '(' || *(sp+1) == ')')) {
++	code = LOCALE_JIS;
++	break;
++      }
++
++      else if (*sp >= 0xa1 && *sp <= 0xdf) {
++	if (*(sp+1) >= 0xf0 && *(sp+1) <= 0xfe) {
++	  code = LOCALE_EUCJ;
++	  break;
++	}
++#  if (LOCALE_DEFAULT == LOCALE_EUCJ)
++	else {
++	  sp++;  i++;
++	}
++#  endif
++      }
++
++      else if ((*sp >= 0x81 && *sp <= 0x9f) || (*sp >= 0xe0 && *sp <= 0xef)) {
++	if ((*(sp+1) >= 0x40 && *(sp+1) <= 0x7e) || *(sp+1) == 0x80) {
++	  code = LOCALE_MSCODE;
++	  break;
++	}
++	else if (*(sp+1) == 0xfd || *(sp+1) == 0xfe) {
++	  code = LOCALE_EUCJ;
++	  break;
++	}
++	else {
++	  sp++;  i++;
++	}
++      }
++
++      else if (*sp >= 0xf0 && *sp <= 0xfe) {
++	code = LOCALE_EUCJ;
++	break;
++      }
++
++      sp++;  i++;
++    }
++    if (!code)  code = LOCALE_DEFAULT;
++#  if 0	/* obsolete method */
++    setlocale(LC_ALL, localeList[code]);
++#  endif
++/*fprintf(stderr, "\n%s\n\n", localeList[code]);*/
++  }
++
++  return code;
++}
++#endif	/* TV_L10N */
++
++#ifdef TV_MULTILINGUAL
++static void setCodingSpec(tv, cs)
++    TVINFO *tv;
++    struct coding_spec *cs;
++{
++  if (xvbcmp((char *) &tv->ccs, (char *) cs, sizeof *cs) == 0)
++    return;
++  
++  tv->ccs = *cs;
++#if 0
++  ml_set_charsets(tv->ctx, &tv->ccs.coding_system);
++  if (tv->cv_text != NULL) {
++      free(tv->cv_text);
++      tv->cv_text = NULL;
++  }
++  if (tv->ccs.converter == NULL) {
++      tv->txt = ml_draw_text(tv->ctx, tv->text, tv->textlen);
++  } else {
++      tv->cv_text = (*tv->ccs.converter)(tv->text, tv->textlen, &tv->cv_len);
++      tv->txt = ml_draw_text(tv->ctx, tv->cv_text, tv->cv_len);
++  }
++#else
++  computeText(tv);
++  computeScrlVals(tv);
++#endif
++  /* drawTextW(0, &tv->vscrl); */
++}
++#endif
++
++
+ /**********************************************************************/
+ /* BUILT-IN TEXT FILES ************************************************/
+ /**********************************************************************/
+@@ -1560,7 +2132,517 @@
+   OpenTextView(keyhelp, (int) strlen(keyhelp), "XV Help", 0);
+ }
+ 
++#ifdef TV_MULTILINGUAL
++
++#define TV_ML_ACCEPT TV_NCSS
++#define TV_ML_CLOSE  (TV_ML_ACCEPT + 1)
++#define TV_ML_NBUTTS (TV_ML_CLOSE + 1)
++
++#define TV_ML_RETCODE	0
++#	define TV_ML_RET_LF	0
++#	define TV_ML_RET_CRLF	1
++#	define TV_ML_RET_CR	2
++#	define TV_ML_RET_ANY	3
++#define TV_ML_GL	1
++#define TV_ML_GR	2
++#define TV_ML_CVTR	3
++#define TV_ML_NRBUTTS	4
++
++#define TV_ML_SHORT	0
++#define TV_ML_LOCK	1
++#define TV_ML_NCBUTTS	2
++
++#define TV_ML_NLISTS	4
++
++#define CSWIDE (BUTTW3 * 5 + 5 * 6)
++#define CSHIGH 450
++
++typedef struct csinfo_t {
++    TVINFO *tv;
++    RBUTT *rbt[TV_ML_NRBUTTS];
++    CBUTT cbt[TV_ML_NCBUTTS];
++    LIST ls[TV_ML_NLISTS];
++    BUTT bt[TV_ML_NBUTTS];
++    int up;
++    Window win;
++    struct coding_spec tcs;	/* temporary coding_spec */
++} CSINFO;
++CSINFO csinfo[MAXTVWIN];
++static char **regs;
++static int nregs;
++
++static int  csCheckEvent           PARM((CSINFO *, XEvent *));
++static void csReflect              PARM((CSINFO *));
++static void csRedraw               PARM((CSINFO *));
++static void csListRedraw           PARM((LIST *));
++static void csLsRedraw             PARM((int, SCRL *));
++static void create_registry_list   PARM((void));
++
++static char *(*cvtrtab[])PARM((char *, int, int *)) = {
++    NULL,
++    sjis_to_jis,
++};
++
++static void createCsWins(geom)
++    char *geom;
++{
++    XSetWindowAttributes xswa;
++    char **t;
++    int i, j;
++    
++    create_registry_list();
++    
++    xswa.backing_store = WhenMapped;
++    for (i = 0; i < MAXTVWIN; i++) {
++	char nam[8];
++	TVINFO *tv = &tinfo[i];
++	CSINFO *cs = &csinfo[i];
++	tv->cs = cs;
++	cs->tv = tv;
++	sprintf(nam, "XVcs%d", i);
++	cs->win = CreateWindow("xv codeset", nam, geom,
++			       CSWIDE, CSHIGH, infofg, infobg, 0);
++	if (!cs->win) FatalError("couldn't create 'charset' window!");
++#ifdef BACKING_STORE
++	XChangeWindowAttributes(theDisp, cs->win, CWBackingStore, &xswa);
++#endif
++	XSelectInput(theDisp, cs->win, ExposureMask | ButtonPressMask);
++	
++	DrawString(cs->win, 5, 5 + ASCENT, "Initial States");
++	for (i = 0; i < TV_ML_NLISTS; i++) {
++	    int x, y;
++	    char buf[80];
++	    
++	    if (i / 2 == 0)
++		x = 15;
++	    else
++		x = 280;
++	    if (i % 2 == 0)
++		y = 5 + LINEHIGH * 1;
++	    else
++		y = 5 + LINEHIGH * 7 + SPACING * 3;
++	    
++	    sprintf(buf, "Designation for G%d:", i + 1);
++	    DrawString(cs->win, x, y + ASCENT, buf);
++	    
++	    LSCreate(&cs->ls[i], cs->win, x + 15, y + LINEHIGH,
++			200, LINEHIGH * 5, 5,
++			regs, nregs + 2,
++			infofg, infobg, hicol, locol, csLsRedraw, 0, 0);
++	    cs->ls[i].selected = 0;
++	}
++	
++	for (i = 0; i < 2; i++) {
++	    char *p;
++	    int n;
++	    int x, y;
++	    int j;
++	    
++	    if ((p = (char *) malloc(3 * 4)) == NULL)
++		FatalError("out of memory in createCsWins().");
++	    strcpy(p, "G1 G2 G3 G4");
++	    p[2] = p[5] = p[8] = '\0';
++	    n = (i == 0 ? TV_ML_GL : TV_ML_GR);
++	    x = (i == 0 ? 15 : 280);
++	    y = 235;
++	    DrawString(cs->win, x, y + ASCENT, "Assignment for GL:");
++	    x += 15;
++	    y += LINEHIGH;
++	    cs->rbt[n] = RBCreate(NULL, cs->win,
++				  x, y, p, infofg, infobg, hicol, locol);
++	    for (j = 1; j < 4; j++) {
++		p += 3;
++		x += 50;
++		RBCreate(cs->rbt[n], cs->win,
++			 x, y, p, infofg, infobg, hicol, locol);
++	    }
++	}
++	
++	DrawString(cs->win, 5, 280 + ASCENT, "Ret Code:");
++	cs->rbt[TV_ML_RETCODE] =
++	    RBCreate(NULL, cs->win, 20, 300, "LF", infofg,infobg, hicol,locol);
++	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 20, 300 + 20, "CR+LF",
++		 infofg, infobg, hicol, locol);
++	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 90, 300, "CR",
++		 infofg, infobg, hicol, locol);
++	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 90, 300 + 20, "Any",
++		 infofg, infobg, hicol, locol);
++	
++	DrawString(cs->win, 350, 280 + ASCENT, "Converter:");
++	cs->rbt[TV_ML_CVTR] =
++	    RBCreate(NULL, cs->win, 365, 300, "Nothing",
++		     infofg, infobg, hicol, locol);
++	RBCreate(cs->rbt[TV_ML_CVTR], cs->win, 365, 300 + 20, "Shift JIS",
++		 infofg, infobg, hicol, locol);
++
++	CBCreate(&cs->cbt[TV_ML_SHORT], cs->win, 200, 300, "Short Form",
++		 infofg, infobg, hicol, locol);
++	CBCreate(&cs->cbt[TV_ML_LOCK], cs->win, 200, 320, "Locking Shift",
++		 infofg, infobg, hicol, locol);
++	
++	for (j = 0; j < TV_NCSS; j++) {
++	    BTCreate(&cs->bt[j], cs->win,
++		     5 + (BUTTW3 + 5) * (j % 5),
++		     350 + 5 + (BUTTH + 5) * (j / 5),
++		     BUTTW3, BUTTH, codeSetNames[j],
++		     infofg, infobg, hicol, locol);
++	}
++	BTCreate(&cs->bt[TV_ML_ACCEPT], cs->win,
++		 CSWIDE - 10 - BUTTW3 * 2, CSHIGH - 5 - BUTTH, BUTTW3, BUTTH,
++		 "Accept", infofg, infobg, hicol, locol);
++	BTCreate(&cs->bt[TV_ML_CLOSE], cs->win,
++		 CSWIDE - 5 - BUTTW3, CSHIGH - 5 - BUTTH, BUTTW3, BUTTH,
++		 "Close", infofg, infobg, hicol, locol);
++	
++	XMapSubwindows(theDisp, cs->win);
++	cs->up = 0;
++    }
++}
++
++static void openCsWin(tv)
++    TVINFO *tv;
++{
++    CSINFO *cs = tv->cs;
++    if (cs->up)
++	return;
++    
++    XMapRaised(theDisp, cs->win);
++    cs->up = 1;
++    cs->tcs = cs->tv->ccs;
++    csReflect(cs);
++}
++
++static void closeCsWin(tv)
++    TVINFO *tv;
++{
++    CSINFO *cs = tv->cs;
++    if (!cs->up)
++	return;
++    cs->up = 0;
++    XUnmapWindow(theDisp, cs->win);
++}
++
++int CharsetCheckEvent(xev)
++    XEvent *xev;
++{
++    int i;
++    CSINFO *cs;
++    
++    for (cs = csinfo, i = 0; i < MAXTVWIN; cs++, i++) {
++	if (!cs->up)
++	    continue;
++	if (csCheckEvent(cs, xev))
++	    break;
++    }
++    if (i < MAXTVWIN)
++	return 1;
++    return 0;
++}
++
++static int csCheckEvent(cs, xev)
++    CSINFO *cs;
++    XEvent *xev;
++{
++    TVINFO *tv = cs->tv;
++    RBUTT **rbp;
++    CBUTT *cbp;
++    LIST *ls;
++    BUTT *bp;
++    int i, j;
++    int n;
++    
++    if (xev->type == Expose) {
++	int x, y, w, h;
++	XExposeEvent *e = (XExposeEvent *) xev;
++	x = e->x; y = e->y; w = e->width; h = e->height;
++	
++	if (cs->win == e->window){
++	    csRedraw(cs);
++	    return 1;
++	} else {
++	    for (i = 0; i < TV_ML_NLISTS; i++) {
++		if (cs->ls[i].win == e->window) {
++		    LSRedraw(&cs->ls[i], 0);
++		    return 1;
++		}
++	    }
++	   for (i = 0; i < TV_ML_NLISTS; i++) {
++		if (cs->ls[i].scrl.win == e->window) {
++		    SCRedraw(&cs->ls[i].scrl);
++		    return 1;
++		}
++	   }
++	}
++    } else if (xev->type == ButtonPress) {
++	int x, y;
++	XButtonEvent *e = (XButtonEvent *) xev;
++	x = e->x; y = e->y;
++	if (cs->win == e->window) {
++	    for (bp = cs->bt, i = 0; i < TV_ML_NBUTTS; bp++, i++) {
++		if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
++		    break;
++	    }
++	    if (i < TV_ML_NBUTTS) {
++		if (BTTrack(bp)) {
++		    if (i < TV_NCSS) {
++			cs->tcs = coding_spec[i];
++			csReflect(cs);
++		    } else {
++			switch (i) {
++			case TV_ML_ACCEPT:
++			    setCodingSpec(cs->tv, &cs->tcs);
++			    break;
++			case TV_ML_CLOSE:
++			    closeCsWin(cs->tv);
++			    break;
++			}
++		    }
++		}
++		return 1;
++	    }
++	    for (cbp = cs->cbt, i = 0; i < TV_ML_NCBUTTS; cbp++, i++) {
++		if (CBClick(cbp, x, y) && CBTrack(cbp))
++		    break;
++	    }
++	    if (i < TV_ML_NCBUTTS) {
++		switch (i) {
++		case TV_ML_SHORT:
++		    cs->tcs.coding_system.short_form = cbp->val;
++		    break;
++		case TV_ML_LOCK:
++		    cs->tcs.coding_system.lock_shift = cbp->val;
++		    break;
++		}
++		return 1;
++	    }
++	    for (rbp = cs->rbt, i = 0; i < TV_ML_NRBUTTS; rbp++, i++) {
++		if ((n = RBClick(*rbp, x, y)) >= 0 && RBTrack(*rbp, n)) {
++		    break;
++		}
++	    }
++	    if (i < TV_ML_NRBUTTS) {
++		switch (i) {
++		case TV_ML_RETCODE:
++		    cs->tcs.coding_system.eol = n;
++		    break;
++		case TV_ML_GL:
++		    cs->tcs.coding_system.gl = n;
++		    break;
++		case TV_ML_GR:
++		    cs->tcs.coding_system.gr = n;
++		    break;
++		case TV_ML_CVTR:
++		    cs->tcs.converter = cvtrtab[n];
++		    break;
++		}
++		return 1;
++	    }
++	} else {
++	    for (ls = cs->ls, i = 0; i < TV_ML_NLISTS; ls++, i++) {
++		if (ls->win == e->window) {
++		    LSClick(ls, e);
++		    n = ls->selected;
++		    if (n < nregs) {
++			char r[32], *p = r;
++			int b7;
++			strcpy(r, regs[n]);
++			if ((p = strrchr(r, '/')) != NULL) {
++			    *p = '\0';
++			    b7 = (*(p + 1) == 'R' ? 1 : 0);
++			} else
++			    b7 = 0;	/* shouldn't occur */
++			cs->tcs.coding_system.design[i] = lookup_design(r, b7);
++		    } else if (n == nregs)    /* initially none is designed. */
++			cs->tcs.coding_system.design[i].bpc = 0;
++		    else
++			cs->tcs.coding_system.design[i].bpc = -1;
++		    return 1;
++		}
++	    }
++	    for (ls = cs->ls, i = 0; i < TV_ML_NLISTS; ls++, i++) {
++		if (ls->scrl.win == e->window) {
++		    SCTrack(&ls->scrl, x, y);
++		    return 1;
++		}
++	    }
++	}
++    }
++    return 0;
++}
++
++static void csReflect(cs)
++    CSINFO *cs;
++{
++    int i;
++    
++    RBSelect(cs->rbt[TV_ML_RETCODE], cs->tcs.coding_system.eol);
++    RBSelect(cs->rbt[TV_ML_GL], cs->tcs.coding_system.gl);
++    RBSelect(cs->rbt[TV_ML_GR], cs->tcs.coding_system.gr);
++    for (i = 0; i < sizeof cvtrtab / sizeof cvtrtab[0]; i++) {
++	if (cs->tcs.converter == cvtrtab[i])
++	    break;
++    }
++    if (i >= sizeof cvtrtab / sizeof cvtrtab[0])
++	FatalError("program error in csReflect().");
++    RBSelect(cs->rbt[TV_ML_CVTR], i);
++    
++    cs->cbt[TV_ML_SHORT].val = cs->tcs.coding_system.short_form;
++    cs->cbt[TV_ML_LOCK].val = cs->tcs.coding_system.lock_shift;
++    for (i = 0; i < TV_ML_NLISTS; i++) {
++	struct design design = cs->tcs.coding_system.design[i];
++	char *reg, r[32];
++	int b7;
++	int n = 0;
++	switch (design.bpc) {
++	case -1:
++	    n = nregs + 1;
++	    break;
++	case 0:
++	    n = nregs;
++	    break;
++	case 1:
++	case 2:
++	    if ((reg = lookup_registry(design, &b7)) == NULL)
++		FatalError("internal error in csReflect.");
++	    sprintf(r, "%s/%s", reg, b7 ? "Right" : "Left");
++	    for (n = 0; n < nregs; n++) {
++		if (strcmp(regs[n], r) == 0)
++		    break;
++	    }
++	}
++	cs->ls[i].selected = n;
++	ScrollToCurrent(&cs->ls[i]);
++    }
++    csRedraw(cs);
++    for (i = 0; i < TV_ML_NLISTS; i++)
++	csListRedraw(&cs->ls[i]);
++}
++
++static void csRedraw(cs)
++    CSINFO *cs;
++{
++    int i;
++    
++    XSetForeground(theDisp, theGC, infofg);
++    DrawString(cs->win,  5,5 + ASCENT, "Initial States");
++    for (i = 0; i < TV_ML_NLISTS; i++) {
++	int x, y;
++	char buf[80];
++	
++	if (i / 2 == 0)
++	    x = 15;
++	else
++	    x = 280;
++	if (i % 2 == 0)
++	    y = 5 + LINEHIGH * 1;
++	else
++	    y = 5 + LINEHIGH * 7 + SPACING * 3;
++	
++	sprintf(buf, "Designation for G%d:", i);
++	DrawString(cs->win, x, y + ASCENT, buf);
++    }
++    
++    DrawString(cs->win,  15, 235 + ASCENT, "Invocation for GL:");
++    DrawString(cs->win, 280, 235 + ASCENT, "Invocation for GR:");
++    DrawString(cs->win,   5, 280 + ASCENT, "Ret Code:");
++    DrawString(cs->win, 350, 280 + ASCENT, "Converter:");
++    
++    for (i = 0; i < TV_ML_NBUTTS; i++)
++	BTRedraw(&cs->bt[i]);
++    for (i = 0; i < TV_ML_NCBUTTS; i++)
++	CBRedraw(&cs->cbt[i]);
++    for (i = 0; i < TV_ML_NRBUTTS; i++)
++	RBRedraw(cs->rbt[i], -1);
++}
++
++static void csListRedraw(ls)
++    LIST *ls;
++{
++    int i;
++    for (i = 0; i < TV_ML_NLISTS; i++) {
++	LSRedraw(ls, 0);
++	SCRedraw(&ls->scrl);
++    }
++}
++
++static void csLsRedraw(delta, sptr)
++    int delta;
++    SCRL *sptr;
++{
++    int i, j;
++    for (i = 0; i < MAXTVWIN; i++) {
++	for (j = 0; j < TV_ML_NLISTS; j++) {
++	    if (sptr == &csinfo[i].ls[j].scrl) {
++		LSRedraw(&csinfo[i].ls[j], delta);
++		return;
++	    }
++	}
++    }
++}
++
++int CharsetDelWin(win)
++    Window win;
++{
++    CSINFO *cs;
++    int i;
++
++    for (cs = csinfo, i = 0; i < TV_NCSS; cs++, i++) {
++	if (cs->win == win) {
++	    if (cs->up) {
++		XUnmapWindow(theDisp, cs->win);
++		cs->up = 0;
++	    }
++	    return 1;
++	}
++    }
++    return 0;
++}
++
++static int reg_comp PARM((const void *, const void *));
++static void create_registry_list()
++{
++    struct design d;
++    char *names, *p;
++    int i;
++    
++    if ((p = names = (char *) malloc(32 * 0x80 * 2 * 2)) == NULL)
++	FatalError("out of memory in create_name_list#1.");
++    nregs = 0;
++    for (d.bpc = 1; d.bpc <=2; d.bpc++) {
++	for (d.noc = 94; d.noc <= 96; d.noc += 2) {
++	    for (d.des = ' '; (unsigned char) d.des < 0x80; d.des++) {
++		int b7;
++		char *r;
++		if ((r = lookup_registry(d, &b7)) != NULL) {
++		    sprintf(p, "%s/%s", r, b7 ? "Right" : "Left");
++		    p += strlen(p) + 1;
++		    nregs++;
++		}
++	    }
++	}
++    }
++    if ((names = (char *) realloc(names, (size_t) (p - names))) == NULL)
++	FatalError("out of memory in create_name_list#2.");
++    if ((regs = (char **) malloc(sizeof(char *) * (nregs + 3))) == NULL)
++	FatalError("out of memory in create_name_list#3.");
++    p = names;
++    for (i = 0; i < nregs; i++) {
++	regs[i] = p;
++	p += strlen(p) + 1;
++    }
++    qsort(regs, (size_t) nregs, sizeof(char *), reg_comp);
++    regs[i++] = "nothing";
++    regs[i++] = "unused";
++    regs[i++] = NULL;
++}
++static int reg_comp(dst, src)
++    const void *dst, *src;
++{
++    return strcmp(*(char **) dst, *(char **) src);
++}
++
+ 
++#endif
+ 
+ 
+ 
+diff -urN xv-3.10a/xvtiff.c xv-3.10a-jp-extension-current/xvtiff.c
+--- xv-3.10a/xvtiff.c	Sat Jan 14 04:53:34 1995
++++ xv-3.10a-jp-extension-current/xvtiff.c	Wed Oct  9 20:36:29 1996
+@@ -1381,7 +1381,7 @@
+   }
+ }
+ 
+-#define Code2V(c, RB, RW, CR)  ((((c)-(int)RB)*(float)CR)/(float)(RW-RB))
++#define Code2V(c, RB, RW, CR)  ((((int)(c)-(int)RB)*(float)CR)/(float)(RW-RB))
+ 
+ #define	CLAMP(f,min,max) \
+     (int)((f)+.5 < (min) ? (min) : (f)+.5 > (max) ? (max) : (f)+.5)
+diff -urN xv-3.10a/xvvd.c xv-3.10a-jp-extension-current/xvvd.c
+--- xv-3.10a/xvvd.c
++++ xv-3.10a-jp-extension-current/xvvd.c	Wed Oct  9 20:37:21 1996
+@@ -0,0 +1,1069 @@
++
++/*
++ * xvvd.c - extract archived file automatically and regard it as a
++ *          directory.
++ */
++
++#define NEEDSDIR
++
++#include "xv.h"
++
++#ifdef AUTO_EXPAND
++
++static void  vd_Dirtovd    		PARM((char *));
++static void  vd_Vdtodir    		PARM((char *));
++static int   vd_Mkvdir    		PARM((char *));
++static int   vd_Rmvdir     		PARM((char *));
++static int   vd_Movevdir  		PARM((char *, char *));
++static void  vd_addvdtable		PARM((char *));
++static void  vd_packvdtable		PARM((void));
++static int   vd_recursive_mkdir		PARM((char *));
++static int   vd_recursive_rmdir		PARM((char *));
++static void  vd_optimize_path		PARM((char *));
++static int   vd_ftype			PARM((char *));
++static int   vd_compp			PARM((char *, char *));
++static int   vd_UncompressFile		PARM((char *, char *));
++static int   vd_tarc			PARM((char *));
++static u_int vd_tar_sumchk		PARM((char *));
++
++#define VD_VDTABLESIZE	100
++
++#define VD_ERR -2
++#define VD_UKN -1
++
++static char *ext_command[] = {
++/* KEEP 0 */
++    NULL,
++#define VD_ARC 1
++    "arc xo %s",
++#define VD_ARJ 2
++    "unarj x %s",
++#define VD_LZH 3
++    "lha -xf %s",
++#define VD_TAR 4
++    "tar xvf %s",
++#define VD_ZIP 5
++    "unzip -xo %s",
++#define VD_ZOO 6
++    "zoo xOS %s",
++};
++
++int vdcount = 0;
++
++static char vdroot[MAXPATHLEN+1];
++static char *vdtable[VD_VDTABLESIZE];
++
++/*
++ * These functions initialize and settle virtual directory system.
++ * Vdinit:
++ *	creates root of virtual directory.
++ * Vdsettle:
++ *	sweeps virtual directories.
++ */
++void Vdinit()
++{
++#ifndef VMS
++    char tmp[MAXPATHLEN+1];
++
++    xv_getwd(tmp, MAXPATHLEN+1);
++    if (chdir(tmpdir)) {
++	fprintf(stderr, "Warning: cannot chdir to tmpdir = '%s'.\n", tmpdir);
++	fprintf(stderr,
++		"         I use current directory '%s' instead of tmpdir.\n",
++		tmp);
++    }
++    xv_getwd(vdroot, MAXPATHLEN+1);
++    strcat(vdroot, "/.xvvdXXXXXX");
++    chdir(tmp);
++#else
++    sprintf(vdroot, "Sys$Scratch:xvvdXXXXXX");
++#endif /* VMS */
++    mktemp(vdroot);
++}
++
++void Vdsettle()
++{
++    int i;
++
++    for (i = 0; i < vdcount; i++)
++	free(vdtable[i]);
++
++    vdcount = 0;
++
++    vd_recursive_rmdir(vdroot);
++}
++
++/*
++ * This function chdir to virtual directory, if specified path is in
++ * virtual directlry.
++ */
++int Chvdir(dir)
++char *dir;
++{
++    char buf[MAXPATHLEN+1];
++
++    if (Mkvdir(dir) == VD_ERR)
++	return -1;
++
++    strcpy(buf, dir);
++    Dirtovd(buf);
++
++    return (chdir(buf));
++}
++
++/*
++ * These functions convert directory <-> virtual directory.
++ * Dirtovd:
++ *	front interface of vd_Dirtovd.
++ * vd_Dirtovd:
++ *	converts directory to virtual directry.
++ * Vdtodir:
++ *	front interface of vd_Vdtodir.
++ * vd_Vdtodir:
++ *	converts virtual directry to normal directory.
++ * Dirtosubst:
++ *	converts directry to substance of archive.
++ */
++void Dirtovd(dir)
++char *dir;
++{
++    int i;
++
++    vd_optimize_path(dir);
++
++    vd_Dirtovd(dir);
++}
++
++static void vd_Dirtovd(dir)
++char *dir;
++{
++    int i;
++
++    for (i = 0; i < vdcount; i++)
++	if (!strncmp(dir, vdtable[i], strlen(vdtable[i]))) {
++	    char tmp[MAXPATHLEN+1];
++
++	    sprintf(tmp, "%s%s", vdroot, dir);
++	    strcpy(dir, tmp);
++	    Dirtovd(dir);
++	}
++}
++
++void Vdtodir(dir)
++char *dir;
++{
++    int i;
++
++    vd_optimize_path(dir);
++
++    vd_Vdtodir(dir);
++}
++
++static void vd_Vdtodir(vd)
++char *vd;
++{
++    int i;
++    char tmp[MAXPATHLEN+1];
++
++    for (i = vdcount-1; i >= 0; i--) {
++	sprintf(tmp, "%s%s", vdroot, vdtable[i]);
++	if(!strncmp(vd, tmp, strlen(tmp))) {
++	    strcpy(tmp, vd+strlen(vdroot));
++	    strcpy(vd, tmp);
++	    Vdtodir(vd);
++	}
++    }
++} 
++
++void Dirtosubst(dir)
++char *dir;
++{
++    char tmp[MAXPATHLEN+1];
++
++    Dirtovd(dir);
++
++    strcpy(tmp, dir+strlen(vdroot));
++
++    if (Isarchive(tmp))
++	strcpy(dir, tmp);
++}
++    
++/*
++ * These functions make virtual directory and extracts archive, if
++ * specified path is archive.
++ * Mkvdir:
++ *	front interface of vd_Mkvdir.
++ * vd_Mkvdir:
++ *	does real work.
++ * Mkvdir_force: (used by makeThumbDir(in xvbrowse.c) only)
++ *	make virtual directory by force.
++ */
++int Mkvdir(dir)
++char *dir;
++{
++    char dir1[MAXPATHLEN+1], dir2[MAXPATHLEN+1];
++    char *d1, *d2;
++    int rv;
++
++#if defined(SYSV) || defined(SVR4)
++    sighold(SIGHUP);
++    sighold(SIGCHLD);
++#else
++    int mask;
++    mask = sigblock(sigmask(SIGHUP)|sigmask(SIGCHLD));
++#endif
++
++    strcpy(dir1, dir);
++    vd_optimize_path(dir1);
++
++    if ((rv = vd_Mkvdir(dir1)) != VD_ERR)
++	goto MKVDIR_END;
++
++    strcpy(dir2, dir1);
++    d2 = dir2 + strlen(dir2);
++    while (rv == VD_ERR) {
++	d2--;
++	while (*d2 != '/')
++	    d2--;
++	*d2 = '\0';
++	rv = vd_Mkvdir(dir2);
++    }
++    d1 = dir1 + strlen(dir2);
++    while ((rv != VD_ERR) && (*d1 != '\0')) {
++	*d2++ = *d1++;
++	while ((*d1 != '/') && (*d1 != '\0'))
++	    *d2++ = *d1++;
++	*d2 = '\0';
++	rv = vd_Mkvdir(dir2);
++    }
++
++MKVDIR_END:
++#if defined(SYSV) || defined(SVR4)
++    sigrelse(SIGHUP);
++    sigrelse(SIGCHLD);
++#else
++    sigsetmask(mask);
++#endif
++
++    return rv;
++}
++
++static int vd_Mkvdir(dir)
++char *dir;
++{
++    char dir1[MAXPATHLEN+1], dir2[MAXPATHLEN+1], tmp[MAXPATHLEN+1];
++    int ftype, i;
++    struct stat st;
++    FILE *pfp;
++
++    strcpy(dir1, dir);
++    Dirtovd(dir1);
++    strcpy(dir2, dir1);
++
++    WaitCursor();
++
++    if ((ftype = vd_ftype(dir1)) < 0) {
++	SetCursors(-1);
++	return ftype;
++    }
++    if (ftype == RFT_COMPRESS) {
++	if (!(ftype = vd_compp(dir1, tmp))) {
++	    SetCursors(-1);
++	    return ftype;
++	}
++	strcpy(dir1, tmp);
++    }
++
++    if (!stat(dir1, &st)) {
++	for(i = 0; i < vdcount; i++)
++	    if (!strcmp(vdtable[i], dir2)) {
++		SetCursors(-1);
++		return 0;
++	    }
++
++	if (!S_ISDIR(st.st_mode)) {
++	    char origdir[MAXPATHLEN+1], buf[MAXPATHLEN+10], buf1[100];
++
++	    if (vdcount >= VD_VDTABLESIZE) {
++		ErrPopUp("Sory, you can't make virtual directory any more.",
++			 "\nBummer!");
++		goto VD_MKVDIR_ERR;
++	    }
++
++	    WaitCursor();
++
++	    xv_getwd(origdir, MAXPATHLEN+1);
++
++	    sprintf(tmp, "%s%s", vdroot, dir2);
++	    if (vd_recursive_mkdir(tmp) || chdir(tmp)) {
++		SetISTR(ISTR_INFO, "fail to make virtual directory.");
++		Warning();
++		goto VD_MKVDIR_ERR;
++	    }
++	    sprintf(buf, ext_command[ftype], dir1);
++
++	    WaitCursor();
++
++	    if((pfp = popen(buf, "r")) == NULL) {
++		SetISTR(ISTR_INFO, "fail to extract archive '%s'.",
++			BaseName(dir2));
++		Warning();
++		goto VD_MKVDIR_ERR;
++	    }
++	    while (1) {
++		if (fread(buf1, 1, sizeof(buf1), pfp) < sizeof(buf1))
++		    break;
++		WaitCursor();
++	    }
++	    if (!feof(pfp)) {
++		SetISTR(ISTR_INFO, "Pipe was broken.");
++		Warning();
++		pclose(pfp);
++		goto VD_MKVDIR_ERR;
++	    }
++	    pclose(pfp);
++
++	    if (strcmp(dir1, dir2))
++		unlink(dir1);
++
++	    vd_addvdtable(dir2);
++	    Dirtovd(origdir);
++	    chdir(origdir);
++	    SetCursors(-1);
++	    return 0;
++
++VD_MKVDIR_ERR:
++	    if (strcmp(dir1, dir2))
++		unlink(dir1);
++	    SetCursors(-1);
++	    return VD_ERR;
++	}
++    }
++    SetCursors(-1);
++    return VD_ERR;
++}
++
++#ifdef VIRTUAL_TD
++void Mkvdir_force(dir)
++char *dir;
++{
++    char tmp[MAXPATHLEN+1];
++
++    if (vdcount >= VD_VDTABLESIZE) {
++      ErrPopUp("Sory, you can't make virtual directory any more.",
++	       "\nBummer!");
++      return;
++    }
++
++    sprintf(tmp, "%s%s", vdroot, dir);
++    if (vd_recursive_mkdir(tmp)) {
++      SetISTR(ISTR_INFO, "fail to make virtual directory.");
++      Warning();
++      return;
++    }
++
++    vd_addvdtable(dir);
++}
++#endif /* VIRTUAL_TD */
++
++/*
++ * These functions remove virtual directory, if exists.
++ * Rmvdir:
++ *	front interface of vd_Rmvdir.
++ * vd_Rmvdir:
++ *	remove virtual directory function.
++ */
++int Rmvdir(dir)
++char *dir;
++{
++    int rv;
++    char buf[MAXPATHLEN+1];
++  
++    strcpy(buf, dir);
++    vd_optimize_path(buf);
++
++    rv = vd_Rmvdir(buf);
++    vd_packvdtable();
++    return rv;
++}
++
++static int vd_Rmvdir(dir)
++char *dir;
++{
++    int i;
++    char tmp[MAXPATHLEN+1];
++
++    for(i = 0; i < vdcount; i++)
++	if (!strncmp(dir, vdtable[i], strlen(dir))) {
++	    sprintf(tmp, "%s%s", vdroot, vdtable[i]);
++	    if (vd_Rmvdir(tmp))
++		return 1;
++	    if (vd_recursive_rmdir(tmp))
++		return 1;
++	    vdtable[i][0] = '\0';
++	}
++    return 0;
++}
++
++/*
++ * These functions move virtual directory, if exists.
++ * Movevdir:
++ *	front interface of move virtual directory function.
++ * vd_Movevdir:
++ *	does real works.
++ */
++int Movevdir(src, dst)
++char *src, *dst;
++{
++/*
++    char sbuf[MAXPATHLEN+1], dbuf[MAXPATHLEN+1];
++
++    strcpy(sbuf, src);
++    vd_optimize_path(sbuf);
++
++    strcpy(dbuf, dst);
++    vd_optimize_path(dbuf);
++
++    return (vd_Movevdir(sbuf, dbuf));
++*/
++    return (vd_Movevdir(src, dst));
++}
++
++static int vd_Movevdir(src, dst)
++char *src, *dst;
++{
++    int i;
++    char *p, *pp;
++    char tmp[MAXPATHLEN+1], tmps[MAXPATHLEN+1], tmpd[MAXPATHLEN+1];
++
++    for (i = 0; i < vdcount; i++)
++	if (!strncmp(src, vdtable[i], strlen(src))) {
++	    sprintf(tmps, "%s%s", vdroot, vdtable[i]);
++	    sprintf(tmp, "%s%s", dst, vdtable[i]+strlen(src));
++	    sprintf(tmpd, "%s%s", vdroot, tmp);
++
++	    if (vd_Movevdir(tmps, tmpd))
++		return 1;
++
++	    pp = vdtable[i];
++	    p = (char *) malloc(strlen(tmp)+1);
++	    strcpy(p, tmp);
++	    vdtable[i] = p;
++
++	    strcpy(tmp, tmpd);
++	    for (p = tmp+strlen(tmp); *p != '/'; p--)
++		;
++	    *p = '\0';
++
++	    if (vd_recursive_mkdir(tmp))
++		goto VD_MOVEVDIR_ERR;
++
++	    if (rename(tmps, tmpd) < 0)
++		goto VD_MOVEVDIR_ERR;
++
++	    free(pp);
++	}
++    return 0;
++
++VD_MOVEVDIR_ERR:
++    free(vdtable[i]);
++    vdtable[i] = pp;
++    return 1;
++}
++
++/*
++ * These functions handle table of virual directories.
++ * vd_addvdtable:
++ *	add virtual directory to table.
++ * vd_packvdtable:
++ *	remove disused virtual directories from table.
++ */
++static void vd_addvdtable(vd)
++char *vd;
++{
++    char *p;
++    p = (char *) malloc(strlen(vd)+1);
++    strcpy(p, vd);
++    vdtable[vdcount] = p;
++    vdcount++;
++}
++
++static void vd_packvdtable()
++{
++    int i, j;
++
++    for (i = j = 0; i < vdcount; i++)
++	if (vdtable[i][0] != '\0')
++	    vdtable[j++] = vdtable[i];
++	else
++	    free(vdtable[i]);
++
++    vdcount = j;
++}
++
++/*
++ * These are utility functions.
++ * vd_recursive_mkdir:
++ *	make directories recursively.
++ * vd_recursive_rmdir
++ *	remove directories recursively.
++ */
++static int vd_recursive_mkdir(dir)
++char *dir;
++{
++    char buf[MAXPATHLEN+1], *p;
++    struct stat st;
++
++    strcpy(buf, dir);
++
++    if (buf[strlen(buf) - 1] == '/')
++	buf[strlen(buf) - 1] = '\0';
++
++    p = rindex(buf, '/');
++    *p = '\0';
++
++    if (stat(buf, &st) < 0)
++	if (vd_recursive_mkdir(buf) < 0)
++	    return (-1);
++
++    *p = '/';
++    if (mkdir(buf, 0700) < 0)
++	return (-1);
++
++    return (0);
++}
++
++static int vd_recursive_rmdir(dir)
++char *dir;
++{
++    char buf[MAXPATHLEN+1], buf2[MAXPATHLEN+1];
++    DIR *dp;
++    struct dirent *di;
++
++    strcpy(buf, dir);
++
++    if (buf[strlen(buf) - 1] == '/')
++	buf[strlen(buf) - 1] = '\0';
++
++    if ((dp = opendir(buf)) == NULL)
++	return (-1);
++
++    while ((di = readdir(dp)) != NULL) {
++	struct stat st;
++
++	if (!strcmp(di->d_name, ".") || !strcmp(di->d_name, ".."))
++	    continue;
++
++	sprintf(buf2, "%s/%s", dir, di->d_name);
++
++	stat(buf2, &st);
++	if (S_ISDIR(st.st_mode)) {
++	    if (vd_recursive_rmdir(buf2) < 0)
++		goto VD_RECURSIVE_RMDIR_ERR;
++	} else
++	    unlink(buf2);
++    }
++    if (rmdir(buf) < 0)
++	goto VD_RECURSIVE_RMDIR_ERR;
++
++    closedir(dp);
++    return (0);
++
++VD_RECURSIVE_RMDIR_ERR:
++    closedir(dp);
++    return (-1);
++}
++
++/*
++ * These functions tests specified path.
++ * Isarchive:
++ *	tests, is it archive?
++ * Isvdir:
++ *	tests, is it in the virtual directory?
++ */
++int Isarchive(path)
++char *path;
++{
++    int ftype;
++
++    if ((ftype = vd_ftype(path)) < 0)
++	return 0;
++
++    if (ftype == RFT_COMPRESS)
++	if (!(ftype = vd_compp(path, NULL)))
++	    return 0;
++
++    return ftype;
++}
++
++int Isvdir(path)
++char *path;
++{
++    int rv = 0;
++    char tmp1[MAXPATHLEN+1], tmp2[MAXPATHLEN+1];
++    int archive1, archive2;
++
++    strcpy(tmp1, path);
++    strcpy(tmp2, path);
++
++    vd_optimize_path(tmp1);
++    Dirtovd(tmp2);
++
++    archive1 = Isarchive(tmp1);
++    archive2 = Isarchive(tmp2);
++
++    if (strcmp(tmp1, tmp2)) {
++	char tmp3[MAXPATHLEN+1], tmp4[MAXPATHLEN+1];
++	int archive3, archive4;
++
++	sprintf(tmp3, "%s%s", vdroot, tmp1);
++	strcpy(tmp4, tmp2+strlen(vdroot));
++
++	archive3 = Isarchive(tmp3);
++	archive4 = Isarchive(tmp4);
++
++	if (archive4 && !strcmp(tmp1, tmp4)) {
++	    rv |= 06;
++	    return rv;
++	}
++	rv |= 01;
++	if (archive2)
++	    rv |= 02;
++	else if (archive4)
++	    rv |= 06;
++	return rv;
++    }
++    if (archive1)
++	rv |= 02;
++
++    return rv;
++}
++
++/*
++ * This function optimizes given path.
++ * Expand '~' to home directory and removes '.', and treat '..'.
++ */
++static void vd_optimize_path(path)
++char *path;
++{
++    char *tmp, *reserve;
++
++    if (!strcmp(path, STDINSTR))
++	return;
++
++    if (*path == '\0') {
++	xv_getwd(path, MAXPATHLEN+1);
++	return;
++    }
++    if (*path == '~')
++	Globify(path);
++    if (*path != '/') {
++	char tmp[MAXPATHLEN+1];
++
++	strcpy(tmp, path);
++	xv_getwd(path, MAXPATHLEN+1);
++	strcat(path, "/");
++	strcat(path, tmp);
++    }
++
++    reserve = tmp = path;
++    while(*path != '\0') {
++	if (*path == '/') {
++	    *tmp++ = *path;
++	    while (*++path == '/')
++		;
++	    continue;
++	}
++	if ((*path == '.') && (*(path-1) == '/')) {
++	    if (*(path+1) == '/') {
++		tmp--;
++		path++;
++		continue;
++	    } else if (*(path+1) == '\0') {
++		tmp--;
++		break;
++	    } else if (*(path+1) == '.')
++		if (*(path+2) == '/') {
++		    if ((tmp - reserve) > 1)
++			for (tmp-=2; (*tmp != '/'); tmp--)
++			    ;
++		    else
++			tmp = reserve;
++		    path+=2;
++		    continue;
++		} else if (*(path+2) == '\0') {
++		    if ((tmp - reserve) > 1)
++			for (tmp-=2; (*tmp != '/'); tmp--)
++			    ;
++		    else
++			tmp = reserve+1;
++		    break;
++		}
++	}
++	*tmp++ = *path++;
++    }
++    if (((tmp - reserve) > 1) && *(tmp-1) == '/')
++	tmp--;
++    if (tmp == reserve)
++	*tmp++ = '/';
++
++    *tmp = '\0';
++}
++
++/*
++ * These functions dicide file type.
++ */
++static int vd_ftype(fname)
++char *fname;
++{
++    /* check archive type */
++
++    FILE *fp;
++    byte  magicno[30];    /* first 30 bytes of file */
++    int   rv, n;
++    struct stat st;
++
++    if (!fname) return VD_ERR;   /* shouldn't happen */
++
++    if ((!stat(fname, &st)) && (st.st_mode & S_IFMT) == S_IFDIR) 
++	return VD_UKN;
++    fp = xv_fopen(fname, "r");
++    if (!fp) return VD_ERR;
++
++    n = fread(magicno, (size_t) 1, (size_t) 30, fp);  
++    fclose(fp);
++
++    if (n<30) return VD_UKN;    /* files less than 30 bytes long... */
++
++    rv = VD_UKN;
++
++    if (magicno[0] == 0x60 && magicno[1]==0xea) rv = VD_ARJ;
++
++    else if (magicno[2] == '-' && magicno[3] == 'l' &&
++	     magicno[4] == 'h') rv = VD_LZH;
++
++    else if (strncmp((char *) magicno,"PK", (size_t) 2)==0) rv = VD_ZIP;
++
++    else if (magicno[20]==0xdc && magicno[21]==0xa7 &&
++	     magicno[22]==0xc4 && magicno[23]==0xfd) rv = VD_ZOO;
++
++    else if (vd_tarc(fname)) rv = VD_TAR;
++
++    else if (magicno[0]==0x1f && magicno[1]==0x9d) rv = RFT_COMPRESS;
++
++    else if (!strncmp((char *) &magicno[11], "MAJYO", (size_t) 5))
++	     rv = VD_UKN; /* XXX */
++
++    else if (magicno[0] == 26) rv = VD_ARC;
++
++#ifdef GUNZIP
++    else if (magicno[0]==0x1f && magicno[1]==0x8b) rv = RFT_COMPRESS;/* gzip */
++    else if (magicno[0]==0x1f && magicno[1]==0x9e) rv = RFT_COMPRESS;/*  old */
++    else if (magicno[0]==0x1f && magicno[1]==0x1e) rv = RFT_COMPRESS;/* pack */
++#endif
++
++    return rv;
++}
++
++static int vd_compp(path, newpath)
++char *path, *newpath;
++{
++    /*
++     * uncompress and check archive type.
++     *
++     * If newpath is NULL, uncompress only 512 byte of 'path' and 
++     * check archive type, so it is for SPEED-UP strategy.
++     * In this case, caller this function does not have to unlink
++     * tempoary file.
++     * Unfortunately it does not work in VMS system.
++     */
++
++    int file_type, r;
++    char uncompname[128], basename[128];
++
++    if (newpath) *newpath = '\0';
++    strcpy(basename, path);
++#if (defined(VMS) && !defined(GUNZIP))
++    /* VMS decompress doesn't like the file to have a trailing .Z in fname
++    however, GUnZip is OK with it, which we are calling UnCompress */
++    *rindex (basename, '.') = '\0';
++#endif
++#ifdef VMS
++    if (UncompressFile(basename, uncompname)) {
++#else
++    if (newpath == NULL)
++	r = vd_UncompressFile(basename, uncompname);
++    else
++	r = UncompressFile(basename, uncompname);
++    if (r) {
++#endif
++	if ((file_type = vd_ftype(uncompname)) < 0) {
++	    unlink(uncompname);
++	    return 0;
++	}
++	if (newpath) strcpy(newpath, uncompname);
++	else unlink(uncompname);
++    } else {
++	return 0;
++    }
++    return file_type;
++}
++
++#define HEADERSIZE 512
++
++static void  vd_Dirtovd    		PARM((char *));
++static int   stderr_on			PARM((void));
++static int   stderr_off			PARM((void));
++static FILE  *popen_nul			PARM((char *, char *));
++
++static int vd_UncompressFile(name, uncompname)
++char *name, *uncompname;
++{
++    /* Yap, I`m nearly same as original `UncompnameFile' function, but,
++       1) I extract `name' file ONLY first 512 byte.
++       2) I'm called only from UNIX and UNIX like OS, *NOT* VMS */
++    /* returns '1' on success, with name of uncompressed file in uncompname
++       returns '0' on failure */
++
++    char namez[128], *fname, buf[512], tmp[HEADERSIZE];
++    int n;
++    FILE *pfp, *tfp;
++  
++    fname = name;
++    namez[0] = '\0';
++
++
++#ifndef GUNZIP
++    /* see if compressed file name ends with '.Z'.  If it *doesn't* we need
++       temporarly rename it so it *does*, uncompress it, and rename *back*
++       to what it was.  necessary because uncompress doesn't handle files
++       that don't end with '.Z' */
++
++    if (strlen(name) >= (size_t) 2            && 
++	strcmp(name + strlen(name)-2,".Z")!=0 &&
++	strcmp(name + strlen(name)-2,".z")!=0) {
++	strcpy(namez, name);
++	strcat(namez,".Z");
++
++	if (rename(name, namez) < 0) {
++	    sprintf(buf, "Error renaming '%s' to '%s':  %s",
++		    name, namez, ERRSTR(errno));
++	    ErrPopUp(buf, "\nBummer!");
++	    return 0;
++	}
++
++	fname = namez;
++    }
++#endif   /* not GUNZIP */
++  
++    sprintf(uncompname, "%s/xvuXXXXXX", tmpdir);
++    mktemp(uncompname);
++    sprintf(buf,"%s -c %s", UNCOMPRESS, fname);
++
++    SetISTR(ISTR_INFO, "Uncompressing Header '%s'...", BaseName(fname));
++    if ((pfp = popen_nul(buf, "r")) == NULL) {
++	SetISTR(ISTR_INFO, "Cannot extract for archive '%s'.",
++		BaseName(fname));
++	Warning();
++	return 0;
++    }
++    if ((tfp = fopen(uncompname, "w")) == NULL) {
++	SetISTR(ISTR_INFO, "Unable to create temporarly file.",
++		BaseName(uncompname));
++	Warning();
++	pclose(pfp);
++	return 0;
++    }
++    if ((n = fread(tmp, 1, sizeof(tmp), pfp)) != HEADERSIZE) {
++	SetISTR(ISTR_INFO, "Unable to read '%s'.",
++		BaseName(fname));
++	Warning();
++	pclose(pfp);
++	fclose(tfp);
++	return 0;
++    }
++    fwrite(tmp, 1, n, tfp);
++    fclose(tfp);
++    pclose(pfp);
++    
++    /* if we renamed the file to end with a .Z for the sake of 'uncompress', 
++       rename it back to what it once was... */
++
++    if (strlen(namez)) {
++	if (rename(namez, name) < 0) {
++	    sprintf(buf, "Error renaming '%s' to '%s':  %s",
++		    namez, name, ERRSTR(errno));
++	    ErrPopUp(buf, "\nBummer!");
++	}
++    }
++  
++    return 1;
++}
++
++#define TARBLOCK 512
++#define CKSTART 148 /* XXX */
++#define CKSIZE 8
++
++/*
++ * Tar file: 1, other: 0
++ */
++static int vd_tarc(fname)
++char *fname;
++{
++    FILE *fp;
++    unsigned int sum;
++    char *ckp, buf[TARBLOCK];
++
++    if ((fp = fopen(fname, "r")) == NULL)
++	return 0;
++
++    fread(buf, TARBLOCK, 1, fp);
++    fclose(fp);
++
++    for (sum = 0, ckp = buf + CKSTART;
++	 (ckp < buf + CKSTART + CKSIZE) && *ckp != '\0';
++	 ckp++) {
++	sum *= 8;
++	if (*ckp == ' ')
++	    continue;
++	if (*ckp < '0' || '7' < *ckp)
++	    return 0;
++	sum += *ckp - '0';
++    }
++    if (sum != vd_tar_sumchk(buf))
++	return 0;
++
++    return 1;
++}
++
++static unsigned int vd_tar_sumchk(buf)
++char *buf;
++{
++    int i;
++    unsigned int sum = 0;
++
++    for (i = 0; i < CKSTART; i++) {
++	sum += *(buf + i);
++    }
++    sum += ' ' * 8;
++    for (i += 8; i < TARBLOCK; i++) {
++	sum += *(buf + i);
++    }
++    return sum;
++}
++
++
++static stde = -1;        /*  fd of stderr    */
++static nul = -1;         /*  fd of /dev/null */
++
++/*
++ * switch off the output to stderr(bypass to /dev/null).
++ */
++static int stderr_off()
++{
++    if (nul < 0)
++      nul = open("/dev/null", O_RDONLY);
++    if (nul < 0) {
++	fprintf(stderr, "/dev/null open failure\n");
++	return -1;
++    }
++    if (stde < 0)
++	stde = dup(2);
++    if (stde < 0) {
++	fprintf(stderr, "duplicate stderr failure\n");
++	return -1;
++    }
++    close(2);
++    dup(nul);
++    return 0;
++}
++
++/*
++ * turn on stderr output.
++ */
++static int stderr_on()
++{
++    if ((stde < 0) || (nul < 0)) {
++	fprintf(stderr, "stderr_on should call after stderr_off\n");
++	return -1;
++    }
++    close(2);
++    dup(stde);
++    return 0;
++}
++
++/*
++ * popen with no output to stderr.
++ */
++static FILE *popen_nul(prog, mode)
++char *prog, *mode;
++{
++    FILE *fp;
++
++    stderr_off();
++    fp = popen(prog, mode);
++    stderr_on();
++    return fp;
++}
++
++/*
++ * These functions are for SIGNAL.
++ * If XV end by C-c, there are dust of directory which name is .xvvd???,
++ * made by xvvd. Then, I handle SIGINT, and add good finish.
++ */
++void vd_HUPhandler()
++{
++#if defined(SYSV) || defined(SVR4)
++    sighold(SIGHUP);
++#else
++    int mask;
++    mask = sigblock(sigmask(SIGHUP));
++#endif
++
++  Vdsettle();
++
++#if defined(SYSV) || defined(SVR4)
++    sigrelse(SIGHUP);
++    signal(SIGHUP, (void (*)PARM((int))) vd_HUPhandler);
++#else
++    sigsetmask(mask);
++#endif
++}
++
++void vd_handler(sig)
++int sig;
++{
++#if defined(SYSV) || defined(SVR4)
++    sighold(sig);
++#else
++    sigblock(sigmask(sig));
++#endif
++
++    Quit(1); /*exit(1);*/
++}
++
++int vd_Xhandler(disp,event)
++Display *disp;
++XErrorEvent *event;
++{
++    Quit(1); /*exit(1);*/
++}
++
++int vd_XIOhandler(disp)
++Display *disp;
++{
++    fprintf(stderr, "XIO  fatal IO error ? (?) on X server\n");
++    fprintf(stderr, "You must normal exit in xv usage.\n");
++    Quit(1); /*exit(1);*/
++}
++
++void vd_handler_setup()
++{
++    signal(SIGHUP, (void (*)PARM((int))) vd_HUPhandler);
++    signal(SIGINT, (void (*)PARM((int))) vd_handler);
++    signal(SIGTERM,(void (*)PARM((int))) vd_handler);
++
++    XSetErrorHandler(vd_Xhandler);
++    XSetIOErrorHandler(vd_XIOhandler);
++}
++#endif /* AUTO_EXPAND */
diff -Naur xv-3.10a.old/xv-jp-extension/README.PhotoCD xv-3.10a/xv-jp-extension/README.PhotoCD
--- xv-3.10a.old/xv-jp-extension/README.PhotoCD	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/README.PhotoCD	Thu Mar 23 09:21:50 1995
@@ -0,0 +1,88 @@
+Copyright 1993,1994 David Clunie, Riyadh, Saudi Arabia.
+
+PCD patch for XV 3.00 Release Notes 6 Jan 94.
+
+Modified Mar 95 for XV 3.10a and to include in magpic patch by
+ikeyan@airlab.cs.ritsumei.ac.jp <IKEMOTO Masahiro>.
+
+These patches allow xv to read Kodak photocd files and choose which of the
+5 available resolutions one wants to view.
+
+It is pretty crude and was written quickly for a specific purpose and has
+not really been cleaned up. It is poorly structured, full of debugging
+codes and verbose comments, and there is very little attempt at optimizing
+things. No profiling has been done.
+
+There is not yet support for overview files, nor is there a facility to
+use the higher resolution chroma planes from when viewing lower resolution
+images. Colin Canfield (see below) has added support for the visual
+schnauzer thumbnail and command line (which I never use so hadn't
+bothered with). So for instance, one can now specify which resolution
+to use from the command line, and hence do slide shows without the size
+window popping up (happy now Pim ? :) )
+
+It's only claim to fame is that it works and produces reasonable looking
+images.
+
+The outline of this is shamelessly derived from xvpbm.c to read the
+file, and xvtiffwr.c to handle the popup window and X stuff (X never
+has been my forte !), and the PhotoCD format information (though not
+the code) was found in Hadmut Danisch's (danisch@ira.uka.de) hpcdtoppm
+program in which he has reverse engineered the format by studying
+hex dumps of PhotoCDs ! After all who can afford the Kodak developer's
+kit, which none of us have seen yet ? Am I even allowed to mention these
+words (Kodak, PhotoCD) ? I presume they are registered trade marks.
+
+PS. I have no idea how Halmut worked out the YCC <-> RGB conversion
+factors, but I have calculated them from his tables and the results
+look good enough to me.
+
+Sooner or later I will get around to trying to read overview files, using
+the higher resolution chroma maps (what Hadmut calls "overskip"), and get
+the colour tables right !
+
+Feel free to send me comments or improvements, or even better, more
+information about the photo CD format ... hopefully someone who really
+knows what they are doing will tidy it up or do a neater job.
+
+david (dclunie@flash.us.com) (now living in sunny Saudi Arabia !)
+
+---------
+
+The trace #define in xvpcd.c is now in the right place, and the ansi
+prototype for the magnify function has been fixed. Colin made me switch to xvbcopy() which seems like a good idea for System V victims.
+
+Still haven't fixed the colour tables. Supposedly they are a bit green. I
+just bought a Mac so I thought I might run some photoCD images through
+Adobe Photoshop and compare the colours with the xv patch. Stay tuned.
+
+---------
+
+Date: Wed, 22 Dec 1993 16:09:52 --1000
+From: colinc@fitmail.fit.qut.edu.au (Colin Canfield )
+
+I have done some more work using your patch I thought you might be intested in.
+The major change was adding a size parameter to the LoadPCD; either -1 to mean
+the popup or else the size you desired. This allows batch mode processing,
+specifically xv -pcd <size> <filename>, and the visual schnauzer can work in 
+quick mode (ie. you don't have to select each image size when it is building 
+the icons)
+
+I have added an xbm file for the file type but haven't drawn an icon for it,
+this is in bitmaps/br_pcd.xbm. I will just send you the new files.
+
+---------
+
+I have modified for XV 3.10a and to include in magpic patch. I removed
+HAVE_PCD symbol.
+
+I have removed some unused valuables, and changed order of argument of
+ULineString() function.
+
+I have replaced XDrawString() function to DrawString() in DrawTD().
+
+I have imported PARM() scheme and fix some prototype definition.
+
+I have drawn a photocd icon, this is in bits/br_pcd.
+
+	ikeyan@airlab.cs.ritsumei.ac.jp <ikeyan@airlab.cs.ritsumei.ac.jp>
diff -Naur xv-3.10a.old/xv-jp-extension/README.xv310a-ext-5.3.3 xv-3.10a/xv-jp-extension/README.xv310a-ext-5.3.3
--- xv-3.10a.old/xv-jp-extension/README.xv310a-ext-5.3.3	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/README.xv310a-ext-5.3.3	Thu Nov 21 17:07:20 1996
@@ -0,0 +1,651 @@
+
+	XV - Version 3.10a Rev: 12/29/94
+	Japanese extention $B%Q%C%A(B rev5.3.3 10/07/96
+
+[$B$3$N%Q%C%A$O2?(B?]
+
+  XV Version 3.10a $B$N5!G=$r3HD%$9$k$?$a$N%Q%C%A$G$9(B. $B6qBNE*$KDI2C$5$l(B
+$B$k5!G=$O0J2<$NDL$j$G$9(B.
+
+  $B!&(BMAKI, MAG, PIC, Pi, PIC2 $B%U%)!<%^%C%H$N2hA|%G!<%?$rI=<($G$-$^$9(B.
+  $B!&(BMAKI, MAG, PIC, Pi, PIC2 $B%U%)!<%^%C%H$G2hA|%G!<%?$rJ]B8$G$-$^$9(B.
+  $B!&(BKodak PhotoCD $B%U%)!<%^%C%H$N2hA|%G!<%?$rI=<($G$-$^$9(B.
+  $B!&@hF,(B 128Bytes $B$K%U%!%$%k>pJs$,IU2C$5$l$F$$$k(B Macintosh $B%U%!%$%k(B
+    (MacBinay $B7A<0(B) $B$N2hA|%G!<%?$rI=<($G$-$^$9(B.
+  $B!&(Barc, arj, lzh, tar, tar+compress(or gzip, pack(gzip $B$GE83+2DG=$J$b(B
+    $B$N(B)), zip, zoo $B7A<0$G%"!<%+%$%V$5$l$?%U%!%$%k$r<+F0E83+$7$F(B, $B%G%#(B
+    $B%l%/%H%j$N$h$&$K07$&$3$H$,$G$-$^$9(B.
+  $B!&F|K\8l(B, $B$"$k$$$OB?9q8l$r4^$`%F%-%9%H%U%!%$%k$r(B TextViewer $B$GI=<($9(B
+    $B$k$3$H$,$G$-$^$9(B.
+  $B!&(BVisual Shunauzer $B$GI=<($5$l$k(B Icon $B$K(B, $B2hA|$N%"%9%Z%/%H$rH?1G$5$;(B
+    $B$k$3$H$,$G$-$^$9(B.
+  $B!&(BIcon $BJ]B8MQ$N%G%#%l%/%H%j$,:n@.$G$-$J$$>l9g$G$b(B, Virtual directory 
+    $B5!9=$rMQ$$$F(B, XV $B$r=*N;$9$k$^$G(BIcon $B$rJ];}$9$k$3$H$,$G$-$^$9(B.
+  $B!&(B~/.xv_mgcsfx $B$K%U%#%k%?%3%^%s%I$rDj5A$9$k$3$H$K$h$j(B, XV $B$GD>@\%5%]!<(B
+    $B%H$5$l$F$$$J$$%U%)!<%^%C%H$N2hA|$bI=<($9$k$3$H$,$G$-$^$9(B.
+
+
+[$B$3$N%"!<%+%$%V$,4^$`$b$N(B]
+
+  README.xv310a-ext-5.3.3	$B$3$N%U%!%$%k(B
+  README.xv310a-ext-5.3.3.eg	$B1Q8lHG(B README
+  README.PhotoCD		PhotoCD $B%Q%C%A$N(B README
+  CHANGELOG.jp-ext		$BJQ99MzNr(B
+  magic.add			magic $B%G!<%?%Y!<%9$N%5%s%W%k(B
+  Patch.xv310a-ext-5.3.3	$B%Q%C%A(B
+  contrib/			$B2hA|%U%)!<%^%C%HJQ49%U%#%k%?$N%=!<%9(B(*)
+
+  * xv-jp-extension $B%W%m%8%'%/%H$G$O(B, XV $B$GD>@\%5%]!<%H$5$l$F$$$J$$%U%)!<(B
+    $B%^%C%H$+$i(B ppm $B%U%)!<%^%C%H$X$NJQ49%U%#%k%?$rJg=8$7$^$9(B($B$=$N5U$N$3(B
+    $B$H$r9T$&%U%#%k%?$b$"$l$P(B, $B$J$*NI$$$G$9(B). $B4sB#$7$F$$$?$@$$$?%W%m%0(B
+    $B%i%`$O(B, $B<!2s$N%j%j!<%9$+$i$N(B contrib $B$K4^$^$;$FD:$-$^$9(B.
+
+
+[$B%Q%C%A$NEv$FJ}(B]
+
+1. $B$3$N%"!<%+%$%V$r(B XV-3.10a $B$NE83+$7$F$"$k%G%#%l%/%H%j$GE83+$7$^$9(B.
+
+2. $B%Q%C%A$rEv$F$^$9(B.
+	% patch -p1 < xv-jp-extension/Patch.xv310a-ext-5.3.3
+
+3. config.h $B$rE,@Z$K@_Dj$7$^$9(B.
+
+ a) MAG, PIC, MAKI, Pi, PIC2, PhotoCD $B3F%U%)!<%^%C%H$N$&$A(B, $B%5%]!<%H$7(B
+    $B$?$/$J$$%U%)!<%^%C%H$,$"$k>l9g$O(B,
+	#define HAVE_MAG
+	#define HAVE_PIC
+	#define HAVE_MAKI
+	#define HAVE_PI
+	#define HAVE_PIC2
+	#define HAVE_PCD
+     $B$N$&$A(B, $B3:Ev$9$k9T$r%3%a%s%H%"%&%H$7$F2<$5$$(B.
+
+  b) MacBinary $B7A<0$N%U%!%$%k$r07$$$?$$>l9g$O(B,
+	#undef MACBINARY
+     $B$N9T$N(B MACBINARY $B$r(B define $B$7$F2<$5$$(B.
+     ($BC"$7$3$NMM$K%3%s%Q%$%k$7$?(B XV $B$G$b(B, MacBinary $B%U%!%$%k$r07$&>l9g(B
+      $B$K$O%j%=!<%9$H$7$F(B `macbinary' $B$r;XDj$9$k$+(B, $B<B9T;~$K(B `-macbinary'
+      $B%*%W%7%g%s$N;XDj$,I,MW$G$9(B)
+
+  c) $B%"!<%+%$%V<+F0E83+5!G=$rMxMQ$7$?$$>l9g$O(B,
+	#undef AUTO_EXPAND
+     $B$r(B define $B$7$F$/$@$5$$(B. $B$^$?(B, $B2>A[(B Icon $B%G%#%l%/%H%j5!9=$rMQ$$$?(B
+     $B$$>l9g$O(B, AUTO_EXPAND $B$H$H$b$K(B, 
+	#undef VIRTUAL_TD
+     $B$r(B define $B$7$F$/$@$5$$(B.
+
+  d) Visual Shunauzer $B$N(B icon $B$K%"%9%Z%/%H$rH?1G$G$-$k$h$&$K$7$?$$>l(B
+     $B9g$O(B, 
+	#undef VS_ADJUST
+     $B$r(B define $B$7$F$/$@$5$$(B.
+
+  e) TextViewer $B$NF|K\8lI=<(5!G=$rMxMQ$7$?$$>l9g$O(B, 
+	#undef TV_L10N
+     $B$r(B define $B$7$F$/$@$5$$(B.
+     ($BF|K\8l(B TextViewer $B$K$D$$$F$N>\:Y$O(B[$B;HMQ$K$"$?$C$F(B]$B$N!V(BTextViewer 
+     $BF|K\8lI=<(5!G=$K$D$$$F!W$N9`$r;2>H$7$F$/$@$5$$(B)
+
+  f) TextViewer $B$NB?9q8lI=<(5!G=$rMxMQ$7$?$$>l9g$O(B, 
+	#undef TV_MULTILINGUAL
+     $B$r(B define $B$7$F$/$@$5$$(B.
+     $BB?9q8lI=<(5!G=$r;HMQ$9$k$h$&$K@_Dj$7$?>l9g$O(B, TV_L10N $B$NF|K\8lI=(B
+     $B<(5!G=$O<+F0E*$K%*%U$K$J$j$^$9(B.
+     ($BB?9q8l(B TextViewer $B$K$D$$$F$N>\:Y$O(B[$B;HMQ$K$"$?$C$F(B]$B$N!V(BTextViewer 
+     $BB?9q8lI=<(5!G=$K$D$$$F!W$N9`$r;2>H$7$F$/$@$5$$(B)
+
+  g) $B%f!<%6Dj5A%U%#%k%?5!G=$rMxMQ$7$?$$>l9g$O(B,
+	#undef HAVE_MGCSFX
+     $B$r(B define $B$7$F$/$@$5$$(B.
+     $B$^$?(B, $B%f!<%6Dj5A%U%#%k%?$N%9%?!<%H%"%C%W%U%!%$%k$r(B, $B%W%j%W%m%;%C(B
+     $B%5$G=hM}$5$;$?$$>l9g$O(B,
+	#  undef USE_MGCSFX_PREPROCESSOR
+     $B$r(B define $B$7$F$/$@$5$$(B.
+     ($B%f!<%6Dj5A%U%#%k%?$K$D$$$F$N>\:Y$O(B[$B;HMQ$K$"$?$C$F(B]$B$N!V%f!<%6Dj5A(B
+     $B%U%#%k%?5!G=$K$D$$$F!W$N9`$r;2>H$7$F$/$@$5$$(B)
+
+4.  XV $B$N(B INSTALL $B$K$7$?$,$C$F%3%s%Q%$%k$7$^$9(B.
+
+  a) Makefile $B$rMxMQ$9$k>l9g$O(B, Makefile $BFb$N3:Ev2U=j$rE,@Z$K@_Dj$7(B,
+     make $B$r<B9T$7$F2<$5$$(B.
+     ($BF|K\8l(B TextViewer $B$r;HMQ$9$k>l9g$K(B, $B$*;H$$$N(B X Window System $B$,(B 
+      X_LOCALE $BIU$-$G%3%s%Q%$%k$5$l$F$$$k>l9g$O(B, Makefile $B$N(B
+      #TVL10N = -DX_LOCALE
+      $B$N9T$N%3%a%s%H$r30$7$F$/$@$5$$(B. $B>\$7$/$O(B[$B;HMQ$K$"$?$C$F(B]$B$N(B
+      $B!V(BTextViewer $BF|K\8lI=<(5!G=$K$D$$$F!W$N9`$r;2>H$7$F$/$@$5$$(B)
+
+  b) imake $B$rMxMQ$9$k>l9g$O(B, Imakefile $BFb$N3:Ev2U=j$rE,@Z$K@_Dj$7(B,
+
+       cd jpeg ; ./configure ; make libjpeg.a ; cd ..
+       xmkmf
+       make Makefiles
+       make depend
+       make
+
+     $B$NMM$K<B9T$7$F2<$5$$(B.
+
+5. contrib $B$K4^$^$l$k%U%#%k%?$r;HMQ$9$k>l9g$O(B, $BE,59%3%s%Q%$%k$7$F;HMQ(B
+   $B$7$F$/$@$5$$(B.
+
+
+[$B;HMQ$K$"$?$C$F(B]
+
+  $B!&%*%W%7%g%s$K$D$$$F(B
+    $B$3$N%Q%C%A$K$h$C$F(B, XV $B$K(B -macbinary(MACBINARY $B$rDj5A$7$?>l9g(B), 
+    -nopicadjust(HAVE_PIC $B$"$k$$$O(B HAVE_PIC2 $B$rDj5A$7$?>l9g(B),
+    -pcd(HAVE_PCD $B$rDj5A$7$?>l9g(B),
+    -pic2split(HAVE_PIC2 $B$rDj5A$7$?>l9g(B)
+    -vsadjust(VS_ADJUST $B$rDj5A$7$?>l9g(B)
+    -mgcsfx(HAVE_MGCSFX $B$rDj5A$7$?>l9g(B)
+    -nomgcsfx(HAVE_MGCSFX $B$rDj5A$7$?>l9g(B)
+    $B$N%*%W%7%g%s$,DI2C$5$l$^$9(B.
+
+    XV $B$K(B -macbinary $B%*%W%7%g%s$rIU$1$F5/F0$9$k$3$H$K$h$j(B, MacBinary
+    $B7A<0$N%U%!%$%k$rFI$_9~$`$3$H$,$G$-$k$h$&$K$J$j$^$9(B.
+
+    $B$^$?(B, -nopicadjust $B%*%W%7%g%s$rIU$1$F5/F0$9$k$3$H$K$h$j(B, PIC, PIC2
+    $B%U%)!<%^%C%H$N%"%9%Z%/%HHf$rL5;k$9$k$h$&$K$J$j$^$9(B.
+    ($B$3$N%*%W%7%g%s$K$h$j(B, $B%"%9%Z%/%HHf$,(B 1:1 $B$G$J$$(B PIC, PIC2 $B2hA|$N(B
+     $BI=<($,B.$/$J$j$^$9(B)
+
+    -pcd # $B%*%W%7%g%s$O(B, PhotoCD $B$N2rA|EY$r;XDj$9$k$?$a$KMQ$$$^$9(B. $B%*(B
+   $B%W%7%g%s$N8e$KB3$/?t;z$O(B, $B$=$l$>$l(B
+
+    0: "192*128   Base/16"
+    1: "384*256   Base/4"
+    2: "768*512   Base"
+    3: "1536*1024 4Base"
+    4: "3072*2048 16Base"
+
+    $B$r;XDj$7$?$3$H$K$J$j$^$9(B.
+
+    -pic2split $B%*%W%7%g%s$rIU$1$F(B XV $B$r5/F0$9$k$H(B, $B%^%k%A%V%m%C%/$N(B
+    PIC2$B%U%!%$%k$rFI$_9~$`$H$-$K(B, $B%V%m%C%/$r$=$l$>$l%Z!<%8$KJ,3d$9$k$h(B
+   $B$&$K$J$j$^$9(B.
+
+    -vsadjust $B%*%W%7%g%s$rIU$1$F(B XV $B$r5/F0$9$k$H(B, Visual Shunauzer $B$N(B 
+    icon $B$K(B, $B2hA|$N%"%9%Z%/%H$,H?1G$5$l$k$h$&$K$J$j$^$9(B.
+
+    -mgcsfx $B%*%W%7%g%s$rIU$1$F(B XV $B$r5/F0$9$k$H(B, unknown $B$J(B format $B$K$D(B
+    $B$$$F%U%#%k%?$NF~NO$r5a$a$k$h$&$K$J$j$^$9(B.
+
+    -nomgcsfx $B%*%W%7%g%s$rIU$1$F(B XV $B$r5/F0$9$k$3$H$K$h$j(B, ~/.xv_mgcsfx 
+    $B$rFI$_9~$^$J$$$h$&$K$J$j$^$9(B.
+
+  $B!&(Bmaki $B%U%)!<%^%C%H$K$D$$$F(B
+    maki $B%U%)!<%^%C%H$O(B, $B$=$N;EMM>e(B, 640x400 $B0J30$N2rA|EY$G$N%;!<%V$O(B
+    $B$G$-$^$;$s(B.
+
+  $B!&(BPIC$B7A<0$G$N%;!<%V$K$D$$$F(B
+    $B5!<o%?%$%W$r(B0x0f($B3HD%%?%$%W(B)$B$K$7$F$$$k$?$a$K(B, $B0lIt$N%m!<%@$G$OI=<((B
+    $B$G$-$J$$$3$H$,$"$j$^$9(B.
+
+  $B!&(BPIC2$B%U%)!<%^%C%H$K$D$$$F(B
+    PIC2 $B$N%V%m%C%/%U%)!<%^%C%H$K$O(B, 4$B$D$N<oN`$,$"$j$^$9(B. $B05=LN($O(B,
+    P2BI, P2BM -> P2SF -> P2SS $B$N=g$K9b$/$J$j$^$9(B.
+
+    P2BI, P2BM $B$O(B, PIC2 $B$NFbIt7A<0$r$=$N$^$^%U%!%$%k$KG<$a$k$b$N$G(B, $B05(B
+    $B=L$OA4$/9T$o$l$^$;$s(B. P2BM $B$H(B P2BI $B$N0c$$$O(B, 2byte $B$N%+%i!<%3!<%I(B
+    $B$rG<$a$k$H$-$K(B, Intel order(Little endian)$B$GG<$a$k$+(B, Motorola
+    order(Big endian)$B$GG<$a$k$+$N0c$$$G$9(B.
+
+    P2SF $B$O(B, PIC $B%U%)!<%^%C%H$H$[$\F1MM$N05=LK!$rMQ$$$F$*$j(B, $BNX3T@~$r(B
+    $BCj=P$9$k$3$H$K$h$k%i%s%l%s%0%905=L$H(B, $B?'%-%c%C%7%e$rMQ$$$?05=L$r9T(B
+    $B$$$^$9(B.
+
+    P2SS $B$O(B, P2SF $B$GMQ$$$i$l$?05=LK!$K2C$((B, $B3F!9$N%T%/%;%k$K$D$$$F?'M=(B
+    $BB,$r9T$$$^$9(B. $B$=$7$F(B, $B$=$l$i$r%U%!%$%k$KG<$a$k:]$K(B, $B;;=Q05=L$H8F$P(B
+    $B$l$kM}O@>e:GBg$N05=L8zN($rF@$i$l$k05=L$r9T$$$^$9(B.
+
+    ColorDepth $B$O(B, $B%;!<%V$9$k?'$N%S%C%H?t$r;XDj$9$k$b$N$G$9(B. 15bit $B$G(B
+    $B$"$l$P(B, RGB $B$=$l$>$l(B 5bit $B$E$D%;!<%V$5$l$k$3$H$K$J$j$^$9(B.
+
+    XV $B$NFbIt$G$O%+%i!<$O(B 24bit $B$G07$o$l$F$$$^$9$N$G(B, 24bit $B$h$j>/$J$$(B
+    ColorDepth $B$G%;!<%V$9$k$H(B, $BKX$I$N>l9g$=$NJ,$N%+%i!<>pJs$O<:$o$l$F(B
+    $B$7$^$$$^$9(B.
+
+    $BNc30$O(B, PIC2 $B$"$k$$$O(B PIC $B$r(B, $B%m!<%I$7$?$H$-$HF1$8(B ColorDepath $B$G(B
+    $B%;!<%V$9$k>l9g$G$9(B. $B$3$N>l9g$O(B, $BK\Mh$N%$%a!<%8%U%!%$%k$N>pJs$O<:$o(B
+    $B$l$^$;$s(B.
+
+    $BA*Br$G$-$k(B ColorDepth $B$N$&$A(B, $B%]!<%?%S%j%F%#$,$"$k$N$O(B, 24bit $B$H(B
+    15bit $B$N$_$G$9(B. $BB>5!<o$X%G!<%?$r0\F0$7$h$&$H9M$($F$$$k$R$H$OCm0U$7(B
+    $B$F$/$@$5$$(B.
+
+    PIC2 $B%U%)!<%^%C%H$G%;!<%V$7$h$&$H$9$k$H$-$K(B, $B$9$G$KB8:_$9$k%U%!%$%k(B
+    $B$,;XDj$5$l(B, $B$+$D$=$l$,(B PIC2 $B%U%!%$%k$G$"$C$?>l9g(B, $BDI2C%;!<%V$9$k$+(B
+    $B$I$&$+?R$$$F$/$k$h$&$K$J$C$F$$$^$9(B.
+
+    $BDI2C%;!<%V$r$7$?>l9g(B, $B%^%k%A%V%m%C%/(B PIC2 $B%U%!%$%k$H$7$F%;!<%V$5$l(B
+    $B$^$9(B. $B$3$N$H$-$O(B, $B4{B8$N(B PIC2 $B%U%!%$%k$HF1$8(B ColorDepth $B$7$+A*Br$G(B
+    $B$-$^$;$s$N$G(B, $BCm0U$7$F$/$@$5$$(B.
+
+    PIC2 $B%;!<%V;~$N%*%U%;%C%H$O(B, $B:8>e$r86E@$H$7$?%I%C%H?t$G;XDj$7$F$/(B
+    $B$@$5$$(B. $B2hA|$O(B, $B$3$N%*%U%;%C%H$NJ,$@$186E@$+$iN%$l$?0LCV$K%;!<%V$5(B
+    $B$l$^$9(B.
+
+  $B!&%"!<%+%$%V<+F0E83+5!G=$K$D$$$F(B
+    $B%"!<%+%$%V<+F0E83+5!G=$rMxMQ$9$k$K$O(B, $B%"!<%+%$%V7A<0$K1~$8$?E83+%D!<(B
+    $B%k$,I,MW$G$9(B. $BE83+%D!<%k$O(B, xvvd.c $B$K0J2<$N$h$&$KDj5A$5$l$F$$$^$9(B
+    $B$N$G(B, $BB>$NE83+%D!<%k$r;HMQ$7$?$$$+$?$O(B, $B$3$l$i$r$*;}$A$N%D!<%k$K9g(B
+    $B$o$;$FJQ99$7$F$/$@$5$$(B.
+
+    arc:	arc xo
+    arj:	unarj x
+    lzh:	lha -xf
+    tar:	tar xvf
+    zip:	unzip -xo
+    zoo:	zoo xOS
+
+    $B%"!<%+%$%V$5$l$?%U%!%$%k$O(B, $B%F%s%]%i%j%(%j%"$KE83+$5$l(B, $B2>A[E*$K%G%#(B
+    $B%l%/%H%j$H$7$F07$o$l$^$9(B. $B$3$N2>A[%G%#%l%/%H%j$NFbMF$O(B, $B0l@ZJQ99$9(B
+    $B$k$3$H$,$G$-$^$;$s(B.
+
+    $B%;!<%V;~$K$*$$$F(B, $B2>A[%G%#%l%/%H%jFb$K2hA|$r%;!<%V$9$k$3$H$O$G$-$^(B
+    $B$;$s(B($B%"!<%+%$%V<+BN$K>e=q$-$9$k$3$H$O2DG=$G$9(B).
+
+    Visual Shunauzer $B$G$O(B, $B2>A[%G%#%l%/%H%jFb$K$*$$$F(B, $B%U%!%$%k$K4X$9(B
+    $B$k%G%j!<%H$d%j%M!<%`$J$I$NA`:n$O$G$-$^$;$s$7(B, $B?75,$K%G%#%l%/%H%j$r(B
+    $B:n@.$9$k$3$H$b$G$-$^$;$s(B. $B$^$?(B, $B2>A[%G%#%l%/%H%jFb$K(B, $BB>$N%G%#%l%/(B
+    $B%H%j$+$i%U%!%$%k$r%3%T!<$7$F$/$k$3$H$b$G$-$^$;$s(B.
+    (Icon update $B$O2DG=$G$9$,(B, $B$=$N7k2L$O(B XV $B$r=*N;$9$k$H<:$o$l$^$9(B)
+
+    $B$^$?(B, $B2>A[%G%#%l%/%H%j$+$iIaDL$N%G%#%l%/%H%j$KBP$7$F%U%!%$%k$r%I%i%C(B
+    $B%0$9$k$H(B, $B%`!<%V$G$O$J$/%3%T!<$H$7$F07$o$l$^$9(B.
+
+    $B2>A[%G%#%l%/%H%j$r3+$-$9$.$F%F%s%]%i%j%(%j%"$,B-$j$J$/$J$C$?>l9g$O(B,
+    `Misc Commands' $B%a%K%e!<$NCf$N(B `Clear virtual directory' $B$rA*Br$7(B
+    $B$F(B, $B2>A[%G%#%l%/%H%j$r%/%j%"$7$F$/$@$5$$(B.
+
+    $B2?$i$+$N860x$G(B XV $B$,0[>o=*N;$9$k$H(B, $B%F%s%]%i%j%(%j%"$KE83+%$%a!<%8(B
+    $B$,;D$k$3$H$,$"$j$^$9(B. $B$=$N>l9g$O(B, TMPDIR/.xvvdXXXXX(XXXXX $B$O(B $B0[>o(B
+    $B=*N;$7$?(B XV $B$N%W%m%;%9(B id)$B$r>C5n$7$F$/$@$5$$(B.
+
+  $B!&(BTextViewer $BF|K\8lI=<(5!G=$K$D$$$F(B
+    $B:#2s$N%Q%C%A$GF|K\8l2=$5$l$?(B TextViewer $B$O(B, $BF|K\8lJ8;z%3!<%I$r<+F0(B
+    $BH=JL$7$FI=<($r9T$$$^$9(B. $BJ8;z%3!<%I$NH=JL$K<:GT$7$F(B, $B$*$+$7$JJ8;z$,(B
+    $BI=<($5$l$?$H$-$K$O(B, TextViewer $B$N:82<$K$"$k%\%?%s$rMxMQ$7$F(B, $B%F%-(B
+    $B%9%H$NJ8;z%3!<%I$r<jF0$G@_Dj$7$F$/$@$5$$(B.
+
+    $BF|K\8l2=$5$l$?(B TextViewer $B$O(B, X Window System $B$N9q:]2=5!G=$r;HMQ$7(B
+    $B$F$$$^$9(B. $BF|K\8l$,;]$/I=<($5$l$J$$$J$I(B, $BF|K\8lI=<(5!G=$,$&$^$/F/$+(B
+    $B$J$$>l9g$O(B, $B0J2<$N9`L\$r%A%'%C%/$7$F$_$F$/$@$5$$(B.
+
+    * XV $B$N%=!<%9Cf$G@5$7$$(B locale $BL>$,A*Br$5$l$F$$$^$9$+!)(B
+      - X_LOCALE $B$rDj5A$7$F(B X $B$r9=C[$7$F$$$k>l9g(B. 
+
+	X_LOCALE $B$rDj5A$7$F9=C[$5$l$?(B X $B$r;HMQ$7$F$$$F(B, Makefile.std
+	$B$rMQ$$$F(B XV $B$r%3%s%Q%$%k$7$F$$$k>l9g$O(B, 
+	#TVL10N = -DX_LOCALE
+	$B$N9T$N%3%a%s%H$r30$7$F$/$@$5$$(B. 
+
+      - X_LOCALE $B$rDj5A$7$J$$$G(B X $B$r9=C[$7$F$$$k>l9g(B. 
+
+        X_LOCALE $B$rDj5A$7$J$$$G9=C[$5$l$F$$$k(B X $B$N>l9g(B, OS $B$,%5%]!<%H(B
+        $B$9$k(B locale $B$NL>A0$r@5$7$/@_Dj$7$J$$$H(B, TextViewer $B$NF|K\8lI=(B
+        $B<(5!G=$,@5>o$KF/$-$^$;$s(B. $B$3$A$i$GD4::$G$-$kHO0O$N(B OS $B$K$D$$$F(B
+        $B$O(B "xv.h" $B$K5-=R$7$F$"$j$^$9$,(B, $B$=$l$G$bF0:n$7$J$$>l9g$K$O(B,
+        "config.h" $B$N(B LOCALE_{EUC|JIS|MSKANJI}_NAME $B$NItJ,$r%"%s%3%a%s(B 
+        $B%H$7$F(B, $B$*;H$$$N(B OS $B$K9g$o$;$?(B locale $BL>$r@_Dj$7$F$/$@$5$$(B.
+
+        $B8=>u$G$O(B, $BF|K\8l(BEUC $B$KEv$?$k(B locale $BL>$7$+;HMQ$7$F$$$J$$$N$G(B,
+        JIS$B%3!<%I(B, $B$*$h$S(B MS$B4A;z%3!<%I$KEv$?$k(B locale $BL>$O(B, $BFC$K5-=R$7(B
+        $B$J$/$F$b9=$$$^$;$s(B.
+
+        $B$J$*(B, $B$3$3$G@_Dj$9$k(B locale $BL>$O(B, X $B$,G'<1$G$-$k$b$N$G$J$/$F$O(B
+        $B$J$j$^$;$s(B. locale $BL>$r@5$7$/JQ99$7$F$b(B, TextViewer $B$,$&$^$/F0(B
+        $B:n$7$J$$>l9g$K$O(B, X11R6 $B$N>l9g(B, lib/X11/locale/locale.alias $B%U%!(B
+        $B%$%k(B, X11R5 $B$N>l9g(B, lib/X11/nls $B$N2<$N%U%!%$%k$r%A%'%C%/$7$F$_(B
+        $B$F$/$@$5$$(B.
+
+        "xv.h" $B$K5-=R$5$l$F$$$J$$(B OS $B$K$D$$$F(B, $B$&$^$/(B TextViewer $B$NF|(B
+	$BK\8lI=<(5!G=$rF0:n$5$;$k$3$H$,$G$-$^$7$?$i(B, $B$=$N(B OS $B$K$D$$$F$N(B
+	$B>pJs$r(B, $B$3$A$i$^$GJs9p$7$F$$$?$@$-$?$$$H;W$$$^$9(B.
+
+	$BDs6!$7$F$$$?$@$/>pJs$O(B, 
+	$B!&(Bcpp $B$G(B, OS $B$,H=JL$G$-$kDj?t(B. 
+	  (gcc $B$N>l9g(B, gcc -v $B$GI=<($5$l$k(B spec $B%U%!%$%k$K(B, $BDj5A$5$l$k(B
+	   $BDj?t$N>pJs$,5-=R$5$l$F$$$^$9(B)
+	$B!&F|K\8l(BEUC, JIS, MS$B4A;z$K3:Ev$9$k(B OS $B$N(B locale $BL>(B
+	  ($BF|K\8l(BEUC $B0J30$O(B, $BL5$7$J$i$PL5$7$G7k9=$G$9(B).
+	$B$G$9(B. 
+
+    * "-*-fixed-medium-r-normal--14-*" $B$+(B, 
+      "-*-fixed-medium-r-normal--16-*" $B$K3:Ev$9$k%U%)%s%H(B($BF|K\8l%U%)%s(B
+      $B%H$r4^$`(B)$B$O$"$j$^$9$+!)(B
+
+      TextViewer $B$OF|K\8l$r4^$`%F%-%9%H$rI=<($9$k:]$K(B, $B$3$l$i$N%U%)%s(B
+      $B%H$r;HMQ$7$^$9(B. $B$3$l$i$N%U%)%s%H$,%$%s%9%H!<%k$5$l$F$$$J$$>l9g(B
+      $B$K$O(B, $B?7$?$K%U%)%s%H$r%$%s%9%H!<%k$9$k$+(B, "config.h" $B$N(B,
+      TV_FONTSIZE $B$N2U=j$r%"%s%3%a%s%H$7$F%U%)%s%H%5%$%:$N%(%s%H%j$rJQ(B
+      $B99$7$F$/$@$5$$(B. $B>l9g$K$h$C$F$O(B, $B2C$($F(B TV_FONTSET $B$N2U=j$r%"%s%3(B
+      $B%a%s%H$7$F(B, $B%U%)%s%HL>$r$*;H$$$N%^%7%s$K9g$o$;$FJQ99$7$F$/$@$5$$(B.
+
+    $B0J>e$N$3$H$r%A%'%C%/$7$F$b(B TextViewer $B$,@5>o$KF0:n$7$J$$>l9g$O(B, $B>u(B
+    $B67$r$3$A$i$^$GJs9p$7$F$/$@$5$$(B. $B$G$-$k8B$jBP=h$r9T$$$?$$$H;W$$$^$9(B.
+
+  $B!&(BTextViewer $BB?9q8lI=<(5!G=$K$D$$$F(B
+    $B$3$N5!G=$r;HMQ$9$k$H(B, $B1Q8l$dF|K\8l$@$1$G$J$/B>$N8@8l$b(B TextViewer 
+    $B$GI=<($9$k$3$H$,$G$-$^$9(B. locale $B$r;H$C$F$$$^$;$s$N$G(B, locale $B$,<e(B
+    $B$$(B OS $B$G$b;HMQ$G$-$^$9(B.
+
+    $B$?$@$7(B, $B%5%]!<%H$7$F$$$k%(%s%3!<%IJ}K!$O(B ISO 2022 $B7O$H(B Shift JIS
+    (Microsoft Kanji Code)$B$N$_$G$9(B. $B$^$?(B, $B1&$+$i=q$/8@8l$dAH9g$;J8;z$O(B
+    $B%5%]!<%H$7$F$$$^$;$s(B.
+
+    $B$3$N5!G=$r;HMQ$9$k$?$a$K$O(B, config.h $B$N(B 
+	#undef TV_MULTILINGUAL
+    $B$r(B define $B$K$7$F%3%s%Q%$%k$7$F$/$@$5$$(B. $B$3$N;~(B, TV_L10N $B$O<+F0E*$K(B 
+    undef $B$K$J$j$^$9(B. $B$^$?(B, $B%G%U%)%k%H$N%3!<%I7O$r(B TV_DEFAULT_CODESET 
+    $B$K;XDj$7$F2<$5$$(B. $B%3!<%I7O$O0J2<$NCf$+$i(B1$B$D$rA*$s$G2<$5$$(B.
+
+	TV_PLAIN		TV_ISO_2022_KR
+	TV_ISO_8859_1		TV_EUC_KOREA
+	TV_ISO_2022_JP		TV_ISO_2022_SS2_8
+	TV_EUC_JAPAN		TV_ISO_2022_SS2_7
+	TV_ISO_2022_INT_1	TV_SHIFT_JIS
+
+	(*) TV_PLAIN $B$O(B, $B=i4|>uBV$G(B G[1-4] $B$,A4$F(B iso-8859-1 $B$N:8H>LL(B
+	    $B$K$J$C$F$$$^$9$,(B, TV_ISO_8859_1 $B$O(B G2 $B$,(B iso-8859-1 $B$N1&H>(B
+	    $BLL$K$J$C$F$$$^$9(B.
+
+    $B5/F08e$G$b(B xv codeset $B%Q%M%k$G@_Dj$G$-$^$9$,(B, $B$@$+$i$H8@$C$F%3%s%Q(B
+    $B%$%k;~$N@_Dj$r$$$$2C8:$K$9$k$H(B, $B=i4|2=;~$KITMW$J%U%)%s%H$r%m!<%I$7(B
+    $B$F$7$^$$(B, XV $B$N5/F0$,CY$/$J$C$F$7$^$$$^$9(B.
+
+    $B<!$K!"%f!<%6$,9T$J$&$3$H$N$G$-$k@_Dj$K$D$$$F@bL@$7$^$9!#(B
+
+    $B%$%s%9%H!<%k;~$N(B TV_DEFAULT_CODESET $B$,5$$KF~$i$J$$%f!<%6$O!"(Bxrdb 
+    $B$K;XDj$9$k%U%!%$%k(B(.Xresources $B$J$I(B)$B$K0J2<$N$h$&$K=q$$$F2<$5$$!#(B
+
+	xv.codeSet:	euc-japan
+
+    $B$3$3$G$O!"0J2<$NCf$+$iA*Br$7$F2<$5$$!#BgJ8;z$H>.J8;z$r6hJL$7!"%9%Z!<(B
+    $B%9$N?t$K$bCm0U$7$F2<$5$$!#(B
+
+	plain		iso-2022-kr
+	iso-8859-1	euc-korea
+	iso-2022-jp	iso-2022-ss2-8
+	euc-japan	iso-2022-ss2-7
+	iso-2022-int-1	Shift JIS
+
+    text viewer $B$G;HMQ$5$l$k%U%)%s%H$b;XDj$G$-$^$9!#(Bxrdb $B$G;XDj$9$k%U%!(B
+    $B%$%k(B(.Xresources $B$J$I(B)$B$K0J2<$N$h$&$K=q$$$F2<$5$$!#(B
+
+	xv.fontSet:						 \
+	    -misc-fixed-medium-r-normal--16-*-*-*-*-*-iso8859-1, \
+	    -misc-fixed-medium-r-normal--16-*-*-*-*-*-jisx0208.1983-0
+
+    $B$^$?$O(B, $B$b$C$H4JC1$K(B,
+
+	xv.fontSet: -*--16-*
+
+    $B$H=q$$$F$b9=$$$^$;$s(B. $B;XDj$5$l$F$$$k%U%)%s%H$r;H$*$&$H$7$?$,(B, $B$=$N(B
+    $B%U%)%s%H$,B8:_$7$J$$>l9g(B,
+
+	xxx: font not found
+
+    $B$HI=<($5$l$^$9(B. $B$3$3$G(B, xxx $B$O%U%)%s%H$NL>A0$G$9(B. $B$^$?(B, $B;XDj$5$l$?(B
+    $B%U%)%s%H$,B8:_$7$J$$(B, $B$^$?$O(B, $B%U%)%s%H$,;XDj$5$l$F$$$J$$>l9g$K$O(B,
+
+	font for xxx not found.
+	using ascii font.
+
+    $B$HI=<($5$l$^$9(B. xxx $B$O%l%8%9%H%jL>(B(jisx0208.1983-0 $B$J$I(B)$B$G$9(B.
+
+    $B$5$F(B, $B$3$N5!G=$rAH$`9~$`$H(B, $B?'!9$J8@8l$N%F%-%9%H$,I=<($G$-$^$9$,(B,
+    $B$&$^$/I=<($G$-$J$$$3$H$b$7$P$7$P$"$j$^$9(B. $B$3$N;~$O(B xv text viewer 
+    $B$N:82<$K$"$k(B Code Sets $B$H$$$&%\%?%s$r2!$9$H8=$l$k(B xv codeset $B%Q%M(B
+    $B%k$G@_Dj$7$F2<$5$$(B. $B@_Dj$O(B text viewer $B$4$H$KFHN)$7$F9T$J$($^$9(B.
+    $B0J2<$K(B xv codeset $B%Q%M%k$N;H$$J}$r@bL@$7$^$9(B.
+
+    o Accept $B%\%?%s$H(B Close $B%\%?%s(B
+
+      $B0lHV2<$K$"$k%\%?%s$G$9(B. $BB>$N%\%?%s$d%a%K%e!<$J$I$G;XDj$7$?8e$K(B
+      Accept $B%\%?%s$r2!$9$H(B, $B$=$N;XDj$,(B text viewer $B$KH?1G$5$l$^$9(B.
+      $B$^$?(B, Close $B%\%?%s$r2!$9$H(B xv codeset $B%Q%M%k$rJD$8$^$9(B.
+
+      $BB>$N%\%?%s$d%a%K%e!<$J$I$G;XDj$7$F$b(B, Accept $B%\%?%s$r2!$5$:$K(B 
+      Close $B%\%?%s$r2!$9$H(B, text viewer $B$KH?1G$5$l$J$$$^$^(B xv codeset 
+      $B%Q%M%k$,JD$8$^$9(B.
+
+    o $B%7%g!<%H%+%C%H%\%?%s(B
+
+      $B2<$NJ}$K(B, iso-8859-1 $B$d(B euc-japan $B$J$I$H=q$+$l$?%\%?%s$,$$$/$D$+(B
+      $B$"$j$^$9(B. $B$3$l$i$r%7%g!<%H%+%C%H%\%?%s$H8F$S$^$9(B. $B$3$l$i$N%\%?%s(B
+      $B$r2!$9$3$H$h$C$F(B, $B0J2<$K@bL@$9$k(B Initial States $B$J$I$N@_Dj$r$^$H(B
+      $B$a$F9T$J$&$3$H$,$G$-$^$9(B.
+
+      ISO 2022 $B7?$N%(%s%3!<%IJ}K!$rM}2r$7$F$$$J$$J}$O(B, $B$3$l$i$N%\%?%s(B
+      $B$r;H$&$@$1$G$bNI$$$H;W$$$^$9(B.
+
+    o Initial States
+
+      $B=i4|>uBV$GCf4V%P%C%U%!(B(G0$B!A(BG3)$B$K;X<($5$l$F$$$kJ8;z=89g$H(B, GL $B$H(B 
+      GR $B$K8F$S=P$5$l$F$$$kCf4V%P%C%U%!$r;XDj$7$^$9(B. */Left $B$OJ8;z=89g(B
+      $B$N:8H>LL(B, */Right $B$O1&H>LL$r0UL#$7$^$9(B. nothing $B$O=i4|>uBV$G2?$b(B
+      $B8F$S=P$5$J$$$3$H$r;XDj$7(B, unused $B$O$=$NCf4V%P%C%U%!$r;HMQ$7$J$$(B
+      $B$3$H$r;XDj$7$^$9(B.
+
+    o Ret Code
+
+      $B2~9T%3!<%I$r;XDj$7$^$9(B. LF, CR, CR+LF $B$O$=$N$^$^$N0UL#$G$9(B. UNIX 
+      $B$G:n@.$7$?%F%-%9%H$rI=<($9$k;~$O(B LF $B$r(B, DOS $B$G:n@.$7$?%F%-%9%H$r(B
+      $BI=<($9$k;~$O(B CR+LF $B$r(B, Mac $B$G:n@.$7$?%F%-%9%H$rI=<($9$k;~$O(B CR 
+      $B$rA*Br$7$F2<$5$$(B.
+
+      $B$^$l$K(B, ^M^M^J $B$J$I$,2~9T%3!<%I$K$J$C$F$$$k%F%-%9%H$,B8:_$7$^$9(B.
+      $B$3$&$$$&;~$O(B Any $B$rA*Br$7$F2<$5$$(B. $BO"B3$9$k(B ^M $B$d(B ^J $B$r(B1$B$D$N2~9T(B
+      $B%3!<%I$H$7$FG'<1$9$k$h$&$K$J$j$^$9(B. $B$?$@$7(B, ^M^M^J $B$,(B1$B$D$N2~9T%3!<(B
+      $B%I$HG'<1$5$l$kBe$o$j$K(B, ^J^J $B$b(B1$B$D$N2~9T%3!<%I$HG'<1$5$l$^$9(B.
+
+    o Short Form $B$H(B Locking Shift
+
+      $BC;=L7A(B(^[$B $B$O(B ^[$(B $B$NC;=L7A(B)$B$d%m%C%/%7%U%H$r;HMQ$9$k$+$I$&$+$r(B
+      $B;XDj$7$^$9(B.
+
+    o Converter
+
+      ISO 2022 $B%Q!<%5$KEO$9A0$KDL$9%3%s%P!<%?$r;XDj$7$^$9(B. Nothing $B$r(B
+      $B;XDj$9$k$H%3%s%P!<%?$r;H$$$^$;$s(B. Shift JIS $B$r;XDj$9$k$H(B Shift
+      JIS $B$r(B ISO 2022 $B7?$KJQ49$7$^$9(B.
+
+    $B2#$KD92a$.$k%F%-%9%H$rI=<($5$;$h$&$H$9$k$H(B, X $B%5!<%P$N%P%0$,8=$l$k(B
+    $B$3$H$,$"$k$N$G(B, $BESCf$G@Z$jMn$H$7(B, $BBe$o$j$K(B "..." $B$rI=<($7$F$$$^$9(B.
+    $B$^$?(B, Shift JIS $B$r=|$-(B, ISO 2022 $B7?$G$J$$8@8l(B(GB $B$J$I(B)$B$O%5%]!<%H$7(B
+    $B$F$$$^$;$s(B. JIS, EUC, Shift JIS $B$N<+F0H=JL$O9T$J$$$^$;$s(B.
+
+    $B$3$N5!G=$N<BAu<T<+?H!"(BISO 2022 $B$K4X$9$k5,3J$rFI$s$@$3$H$,$J$$$?$a!"(B
+    $B$3$N<BAu$,@5$7$$$H$O;W$($^$;$s!#!V$*$+$7$$!W$H;W$o$l$?J}$O8fO"Mm2<(B
+    $B$5$$!#(B
+
+  $B!&(Bmagic $B%G!<%?%Y!<%9$N%5%s%W%k$K$D$$$F(B
+    XV japanese extension $B$GDI2C$5$l$k2hA|%U%)!<%^%C%H$K$D$$$F$N(B,
+    magic $B%G!<%?%Y!<%9$N%5%s%W%k$G$9(B. /etc/magic $B$KDI2C$9$l$P(B, MAG $B$d(B 
+    PIC $B$J$I$N2hA|$r(B, file $B%3%^%s%I$GH=JL$9$k$3$H$,$G$-$k$h$&$K$J$j$^(B
+    $B$9(B.
+
+    $B$J$*(B, $B%7%9%F%`$N(B magic $B%U%!%$%k$K(B PPM/PGM $BEy(B, PNM $B7O$N2hA|%U%!%$%k(B
+    $B$N%G!<%?%Y!<%9$,$9$G$KB8:_$7$F$$$k>l9g$K$O(B, PIC2 $B$N%^%8%C%/%J%s%P!<(B
+    $B$H%3%s%U%j%/%H$7$F(B file $B%3%^%s%I$,H=CG$r8m$C$F$7$^$$$^$9$N$G(B,
+    magic.add $B$O(B PNM $B7O$N%G!<%?%Y!<%9$h$jA0$KDI2C$7$F$/$@$5$$(B.
+
+    beshort $B$J$I$N7A<0$,;HMQ$G$-$k%P!<%8%g%s$N(B file $B%3%^%s%I$r;HMQ$7$F(B
+    $B$$$k>l9g$O(B, PIC2 $B$N%G!<%?%Y!<%9$N%3%a%s%H$r30$9$H(B, $B$h$j>\:Y$J>pJs(B
+    $B$rI=<($G$-$k$h$&$K$J$j$^$9(B.
+
+  $B!&%f!<%6Dj5A%U%#%k%?5!G=$K$D$$$F(B
+    $B%f!<%6!<Dj5A%U%#%k%?5!G=$H$O(B, XV $B$,%5%]!<%H$7$F$$$J$$2hA|%U%)!<%^%C(B
+    $B%H$N2hA|$r(B, $B<+F0E*$K2?$i$+$N%U%#%k%?%3%^%s%I$rMQ$$$FMxMQ2DG=$J%U%)!<(B
+    $B%^%C%H$KJQ49$7$FI=<($7$h$&$H$$$&$b$N$G$9(B. $B5U$K(B, $B$=$l$i$N%5%]!<%H$5(B
+    $B$l$F$$$J$$%U%!%$%k$KJQ49$7$F%;!<%V$9$k$3$H$b2DG=$H$J$C$F$$$^$9(B.
+
+    $B%f!<%6!<Dj5A%U%#%k%?5!G=$rMxMQ$9$k$K$O(B, $B;HMQ$7$?$$2hA|%U%)!<%^%C%H(B
+    $B$K1~$8$?Dj5A$r%9%?!<%H%"%C%W%U%!%$%k$KDj5A$7$J$1$l$P$J$j$^$;$s(B. $B$^(B
+    $B$?(B, $B$=$l$>$l$N%U%)!<%^%C%H$N2hA|$+$i(B, XV $B$GMxMQ$G$-$k%U%)!<%^%C%H(B
+    $B$KJQ49$G$-$k%U%#%k%?$,I,MW$G$9(B. ($B%;!<%V$9$k$K$O5U$N%U%#%k%?$,I,MW(B)
+
+    $B%9%?!<%H%"%C%W%U%!%$%k$O(B, $B6&DL$N$b$N$H3F<+$N%[!<%`%G%#%l%/%H%j$K$"(B
+    $B$k$b$N$H$N#2$D$rFI$_9~$_$^$9(B. $B$=$l$i$N%U%!%$%kL>$O(B, `config.h' $B$N(B
+    $BCf$G:FDj5A$9$k$3$H$,$G$-$^$9(B. $B%G%U%)%k%H$G$O(B,
+    `/usr/local/lib/xv_mgcsfx' $B$H(B `~/.xv_mgcsfx' $B$G$9(B.
+
+    $B%9%?!<%H%"%C%W%U%!%$%k$NDj5A$O<!$N$h$&$K9T$J$$$^$9(B.
+    $B%G!<%?$r#19T$K(B `:' $B$G6h@Z$C$F#9$D=q$/(B
+      <desc>:<ms type>:<ofs>:<magic>:<suffix>:<in it>:<in c>:<out it>:<out c>
+    $B3F!9$O(B,
+      <desc>           $BN`JLMQ%7%s%\%k(B
+      <ms type>        $B<1JLJ}K!$N;XDj(B (magic $B$r?d>)(B)
+                         string - <ofs> $B$N0LCV$+$i(B1byte$B$N%G!<%?$,(B <magic>
+                                  $B$K;XDj$7$F$"$kDL$j$KJB$V(B.
+                         suffix - <suffix> $B$K;XDj$7$?J8;zNs$,%U%!%$%kL>(B
+                                  $B$N:G8e$KImB0(B.
+                         beint16 - 16 bit integer (big endian)
+                         beint32 - 32 bit integer (big endian)
+                         leint16 - 16 bit integer (little endian)
+                         leint32 - 32 bit integer (little endian)
+      <ofs>            $B%^%8%C%/%J%s%P!<$N%G!<%?$,B8:_$9$k%*%U%;%C%H(B
+      <magic>          $B%^%8%C%/%J%s%P!<$N%G!<%?(B
+      <suffix>         $B%5%U%#%C%/%9(B($B3HD%;R(B)
+      <in it>          XV $B$K(B <in c> $B$+$iF~NO$5$l$k2hA|%U%)!<%^%C%H%?%$%W(B
+                         PNM (PPM, PGM, PBM)
+                         AUTO  $B%U%#%k%?=hM}8e$N%$%a!<%8$r%F%s%]%i%j$K=q(B
+                               $B$-=P$7$F(B, XV $B$NG'<1=hM}$rDL$7$F$+$i%m!<%I(B
+                               $B$7$^$9(B.
+      <in c>           $B%m!<%I$K;HMQ$9$k%3%^%s%I(B
+                         '%s' $B$,J8;zNsCf$K4^$^$l$F$$$?>l9g(B, $B%U%!%$%kL>$K(B
+                         $BCV$-49$($i$l$^$9(B.
+      <out it>         XV $B$+$i(B <out c> $B$X=PNO$5$l$k2hA|%U%)!<%^%C%H%?%$%W(B
+                         PNM_RAW   (PPM_RAW, PGM_RAW, PBM_RAW)
+                         PNM_ASCII (PPM_ASCII, PGM_ASCII, PBM_ASCII)
+      <out c>          $B%;!<%V$K;HMQ$9$k%3%^%s%I(B
+    $B$H$J$j$^$9(B.
+    $B$^$?(B, `#'$B$G;O$^$k9T$O%3%a%s%H$H$_$J$7$^$9(B.
+
+    $BNc#1(B  ML1
+           ML1:magic:0:\1\0\0\x1a:.ml1:PNM:ml1toppm %s::
+
+    $BNc#2(B  PICT
+           PICT:suffix:::.pict:PNM:picttoppm:PNM_RAW:ppmtopict
+
+    $BNc#3(B  cache file of CERN httpd
+           CERN_httpd_cache:magic:0:HTTP/1.0::AUTO:unchc %s::
+
+    $B%5%s%W%k$H$7$F(B `xv_mgcsfx.sample' $B$H$$$&%U%!%$%k$,ImB0$5$l$F$$$k$N(B
+    $B$G(B, $B;29M$K$7$F2<$5$$(B.
+
+    $B%U%!%$%k$NG'<1$O(B, MACBINARY $B0J30$N2hA|%U%)!<%^%C%H$NA4$F$KM%@h$7$^(B
+    $B$9(B.  $B$^$?(B, compress(gzip) $B$5$l$?%U%!%$%k$d(B, $BI8=`F~NO$+$i$NF~NO$J$I(B
+    $B$N#1EY%F%s%]%i%j$KE83+$5$l$F$+$i=hM}$5$l$k%U%!%$%k$O(B, $B%F%s%]%i%j$G(B
+    $B$N%U%!%$%kL>$K%5%U%#%C%/%9$,IU2C$5$l$J$$$?$a(B, `suffix'$B$G$OG'<1$G$-(B
+    $B$^$;$s(B.
+
+    $B8=:_(B, <in it>, <out it>$B$H$7$F;HMQ$G$-$k$b$N$O(BPNM$B%U%)!<%^%C%H$N$_$G(B
+    $B$"$k$?$a(B, <in c> $B$K;XDj$9$k%U%#%k%?%3%^%s%I$O(BPNM$B%U%)!<%^%C%H$N2hA|(B
+    $B$rI8=`=PNO$K=PNO$7$J$1$l$P$J$j$^$;$s(B. $B$^$?(B, <out c> $B$K;XDj$9$k%U%#(B
+    $B%k%?%3%^%s%I$O(BPNM$B%U%)!<%^%C%H$N2hA|$rI8=`F~NO$H$7$F<u$1$H$j(B, $BJQ49(B
+    $B8e$N2hA|$rI8=`=PNO$K=PNO$7$J$1$l$P$J$j$^$;$s(B.
+
+    $B%W%j%W%m%;%C%55!G=$r;HMQ$9$k>l9g(B, $B%9%?!<%H%"%C%W%U%!%$%k$rFI$_9~$`A0(B
+    $B$K(B, $B#1EY%W%j%W%m%;%C%5$G=hM}$r9T$J$$$^$9(B. $B$3$N$H$-(B, $B%W%j%W%m%;%C%5$,(B
+    `#'$B$G;O$^$k%3%a%s%H$r%(%i!<$K$7$F$7$^$&$N$G(B, $BDL>o$N%3%a%s%H$O=q$1$^(B
+    $B$;$s(B. $B%3%a%s%H$r=q$-$?$$>l9g$O(B `# /* comment */' $B$J$I$H=q$/$HNI$$$G(B
+    $B$7$g$&(B($B%W%j%W%m%;%C%5$N;EMM$K$h$j$^$9(B).
+
+
+[$B%P%0(B]
+
+  $B!&(BPIC $B$N%3%a%s%HNN0h$r;H$C$?3HD%$O%5%]!<%H$7$F$$$^$;$s(B.
+  $B!&%Q%l%C%HIU$-(B 8bit PIC2 $B%U%)!<%^%C%H$O$^$@%5%]!<%H$7$F$$$^$;$s(B.
+  $B!&(BDEC OSF/1 $B$G(B, X_LOCALE $B$r;XDj$7$J$$$G9=C[$5$l$?(B X Window System $B$r(B
+    $B;HMQ$7$F$$$k>l9g(B, jisx0201($B$$$o$f$kH>3Q%+%J(B)$B$K4^$^$l$k%3!<%I$,(B, $BF|(B
+    $BK\8l2=$5$l$?(B TextViewer $B$G@5>o$KI=<($5$l$^$;$s(B.
+  $B!&%f!<%6!<Dj5A%U%#%k%?$rMQ$$$F(B save $B$r9T$J$&>l9g$K(B, $B@5$7$$%3%^%s%I$r(B
+    $B;XDj$7$F$$$J$$$H(B, $B%7%9%F%`B&$+$i0[>o=*N;$5$;$i$l$k>l9g$,$"$j$^$9(B.
+    $B$5$i$K(B, $B%7%0%J%k(B SIGCHLD $B$r%H%i%C%W$9$k$3$H$K$h$kIT6q9g$,@8$8$k(B 
+    OS $B$,$"$k$+$b$7$l$^$;$s(B. (Solaris 2.1 $B$G@8$8$k$3$H$O3NG':Q$_(B)
+  $B!&(BVMS $B$K$*$$$F$NF0:n3NG'$,9T$o$l$F$$$^$;$s(B. VMS $B$K$*$1$kF0:n%l%]!<%H(B,
+    $B$*$h$S(B VMS $BBP1~$N%3!<%I$N4sM?$rJg=8$7$^$9(B.
+
+
+[$BF0:n4D6-(B]
+
+  $B3NG'$7$?$N$O0J2<$N4D6-$G$9(B.
+
+  $B!&(BDEC AlphaStation 400 (OSF/1 3.0, X11R5<OS_LOCALE>, gcc-2.6.3/cc)
+  $B!&(BDEC DEC5000 (ULTRIX 4.3, X11R5<X_LOCALE>, cc)
+  $B!&(BHP-9000/715 (HP-UX A.09.05, X11R6<OS_LOCALE>, gcc-2.6.3/cc)
+  $B!&(BIBM-PC/AT$B8_495!(B (FreeBSD 2.0, XFree86 3.1.1[X11R6]<X_LOCALE>, gcc-2.6.3)
+  $B!&(BIBM-PC/AT$B8_495!(B (Linux 1.2.8, XFree86 2.1.1[X11R5]<X_LOCALE>, gcc-2.5.8)
+  $B!&(BNEC EWS4800/360EX (EWS-UX/V(Rel 4.2) Release9.2 Rev.B, X11R5<OS_LOCALE>,
+                       /usr/abiccs/bin/cc)
+  $B!&(BSGI Indy (IRIX5.2, X11R5<OS_LOCALE>, gcc-2.6.2 and cc)
+  $B!&(BSGI Indigo2 (IRIX5.3, X11R6<OS_LOCALE>, cc)
+  $B!&(BSONY NWS-1750 (NEWS-OS 4.2C, X11R5<OS_LOCALE>, gcc-2.6.0)
+  $B!&(BSONY NWS-5000 (NEWS-OS 4.2.1R, X11R5<OS_LOCALE>, gcc-2.6.3)
+  $B!&(BSONY NWS-5000 (NEWS-OS 6.03, X11R5<OS_LOCALE>, gcc-2.6.1)
+  $B!&(BSONY NWS-5000 (NEWS-OS 4.2.1a+RD, X11R6.1<X_LOCALE>, gcc-2.7.2/GNU as, ld)
+  $B!&(BSun SparcStation (SunOS 4.1.3, X11R6<X_LOCALE>, gcc-2.6.3)
+  $B!&(BSun SparcStation (SunOS 5.3, X11R6<X_LOCALE>, gcc-2.6.3)
+  $B!&(BSun Ultra1 (SunOS 5.5, X11R6.1<X_LOCALE>, gcc-2.7.2)
+  $B!&(BIBM-PC/AT$B8_495!(B (Linux 2.0.22, XFree86 3.1.2[X11R6]<X_LOCALE>, gcc-2.7.2)
+
+
+[$BCx:n8"(B]
+
+$B$3$N%Q%C%A%-%C%H$O(B, $B0J2<$N%9%?%C%U$K$h$C$F:n@.$5$l$^$7$?(B.
+
+  $BCSK\(B $B>;90(B <ikeyan@airlab.cs.ritsumei.ac.jp>
+  $B0f>e(B $BE/Li(B <inoue@eindsman.tsh.cae.ntt.jp>
+  $B7'C+(B $B@5O/(B <mec006@cc.mech.tohoku.ac.jp>
+  $B<sF#(B $B0l9,(B <shudoh@muraoka.info.waseda.ac.jp>
+  $B86Ln(B $BM5<y(B <ymh@mars.dtinet.or.jp>
+  $BJ?K\(B $B8wFs(B <hiramoto@Nurse.Angel.nanako.or.jp>
+  $B;0Be@n(B $B?.5A(B <nmiyo@hic.co.jp>
+  $B2#;3(B $BEP(B <yokoyama@cbs.canon.co.jp>
+  (50$B2;=g(B)
+ 
+  $B3F%Q%C%A(B, $B%U%!%$%k$NCx:n8"$O@=:n<T$K$"$j$^$9(B. $BG[I[$O%"!<%+%$%V$K4^$^(B
+$B$l$k%U%!%$%k$9$Y$F$rF1;~$KG[I[$9$k8B$j<+M3$G$9(B.
+
+  $B%Q%C%A$N1?MQ$K4X$7$F$O(B XV $B$HF1$8$H9M$($F2<$5$$(B. ($B>&MQ$K;HMQ$9$kEy$G(B)
+XV $B$N1?MQ$K4X$7$F(B Bradley $B;a$N5v2D$,F@$i$l$?$J$i$P(B, $B$3$N%Q%C%A$KBP$7$F(B
+$B$bF1MM$N5v2D$,M?$($i$l$?$H9M$($FD:$$$F7k9=$G$9(B.
+
+  $B%Q%C%A$NE,MQ$OA4$F8D?M$N@UG$$K$*$$$F9T$J$C$F2<$5$$(B.
+
+  XV $B$N%G%#%9%H%j%S%e!<%7%g%s$K4^$^$l$k(B README $B$rI,$:FI$s$G2<$5$$(B. $B2~(B
+$BJQ$5$l$?(B XV $B$r:FG[I[$9$k$3$H$O=PMh$^$;$s(B.
+
+
+[$B<U<-(B]
+
+  $B$3$N%Q%C%A%-%C%H$r:n@.$9$k$K$"$?$C$F(B, $B0J2<$NJ}!9$N8f6(NO$rF@$^$7(B
+$B$?(B. $B?4$h$j46<UCW$7$^$9(B.
+
+o XV $B$N:n<T$N(B John Bradley$B$5$s(B
+o xv221-magpic-patch $B$N:n<T$N;38}L@9($5$s(B
+o README $B$N1QLu$K6(NO$7$F$/$@$5$C$?:#@.J8L@$5$s(B
+o timtoppm $B$r4sB#$7$F$/$@$5$C$?OI:d8w0l$5$s(B
+o camtoppm $B$r4sB#$7$F$/$@$5$C$?@gED=$;J$5$s(B
+o cam $B7A<0$N2hA|$K4X$7$F9W8%$7$F$/$@$5$C$?$-$`$i$+$:$7$5$s(B
+o NEWS-OS, SunOS-5$B7O$K4X$7$F(B, $BF0:n3NG'$KB?Bg$J6(NO$rD:$$$?Cf<#909T$5$s(B
+o $B$=$NB>(B, $BF0:n3NG'$K6(NO$7$F$/$@$5$C$?3'$5$s(B
+
+
+[$B%Q%C%A<h$j$^$H$a(B/$B@=:n(B]
+
+$BCSK\(B $B>;90(B (IKEMOTO Masahiro) / $BN)L?4[Bg3XM}9)3X8&5f2J(B
+E-Mail: ikeyan@airlab.cs.ritsumei.ac.jp
+
+$BIT6q9g$d(B, $BMW5a(B, $B46A[$J$I$N%l%]!<%H$O(B, $B0J2<$N%"%I%l%9$^$G$*4j$$$7$^$9(B.
+E-mail: xv@airlab.cs.ritsumei.ac.jp
+
+--
+o `XV'$B$O(B, X Window System$B>e$N2hA|I=<(%W%m%0%i%`$G$9(B.
+   XV is Copyright 1989, 1994 by John Bradley.
+   X Window System is a trademark of X Consortium, Inc.
+o MAKI/MAG $B%U%)!<%^%C%H$O$^$-$A$c$s(BNET$B$K$*$$$F3+H/$5$l$?2hA|%G!<%?%U%)!<(B
+  $B%^%C%H$G$9(B.
+o PIC/PIC2/Pi $B%U%)!<%^%C%H$O$d$J$.$5$oL@;a$,9M0F$5$l$?2hA|%G!<%?%U%)!<(B
+  $B%^%C%H$G$9(B.
+o PhotoCD $B%U%)!<%^%C%H$O(B, $B3t<02q<R%3%@%C%/$G3+H/$5$l$?$b$N$G$9(B.
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/Makefile xv-3.10a/xv-jp-extension/contrib/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/Makefile	Mon Nov 27 16:33:34 1995
@@ -0,0 +1,7 @@
+SUBDIRS = cam free q4 tim unchc
+
+all install clean:
+	for subdir in $(SUBDIRS); do \
+	  echo making $@ in $$subdir; \
+	  (cd $$subdir && make $@) || exit 1; \
+	done
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/README xv-3.10a/xv-jp-extension/contrib/README
--- xv-3.10a.old/xv-jp-extension/contrib/README	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/README	Fri Dec  1 16:13:12 1995
@@ -0,0 +1,39 @@
+
+	XV Japanese extension contribution filters.
+
+[OVERVIEW]
+
+  This directory contains image format conversion filters for user
+defined filter extension.
+
+
+[DESCRIPTION]
+
+camtoppm:	CAM(CASIO Digital camera QV-10's format)
+		  -> ppm(or jpeg) filter.
+freetopbm:	DB-Z, SAURUS Freehand Meme, PV-F1 Action Board, Wiz Quick Memo
+		  -> pbm filter.
+xbm2free:	xbm -> DB-Z, SAURUS Freehand Meme, PV-F1 Action Board,
+		  Wiz Quick Memo filter.
+q4toppm:	XLD4(Q4) -> ppm filter.
+timtoppm:	tim(USED by SONY PlayStation) -> ppm filter.
+unchc:		skip header of CERN httpd cache file.
+
+
+[NOTICE]
+
+camtoppm:	needs djpeg command included JPEG library's archive
+		for conversion to ppm.
+xbm2free:	is not compiled default. Please extract
+		xbm2free-1.10.tar.gz and read its document.
+
+
+[COPYRIGHT]
+
+camtoppm:	SENDA Shuji <senda@kuis.kyoto-u.ac.jp>
+free2pbm, xbm2free:
+		SATO Masahiro <satou@kintaro3.elcom.nitech.ac.jp>
+q4toppm:	TAKAO Minoru <GGC01363@niftyserve.or.jp>,
+		INOUE Tetsuya <tin329@chino.it.okayama-u.ac.jp>
+timtoppm:	WASHISAKA Mitsukazu <wasisaka@rouge.brl.ntt.jp>
+unchc:		INOUE Tetsuya <tin329@chino.it.okayama-u.ac.jp>
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/cam/Makefile xv-3.10a/xv-jp-extension/contrib/cam/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/cam/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/cam/Makefile	Tue Dec  5 15:47:14 1995
@@ -0,0 +1,11 @@
+DEST		= /usr/local/bin
+
+#INSTALL	= install -c
+INSTALL		= cp
+
+
+all clean:
+
+install:	camtoppm.pl
+		$(INSTALL) camtoppm.pl $(DEST)/camtoppm
+###
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/cam/camtoppm.pl xv-3.10a/xv-jp-extension/contrib/cam/camtoppm.pl
--- xv-3.10a.old/xv-jp-extension/contrib/cam/camtoppm.pl	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/cam/camtoppm.pl	Mon Oct  2 14:00:55 1995
@@ -0,0 +1,165 @@
+#!/usr/local/bin/perl
+#
+# camtoppm $Revision: 1.0 $ programmed by SENDA Shuji
+#
+# Convert cam-file to ppm (or jpeg) file
+#
+
+require 'getopts.pl';
+&Getopts("hctjp");
+
+if ($opt_h || $#ARGV > 0) {
+    print STDERR "Usage : $0 [-c|-t|-j|-p] [cam_file]\n";
+    print STDERR "-c : print comments\n";
+    print STDERR "-t : output thumbnail image 52x36 (ppm)\n";
+    print STDERR "-j : output full image 480x240 (jpeg)\n";
+    print STDERR "-p : output full image 480x240 (ppm) [default]\n";
+    exit 0;
+}
+
+$area_comment = 1;
+$area_thumbnail = 2;
+$area_jfif = 3;
+
+&setconst;			# set JFIF constant tables
+
+if ($opt_c) {
+    $pickid = $area_comment;
+} elsif ($opt_t) {
+    $pickid = $area_thumbnail;
+} else {
+    $pickid = $area_jfif;
+}
+
+if ($#ARGV) {
+    open(FILE, "-");
+    $ARGV[0] = "stdin";
+} else {
+    open(FILE, $ARGV[0]) || die "$ARGV[0] can not be opened";
+}
+$narea = &camopen(FILE) || die "$ARGV[0] is not cam file";
+$off = 0;
+foreach (1..$narea) {
+    ($id, $len) = &camarea(FILE);
+    if ($id == $pickid) {
+	$pickoff = $off;
+    }
+    $off += $len;
+}
+die "can not find ID:$pickid" if (!defined($pickoff));
+if ($pickoff) {
+    read(FILE, $buf, $pickoff) || die "read error"; # dummy read
+}
+
+if ($pickid == $area_comment) {
+    while (1) {
+	read(FILE, $cid, 1);
+	last if ($cid eq "\x00");
+	$cid = unpack("C", $cid);
+	$comment = "";
+	while (1) {
+	    read(FILE, $buf, 1);
+	    last if ($buf eq "\x00");
+	    $comment .= $buf;
+	}
+	print "($cid)$comment\n";
+    }
+} elsif ($pickid == $area_thumbnail) {
+    read(FILE, $data, $len);
+    print "P6\n52 36\n255\n$data";
+} elsif ($pickid == $area_jfif) {
+    if (!$opt_j || $opt_p) {
+	open(PPMOUT, "|djpeg");
+	select(PPMOUT);
+    }
+
+    read(FILE, $buf, 8) || die "read error";
+    ($narea, $ysize, $usize, $vsize) = unpack("nnnn", $buf);
+    die "JFIF area number != 3" if ($narea != 3);
+
+    print "$soi";
+    print "$app0";
+    print "$dqt0";
+    read(FILE, $buf, 64);
+    print "$buf";
+    print "$dqt1";
+    read(FILE, $buf, 64);
+    print "$buf";
+    print "$sof";
+    print "$dht";
+
+    print "$sos_y";
+    read(FILE, $buf, $ysize);
+    print "$buf";
+    print "$sos_u";
+    read(FILE, $buf, $usize);
+    print "$buf";
+    print "$sos_v";
+    read(FILE, $buf, $vsize);
+    print "$buf";
+
+    print "$eoi";
+}
+exit 0;
+
+sub camopen {			# return (narea)
+    local($fd) = @_;
+    local($buf);
+
+    read($fd, $buf, 4) || die "read error";
+    return undef if ($buf ne "\x07\x20\x4d\x4d");
+    read($fd, $buf, 2) || die "read error";
+    return unpack("n", $buf);
+}
+
+sub camarea {			# return (ID, length)
+    local($fd) = @_;
+    local($buf);
+
+    read($fd, $buf, 16) || die "read error";
+    return unpack("nN", $buf);
+}
+
+sub setconst {
+    $soi = pack("H*", "ffd8");
+    $app0 = pack("H*", "ffe000104a46494600010101012c012c0000");
+    $dqt0 = pack("H*", "ffdb004300");
+    $dqt1 = pack("H*", "ffdb004301");
+    $sof = pack("H*", "ffc000110800f001e003013200021101031101");
+    $dht = pack("H*", "ffc4001f00" .
+		"00010501010101010100000000000000" .
+		"000102030405060708090a0b" .
+		"ffc400b510" .
+		"0002010303020403050504040000017d" .
+		"01020300041105122131410613516107" .
+		"227114328191a1082342b1c11552d1f0" .
+		"2433627282090a161718191a25262728" .
+		"292a3435363738393a43444546474849" .
+		"4a535455565758595a63646566676869" .
+		"6a737475767778797a83848586878889" .
+		"8a92939495969798999aa2a3a4a5a6a7" .
+		"a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5" .
+		"c6c7c8c9cad2d3d4d5d6d7d8d9dae1e2" .
+		"e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8" .
+		"f9fa" .
+		"ffc4001f01" .
+		"00030101010101010101010000000000" .
+		"000102030405060708090a0b" .
+		"ffc400b511" .
+		"00020102040403040705040400010277" .
+		"00010203110405213106124151076171" .
+		"1322328108144291a1b1c109233352f0" .
+		"156272d10a162434e125f11718191a26" .
+		"2728292a35363738393a434445464748" .
+		"494a535455565758595a636465666768" .
+		"696a737475767778797a828384858687" .
+		"88898a92939495969798999aa2a3a4a5" .
+		"a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3" .
+		"c4c5c6c7c8c9cad2d3d4d5d6d7d8d9da" .
+		"e2e3e4e5e6e7e8e9eaf2f3f4f5f6f7f8" .
+		"f9fa");
+    $sos_y = pack("H*", "ffda0008010100003f00");
+    $sos_u = pack("H*", "ffda0008010211003f00");
+    $sos_v = pack("H*", "ffda0008010311003f00");
+    $eoi = pack("H*", "ffd9");
+}
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/Makefile xv-3.10a/xv-jp-extension/contrib/free/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/free/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/Makefile	Tue Dec  5 16:03:03 1995
@@ -0,0 +1,26 @@
+DEST		= /usr/local/bin
+
+CC		= cc
+CFLAGS		= #-O
+LIBS		=
+
+#INSTALL	= install -c -s
+INSTALL		= cp
+
+SRCS		= free2ppm.c
+OBJS		= free2ppm.o
+PROGRAM		= free2ppm
+
+
+all:		$(PROGRAM)
+
+$(PROGRAM):     $(OBJS)
+		$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(PROGRAM)
+
+clean:;		rm -f $(PROGRAM) $(OBJS) tags TAGS core
+
+install:	$(PROGRAM)
+		$(INSTALL) $(PROGRAM) $(DEST)
+
+###
+free2ppm.o:
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/ZFout112.tar.gz xv-3.10a/xv-jp-extension/contrib/free/ZFout112.tar.gz
--- xv-3.10a.old/xv-jp-extension/contrib/free/ZFout112.tar.gz	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/ZFout112.tar.gz	Mon Aug 26 16:20:44 1996
@@ -0,0 +1,62 @@
+麸2ZFout112.tar [s\g詣/Hc,cvH@l/lcYけ3bf$Rsa脯cAl獎w*鰆;{1v抬T6胸91ylJ%x=O~Nw{瑳結`Cye:招F患巾wKs}76黯mklknl[澪api}K3|;LC>?N|85g鴒|je}Ge貞t6y##^i|"|O0apNFjuJw)kt,4m榴 )R禁@15k&L(+[w6t5K矩w*]%)M[d鎹R:桧mGo衛痛WTX%~.svf褐V勁m;錦v嵐GX9濾+-?佩榧D喚pkBJng鶇9"&[`Ev祝s/綟/q恩 嫖#磋6TvhZH韈x;昧拵2仔fwC5k&&岶ゴqXv-設)m6
+spFEhhRjW\~i n,Ym~]\:,~zRHt!nMM611 傳OF(┸l<za垤擂貅匠<G1飆坂+fem;X岻^mT衫D茘9",q:紗複窪瞭sX J徳eiCajぁaR?h4;Dt	燹x?3w蛄Cbj05fVp$(zP%piua嶋(剰yA節ﾙ\+璢乂I~o+珞O#K驪腐樢W2t9r;9b%古)`s纎'毒従@m]充U[t凪悲1'囹x*pg/羂7`塞7G}~1誑Lpl*5[dH-U%Syse3ls 震6o霧7pm)枌褪1{纂DE-V.fgDｱ	\#w2c7'ai殕9pWG]酌38l\+%>X9~JV
+ 翹}+@&<屍0蝗- 閠FHXt]P找>FW"Yy473LU2Dv1苅挨82sy#
++OjN_c 1V从{RK-Pt}U'⊃|J|u}0痕僑:b硬^
+"w6^\QN浪%Hb9	lNE匳8JcLheasBT$B#^%;n於u>Lr蚕ﾚ:I-諧倭{OQ"E1腆F&:sg( b~i潦vwvv<l槨:x4)ｘ霜椢!&,>?5&.{呎OXQ1難瀛`t
+eY/d>=-斬J疉ph
+OI.'櫑+{鍬vLe'm"+t:T珪J# VZx
+]ij| `譏x)B{=>cж""D=bレDUcNNyl螺De!H;zw@+E惷K%`+ .p儡%
+3\Q乂V辷~%#`莇QM=MlpXA霽^-n
+@齋n cb!<,{`{wo陪錮@鯛?:pU豐9It君$al'~ps*s VkY((0*績/ .+cﾖPW(|@4Whqck4L■xx芽	墺麻pO;-綉tI町? ,;x*qYw察0NF;@Dk;aZH掾w眄CNN.[d誄u症28v)_;uk,	.乞EH:U
+XwD"f*Χ>x$L/荵6g姥p3拵H!禅臾191L阜v JC窟u茶;1.dJCg]仂b蹴B宵N3w'M1^*UUX渟▽PTt_z}yっ4沂&u委貢IzmｯtXcu"oHKCサs[h(K/俗/c5d->j'e減jムXIZｼzMD!T8#cgUr}QfV0uKRW]嬬|/E7:p:3dU味<0|b耙B厂$| frIv]A,v%!|F['nR?騨#_"Ru┬F2$)av>H.,8p%{.bqP^@4Qc恢4-SC槁7関rr甑rbE+'s#Ei$YWrN鞅`K #6	WHFDEZD`%)oR,^'戈租8XR襃o喉Ｙ0DVP|諚∀
+{ek]L$gI癲#;涼TN突日du gLin%x&1 c^H6yA3cX支]N;T;\~M~$4Xe\Zyzm-糟k.@'C=:遷\_6L;=o'霸Q[qUdzFPO5 `BtVN;I艝"田)aW|?/-U;Gf2Fg5.z8r/eZS]Ry皮0X生誑(?&!An/q *]%0kd|
+益Y|3^IT 	d+ly>5gk+鄆偲KX^hねJ<;
+搗*1編" jT肅2%`渝]$F/>X!5紅R4災9;鱗Az[22a4ynMMxbu買恃vz囈,VoG/P@顳 逍.Ml	,yVF0w攫:l*k)Fvc觝56‥τ慢.S崩P1n\徭Z
+I%k%
+OgAPx網r詔Y$f MsG)$>Cр6x1芽j,Kh@<E狄魎*6Ё沃,夊淘:iT瞭¬Rv綯/罌fkM-4廝6
+2CK@蔗1w尹A7贔决ZX^a缺FxM%W⊂2[+鮑:Q"耜D釵TFt伴W
+z$c4]扉b彜w<-"}1d<YVhJ└ヱ
++{-Cx3#}攬t徂u)RTChm	c棲z桶紊{bO|陦Ou^MK$E
+T|>"f%q@1!4K
+9u紅(M7件BNU璢yeI封CH詛蟋c}	脂|Sv<x$w"楴A径Eku9闘K	x湘駄N猓F
+p)\x_`B?
+C1YaNEfA~^U/Q/(Kqwvt*<z<hoz灎をqj'獗x:{	@SJV倏h=n	+JRy樫牆d.W刧V3We縟q纐h-$!P Kg*5l馳nV|{YS巍筴s^X幇[#鍮+022-5]D.CR.6@=X{砥N臉eE┛!Ke5s#qJ\b.?}8qwh8]SGAR_=A遅uz$NI鯢Sr<珸6l)	♭p\:)G7"h篁Nz2NELh2衢 b<0[ +Q%y浮cJ/褫nx=0開
+hL!%j1Y$R[9mｃア6g^拡n--睥J6.甜T,tw"bY6;D:FwiLPeN&>]N賈!8EBt[F袮4協Dw`潯ixhu妁h6 DJ′eVI猶m5ge´#/e4yJ讚蜻嚊贏甬 XЖ崛F	U9uM瀚N-Pi炸'G"Mp5M@e}8d1do/GM@濕云=mE灰jXI枸畳E{Z廐Ep緇 腥^NbyD:1g>産7+W74鷸h n#鋩'<Mi@S7ﾞﾆ-hD*:?iLj/(|3 弾兆笹x鷁滅llo閭蔬>3B-< h嚶y\BC曄q!櫟Ｙ,9霹GLd|-bcl黛r祥t)u&教敞wC?b{+tL{G+青79il烙Ｗ穡鐡vSW-Liw宗記E卦患R聿趨摧T帙_gw^9F浩S"7U鰲u3a+  P腹4DAyﾟ!0eft蒐4)O囘4*Dd:w鍛z~痛庖vul;D%, @腓8'謎:助Y$l|Wqo詢&7誼W書zo算索X鏖)Xw1泙5zl邉g).@E庶7ivds濃C∫aツ ,蝮嵋芦QcNgM_3^噤l%ft	[h0	5q+>e駑lr違S軽o}0bJ咽/寥eO*査{:G馴C i;)zA妃4孃*G#jZEVW喞噺蒄B2[FW襟[C/裝VYn/假窮 {=V*晧_殿緻}U&Q/_oZzY5^[&截HeyEuAZ<-f#<U請9-EO*>C]@ZaA].)+JeF_cWwx鵁6UJ弗nk}c$1噴ｆxB'j4信ZS+MKNe誇J4噴cy5X擶0[宍AalPgh3H璞fxU)餾,tMv並:[,~zUr	秉&E蜊栲殫v&直$/;硲mS?X	a -k鮓膰@N狛Rが:K^^:ゃ}~昆"瀾7?_dy`+r#f$/8y,xS靈J藪cAsv.x$7k軽6_澹P+O4XhKW軾bs=q}"L; 
+AgT8鯣RW.{owRWX{,Z3Oo^mzCw甄}M[4`:CZD殍AK
+麻Q
+O多n49E3Ap~撤yRi戻}?
+{{	V0[0p4t牒+%}JhAl填E王mA
+CFy{浄8R瓦7碌cYrv&26&鄒8癆%Z5-懣99gg,r,vB9L{:*8蓖s`ohK#r {顫2	$Du洟=+p},IN@2辯'尹醸ci蘯W\	迭]!TZ,,Dr
+i%v.d)3mFB3`i\7dq螯A%|cWi2(n;'3L=/yXV峅'臂{蝋s9膊bx噫Q?gM$P:m01lt?-]醫T2?]LEj#Q譏Z R#fGx#I{]>力t桀+*5巒毋容zHb溂@#/T
+l狆社轢J邁aj~Q 'P1R奬ZN.惓`Yeеg<ｦmK6<宵&A{Qo糂Sy\R%{R羚^mkM$_A$_}ekR<喊G#h*[G2jdn!G
+Y.!烹6$"2	h} *xwKgoOwS韮1sEC瞼k?陛E海*v{産]sj8C葫釟']l,h逍w噴裄齊]-"v +1}幄Xq&e/Y.=eax￣r,IyK紐ォ_K1,[\淕RAQle^Ok^?!囿吼&50'Q涕2F]扣蟋!iy>'%g$跟X2鵑悗.收
+ )y鴟Q鯊coMZhE來ぷ~仇C挑[f{W 讒I23+|S縫e3'PxF;z裸8/PX0~msЕ喪M^'@s'37f劣o外\5=d,/_浜玄eXq?b
+>Cv#b徑k鞁狂;9
+XZIп^ 楫Py~iT'U]*6髭)j[6-O+2'w:N:離lY瑛0[%ΘR3f_au必8UP摧哢R5瀏&=F-
+`2,桃碌zoO `6i相@Rl匿H?N~Wbk!]豎r<n糒=非T鮑es"0!E8[6i55AF'艝Bsu1堋871NM韲([W-@S廨Fb駮DPB甬*~bHV个$KKD@^徃Cd)u1ワSX-梃S)N練}1蝴rH胄@z註E@s0V皹z1n戻2B)燒^豊r-]Fs7J<牘?索dXIfQvio]R^藻藷⊂Hm肖vc 4v蘋nR;oJXL1bM蕩p7僊JXj0(>守JH3縁~Q駈HE<h2v``苙訛 Lc9X:j 寳#3kAxジV物>x篦思T癜czzS=哩a風bo訃,=孃{引l.0Dg5$動g-l軣pGl<?A嶇#Xs能jIm|７.想繁衣R焜Ivv=凱j+MB~
+^{2-菌={x|	mc坪殲!5%SX]7蒿-ΠLpV舳6SX&Cjt).!江掏側P.jb2J7VI.tZ鰭{BvG柊G涛xX\揣}{O\.B~GXJ^(O"岾.$儼Jt(}闥碍T鰛gc\~予w左鄂鼻h:-BSyY]=/參m*]P`(*5LY嘯TDwJ挑.暇*!LUGUp#I!39OP&2唾[輓=A}~~0<BuK"h^b"Q+GK2>X糟O4to&46h霞_>5OZﾏB嫋l{@&賂M\HぎvS)X'L\W>M[K買R+	iR茣x&uHS2x7?|I`6O鞫t@6s<+Djx89x0檀徐鶴v1~(=冬笈C戳gw*?22/<mp斷PN*]@Az?gyT佰ljP箍Q霽%A鰡(s觚葮r	3&	nSe8OQQU@^AJ)]J側7]*!!g礬凰b:0IAFj]tbDてt坡叢tz∩靜E_H2DEREBHTzjS{!xp0${ /賎~q2狛萓@27rp鑵d冓P'aB癘蕀2l5Lro_禍Tp'x(g}AV8xe 1T	x垈w(3+O 0&H3驚I'R@"wx $珎禺>雹Ax^+GJBRH5#H狂甼OG戞~擅客hg子s鬱X屎i63阪)C_鷯AK_mCU 6mngjx*j匯L_昇 付USr.F6旛	坑7Z敃-M[-([惧?>'聯QjRL^`L~罟";v[=Qへ1X"M:?8}C*={駁U+>]禝飽We\;鯡)2biH Nw?GE褫Ra9鏃$j+6S)tIfMK跂名б|f鑢8
+Ww*p_0Q*霹纜{档[蛻:S/金+R乾<礎嘴鏝7:仏[{羈UTh\枇:Ｆ[博友dVn|歸V}3&T;/@C戰x4xpfbz 8#剄lo}阮QTS*d!QUM鶩<A拯S3/aa繙i袖_N盤9CV<%mRY卆EV:8E
+ Mk)iHi訟gEeK穹餘 没T8qヵ"y蝸I祖`Rq腴xF3e)Nw尾{pﾏY2/3p#RQU8錺He>u"lg;#擶y*<i=醒=1W8試癰PbM5{飭t=]遐箔6ab瑚9CHa佳aQP.Unz.Lq伐ユgf?:'uWbL3y6侃眥x童|<ajV\棒n$3x|WPGU ua(t]l'楢OT5	QRUk6y*へ+'j[}Si(>; BN8FD@z"g~7DMO遐lT@嫁螳=y轎f6W`'<剰v~` Gi'_尖[天aG_(Q1sT鞘6?eoys摘+-E檬0{ufQ`r6 ,+|Q.碾莇e1	8_J.皐.Gji  ](CCInV'Y欝替p5裂K&5o/洟g@		qI髢班袰豕+姉磬p<KD5矍EW澪U#疝[H`L5s龠uq#OqP*xC弼%8散k彦G儷鑵 tqF簔?瑠諮vc+E6Wi@r耨JNQdu;助[守,*4C'syBu槲.\@諛ar沖萍D嫐L腫
+F麸]	teq9泗KwAUn$d1#習9Xts"zw,oL餐blWE]o尻x+$輝冪
+蝦oWqr(WII7ez6蜜縡w1 ).n蛸珍蹴wH30)(Z^>v-fJWxJ=g/.奸_昏JOgI壞PB[%_yG_"fNg2u=bO]z*H^Zu.j5`jYDR~^含1+6茖A剣,M埣&藹z8-刄>r)(pfx'fr_題X]D*爬ス郷蓍[愛HvUxPL副'R'fSU節&鋳J@釈oK>XBg'](p)s店側U附曜-gq紙>DU]豊<ECsh蚓闌 Q^縟m,/名郛xVM)j券椽fO47Pt<tx}斷M<<vCo$K>廿Z帰@2H棋
+ZuZ=_/[%|{(=adU暮-&K祢 i&#巷錯皷0h){冥Kf《嫐"#Xg)R晟py歔鶩%A)気&yb*#v頽彊x}逝rdj"A!yY<lccR榁\;鯵q.H]遷P8[6FN&u調岨答Y+S.匳	.E稠セ85Rq|MQVWM聡_Q*g3(Ζf驩E繰1;y白'nM娯Bg外qWM醫\|!9t@PиQiH`貰}`瓔2K ?Q恕奢瘟蠏MKt迸aTUg緒i(>X]z|EKO`vN69=塩v,{(qp !10_HDEof N',3(蘢@.JER書'>EmvJBnD
+:NgW8T	g'切杲(Zo@b~俵mC	p嘶sD腆{C両<+c嘔-Q嘶b K楳煕就ﾓiq 一。\劍QGR"Ng宍f`"7p$uvEygUJ琅:	hJ?S紂碇:(R	軆cEBB]4@T燮*L*"a屯% ]ha$eU百gCbs09TyY綸&0@ W鶴。0Fje"}U)¢?DY{bM刺_PQ聢偶:S得wm=17~添y~U{8漂>~jH`R;TdSw暁cn壟D和;&F~0話斌畭B6+G温躓;#逃N>4/e容Vz7R2.b淹?e/</S[)z;y`Z撤kX遊$HXedCl
+2剃!V_vC*z畧kJ鷹q\5…恆jI/ﾋIA2*$R<誹H|!滓l0At尚!侑鍔Q7pM:'+I:繰_b*-匆/hBM閇0_JUX] 8<OS君nh扛蓿Y絣跪z@p<Ic!b4槊r4e:檀D.3]E,簀Ago鴃pm~YykdM?u尠38dj$1egGk軻e%　RqL前Q"he担屈?視%Jhde耆k甃t\昨tXCHBD~間zKw{昇c絏GVa%<9k嘸Yy:%0-k甃tY`0钁\.-jMW陋Vy|>1X/Ded.$
+If@g:vv@vRckC樗CC(AW齔x8,(n#65
+X~=-`降HxUfWj 曖XB55餓H父aI贖ﾝV鐵iT]{`勸@wf\w3疏~HX;K番
+To*明\Pg,![q謖軾W桍巉昃-w$vKe<dKa'撲oO夕0`b1= _znFD7除乂^v郤V"VWS噫a色,Wy?8V$7?X#毘78ao{〇RNy(c0H燧[f~VC+v,Y(E=?kＯ:~_d&ﾔ諡[wa=o	 [P | uXHp鉅<&FyeD"m#ZhTwR'J'鯒`%栂`8EjHoT!#[prGBRmｶ羔}M饅戡g~\`)RgU2[*[況u鎚憾|P?蛍５迯xWbed]&9z=]@e9_^靭SJL皐H筌	1u25UpSv@/迴E~E?]Z>樢浅#[7o脉_7|0Ir9K&申cmn6~LfHd熨!J峨bq-mjw関GUb;勣Ry-指=g礫L5X U0萇%z奧#U$噌._+鷽x=oo1*mBy?n"ucR.犢mxNI雜*=髟WЭAFiCdINJje(<e1Q悼:N#%2e	}菇汢蜉;lA軈覃
+Fk゜w',來V(eR)PV護1u?晟mＮGV逡[
+R/ ; ~x|S P@)J嵬1 [x{fVzI\末聚b?_c5<7@+_nA痊IgCn,S2.:#8XrP騒zNp#O,Z樊b負E馮t} 髑鉚wホ_7廐博p著4igV胤忱謐[ t師&:熟~5N>L`E*J唇#沌耘侃z詔rrnvMjw@\<φ墸A9J&]捧;c廴'@4滯 {&.ソbEA[$V1疹\己"LQZ&誓S'[H
+Hf燻nD>{G暄IUp'糞 憫Q~1La08EWbN瓮j猊]V3Mst&h"*Vp\sU>圈q廡Y;+n2=pM @~舸Bd笵尹rjx?R/Nj
+{]芽奘1[[$BH粒侵5稀eOZ)沺bf柵Ab 沫g}}wk2TW弭<&beS灼c
+UPuq.Pu\5bh}oo,&l`)R4I2U t.l{cJfm{賺)> 俚m#$;4謝G佯tO:2y%jig}m;IQ,
+уy綫Q;+緊液亨w_lBYh_懐9Pｓ,=MS(UUzW9~K?=穽T?B/b/Fz;ZX縣麈?~*/g(榿D76,rMuX$*hx?({弥$<ch{(vq_Op尢a=z叺鉞xi苹wG@壌<yznR:\GfUHBM剳瓜I姆]"lr0i{黥7g苧 pVfo
+)a ~掻津AWm[g槎{g設un@羈y-s頷H<鐶闕W化柾NX瓔~濘fb}r?/5yx迥t/N#?^=<,13f飜;c4EJ骰bl4~LRS
+痲岱内"]N~R蝎u8Z/O'g49?C賚│酲佼*]撼\W@i'mFMGUv/_%Ibys5`T|`n)(e固AR*&Bａ%┻柔7傅f~s7]髯_飭kまn栢H幺真o:aNJ2j"&G^D(yQ鰆V9C.GaP緘>a^DV腋-PJXEd5BB=`Zz
+iR帙+Xi|E+咎伏?h当諏入荊l茅G\欹r鷽 &_:軸az-[}
+$攪>賑ywX%黯Z蝨OVh豚J>Wqle^:[齡属]^燵/}客_[6*咎?2i券/V幅(MP_J抵/跏<癲E63~Hgf;t?7垂1i屠銚LAN3n劍娩z亞q
+16┥"FB14A,昜5x|>驕>.暈sB]S鬢-FzcfKmX1u凅N!XdnVM\zUuй蘂$  eVK)愃,= gPa)aG抓PGM怺m:{.WwOLe煙x3bXw*K1DZ曼蝙?孺l%汁?ko~o	_W[筐]m杉	zj匕]\pp閙
+檢{Naam豚A勺h%溜麪|g{+@<VB}@NB霞[eJ+/浪!:X'p/[LmxTT8賍84廃
+V`Np眥0秘,	0e}t= 槃!仙<=;C`L6@でp=+i0FgEy$@∠%9F脣事%O)骼F$Rv$I84Dい"	aUhHMzGR0m|J=(R6439!"uv=S]1>U6清括>[_JbriCQ0 *詢耗KhB岳^zEザ$罵冲 ;YMA{玖l<zО紵片W-@` 4	
+懸Zy枸; Z|2"S|%2ГW%2]]襾p皸f ;6KYk%xvJ{H00_qwa獅畠E撕Y"n|7蛾N+#7晨y
+7H惰m控"j)!,vboh-(PJ|n陌墹EOFsN&4畋3\<听z來lV,9p-8!餮5s様B6拂{$b嵩J{jQPHK)!MjZ:GHBJf}螺哀wiZ翅67YO/e   
\ No newline at end of file
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/diff.MIPS xv-3.10a/xv-jp-extension/contrib/free/diff.MIPS
--- xv-3.10a.old/xv-jp-extension/contrib/free/diff.MIPS	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/diff.MIPS	Tue Dec 12 07:58:27 1995
@@ -0,0 +1,80 @@
+*** xbm2free.mk	Fri Dec  8 13:29:43 1995
+--- xbm2free.mk.MIPS	Fri Dec  8 13:28:56 1995
+***************
+*** 1,7 ****
+  ############### Makefile for xbm2free & ZFoutlib #################
+  GZIP	   = /usr/local/bin/gzip
+  TAR        = tar
+! CC         = cc
+  CFLAGS     = -g
+  SHELL      = /bin/sh
+  
+--- 1,7 ----
+  ############### Makefile for xbm2free & ZFoutlib #################
+  GZIP	   = /usr/local/bin/gzip
+  TAR        = tar
+! CC         = gcc
+  CFLAGS     = -g
+  SHELL      = /bin/sh
+  
+***************
+*** 12,22 ****
+  ################# Macros for xbm2free ##############################
+  # Extra libs. if malloc() requires extra library, change this macro
+  # like as '-L/usr/local/lib/malloc -lmalloc'
+! EXTRALIBS =
+  # Xlib include file directory
+! XINCDIR    = -I/usr/include/X11R5
+  # Xlib library directory
+! XLIBDIR    = -L/usr/lib/X11R5
+  
+  # directory for temporary file
+  XBM2FREETMP=/tmp
+--- 12,22 ----
+  ################# Macros for xbm2free ##############################
+  # Extra libs. if malloc() requires extra library, change this macro
+  # like as '-L/usr/local/lib/malloc -lmalloc'
+! EXTRALIBS = -lbsd
+  # Xlib include file directory
+! XINCDIR    = -I/usr/include
+  # Xlib library directory
+! XLIBDIR    = -L/usr/lib
+  
+  # directory for temporary file
+  XBM2FREETMP=/tmp
+***************
+*** 26,32 ****
+  #USETMPNAM = -DUSE_TMPNAM
+  
+  # C Compiler flags
+! CFLAGSXBM2F = $(CFLAGS) $(STDINCDIRS) $(USETMPNAM)
+  
+  ################# Macros for ZFoutlib ###############################
+  ## If mallc() requires <malloc.h>, change REQMALLOCH to be 'define'
+--- 26,32 ----
+  #USETMPNAM = -DUSE_TMPNAM
+  
+  # C Compiler flags
+! CFLAGSXBM2F = $(CFLAGS) $(STDINCDIRS) -I/usr/include/posix $(USETMPNAM)
+  
+  ################# Macros for ZFoutlib ###############################
+  ## If mallc() requires <malloc.h>, change REQMALLOCH to be 'define'
+***************
+*** 38,45 ****
+  # REQALLOCH = define
+  
+  ## If free() is decleared as free(char *), change FREECHRPNT to be 'define'.
+! FREECHRPNT = undef
+! # FREECHRPNT = define
+  
+  ## C Compiler flags
+  CFLAGSZF = $(CFLAGS) $(STDINCDIRS)
+--- 38,45 ----
+  # REQALLOCH = define
+  
+  ## If free() is decleared as free(char *), change FREECHRPNT to be 'define'.
+! # FREECHRPNT = undef
+! FREECHRPNT = define
+  
+  ## C Compiler flags
+  CFLAGSZF = $(CFLAGS) $(STDINCDIRS)
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/free2pbm.c xv-3.10a/xv-jp-extension/contrib/free/free2pbm.c
--- xv-3.10a.old/xv-jp-extension/contrib/free/free2pbm.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/free2pbm.c	Tue Oct 31 05:29:36 1995
@@ -0,0 +1,352 @@
+/* free2pbm :
+ *  "DB-Z" & "ZAURUS" free hand memo, "PV-F1" action board(figure) 
+ *  "Wiz" quick memo 
+ *  --> Plain/Raw PBM
+ *
+ * (C) Copyright 1994,1995 by M.Sato
+ *
+ * compile:
+ *   cc -O  -o free2pbm free2pbm.c  # -O : optimize flag
+ *
+ * usage:
+ *   free2pbm [options]
+ *
+ *   option:
+ *     -n name : data name
+ *
+ * I/O files:
+ *   stdin  : free hand memo data.
+ *   stdout : plain PBM.
+ *   stderr : messages.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>   /* exit() */
+
+static char verstr[]="@(#) free2pbm Ver.1.00  1995/10/31";
+
+/********* type *******************/
+typedef unsigned int  WORD;
+typedef unsigned char BYTE;
+
+/* free hand memo header */
+typedef struct hdr {
+    WORD length;    /* data length */
+    WORD width;     /* data width - 1 */
+    WORD height;    /* data height - 1 */
+    BYTE qp;        /* dot size (QP value) */
+    BYTE comprs;    /* compress type */
+} HEADER;
+
+/************ const **************/
+#define FALSE 0
+#define TRUE  1
+
+/* value of HEADER.comprs */
+#define LINE    1   /* compress type 1 (line compress) */
+#define ALL     2   /* compress type 2 (compress all data) */
+
+/* character */
+#define D_QUOTE    '\"'
+#define NEWLINE    '\n'
+#define COMMA      ','
+
+/* dot par byte */
+#define D_BYTE  8
+
+/* data/line(pbm output) */
+#define FIELD_LINE 34
+
+/* return value */
+#define RD_OK      0
+#define RD_ERR     1
+#define WT_ERR     2
+#define DATERR     3
+#define BADARG     4
+#define UNKNOWN    5
+
+/* ending message */
+static char *msg[] = {
+    "convert ok",               /* for RD_OK  */
+    "file read error",          /* for RD_ERR */
+    "output error",             /* for WT_ERR */
+    "data error",               /* for DATERR */
+    "Usage: free2pbm [-v]",     /* for BADARG */
+    "unknown compress type",    /* for UNKNOWN */
+};
+
+/* for automata */
+#define CHR_NUM 3
+/*
+ * mode
+ *  0 : COMMA as a field delimiter(default)
+ *  1 : D_QUOTE(1st) readed
+ *  2 : D_QUOTE(2nd)
+ *  3 : data (non quoted)
+ */
+static char in_chrs[CHR_NUM] = {D_QUOTE, COMMA, 0};
+static nextmode[][CHR_NUM] = { 
+/* D_QUOTE, COMMA, other */
+  { 1,      0,     3},
+  { 2,      1,     1},
+  { 2,      0,     1},
+  { 3,      0,     3},
+};
+
+/************** utility functions ***********************************/
+void prog_end(status)
+  int status;
+{
+    fprintf(stderr, "%s\n", msg[status]);
+    exit(status);
+}
+
+int get_chr()
+{
+    int c;
+    if (EOF == (c =getchar())) prog_end(RD_ERR);
+    return(c);
+}
+
+int chrtype(c)
+  int c;
+{
+    int i;
+    for (i = 0; in_chrs[i]; i++) {
+      if (c == in_chrs[i]) return i;
+    }
+    return i;
+}
+
+int field(n)
+  int n;
+{
+    int mode = 0;
+    int count = 1;
+    int c;
+    do {
+      c = get_chr();
+    } while (c == NEWLINE);
+    do {
+      mode = nextmode[mode][chrtype(c)];
+      if (mode == 0) {
+	count++;
+	if (count == n) break;
+      }
+      c = get_chr();
+    } while (c != NEWLINE);
+    return count;
+}
+
+void skip_DQ()
+{
+    int c;
+    if ((c = get_chr()) != D_QUOTE) ungetc(stdin,c);
+}
+
+
+/************* functions for tegaki-memo deta read ******************/
+BYTE ctox(c)
+  int c;
+{
+
+    switch (c) {
+    case '0': return 0x0;
+    case '1': return 0x1;
+    case '2': return 0x2;
+    case '3': return 0x3;
+    case '4': return 0x4;
+    case '5': return 0x5;
+    case '6': return 0x6;
+    case '7': return 0x7;
+    case '8': return 0x8;
+    case '9': return 0x9;
+    case 'A': return 0xa;
+    case 'B': return 0xb;
+    case 'C': return 0xc;
+    case 'D': return 0xd;
+    case 'E': return 0xe;
+    case 'F': return 0xf;
+    default:
+      prog_end(DATERR);
+    }
+}
+
+BYTE readb()
+{
+    BYTE c1, c2;
+
+    c1 = ctox(get_chr());
+    c2 = ctox(get_chr());
+
+    return c1*0x10 + c2;
+}
+
+WORD readw()
+{
+    WORD val_lo, val_hi;
+/*
+ *  ORDER of 'val_lo' and 'val_hi' is VERY important!!
+ */
+    val_lo = readb();
+    val_hi = readb();
+    return val_hi*0x100 + val_lo;
+}
+
+/************* functions for PBM output  ******************/
+void pbm_start(width, height)
+  unsigned int width, height;
+{
+    printf("P1\n%d %d\n", width, height);
+}
+
+
+void pbm_out(pattern, widthp)
+  BYTE pattern;
+  WORD *widthp;
+{
+    static int count = 0;
+    BYTE mask=0x80;
+    int i;
+
+    do {
+      if (*widthp > 0) {
+        putchar((mask & pattern) ? '1' : '0');
+        putchar(' ');
+	--(*widthp);
+        if ((++count % FIELD_LINE) == 0) {
+          putchar('\n'); /* insert newline */
+          count = 0;
+        }
+      }
+      mask>>=1;
+    } while (mask);
+}
+
+void pbm_end()
+{
+    fflush(stdout);
+}
+
+/************* data convertion main *********************************/
+int convert()
+{
+    HEADER header;
+    WORD x_len;
+    WORD x_count;
+    BYTE repeat;
+    BYTE pattern;
+    WORD width;
+
+    /* read header */
+    header.length = readw(); /* not used in this program */
+    header.width  = readw();
+    header.height = readw();
+    header.qp     = readb(); /* not used in this program */
+    header.comprs = readb();
+
+    /* output header */
+    pbm_start(++header.width, ++header.height);
+
+
+    /********** main loop **********/
+    switch (header.comprs) {
+    case LINE:
+      /* loop by data height */
+      for (; header.height != 0; --header.height) {
+
+        if ((x_count = readw()) == 0) return(DATERR);
+	width = header.width;
+
+        while (x_count != 0) {
+          repeat = readb();
+          x_count--;
+
+          if ((repeat & 0x80) == 0) {       /* not compressed */
+            x_count -= (++repeat);            /* repeat+1 datas */
+            while (repeat-- > 0)
+              pbm_out(readb(),&width);
+          } else {                          /* compressed */
+            pattern = readb();
+            repeat = 0x101 - repeat;        /* 0x101-repeat datas */
+            x_count--;
+            while (repeat-- > 0) pbm_out(pattern,&width);
+          }
+        }
+      }
+      break;
+
+    case ALL: 
+
+      width = header.width;
+      x_len = (header.width + D_BYTE-1) / D_BYTE;
+      x_count = x_len;
+
+      while (header.height != 0) {
+        repeat = readb();
+        if ((repeat & 0x80) == 0) {       /* not compressed */
+          do {
+            pbm_out(readb(), &width);
+            if (--x_count == 0) {
+              header.height--;
+              x_count = x_len;
+            }
+          } while (repeat-- > 0);
+	  if (width == 0) width = header.width; 
+        } else {                         /* compressed */
+          pattern = readb();
+          for (repeat = 0x101-repeat; repeat > 0; repeat--) {
+            pbm_out(pattern, &width);
+            if (--x_count == 0) {
+              header.height--;
+              x_count = x_len;
+            }
+          }
+	  if (width == 0) width = header.width; 
+        }
+      }
+      break;
+    default:
+      prog_end(UNKNOWN);
+    }
+    /* ignore data end codes */
+
+    pbm_end();
+    return(RD_OK);
+}
+
+void main(argc, argv)
+  int argc;
+  char *argv[];
+{
+    int i;
+
+    for (i = 1; i < argc; i++) {
+      if (argv[i][0] == '-') {
+        switch (argv[i][1]) {
+        case 'v':
+          fprintf(stderr,"%s\n", verstr);
+          break;
+        default:
+          prog_end(BADARG);
+        }
+      } else {
+        prog_end(BADARG);
+      }
+    }
+
+    /* main */
+
+    switch (i = field(0)) {
+    case 4:  /* "I","SCRT","CLAS","IMG1" : DB-Z, ZAURUS */
+             /* "I","SCRT","INDY","IMG1" : Wiz */
+    case 3:  /* "I","SCRT","IMG1"        : PV-F1 */
+      field(0); /* next line */
+      field(i);
+      skip_DQ();
+      prog_end(convert());
+    default:
+      prog_end(UNKNOWN);
+    }
+}
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/free2pbm.doc xv-3.10a/xv-jp-extension/contrib/free/free2pbm.doc
--- xv-3.10a.old/xv-jp-extension/contrib/free/free2pbm.doc	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/free2pbm.doc	Mon Nov 27 16:41:07 1995
@@ -0,0 +1,150 @@
+====================================================================
+free2pbm:   plain PBM Ro[^                Ver.1.00
+                                                          
+                                        (C) Copyright 1995 by M.Sato
+====================================================================
+P@Tv
+
+  @ca|yCy`tqtrf[^Aou|ePANV
+  {[hi}`jf[^AvNCbNf[^MIv
+  V|[gPTp\R] plain PBM B
+--------------------------------------------------------------------
+Q@A[JCut@C\
+
+      free2pbm.doc : it@Cj
+      free2pbm.c   : \[Xibj
+
+--------------------------------------------------------------------
+R@
+
+  @Wo_CNg\VFiR}hC^[v^j
+  gpOB
+
+--------------------------------------------------------------------
+S@gp@
+
+  @tB^AKX_CNggpB
+  B
+
+@@W@@@Ff[^
+@@Wo@@@Frbg}bvof[^
+@@WG[oFG[bZ[W
+
+  gp
+  % free2pbm <tmemo >tmemo.pbm
+
+  @f[^t@CAf[
+  ^B
+
+
+SDP  Al
+
+  free2pbm AlB
+
+   0 : I
+   1 : G[
+   2 : G[
+   3 : f[^e
+   4 : 
+   5 : mijf[^\
+
+SDQ@
+
+  @f[^f[^{o
+
+  EPstB[hB
+  EtB[hoSNCbNA
+    RANV{[hi}`jAG[B
+  EPs
+  EtB[hB
+  EtB[h_uNI[gi'\"'jAB
+
+  @@BSA_uNI[gi'\"'j
+  si'\n'jR[h^CggpR[hd
+  OBAR[hVtgihrO
+  B
+
+  @f[^svB
+
+  @f[^pJ^JiBpJ
+  ^JigpB
+
+----------------------------------------------------------------------
+T@zzA]AA
+
+  E{\tgEFAA@_
+  EzzFzK
+  EA[JCuSzzｩRzzBR
+    pCﾀs`ｮzzB
+  E]A\A|AB
+
+  ElgpｩRBzzO
+    Ai`zzjB
+
+  Ef[^ASYpｩRs\
+    BKv\[Xt@CpFB
+
+  E{\tgEFAgp@Q
+    {\tgEFASﾒAC
+    B
+----------------------------------------------------------------------
+U@RpC
+
+  @RpCAchar  unsigned char WrbgAint 
+   unsigned int PUrbgijf[^
+  bRpCKvB
+
+  @ItmhwbRpC
+
+    $ cc -O -o free2pbm free2pbm.c
+
+  RpCvBA
+  -O OB
+
+UDP@gpCu
+
+  @vO_A_
+  CuAgp
+  BeRpC}jAQB
+
+----------------------------------------------------------------------
+V@
+
+    Ver.1.00  (95/10/31)
+
+    EJBplain PBM 
+
+
+----------------------------------------------------------------------
+W@Ql
+
+  uUEXo@l IIv\tgoN(), 1994
+
+    @{AdqOMf[^
+    ZpV[vEp[\iJ
+    Bt[\tgﾒAJpfJ
+    Wew[ﾓ\B
+
+----------------------------------------------------------------------
+X@
+
+  @oOAｿAzA|PbgM ;EOBBS {[
+  hdq[Bdq[gp
+  B
+
+    |PbgM  FID = 2932
+    Tf[lbgFID = sun4415
+    lbg@@FID = CNC09351
+    aar    FID = G~     iﾀhcpJ^Jij
+    o`rsdk  FID = MSATO
+
+    Internet: satou@kintaro3.elcom.nitech.ac.jp
+                                           i1996N 3 Lj
+
+
+
+  @f[^FlSﾓvB
+
+
+                                               1995/10/31   _
+----------------------------------------------------------------------
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free-1.10.tar.gz xv-3.10a/xv-jp-extension/contrib/free/xbm2free-1.10.tar.gz
--- xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free-1.10.tar.gz	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/xbm2free-1.10.tar.gz	Fri Dec  1 15:27:31 1995
@@ -0,0 +1,25 @@
+0xbm2free-1.10.tar [s[WWKNX展8v違D8#K}Yl&sb剖胸P母2%)v8L;NyホY01LС|9%v%s睡:閭+烈TΒr_[yN]Uo//^U徴J^{従*~m}>濔>|jW煕渚+x3DC釣M蘂7鬨榁袤wx拠*w=5>_e踪t檗澱荏H蹄%.!-F膳:轆@(武Jj芒\漕P_W{4RУx4卒xa-/嶐s壕F*:GAhhhX醋@Nh/謖h>zHkac癰PCD純Th,NQUOG^+0He{F{ak(EX2驂i瑶qub易D〒T+9p 3jY伜c=Z斜鄭囚^嶮俎湶組k?@{鐔'%eH{}P症S3N\叺Do"5b'3,ebQQ>O=)w('meLKP2ヰ6XY:a痃R基描LMJn.<Oj,b翊C >r<S毀&RQ 脊>湃+a::*跛6eS |e	CGFhDY畫PQ
+c＄拱笶Z&jM&憎`踈\? ;'G4uj
+4tmVk柝fM"v 粘h\珮KEn`ZB.Dt@lmT~ｑ普p允偶Z1奈洩`*冷`圧p噤":(g:il4HOc}歙tCX3iPAuN2bw@{SS黶<,x(里#"O8壗q3D:鮃2溺拍/%J横M>才|k*K桶ａ&c)3*G1J&6$(4;!929-DJx2g t6
+L|[泙恪XgaQb3ァy:V3))C絡F佩ecCDe擇q{樣逎HFv崔%9乙灰湯禧@"凉4O嬖
+氷Z|q5赤`@ a4)K恪a蠏odvZ填H)布Uufあ♯G0KAU7cZ/@_豚q-IL,SVu拑e.B)'et恥ttF9分x/,Y霈hFTLuR6]搭[2|Pg{0#G[0+nq#xW羌$栽-v]="Mud796DcR2!Gx毟碚Bl.]i`qPgLfJG3=Tef23[3ｊ\1*$q;liL
+ 按2燃 WNQW!x@Y)+vﾌd"肘y鮪
+$3q:)櫛心 M坡躄役pp]"ef劭q[盟 @HC>bITu4z=z+K4+)!rK翰w~vV%dt3櫺菌pm亀"BiH*}卦D>疇	)_iyEo5D;e#Z子〈ZG {U;m甲sa,衞V1&0<dLrRA逕絨]Sサ境$d)EZ[0X%xK^dr軆T:CC]u胸EH樟ゴ<翁Z4aRcZZ4惚n ff兮[‘nbgng1s;p渮盗Kv{%lf朷)& 醗飛粱4vE俺w\"Hm5]默謖qU6拊gE顴P[0Ma#1H]7荿^ZwlM骰ΝhUjzdK8Λ誘}[$Zm=繩"M閣*{-TP|S欝2欟^F8\\M]K恚c|{}3k等^_要v{C19辻猯-
+ 4篋GG@[9f;黜蚶X9P#Uc那c{13PY9f迩c6異r1-]uIDfh%gLtCr1OF\qI@DT(5"<x瓔BSwj凭蟐% PRgq本r瞻5襴x楙8m劃枯9N.1^ec籔QKcx劔`\Va咆8If齪磚So暫J*QEJ@ 穆62HE -!h3b;%R#Ww_敞>W称_窓-y默 'LO=z~Cg啌9=s]i覚T~WK3^B\~'#)q祁縺`u<]G壊坑C奚e譎緯7沢~)曚zT-\瑰]zF悃烽a#Y?E|?3ap5椎y漕^0__|#w_o麕.W-yed謨&S'g7v椁djm尨O)3灯a\2$A3裘Tj6x)宙)UhqA貼V唏(a垠#輾O}459-峪i髦遙AA>	崩k'? 5	?O逐!P+>ar鱧靹5宋4}QZKV$LH9!輛[D}/穽Wб)OBt )I癩u\瀏EM+囁 FN94\/s~clm隸矣|+8~槐歩C霹l#]t)shlm[rF蹕哭kE~ぎM語	J[#Yv-e^E棡gY|)站iW~″e~ulmy, V}jns!承TP4	6建>鏥J38x0＠"	,9cnKs笆鴻x:+儘yT畢JsdE<
+IV/O琳[~/_	L7|先 tZ_d>MCm2PeCs>b4ps栢H九醉$+BpE8Qq&	+=〜`R靹S73潰PX17ZRr紡
+エ喃粕y2e"/2Vu[`本>榜玳"\+oL=c朴04#∀Ct`3bL町+KS*+nQ婦(換_/?W街抗i*ч&DJx#4'}A兩龍/尭石(VGp瑣СfetX!籏yuNb賚3Y畊M忖(+OWんP宕?C
+N棡(0k欹xkvYjj 鐐h,肬:#)W$/wZS\茫`N RＥMVm	a%貌實qYA(3_D`R澆!M籵梁)I-L1C%>k晰J	
+1bM.a
+]C梹H+貸0Fw;PN>IFO麿_Y|,LRTE慘E{_YM*lo晴
+O?\|M9~Rg完瓰&佼滝wH尻碍損Puo->10輯惑(I逼?B<7k[s|gmB.lk@E/蓴匈JM25 \#~H(aH_e=QF与cn4y_抱哲-6h?l咳~o{k表}8:,F"B+Y
+_AjPPu]#G蘂工+鵲≠妍A1<;
+P1&\L3/賄l倅^2*g.N<歇
+]p=k淋i?V9U賊綰臂0IQKm&{{緡9se9h案;5tg'#g~?畧5,5;Dc7OXc]-嬖D+f\1N邉Y{芹堙J~EgksMl鴻HKΟ%皺
+01Z|(mbV?qM>I`+:<NEhZ>!S-∫D9{p~i袞ミKK套u NX:>OS濠 F;B'YO涜/rIlOO+(oqGy$HF糺oc`:Z{=xs≒窩mG}任佞U42!o余,
+2塀ヶoUs'杙l壞囘僵墺鏗駭瀏'\滯?8,nZzD?	5來M}4$m8|vIhPf逼》{O&旡(v4?E{痍G>{?蕈oMm0盈ff;f|D日_'VvKCoP4{xxw蝪腥BHtT1.p B淨k31
+5DVDcH%j嫌H鐘M]^\O┸!Rp!3=-^ "ZhqF^!\YBi|}7$S(鮮Cg@桙.Y禄?d6袷 r繧愈n創qEYne真E岑拷D赫w*霏捉E3遘RTa#dJ踟嵬E差)S"航皰?]
+w敲!uN!i*-)靹矯･:鸚卅jjM:\m	7):h"jbq蛯跌|MT爿!m鴿$憔t020d~<＜隘@\5机&O\|U7;w的泡A$ｦe%G| \s^剣c]v}M式GS
+M"lME穿C:簓逹G`+W0[-櫚t*t1~_;)c隅7$5mn]4G|`*遇鰾D;zp:1s趁c<枚knL刑s(iY)v-vY?v鐐;貯郵'P繦fvlOuH]喇,*
+QВa-墾O&Iabi5瑾U~uOod_B}>B~&IG1＼_O烈鞏u1f>~[2roNE^'磔a昜/~/eZ<i5[nA┻bN5z桙'S3YK~:;
+>qS\句#]冥X]S[cc迯s"Z=Pr?枋R)lTw?鯡懈Pｘ畤J攘戍3&擣	4bY=U.= 陳1啓閖覊ou$腎鐔Ш'(''!K	J
+けo蛬a [X~l爲qXs<M釘Z&宸P*Q]q-D)Ｐ=NYYs/A峡hCk##~WVCt[he%F] S_繊-0F=忰滝焙;*W}胝_Mkj+Vm]s_!`{,<CcG8ムFm}O'YR]rD=汢NlGk<%ZC暫煢C'Zbt*Q 夢R%鬢J/)蕁f[rwA菩D壬HR)q9Y7l顱p~y^氛d襃l%i!)B~權?uv%/8?^UKKZ!+b2{pB+4t誘 煌]NA淳>,93yyK(5n`5u*=猖Sn悸0$=林Ht @C淦*N[耗S〕4xoaK? e赫1Q旋柎X爆?応>? P  
\ No newline at end of file
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free.mk xv-3.10a/xv-jp-extension/contrib/free/xbm2free.mk
--- xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free.mk	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/xbm2free.mk	Thu Feb 15 17:35:47 1996
@@ -0,0 +1,98 @@
+############### Makefile for xbm2free & ZFoutlib #################
+GZIP	   = /usr/local/bin/gzip
+TAR        = tar
+CC         = cc
+CFLAGS     = -g
+SHELL      = /bin/sh
+
+DISTDIR    = /usr/local/bin
+
+STDINCDIRS = -I/usr/include
+
+################# Macros for xbm2free ##############################
+# Extra libs. if malloc() requires extra library, change this macro
+# like as '-L/usr/local/lib/malloc -lmalloc'
+EXTRALIBS =
+# Xlib include file directory
+XINCDIR    = -I/usr/include/X11R5
+# Xlib library directory
+XLIBDIR    = -L/usr/lib/X11R5
+
+# directory for temporary file
+XBM2FREETMP=/tmp
+
+## change temporary file name makeing.
+# if USETMPNAM is defined as '-DUSE_TMPNAM', XBM2FREETMP is ignored.
+#USETMPNAM = -DUSE_TMPNAM
+
+# C Compiler flags
+CFLAGSXBM2F = $(CFLAGS) $(STDINCDIRS) $(USETMPNAM)
+
+################# Macros for ZFoutlib ###############################
+## If mallc() requires <malloc.h>, change REQMALLOCH to be 'define'
+REQMALLOCH = undef
+# REQMALLOCH = define
+
+## If mallc() requires <alloc.h>, change REQALLOC to be 'define'
+REQALLOCH = undef
+# REQALLOCH = define
+
+## If free() is decleared as free(char *), change FREECHRPNT to be 'define'.
+FREECHRPNT = undef
+# FREECHRPNT = define
+
+## C Compiler flags
+CFLAGSZF = $(CFLAGS) $(STDINCDIRS)
+
+###################################################################
+ZFOUTDIR   = ./ZFout111
+ZFMAKEIN   = $(ZFOUTDIR)/Makefile.in
+ZFMAKEFILE = $(ZFOUTDIR)/Makefile
+ZFSITEH    = $(ZFOUTDIR)/site.h
+ZFSITEIN   = $(ZFOUTDIR)/site_h.in
+ZFOUTLIBA  = $(ZFOUTDIR)/libZFout.a
+
+XBM2FREEDIR  = ./xbm2free-1.10
+XBM2FREEMKIN = $(XBM2FREEDIR)/Makefile.in
+XBM2FREEMK   = $(XBM2FREEDIR)/Makefile
+XBM2FREE     = $(XBM2FREEDIR)/xbm2free
+XBM2FMKFLAGS  = "XINCDIR=$(XINCDIR) $(UNISDTHDIR)" "XLIBDIR=$(XLIBDIR)" \
+    "TMPDIR_DEFALUT=$(XBM2FREETMP)" \
+    "ZFOUTLIBDIR=-L../$(ZFOUTDIR)" "ZFOUTINCDIR=-I../$(ZFOUTDIR)" \
+    "ZFOUTLIB=-lZFout $(EXTRALIBS)"
+#####################################################################
+all : extract $(XBM2FREE)
+
+install : all
+	cp $(XBM2FREE) $(DISTDIR)
+
+############# EXTRACT ########################################
+extract :  $(ZFOUTDIR) $(XBM2FREEDIR)
+
+$(ZFOUTDIR) : ZFout111.tar.gz
+	$(GZIP) -d -c ZFout111.tar.gz | $(TAR) xvf -
+
+$(XBM2FREEDIR) : xbm2free-1.10.tar.gz
+	$(GZIP) -d -c xbm2free-1.10.tar.gz | $(TAR) xvf -
+
+############# CLEAN ##########################################
+clean-all :
+	rm -rf $(ZFOUTDIR) $(XBM2FREEDIR)
+clean :
+	cd $(ZFOUTDIR); make clean
+	cd $(XBM2FREEDIR); make clean
+
+############# make ZFoutlib.a ##################################
+$(ZFOUTLIBA) : $(ZFOUTDIR)
+	cat $(ZFSITEIN) \
+	  | sed -e 's/undef REQ_MALLOC_H/$(REQMALLOCH) REQ_MALLOC_H/' \
+	  | sed -e 's/undef REQ_ALLOC_H/$(REQALLOCH) REQ_ALLOC_H/' \
+	  | sed -e 's/undef FREE_CHAR_PNT/$(FREECHRPNT) FREE_CHAR_PNT/' \
+	  > $(ZFSITEH)
+	cp $(ZFMAKEIN) $(ZFMAKEFILE)
+	cd $(ZFOUTDIR); make "CFLAGS=$(CFLAGSZF)" "CC=$(CC)"
+############# make xbm2free ####################################
+$(XBM2FREE) : $(XBM2FREEDIR) $(ZFOUTLIBA)
+	cp $(XBM2FREEMKIN) $(XBM2FREEMK)
+	cd $(XBM2FREEDIR); \
+	make "CFLAGS=$(CFLAGSXBM2F)" "CC=$(CC)" $(XBM2FMKFLAGS)
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free.mk.doc xv-3.10a/xv-jp-extension/contrib/free/xbm2free.mk.doc
--- xv-3.10a.old/xv-jp-extension/contrib/free/xbm2free.mk.doc	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/free/xbm2free.mk.doc	Mon Dec 11 23:29:26 1995
@@ -0,0 +1,90 @@
+---------------------------------------------------------------
+xbm2free CXg[(UNIXp)
+---------------------------------------------------------------
+1. xbm2free.mk W
+
+  xbm2free wNCAgC make 
+  BHP-UX 9.0x ORpC
+  C| xbm2free.mk WKv
+  B
+
+2. RpC
+
+  make -f xbm2free.mk all
+  make -f xbm2free.mk install
+
+----------------------------------------------------------------
+xbm2free.mk W
+----------------------------------------------------------------
+xbm2free.mk gp}NCX
+KvB
+
+1. S
+
+  GZIP [/usr/local/bin/gzip]
+    A[JCup
+  CC [cc]
+    bRpCB
+    
+    ZFoutlib  \x?? gpBnr
+    WbRpCB
+    gcc RpCpB
+
+  CFLAGS [-O]
+    bRpCnp[^
+
+  DISTDIR [/usr/local/bin]
+    xbm2free CXg[fBNg
+  STDINCDIR []
+    CN[ht@CfBNgw
+    (-IfBNg w)
+
+3. xbm2free L
+
+  EXTRALIBS []
+    malloc() gCuKv Xlib 
+    g -lX11 OCuwKvC
+    CuwB
+
+  XINCDIR [-I/usr/include/X11R5]
+    Xlib CN[ht@CfBNgw
+
+  XLIBDIR [-L/usr/lib/X11R5]
+    Xlib CufBNgw
+
+  XBMP2FREETMP [/tmp]
+    xbm2free t@CfBNg
+
+  USETMPNAM []
+    xbm2free gpt@CO XBM2FREETMP 
+    getpid() gCtmpnam()  -DUSE_TMPNAM
+    B
+
+  CFLAGSXBM2F [$(CFLAGS) $(STDINCDIRS) $(USETMPNAM)]
+    xbm2free  make  CFLAGS gpB
+
+3. ZFoutlib L
+
+  REQMALLOCH [undef]
+    malloc(), free() vg^Cv stdlib.h C
+    malloc.h  define X
+
+  REQALLOCH [undef]
+    malloc(), free() vg^Cv stdlib.h C
+    alloc.h  define X
+
+  FREECHRPNT [undef]
+    free()  (char *) LXgRpC
+    G[ define X
+
+    LR ZFout110/site_h.in  ZFout110/site.h Rs[
+     sed us}NB
+    undef  define OCbvv
+    ZbTB
+
+  CFLAGSZF [$(CFLAGS) $(STDINCDIRS)]
+    ZFoutlib  make  CFLAGS gpB
+---------------------------------------------------------
+#  malloc() CEEEEE
+_LEｺ.dC.H
+  satou@kintaro3.elcom.nitech.ac.jp
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/q4/Makefile xv-3.10a/xv-jp-extension/contrib/q4/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/q4/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/q4/Makefile	Tue Dec  5 15:52:27 1995
@@ -0,0 +1,26 @@
+DEST		= /usr/local/bin
+
+CC		= cc
+CFLAGS		= #-O
+LIBS		=
+
+#INSTALL	= install -c -s
+INSTALL		= cp
+
+SRCS		= q4toppm.c
+OBJS		= q4toppm.o
+PROGRAM		= q4toppm
+
+
+all:		$(PROGRAM)
+
+$(PROGRAM):     $(OBJS)
+		$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(PROGRAM)
+
+clean:;		rm -f $(PROGRAM) $(OBJS) tags TAGS core
+
+install:	$(PROGRAM)
+		$(INSTALL) $(PROGRAM) $(DEST)
+
+###
+q4toppm.o:
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/q4/q4toppm.c xv-3.10a/xv-jp-extension/contrib/q4/q4toppm.c
--- xv-3.10a.old/xv-jp-extension/contrib/q4/q4toppm.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/q4/q4toppm.c	Tue Sep 26 17:20:05 1995
@@ -0,0 +1,430 @@
+/*
+ *  q4toppm  -  convert XLD4(Q4) format image to PPM format image.
+ *
+ *  Author:  Tetsuya INOUE <tin329@chino.it.okayama-u.ac.jp>
+ *
+ *
+ *  $B$3$l$O!"9bHx!!<B(B <GGC01363@niftyserve.or.jp> $B;a$,!"(Bfj.sources $B$K(B
+ *  $BEj9F$5$l$?(B xq4.tar.gz :
+ *    Subject: xq4 - Q4 loader for X Window
+ *    Message-ID: <INETNEWS-1-18-1.00049@niftyserve.or.jp>
+ *  $B$r2~JQ$7$?$b$N$G$9!#(B
+ */
+
+/*-----------------------------------------------------------
+ *  (C) Copyright 1992 FUJI SYSTEM Co.,LTD
+ *          All Rights Reserved.
+ *      $B#Q#4(B $B%$%a!<%8%m!<%I%W%m%0%i%`(B     <xq4.c>
+ *-----------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+/* If you want to use this within xv, uncomment "#define USE_WITH_XV" and
+ * edit to use LoadQ4 in "xv.h","xv.c","xvdir.c","xvbrowse.c" and etc.
+ */
+/* xv $B$KAH$_9~$s$G$N%F%9%H$O$^$@9T$J$C$F$$$^$;$s!#AH$_9~$`>l9g$KITET9g$,(B
+ * $B$"$l$P=$@5$7$F2<$5$$!#(B
+ */
+/* #define USE_WITH_XV */
+
+#ifdef USE_WITH_XV
+#include "copyright.h"
+#include "xv.h"
+#endif /* USE_WITH_XV */
+
+#define WIDTH  640
+#define HEIGHT 400
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif
+#ifndef SEEK_END
+#define SEEK_END 2
+#endif
+
+
+#ifdef USE_WITH_XV
+int LoadQ4(char *, PICINFO *);
+#endif /* USE_WITH_XV */
+
+#undef ARGS
+#ifdef __STDC__
+#  define ARGS(a) a
+#else
+#  define ARGS(a) ()
+#endif
+
+static int getq4img ARGS((FILE *, char *, char *, char *, unsigned char *, int));
+static int decode_1 ARGS((void));
+static int decode_2 ARGS((void));
+
+
+#ifndef USE_WITH_XV
+void usage()
+{
+  fprintf(stderr,"q4toppm : convert XLD4(Q4) format image to PPM format image.\n");
+  fprintf(stderr,"usage   : q4toppm <q4_file>\n");
+}
+
+int main(argc, argv)
+     int argc;
+     char **argv;
+{
+  struct stat    sbuf;
+  int fsize;
+  char *pic;
+  char r[16],g[16],b[16];
+  FILE *fp;
+  int i;
+  char *fname;
+
+  if(argc > 2){
+    usage();
+    return 1;
+
+  }else if(argc == 2){
+    if(!strcmp(argv[1],"-help") || !strcmp(argv[1],"-h")){
+      usage();
+      return 1;
+    }else if(!strcmp(argv[1],"-")){
+      if(isatty(0)){ /* if stdin is terminal device (key) */
+	usage();
+	return 1;
+      }else{
+	fname = "stdin";
+	fsize = -1;  /* don't check file size in getq4img */
+	fp = stdin;
+      }
+    }else{
+      fname = argv[1];
+      if( stat( fname, &sbuf ) == -1  || (sbuf.st_mode & S_IFMT) != S_IFREG ) {
+	fprintf(stderr, "%s   not found\n", fname);
+	return 1;
+      }
+      fsize = sbuf.st_size;
+      if((fp = fopen(fname, "r" )) == NULL ) return 1;
+    }
+
+  }else if(argc == 1){
+    if(isatty(0)){ /* if stdin is terminal device (key) */
+      usage();
+      return 1;
+    }else{
+      fname = "stdin";
+      fsize = -1;  /* don't check file size in getq4img */
+      fp = stdin;
+    }
+  }
+
+  if((pic = (char *) malloc((size_t) WIDTH * HEIGHT * sizeof(char)))
+     ==NULL){
+    fprintf(stderr, "Can't allocate memory\n");
+    return 1;
+  }
+
+  if(getq4img(fp, r, g, b, pic, fsize)!=0){
+    fprintf(stderr, "%s   Q4 format error\n", fname);
+    free(pic);
+    return 1;
+  }
+
+
+  /* $B%Q%l%C%H$N%9%1!<%k$r(B 0$B!A(B15 $B$+$i(B 0$B!A(B255 $B$KJQ49(B */
+  for(i=0; i<16; i++){
+    r[i] = r[i] *255/15;
+    g[i] = g[i] *255/15;
+    b[i] = b[i] *255/15;
+  }
+
+
+  /* PPM $B%U%!%$%k$N=PNO(B */
+  fprintf(stdout,"P6\n");
+  fprintf(stdout,"%d %d\n", WIDTH, HEIGHT);
+  fprintf(stdout,"255\n");
+
+  for(i=0; i<WIDTH * HEIGHT; i++){
+    fwrite(&r[(int)pic[i]], 1,1,stdout);
+    fwrite(&g[(int)pic[i]], 1,1,stdout);
+    fwrite(&b[(int)pic[i]], 1,1,stdout);
+  }
+
+  return 0;
+}
+#endif /* !USE_WITH_XV */
+
+
+#ifdef USE_WITH_XV
+int LoadQ4(fname, pinfo)
+     char *fname;
+     PICINFO *pinfo;
+{
+  struct stat    sbuf;
+  int            fsize;
+  FILE          *fp;
+  int            i;
+
+  if( stat( fname, &sbuf ) == -1  || (sbuf.st_mode & S_IFMT) != S_IFREG ) {
+    fprintf(stderr, "%s   not found\n", fname);
+    return 0;
+  }
+  fsize = sbuf.st_size;
+  if((pinfo->pic = (byte *) malloc((size_t) WIDTH * HEIGHT * sizeof(char)))
+     ==NULL){
+    fprintf(stderr, "Can't allocate memory in LoadQ4\n");
+    return 0;
+  }
+  if((fp = fopen(fname, "r" )) == NULL){
+    fprintf(stderr, "Can't open file in LoadQ4\n");
+    return 0;
+  }
+  if( getq4img(fp, pinfo->r, pinfo->g, pinfo->b, &pinfo->pic, fsize)!=0){
+    fprintf(stderr, "%s   Q4 format error\n", fname);
+    free(pinfo->pic);
+    return 0;
+  }
+
+  for(i=0; i< 16; i++){
+   pinfo->r[i] = pinfo->r[i] *255/15 ;
+   pinfo->g[i] = pinfo->g[i] *255/15 ;
+   pinfo->b[i] = pinfo->b[i] *255/15 ;
+  }
+
+  pinfo->w = pinfo->normw = WIDTH;
+  pinfo->h = pinfo->normh = HEIGHT;
+  pinfo->type = PIC8;
+  pinfo->frmType = F_MAG;
+  pinfo->colType = F_FULLCOLOR;
+  sprintf(pinfo->fullInfo, "XLD(Q4), 16 colors (%ld bytes)", sbuf.st_size);
+  sprintf(pinfo->shrtInfo, "%dx%d XLD(Q4)", WIDTH, HEIGHT);
+
+  return 1;
+}
+#endif /* USE_WITH_XV */
+
+
+/*-----------------------------------------------------------
+ *      $B#Q#4%U%!%$%k%j!<%I=hM}%W%m%0%i%`(B
+ *-----------------------------------------------------------*/
+
+#define    cnvint( tbl, ix )    ( ((unsigned char *)(tbl))[ix+1] << 8 | \
+                                  ((unsigned char *)(tbl))[ix] )
+#define    strint(tbl,ix,num)   ( ((unsigned char *)(tbl))[ix] \
+                                             = (unsigned char)((num)&0xff), \
+                                  ((unsigned char *)(tbl))[ix+1] \
+                                             = (unsigned char)((num)>>8&0xff) )
+
+#define    MIDBUF  (unsigned)0x7f58
+#define    ENDBUF  (unsigned)0xfdd5
+
+static unsigned   orig_len, data_len;
+static char       palette_ct[] = {
+  0x00, 0x02, 0x04, 0x06, 0x01, 0x03, 0x05, 0x07,
+  0x08, 0x0A, 0x0C, 0x0E, 0x09, 0x0B, 0x0D, 0x0F};
+static unsigned char gbuf0[0xfdf0],gbuf1[0xfdf0],gbuf2[0xfdf0],gbuf3[0xfdf0];
+
+
+static int getq4img( fp, pt_r, pt_g, pt_b, gbuf, ss )
+     FILE            *fp;
+     char            *pt_r, *pt_g, *pt_b;     /* palette table */
+     unsigned char   *gbuf;                   /* graphic buffa */
+     int              ss;
+{
+  unsigned char fbuf[22];
+  long        fsize;
+  int         repeatn, num, skipcnt, i;
+  unsigned    si, dotcnt;
+  unsigned char color, palette_no, rep_palette_no, ch, *dptr;
+
+  if( fread( fbuf, 1, 22, fp ) != 22 ){
+    fclose(fp);
+    return( 2 );
+  }
+  if( fbuf[2] != 2  &&  (fbuf[1] > 1 || fbuf[3] > 1) ){
+    fclose(fp);
+    return( 2 );
+  }
+  if(ss > 0){
+    if( (fsize = cnvint( fbuf, 8 )) != 0 &&
+	/**** xmodem $BEy$G!"%G!<%?$,Bg$-$/$J$k>l9g$N$?$a(B ****/
+	(fsize |= (long)fbuf[10] << 16) > ss){
+      fclose(fp);
+      return( 2 );
+    }
+  }
+  if( memcmp( fbuf + 11, "MAJYO", 5 ) != 0 ) {
+    fclose(fp);
+    return( 2 );
+  }
+  skipcnt = 0;
+  if( (fbuf[4] & 0x02) != 0 )    skipcnt++;
+  if( (fbuf[4] & 0x08) != 0 )    skipcnt++;
+
+  /* $B%Q%l%C%H<hF@(B */
+  data_len = cnvint( fbuf, 0x10 );
+  if( fread( gbuf1, 1, data_len, fp ) != data_len ) {
+    fclose(fp);
+    return( 2 );
+  }
+  data_len = decode_1();                       /* $B%G%3!<%I!!#1(B */
+  decode_2();                                  /* $B%G%3!<%I!!#2(B */
+
+  si = 0;                                      /* $B%G%3!<%I!!#3(B */
+  dptr = gbuf0;
+  while( 1 ) {
+    if( (color = gbuf1[si++]) != 0x10 ) {
+      repeatn = 1;
+    } else {
+      if( (ch = gbuf1[si++]) == 0 ) color = gbuf1[si++], ch = gbuf1[si++];
+      else color = 0;
+      repeatn = (ch << 4) + ch + gbuf1[si++];
+    }
+    for( ; repeatn > 0; repeatn-- ) *dptr++ = color;
+    if( si >= data_len ) break;
+  }
+
+  /* $B%Q%l%C%H=PNO(B */
+  for( i = 0; i < 16; i++ ) {
+    pt_r[i] = gbuf0[6 * i + 1];
+    pt_g[i] = gbuf0[6 * i + 3];
+    pt_b[i] = gbuf0[6 * i + 5];
+  }
+
+  /* $B%V%m%C%/FI$_Ht$P$7=hM}(B */ /* $B%Q%$%W$@$H%(%i!<$K$J$k!)(B */
+  for( ; skipcnt > 0; skipcnt-- )
+    if( fread( fbuf, 1, 6, fp ) != 6  ||
+       fseek( fp, (long)cnvint( fbuf, 0 ), SEEK_CUR ) != 0 ) {
+      fclose(fp);
+      return( 2 );
+    }
+
+  /* $B2hA|%G!<%?=hM}(B */
+  while( fread( fbuf, 1, 6, fp ) > 0 ) {
+    data_len = cnvint( fbuf, 0 );
+    orig_len = cnvint( fbuf, 4 );
+    if( fread( gbuf1, 1, data_len, fp ) != data_len ) {
+      fclose(fp);
+      return( 2 );
+    }
+    data_len = decode_1();                   /* $B%G%3!<%I!!#1(B */
+    decode_2();                              /* $B%G%3!<%I!!#2(B */
+
+    si = 0;
+    dotcnt = orig_len * 2;
+    rep_palette_no = 0x00;
+    while( 1 ) {
+      if( (num = gbuf1[si++]) != 0x10 ) {
+	palette_no = palette_ct[num];
+	repeatn = 1;
+      } else {
+	if( (ch = gbuf1[si++]) == 0 )
+	  rep_palette_no = palette_ct[gbuf1[si++]], ch = gbuf1[si++];
+	palette_no = rep_palette_no;
+	repeatn = (ch << 4) + ch + gbuf1[si++];
+      }
+      for( ; repeatn > 0 && dotcnt > 0; repeatn--, dotcnt-- ) 
+	*gbuf++ = palette_no;
+      if( si >= data_len ) {
+	for( ; dotcnt > 0; dotcnt-- )    /* $B%I%C%H=PNOITB-;~$O7jKd$a(B */
+	  *gbuf++ = palette_no;
+	break;
+      }
+    }
+  }
+
+  fclose( fp );
+  return( 0 );
+}
+
+/* $B%G%3!<%I!!#1(B */
+static int decode_1()
+{
+  unsigned    outnum, misyori, si, di;
+  int         syoribitw, incbitw;
+
+  strint( gbuf1, data_len, 0 );
+  si = 0, di = 0;
+  misyori = gbuf1[si++];
+  incbitw = 3;
+
+  for( syoribitw = 0; si <= data_len; ) {
+    syoribitw += incbitw;
+    if( syoribitw < 8 ) {
+      outnum = misyori >> (8 - syoribitw);
+      misyori &= 0xff >> syoribitw;
+    } else if( syoribitw < 16 ) {
+      outnum = gbuf1[si] >> (16 - syoribitw);
+      outnum |= misyori << (syoribitw - 8);
+      misyori = (0xff >> (syoribitw - 8)) & gbuf1[si++];
+    } else if( syoribitw < 24 ) {
+      outnum = misyori << (syoribitw - 8);
+      outnum |= gbuf1[si++] << (syoribitw - 16);
+      outnum |= gbuf1[si] >> (24 - syoribitw);
+      misyori = gbuf1[si++] & (0xff >> (syoribitw - 16));
+    } else break;
+
+    syoribitw &= 0x07;
+    if( outnum == 0 ) break;
+    if( outnum == 1 ) incbitw++;
+    else strint( gbuf0, di, outnum - 2 ), di += 2;
+  }
+  strint( gbuf0, di, 0 );
+
+  return(di / 2);
+}
+
+/* $B%G%3!<%I!!#2(B */
+static int decode_2()
+{
+  unsigned    ix, len, si, di,soffset, doffset;
+  unsigned    gbuf1_len, gbuf3_int, prev_int, next_int, cur_int;
+  unsigned char *sptr, *dptr;
+
+  for( ix = 0; ix <= 0x11; ix++ ) {
+    gbuf2[ENDBUF + ix] = (char)ix;
+    strint( gbuf3, ix * 2, ENDBUF + ix );
+    strint( gbuf3 + MIDBUF, ix * 2, 1 );
+  }
+  strint( gbuf3, ix * 2, 0 );
+  strint( gbuf3 + MIDBUF, ix * 2, 0 );
+
+  gbuf1_len = 0, si = 1;
+  doffset = 0;
+  prev_int = cnvint( gbuf0, 0 );
+  cur_int = 0x11;
+
+  while( 1 ) {
+    next_int = cnvint( gbuf0, si * 2 );
+    si++;
+    if( next_int > cur_int ) {
+      data_len = gbuf1_len;
+      return( 0 );
+    }
+    di = prev_int * 2;
+    gbuf3_int = soffset = cnvint( gbuf3, di );
+    len = cnvint( gbuf3, MIDBUF + di );
+    if( next_int != cur_int ) gbuf3_int = cnvint( gbuf3, next_int * 2 );
+    strint( gbuf3, cur_int*2, doffset );
+    strint( gbuf3, MIDBUF + cur_int * 2, len + 1 );
+    for( ix = len, sptr = gbuf2 + soffset,
+	dptr = gbuf2 + doffset; ix > 0; ix-- ) *dptr++ = *sptr++;
+    *dptr++ = gbuf2[gbuf3_int];
+    doffset += len + 1;
+    for( ix = len, sptr = gbuf2 + soffset,
+	dptr = gbuf1 + gbuf1_len; ix > 0; ix-- ) *dptr++ = *sptr++;
+    gbuf1_len += len;
+    if( si >= data_len ) {
+      gbuf1[gbuf1_len] = 0;
+      data_len = gbuf1_len;
+      return( 0 );
+    }
+    cur_int++;
+    prev_int = next_int;
+  }
+}
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/tim/Makefile xv-3.10a/xv-jp-extension/contrib/tim/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/tim/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/tim/Makefile	Tue Dec  5 15:53:42 1995
@@ -0,0 +1,26 @@
+DEST		= /usr/local/bin
+
+CC		= cc
+CFLAGS		= #-O
+LIBS		=
+
+#INSTALL	= install -c -s
+INSTALL		= cp
+
+SRCS		= timtoppm.c
+OBJS		= timtoppm.o
+PROGRAM		= timtoppm
+
+
+all:		$(PROGRAM)
+
+$(PROGRAM):     $(OBJS)
+		$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(PROGRAM)
+
+clean:;		rm -f $(PROGRAM) $(OBJS) tags TAGS core
+
+install:	$(PROGRAM)
+		$(INSTALL) $(PROGRAM) $(DEST)
+
+###
+timtoppm.o:
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/tim/timtoppm.c xv-3.10a/xv-jp-extension/contrib/tim/timtoppm.c
--- xv-3.10a.old/xv-jp-extension/contrib/tim/timtoppm.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/tim/timtoppm.c	Thu Sep 14 16:49:17 1995
@@ -0,0 +1,214 @@
+/*
+ * timtoppm.c - read a tim file and produce a ppm file
+ */
+
+#include <stdio.h>
+#include <varargs.h>
+
+#define MAX_INDEX	256
+
+unsigned char r[MAX_INDEX];
+unsigned char g[MAX_INDEX];
+unsigned char b[MAX_INDEX];
+
+
+main (argc, argv)
+int argc;
+char **argv;
+{
+  FILE *fp;
+  int ch;
+  char *fname;
+
+  if (argc <= 1) {
+    fp = stdin;
+  } else {
+    fname = argv[argc-1];
+    if ((fp = fopen(fname, "r")) == NULL) {
+      FatalError("Can't open input file %s.", fname);
+    }
+  }
+
+  if ((ch = getint(fp)) != 0x10) {
+    FatalError("Unknown format %d.", ch);
+  }
+
+  switch (ch = getint(fp)) {
+    case 0x02: load15rgb(fp);  break;
+    case 0x03: load24rgb(fp);  break;
+    case 0x08: load16idx(fp);  break;
+    case 0x09: load256idx(fp); break;
+    default:   FatalError("Unknown format %d.", ch); break;
+  }
+}  
+
+
+/*******************************************/
+static int load15rgb(fp)
+FILE *fp;
+{
+  int   i, j, w, h, c;
+
+  (void)getint(fp);
+  (void)getint(fp);
+  w = getshort(fp);
+  h = getshort(fp);
+
+  printf("P6\n%d %d\n255\n", w, h);
+  for (i = 0; i < h; i++) {
+    for (j = 0; j < w; j++) {
+      c = getshort(fp);
+      putchar(255*(c & 0x1F)/31);
+      putchar(255*((c >> 5) & 0x1F)/31);
+      putchar(255*((c >> 10) & 0x1F)/31);
+    }
+  }
+}
+
+
+/*******************************************/
+static int load24rgb(fp)
+FILE *fp;
+{
+  int   i, j, w, h, c;
+  long  pad;
+
+  (void)getint(fp);
+  (void)getint(fp);
+  c = getshort(fp);
+  w = c*2/3;
+  h = getshort(fp);
+  pad = c*2 % 3;
+
+  printf("P6\n%d %d\n255\n", w, h);
+  for (i = 0; i < h; i++) {
+    for (j = 0; j < w; j++) {
+      putchar(getc(fp)); putchar(getc(fp)); putchar(getc(fp));
+    }
+    for (j = 0; j < pad; j++) {
+      (void)getc(fp);
+    }
+  }
+}
+
+
+/*******************************************/
+static int load16idx(fp)
+FILE *fp;
+{
+  int   i, j, w, h;
+  int   c1, c2;
+  long	offset;
+
+  offset = getint(fp)+16;
+  (void)getint(fp);
+  (void)getint(fp);
+
+  for (i = 0; i < 16; i++) {
+    c1 = getshort(fp);
+    r[i] = 255*(c1 & 0x1F)/31;
+    g[i] = 255*((c1 >> 5) & 0x1F)/31;
+    b[i] = 255*((c1 >> 10) & 0x1F)/31;
+  }
+
+  for (i = offset-52; i > 0; i--) {
+    (void)getc(fp);
+  }
+  w = getshort(fp)*4;
+  h = getshort(fp);
+
+  printf("P6\n%d %d\n255\n", w, h);
+  for (i = 0; i < h; i++) {
+    for (j = 0; j < w; j += 2) {
+      c1 = getc(fp);
+      c2 = (c1 >> 4) & 0x0F;
+      c1 = c1 & 0x0F;
+      putchar(r[c1]); putchar(g[c1]); putchar(b[c1]);
+      putchar(r[c2]); putchar(g[c2]); putchar(b[c2]);
+    }
+  }
+}
+
+
+/*******************************************/
+static int load256idx(fp)
+FILE *fp;
+{
+  int   i, j, w, h, c;
+  long	offset;
+
+  offset = getint(fp)+16;
+  (void)getint(fp);
+  (void)getint(fp);
+
+  for (i = 0; i < 256; i++) {
+    c = getshort(fp);
+    r[i] = 255*(c & 0x1F)/31;
+    g[i] = 255*((c >> 5) & 0x1F)/31;
+    b[i] = 255*((c >> 10) & 0x1F)/31;
+  }
+
+  for (i = offset-532; i > 0; i--) {
+    (void)getc(fp);
+  }
+  w = getshort(fp)*2;
+  h = getshort(fp);
+
+  printf("P6\n%d %d\n255\n", w, h);
+  for (i = 0; i < h; i++) {
+    for (j = 0; j < w; j++) {
+      c = getc(fp);
+      putchar(r[c]); putchar(g[c]); putchar(b[c]);
+    }
+  }
+}
+
+
+/*******************************************/
+static int getint(fp)
+FILE *fp;
+{
+  int c1, c2, c3, c4;
+
+  c1 = getc(fp);
+  if (c1 == EOF) return 0;
+  c2 = getc(fp);
+  if (c2 == EOF) return 0;
+  c3 = getc(fp);
+  if (c3 == EOF) return 0;
+  c4 = getc(fp);
+  if (c4 == EOF) return 0;
+
+  return (c4 << 24) | (c3 << 16) | (c2 << 8) | c1;
+}
+
+
+/*******************************************/
+static int getshort(fp)
+FILE *fp;
+{
+  int c1, c2;
+
+  c1 = getc(fp);
+  if (c1 == EOF) return 0;
+  c2 = getc(fp);
+  if (c2 == EOF) return 0;
+
+  return (c2 << 8) | c1;
+}
+
+
+FatalError(va_alist)
+va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start(ap);
+  format = va_arg(ap, char *);
+  vfprintf(stderr, format, ap);
+  va_end(ap);
+  fprintf(stderr, "\n");
+  fflush(stderr);
+  exit(1);
+}
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/unchc/Makefile xv-3.10a/xv-jp-extension/contrib/unchc/Makefile
--- xv-3.10a.old/xv-jp-extension/contrib/unchc/Makefile	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/unchc/Makefile	Tue Dec  5 15:54:01 1995
@@ -0,0 +1,11 @@
+DEST		= /usr/local/bin
+
+#INSTALL	= install -c
+INSTALL		= cp
+
+
+all clean:
+
+install:	unchc.pl
+		$(INSTALL) unchc.pl $(DEST)/unchc
+###
diff -Naur xv-3.10a.old/xv-jp-extension/contrib/unchc/unchc.pl xv-3.10a/xv-jp-extension/contrib/unchc/unchc.pl
--- xv-3.10a.old/xv-jp-extension/contrib/unchc/unchc.pl	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/contrib/unchc/unchc.pl	Mon Sep 25 17:44:22 1995
@@ -0,0 +1,112 @@
+#!/usr/local/bin/perl
+#
+#  unchc  -  UN Cern Httpd Cache.
+#            Skip header of CERN httpd cache file, and write data to stdout.
+#
+#  Author:  Tetsuya INOUE  <tin329@chino.it.okayama-u.ac.jp>
+#
+#
+#  Algorithm: $@%U%!%$%k$N@hF,$+$i#19T$E$D!"6u9T$^$GFI$_9~$`!#(J
+#             $@$=$l$h$j8e$r%G!<%?$H$_$J$7$F!"(J1 byte $@$4$H$KFI$_9~$s$G$+$i(J
+#             stdout $@$K=q$-9~$`!#(J
+#             $@6u9T$O!"(JUNIX(LF, 0x0A) $@$H(J MSDOS(CR+LF, 0x0D0A) $@$r<1JL$9$k!#(J
+#             $@$b$7!"(JMAC(CR, 0x0D)$@$N7A<0$,B8:_$9$k$J$i8fO"Mm2<$5$$!#(J
+#
+#
+#  $@$3$N%W%m%0%i%`$OHs>o$K$$$$$+$2$s$J$b$N$G$9!#$*$+$7$$!"5$$KF~$i$J$$!"(J
+#  $@;H$($J$$$J$I$,$"$j$^$7$?$i!"0U$r5b$s$G=$@5$7$F2<$5$$!#(J
+#
+
+
+sub pr_help {
+    print "unchc : UN Cern Httpd Cache.\n";
+    print "        Skip header of CERN httpd cache file, ",
+                  "and write data to stdout.\n";
+    print "usage : unchc <cern_httpd_cache_file>\n";
+}
+
+$skiped = 0;
+
+if ($#ARGV == -1 && ! -t){
+    # $@%3%^%s%I%i%$%s0z?t$,L5$/!"(Jstdin $@$,(J tty $@$G$J$1$l$P!"(Jstdin $@$+$iFI$_9~$`(J
+    #  cat foo | unchc  : read stdin(foo)
+    #  unchc < foo      : read stdin(foo)
+
+    $_ = <STDIN>;
+    if (! /^HTTP/) {
+	print STDERR "Probably, this is not CERN httpd cache file.\n";
+	exit 1;
+    }
+    while ($skiped == 0) {
+	$_ = <STDIN>;
+	if (($_ eq "\n") || ($_ eq "\r\n")) {
+	    $skiped = 1;
+	}
+    }
+    while(read(STDIN, $buf, 1)){
+	print STDOUT $buf;
+    }
+    exit 0;
+
+}elsif($#ARGV == 0){
+    # $@%3%^%s%I%i%$%s0z?t$,#1$D$N>l9g(J
+    #  unchc -h     : print help message and exit
+    #  unchc -help  : print help message and exit
+    #  unchc foo    : read foo
+    #  unchc -      : read stdin
+
+    if((@ARGV[0] eq "-h") || (@ARGV[0]  eq "-help")){
+	&pr_help();
+	exit 1;
+    }elsif ((@ARGV[0] eq "-") && ! -t){
+	$_ = <STDIN>;
+	if (! /^HTTP/) {
+	    print STDERR "Probably, this is not CERN httpd cache file.\n";
+	    exit 1;
+	}
+	while ($skiped == 0) {
+	    $_ = <STDIN>;
+	    if (($_ eq "\n") || ($_ eq "\r\n")) {
+		$skiped = 1;
+	    }
+	}
+	while(read(STDIN, $buf, 1)){
+	    print STDOUT $buf;
+	}
+    }elsif (-e @ARGV[0]){
+	$fname = shift(@ARGV);
+	open(FILE, $fname) || die "Can't open $fname: $!\n";
+
+	$_ = <FILE>;
+	if (! /^HTTP/) {
+	    print STDERR "Probably, this is not CERN httpd cache file.\n";
+	    exit 1;
+	}
+	while ($skiped == 0) {
+	    $_ = <FILE>;
+	    if (($_ eq "\n") || ($_ eq "\r\n")) {
+		$skiped = 1;
+	    }
+	}
+	while(read(FILE, $buf, 1)){
+	    print STDOUT $buf;
+	}
+    }else{
+	&pr_help();
+	exit 1;
+    }
+    exit 0;
+}else{
+    # $@%3%^%s%I%i%$%s0z?t$,#20J>e$N>l9g(J $@%(%i!<(J
+
+    &pr_help();
+    exit 1;
+}
+
+# not reached
+&pr_help();
+exit 1;
+
+#
+# end of script.
+#
diff -Naur xv-3.10a.old/xv-jp-extension/magic.add xv-3.10a/xv-jp-extension/magic.add
--- xv-3.10a.old/xv-jp-extension/magic.add	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv-jp-extension/magic.add	Tue Mar  5 16:59:01 1996
@@ -0,0 +1,43 @@
+# MAG
+0	string		MAKI02\040\040	MAG picture
+
+# MAKI
+0	string		MAKI01A\040	MAKI picture
+0	string		MAKI01B\040	MAKI picture
+
+# PIC
+0	string		PIC		PIC picture
+
+# Pi
+0	string		Pi		Pi picture
+
+# PIC2
+0	string		P2DT		PIC2 picture
+#>116	beshort		>0		- %hd x
+#>118	beshort		>0		%hd,
+#>112	beshort		>0		aspect %hd :
+#>114	beshort		>0		%hd,
+#>110	beshort		=0x03		8 colors
+#>110	beshort		=0x06		64 colors
+#>110	beshort		=0x09		512 colors
+#>110	beshort		=0x0c		4096 colors
+#>110	beshort		=0x0f		32768 colors
+#>110	beshort		=0x12		262144 colors
+#>110	beshort		=0x15		2097152 colors
+#>110	beshort		=0x18		16777216 colors
+
+# PhotoCD
+0	long		=0xffffffff	PhotoCD picture
+
+# Canon View Station Image
+0	string		VsStdImf	Cannon View Station Image(std) picture
+0	string		VsObjFormat	Cannon View Station Image(obj) picture
+
+# XLD4(Q4)
+11	string		MAJYO		XLD4(Q4) picture
+
+# ML1
+0	string		\001\000\000\032	ML1 picture
+
+# TIM
+0	string		\020\000\000\000	TIM picture
diff -Naur xv-3.10a.old/xv.c xv-3.10a/xv.c
--- xv-3.10a.old/xv.c	Fri Jan 20 03:08:43 1995
+++ xv-3.10a/xv.c	Tue Apr 24 09:37:06 2001
@@ -62,6 +62,19 @@
 
 static char   basefname[128];   /* just the current fname, no path */
 
+#ifdef TV_L10N
+#  ifndef TV_FONTSET
+#    define TV_FONTSET "-*-fixed-medium-r-normal--%d-*"
+#  endif
+#  ifndef TV_FONTSIZE
+#    define TV_FONTSIZE 14,16
+#  endif
+
+static int    mfontsize[] = { TV_FONTSIZE, 0 };
+static char   mfontset[256];
+#endif
+  
+
 /* things to do upon successfully loading an image */
 static int    autoraw    = 0;   /* force raw if using stdcmap */
 static int    autodither = 0;   /* dither */
@@ -78,6 +91,9 @@
 
 static int    force8     = 0;   /* force 8-bit mode */
 static int    force24    = 0;   /* force 24-bit mode */
+#ifdef HAVE_PCD
+static int    PcdSize    = -1;  /* force 24-bit mode */
+#endif /* HAVE_PCD */
 
 /* used in DeleteCmd() and Quit() */
 static char  **mainargv;
@@ -122,6 +138,10 @@
      *infogeom, *fgstr, *bgstr, *ctrlgeom, *gamgeom, *browgeom, *tmpstr;
 char *rootfgstr, *rootbgstr, *visualstr, *textgeom, *cmtgeom;
 char *monofontname, *flistName;
+#ifdef TV_L10N
+char **misscharset, *defstr;
+int nmisscharset;
+#endif
 int  curstype, stdinflag, browseMode, savenorm, preview, pscomp, preset, 
      rmodeset, gamset, cgamset, perfect, owncmap, rwcolor, stdcmap;
 int  nodecor;
@@ -137,6 +157,9 @@
 /*******************************************/
 {
   int    i;
+#ifdef TV_L10N
+  int    j;
+#endif
   XColor ecdef;
   Window rootReturn, parentReturn, *children;
   unsigned int numChildren, rootDEEP;
@@ -153,6 +176,12 @@
   /*** variable Initialization                       ***/
   /*****************************************************/
 
+#ifdef TV_L10N
+  setlocale(LC_ALL, localeList[LOCALE_EUCJ]);
+  xlocale = (int)XSupportsLocale();	/* assume that (Bool) is (int) */
+	/* if X doesn't support ja_JP.ujis text viewer l10n doesn't work. */
+#endif
+
   xv_getwd(initdir, sizeof(initdir));
   searchdir[0] = '\0';
   fullfname[0] = '\0';
@@ -277,6 +306,22 @@
   tiffW = (Window) NULL;  tiffUp = 0;
 #endif
 
+#ifdef HAVE_PIC2
+  pic2W = (Window) NULL;  pic2Up = 0;
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+  pcdW = (Window) NULL;  pcdUp = 0;
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+  mgcsfxW = (Window) NULL;  mgcsfxUp = 0;
+#endif /* HAVE_MGCSFX */
+
+#ifdef HAVE_PNG
+  pngW = (Window) NULL;  pngUp = 0;
+#endif
+
   imap = ctrlmap = gmap = browmap = cmtmap = 0;
 
   ch_offx = ch_offy = p_offx = p_offy = 0;
@@ -300,6 +345,10 @@
   /* handle user-specified resources and cmd-line arguments */
   parseResources(argc,argv);
   parseCmdLine(argc, argv);
+#ifdef AUTO_EXPAND
+  Vdinit();
+  vd_handler_setup();
+#endif
   verifyArgs();
 
 
@@ -309,7 +358,11 @@
   
   theScreen = DefaultScreen(theDisp);
   theCmap   = DefaultColormap(theDisp, theScreen);
-  rootW     = RootWindow(theDisp,theScreen);
+  if (spec_window) {
+	rootW = spec_window;
+  } else {
+  	rootW = RootWindow(theDisp,theScreen);
+  }
   theGC     = DefaultGC(theDisp,theScreen);
   theVisual = DefaultVisual(theDisp,theScreen);
   ncells    = DisplayCells(theDisp, theScreen);
@@ -326,37 +379,51 @@
    */
 
 
-
   /* if we *haven't* had a non-default visual specified,
      see if we have a TrueColor or DirectColor visual of 24 or 32 bits, 
      and if so, use that as the default visual (prefer TrueColor) */
 
   if (!visualstr && !useroot) {
+    VisualID     defvid;
     XVisualInfo *vinfo, rvinfo;
     int          best,  numvis;
     long         flags;
 
-    best = -1;
+    best          = -1;
     rvinfo.class  = TrueColor;
     rvinfo.screen = theScreen;
-    flags = VisualClassMask | VisualScreenMask;
+    flags         = VisualClassMask | VisualScreenMask;
+    defvid        = XVisualIDFromVisual(DefaultVisual(theDisp, 
+						      DefaultScreen(theDisp)));
     
     vinfo = XGetVisualInfo(theDisp, flags, &rvinfo, &numvis);
-    if (vinfo) {     /* look for a TrueColor, 24-bit or more (pref 24) */
-      for (i=0, best = -1; i<numvis; i++) {
+    if (vinfo) {
+      /* Check list, use 'default', first 24-bit, or first >24-bit */
+      for (i=0; i<numvis && best==-1; i++) {   /* default? */
+	if ((vinfo[i].visualid == defvid) && (vinfo[i].depth >= 24)) best=i;
+      }
+      for (i=0; i<numvis && best==-1; i++) {   /* 24-bit ? */
 	if (vinfo[i].depth == 24) best = i;
-	else if (vinfo[i].depth>24 && best<0) best = i;
+      }
+      for (i=0; i<numvis && best==-1; i++) {   /* >24-bit ? */
+	if (vinfo[i].depth >= 24) best = i;
       }
     }
-
+    
     if (best == -1) {   /* look for a DirectColor, 24-bit or more (pref 24) */
       rvinfo.class = DirectColor;
       if (vinfo) XFree((char *) vinfo);
+      
       vinfo = XGetVisualInfo(theDisp, flags, &rvinfo, &numvis);
       if (vinfo) {
-	for (i=0, best = -1; i<numvis; i++) {
+	for (i=0; i<numvis && best==-1; i++) {   /* default? */
+	  if ((vinfo[i].visualid == defvid) && (vinfo[i].depth >= 24)) best=i;
+	}
+	for (i=0; i<numvis && best==-1; i++) {   /* 24-bit ? */
 	  if (vinfo[i].depth == 24) best = i;
-	  else if (vinfo[i].depth>24 && best<0) best = i;
+	}
+	for (i=0; i<numvis && best==-1; i++) {   /* >24-bit ? */
+	  if (vinfo[i].depth >= 24) best = i;
 	}
       }
     }
@@ -364,8 +431,8 @@
     if (best>=0 && best<numvis) useOtherVisual(vinfo, best);
     if (vinfo) XFree((char *) vinfo);
   }
-
-
+  
+  
 			   
   if (visualstr && useroot) {
     fprintf(stderr, "%s: %sUsing default visual.\n",
@@ -649,7 +716,62 @@
   }
 
   monofont=monofinfo->fid;
-  
+
+#ifdef TV_L10N  
+  if (xlocale) {
+    i = 0;
+    while (mfontsize[i]) {
+      xlocale = 1;	/* True */
+
+      sprintf(mfontset, TV_FONTSET, mfontsize[i]);
+/*fprintf(stderr, "FontSet: %s\n", mfontset);*/
+
+      monofset = XCreateFontSet(theDisp, mfontset,
+				&misscharset, &nmisscharset, &defstr);
+#  if 0	/* not useful */
+      if (!monofset) {
+	/* the current locale is not supported */
+/*fprintf(stderr, "Current locale `%s' is not supported.\n", localeList[i]);*/
+	xlocale = 0;
+	break;
+      }
+#  endif
+/*fprintf(stderr, "# of misscharset in mfontsize[%d]: %d\n", i,nmisscharset);*/
+
+      for (j = 0; j < nmisscharset; j++) {
+	if (!strncmp(misscharset[j], "jisx0208", 8)) {
+	  /* font for JIS X 0208 is not found */
+	  xlocale = 0;
+	  break;
+	}
+      }
+
+      if (xlocale) {
+	monofsetinfo = XExtentsOfFontSet(monofset);
+	monofsetinfo->max_logical_extent.width = mfontsize[i];
+		/* correct size of TextViewer
+		   in case that JIS X 0208 is not found */
+	break;
+      }
+
+      i++;
+    } /* while (mfontsize[i]) */
+
+#  if 0
+    if (nmisscharset > 0) {
+      sprintf(str,"missing %d charset:\n", nmisscharset);
+      for (i = 0; i < nmisscharset; i++) {
+	sprintf(str, "%s\t%s\n", str, misscharset[i]);
+      }
+#    if 0
+      FatalError(str);
+#    else
+      fprintf(stderr, "%s", str);
+#    endif
+    }
+#  endif
+  }
+#endif	/* TV_L10N */
 
   
   
@@ -782,7 +904,26 @@
   XSetTransientForHint(theDisp, tiffW, dirW);
 #endif
   
-  
+#ifdef HAVE_PIC2
+  CreatePIC2W();
+  XSetTransientForHint(theDisp, pic2W, dirW);
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+  CreatePCDW();
+  XSetTransientForHint(theDisp, pcdW, dirW);
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+  CreateMGCSFXW();
+  XSetTransientForHint(theDisp, mgcsfxW, dirW);
+#endif /* HAVE_MGCSFX */
+
+#ifdef HAVE_PNG
+  CreatePNGW();
+  XSetTransientForHint(theDisp, pngW, dirW);
+#endif /* HAVE_PNG */
+
   LoadFishCursors();
   SetCursors(-1);
   
@@ -950,7 +1091,11 @@
   
   dispDEEP  = vinfo[best].depth;
   theScreen = vinfo[best].screen;
-  rootW     = RootWindow(theDisp, theScreen);
+  if (spec_window) {
+	rootW = spec_window;
+  } else {
+  	rootW = RootWindow(theDisp,theScreen);
+  }
   ncells    = vinfo[best].colormap_size;
   theCmap   = XCreateColormap(theDisp, rootW, theVisual, AllocNone);
   
@@ -1096,17 +1241,32 @@
   if (rd_flag("infoMap"))        imap        = def_int;
   if (rd_flag("loadBrowse"))     browseMode  = def_int;
   if (rd_str ("lowlight"))       lostr       = def_str;
+#ifdef MACBINARY
+  if (rd_flag("macbinary"))      handlemacb  = def_int;
+#endif
+#ifdef HAVE_MGCSFX
+  if (rd_flag("mgcsfx"))         mgcsfx      = def_int;
+#endif /* HAVE_MGCSFX */
   if (rd_flag("mono"))           mono        = def_int;
   if (rd_str ("monofont"))       monofontname = def_str;
   if (rd_int ("ncols"))          ncols       = def_int;
   if (rd_flag("ninstall"))       ninstall    = def_int;
   if (rd_flag("nodecor"))        nodecor     = def_int;
   if (rd_flag("nolimits"))       nolimits    = def_int;
+#ifdef HAVE_MGCSFX
+  if (rd_flag("nomgcsfx"))       nomgcsfx    = def_int;
+#endif /* HAVE_MGCSFX */
+#if defined(HAVE_PIC) || defined(HAVE_PIC2)
+  if (rd_flag("nopicadjust"))    nopicadjust = def_int;
+#endif /* HAVE_PIC || HAVE_PIC2 */
   if (rd_flag("nopos"))          nopos       = def_int;
   if (rd_flag("noqcheck"))       noqcheck    = def_int;
   if (rd_flag("nostat"))         nostat      = def_int;
   if (rd_flag("ownCmap"))        owncmap     = def_int;
   if (rd_flag("perfect"))        perfect     = def_int;
+#ifdef HAVE_PIC2
+  if (rd_flag("pic2split"))      pic2split   = def_int;
+#endif /* HAVE_PIC2 */
   if (rd_flag("popupKludge"))    winCtrPosKludge = def_int;
   if (rd_str ("print"))          strncpy(printCmd, def_str, 
 					 (size_t) PRINTCMDLEN);
@@ -1124,6 +1284,9 @@
   if (rd_str ("textviewGeometry")) textgeom  = def_str;
   if (rd_flag("useStdCmap"))     stdcmap     = def_int;
   if (rd_str ("visual"))         visualstr   = def_str;
+#ifdef VS_ADJUST
+  if (rd_flag("vsadjust"))       vsadjust    = def_int;
+#endif /* VS_ADJUST */
   if (rd_flag("vsDisable"))      novbrowse   = def_int;
   if (rd_str ("vsGeometry"))     browgeom    = def_str;
   if (rd_flag("vsMap"))          browmap     = def_int;
@@ -1158,7 +1321,13 @@
       }
 
       if (numnames<MAXNAMES) {
+#ifdef AUTO_EXPAND
+	if(Isarchive(argv[i]) == 0){ /* Not archive file */
+	  namelist[numnames++] = argv[i];
+	}
+#else
 	namelist[numnames++] = argv[i];
+#endif
 	if (numnames==MAXNAMES) {
 	  fprintf(stderr,"%s: too many filenames.  Only using first %d.\n",
 		  cmd, MAXNAMES);
@@ -1184,6 +1353,14 @@
       }
     }
 
+    else if (!argcmp(argv[i],"-windowid",3,0,&pm)) {
+      if (++i<argc) {
+	if (sscanf(argv[i], "%ld", &spec_window) != 1) {
+		fprintf(stderr,"%s: bad argument to -windowid '%s'\n",cmd,argv[i]);
+        }
+      }
+    }
+
     else if (!argcmp(argv[i],"-best24",3,0,&pm))          /* -best */
       conv24 = CONV24_BEST;
     
@@ -1339,10 +1516,18 @@
     if (!argcmp(argv[i],"-max",4,1,&automax));	        /* auto maximize */
     else if (!argcmp(argv[i],"-maxpect",5,1,&pm))       /* auto maximize */
       { automax=pm; fixedaspect=pm; }
+
+#ifdef MACBINARY
+    else if (!argcmp(argv[i],"-macbinary",3,1,&handlemacb)); /* macbinary */
+#endif
     
     else if (!argcmp(argv[i],"-mfn",3,0,&pm))           /* mono font name */
       { if (++i<argc) monofontname = argv[i]; }
 
+#ifdef HAVE_MGCSFX
+    else if (!argcmp(argv[i],"-mgcsfx", 4,1,&mgcsfx));  /* mgcsfx */
+#endif /* HAVE_MGCSFX */
+
     else if (!argcmp(argv[i],"-mono",3,1,&mono));	/* mono */
     
     else if (!argcmp(argv[i],"-name",3,0,&pm))          /* name */
@@ -1355,13 +1540,26 @@
     else if (!argcmp(argv[i],"-nodecor",   4,1,&nodecor));
     else if (!argcmp(argv[i],"-nofreecols",4,1,&noFreeCols));
     else if (!argcmp(argv[i],"-nolimits",  4,1,&nolimits));   /* nolimits */
+#ifdef HAVE_MGCSFX
+    else if (!argcmp(argv[i],"-nomgcsfx", 4,1,&nomgcsfx));    /* nomgcsfx */
+#endif /* HAVE_MGCSFX */
+#if defined(HAVE_PIC) || defined(HAVE_PIC2)
+    else if (!argcmp(argv[i],"-nopicadjust", 4,1,&nopicadjust));/*nopicadjust*/
+#endif /* HAVE_PIC || HAVE_PIC2 */
     else if (!argcmp(argv[i],"-nopos",     4,1,&nopos));      /* nopos */
     else if (!argcmp(argv[i],"-noqcheck",  4,1,&noqcheck));   /* noqcheck */
     else if (!argcmp(argv[i],"-noresetroot",5,1,&resetroot)); /* reset root*/
     else if (!argcmp(argv[i],"-norm",      5,1,&autonorm));   /* norm */
     else if (!argcmp(argv[i],"-nostat",    4,1,&nostat));     /* nostat */
     else if (!argcmp(argv[i],"-owncmap",   2,1,&owncmap));    /* own cmap */
+#ifdef HAVE_PCD
+    else if (!argcmp(argv[i],"-pcd",       3,0,&pm))    /* pcd with size */
+	{ if (++i<argc) PcdSize = atoi(argv[i]); }
+#endif /* HAVE_PCD */
     else if (!argcmp(argv[i],"-perfect",   3,1,&perfect));    /* -perfect */
+#ifdef HAVE_PIC2
+    else if (!argcmp(argv[i],"-pic2split", 3,1,&pic2split));  /* pic2split */
+#endif /* HAVE_PIC2 */
     else if (!argcmp(argv[i],"-pkludge",   3,1,&winCtrPosKludge));
     else if (!argcmp(argv[i],"-poll",      3,1,&polling));    /* chk mod? */
 
@@ -1415,6 +1613,10 @@
     else if (!argcmp(argv[i],"-visual",4,0,&pm))           /* visual */
       { if (++i<argc) visualstr = argv[i]; }
     
+#ifdef VS_ADJUST
+    else if (!argcmp(argv[i],"-vsadjust", 3,1,&vsadjust));  /* vsadjust */
+#endif /* VS_ADJUST */
+
     else if (!argcmp(argv[i],"-vsdisable",4,1,&novbrowse)); /* disable sch? */
     
     else if (!argcmp(argv[i],"-vsgeometry",4,0,&pm))	/* visSchnauzer geom */
@@ -1453,7 +1655,11 @@
   /* check options for validity */
 
   if (strlen(searchdir)) {  /* got a search directory */
+#ifdef AUTO_EXPAND
+    if (Chvdir(searchdir)) {
+#else
     if (chdir(searchdir)) {
+#endif
       fprintf(stderr,"xv: unable to cd to directory '%s'.\n",searchdir);
       fprintf(stderr,
        "    Ignoring '-dir' option and/or 'xv.searchDirectory' resource\n");
@@ -1600,9 +1806,15 @@
   printoption("[-/+lbrowse]");
   printoption("[-lo color]");
   printoption("[-/+loadclear]");
+#ifdef MACBINARY
+  printoption("[-/+macbinary]");
+#endif
   printoption("[-/+max]");
   printoption("[-/+maxpect]");
   printoption("[-mfn font]");
+#ifdef HAVE_MGCSFX
+  printoption("[-/+mgcsfx]");
+#endif /* HAVE_MGCSFX */
   printoption("[-/+mono]");
   printoption("[-name str]");
   printoption("[-ncols #]");
@@ -1610,13 +1822,25 @@
   printoption("[-/+nodecor]");
   printoption("[-/+nofreecols]");
   printoption("[-/+nolimits]");
+#ifdef HAVE_MGCSFX
+  printoption("[-/+nomgcsfx]");
+#endif /* HAVE_MGCSFX */
+#if defined(HAVE_PIC) || defined(HAVE_PIC2)
+  printoption("[-/+nopicadjust]");
+#endif /* HAVE_PIC || HAVE_PIC2 */
   printoption("[-/+nopos]");
   printoption("[-/+noqcheck]");
   printoption("[-/+noresetroot]");
   printoption("[-/+norm]");
   printoption("[-/+nostat]");
   printoption("[-/+owncmap]");
+#ifdef HAVE_PCD
+  printoption("[-pcd size]");
+#endif /* HAVE_PCD */
   printoption("[-/+perfect]");
+#ifdef HAVE_PIC2
+  printoption("[-/+pic2split]");
+#endif /* HAVE_PIC2 */
   printoption("[-/+pkludge]");
   printoption("[-/+poll]");
   printoption("[-preset #]");
@@ -1640,12 +1864,16 @@
   printoption("[-/+vflip]");
   printoption("[-/+viewonly]");
   printoption("[-visual type]");
+#ifdef VS_ADJUST
+  printoption("[-/+vsadjust]");
+#endif /* VS_ADJUST */
   printoption("[-/+vsdisable]");
   printoption("[-vsgeometry geom]");
   printoption("[-/+vsmap]");
   printoption("[-/+vsperfect]");
   printoption("[-wait seconds]");
   printoption("[-white color]");
+  printoption("[-windowid windowid]");
   printoption("[-/+wloop]");
   printoption("[filename ...]");
   fprintf(stderr,"\n\n");
@@ -1668,6 +1896,7 @@
   fprintf(stderr,"\t7: centered on a 'brick' background\n");
   fprintf(stderr,"\t8: symmetrical tiling\n");
   fprintf(stderr,"\t9: symmetrical mirrored tiling\n");
+  fprintf(stderr,"\t10: upper left corner\n");
   fprintf(stderr,"\n");
   Quit(1);
 }
@@ -1723,6 +1952,10 @@
   char *fullname,       /* full name of the original file */
         filename[512],  /* full name of file to load (could be /tmp/xxx)*/
         globnm[512];    /* globbed version of fullname of orig file */
+#ifdef MACBINARY
+  char origname[512];	/* file name of original file (NO processing) */
+  origname[0] = '\0';
+#endif
 
   xvbzero((char *) &pinfo, sizeof(PICINFO));
 
@@ -1855,8 +2088,22 @@
       frompipe = 1;
     }
   }
+#ifdef AUTO_EXPAND
+  else {
+    fullname = (char *) malloc(MAXPATHLEN+2);
+    strcpy(fullname, namelist[filenum]);
+    freename = 1;
+  }
+  tmp = (char *) rindex(fullname, '/');
+  if (tmp) {
+      *tmp = '\0';
+      Mkvdir(fullname);
+      *tmp = '/';
+  }
+  Dirtovd(fullname);
+#else
   else fullname = namelist[filenum];
-
+#endif
 
   strcpy(fullfname, fullname);
   tmp = BaseName(fullname);
@@ -1876,6 +2123,10 @@
 	     strcmp(basefname+strlen(basefname)-3,".gz")==0)
       basefname[strlen(basefname)-3]='\0';
 #endif /* GUNZIP */
+#ifdef BUNZIP2
+    if (strlen(basefname)>4 && strcmp(basefname+strlen(basefname)-4,".bz2")==0)
+      basefname[strlen(basefname)-4]='\0';
+#endif /* BUNZIP2 */
   }
 
 
@@ -1991,14 +2242,20 @@
   filetype = ReadFileType(filename);
 
 
-  if (filetype == RFT_COMPRESS) {   /* a compressed file.  uncompress it */
+#ifdef HAVE_MGCSFX
+  if (mgcsfx && filetype == RFT_UNKNOWN){ /* force use MgcSfx */
+    if(getInputCom() != 0) filetype = RFT_MGCSFX;
+  }
+#endif /* HAVE_MGCSFX */
+
+  if ((filetype == RFT_COMPRESS) || (filetype == RFT_BZIP2)) {   /* a compressed file.  uncompress it */
     char tmpname[128];
 
     if (
 #ifndef VMS
-	UncompressFile(filename, tmpname)
+	UncompressFile(filename, tmpname, filetype)
 #else
-	UncompressFile(basefname, tmpname)
+	UncompressFile(basefname, tmpname, filetype)
 #endif
 	) {
 
@@ -2014,6 +2271,51 @@
     WaitCursor();
   }
 
+#ifdef MACBINARY
+  if (handlemacb && macb_file == True) {
+    char tmpname[128];
+
+    if (RemoveMacbinary(filename, tmpname)) {
+      if (strcmp(fullname,filename)!=0) unlink(filename);
+      strcpy(origname, filename);
+      strcpy(filename, tmpname);
+    }
+    else filetype = RFT_ERROR;
+
+    WaitCursor();
+  }
+#endif
+
+#ifdef HAVE_MGCSFX_AUTO
+  if(filetype == RFT_MGCSFX){
+      char tmpname[128], tmp[256];
+      char *icom;
+
+      if((icom = mgcsfx_auto_input_com(filename)) != NULL){
+	sprintf(tmpname, "%s/xvmsautoXXXXXX", tmpdir);
+	mktemp(tmpname);
+	SetISTR(ISTR_INFO, "Converting to known format by MgcSfx auto...");
+	sprintf(tmp,"%s >%s", icom, tmpname);
+      }else goto ms_auto_no;
+
+#ifndef VMS
+      if (system(tmp)) {
+#else
+      if (!system(tmp)) {
+#endif
+        SetISTR(ISTR_INFO, "Unable to convert '%s' by MgcSfx auto.", BaseName(filename
+));
+        Warning();
+	filetype = RFT_ERROR;
+        goto ms_auto_no;
+      }
+
+      filetype = ReadFileType(tmpname);
+      if (strcmp(fullname,filename)!=0) unlink(filename);
+      strcpy(filename, tmpname);
+  }
+ms_auto_no:
+#endif /* HAVE_MGCSFX_AUTO */
 
   if (filetype == RFT_ERROR) {
     char  foostr[512];
@@ -2027,7 +2329,12 @@
 
   if (filetype == RFT_UNKNOWN) {
     /* view as a text/hex file */
-    TextView(filename);
+#ifdef MACBINARY
+    if (origname[0])
+      TextView(origname);
+    else
+#endif
+      TextView(filename);
     SetISTR(ISTR_INFO,"'%s' not in a recognized format.", basefname);
     /* Warning();  */
     goto SHOWN_AS_TEXT;
@@ -2540,6 +2847,9 @@
   FILE *fp;
   byte  magicno[30];    /* first 30 bytes of file */
   int   rv, n;
+#ifdef MACBINARY
+  int macbin_alrchk = False;
+#endif
 
   if (!fname) return RFT_ERROR;   /* shouldn't happen */
 
@@ -2553,12 +2863,29 @@
 
   rv = RFT_UNKNOWN;
 
+#ifdef MACBINARY
+  macb_file = False;
+  while (1) {
+#endif
+
+#ifdef HAVE_MGCSFX
+  if(is_mgcsfx(fname, magicno, 30) != 0) rv = RFT_MGCSFX;
+
+  else if (strncmp((char *) magicno,"GIF87a", (size_t) 6)==0 ||
+      strncmp((char *) magicno,"GIF89a", (size_t) 6)==0)        rv = RFT_GIF;
+#else
   if (strncmp((char *) magicno,"GIF87a", (size_t) 6)==0 ||
       strncmp((char *) magicno,"GIF89a", (size_t) 6)==0)        rv = RFT_GIF;
+#endif /* HAVE_MGCSFX */
 
   else if (strncmp((char *) magicno,"VIEW", (size_t) 4)==0 ||
 	   strncmp((char *) magicno,"WEIV", (size_t) 4)==0)     rv = RFT_PM;
 
+#ifdef HAVE_PIC2
+  else if (magicno[0]=='P' && magicno[1]=='2'
+	   &&magicno[2]=='D'&&magicno[3]=='T')		rv = RFT_PIC2;
+#endif /* HAVE_PIC2 */
+
   else if (magicno[0] == 'P' && magicno[1]>='1' && 
 	   magicno[1]<='6')                             rv = RFT_PBM;
 
@@ -2583,6 +2910,9 @@
 #ifdef GUNZIP
   else if (magicno[0]==0x1f && magicno[1]==0x8b)        rv = RFT_COMPRESS;
 #endif
+#ifdef BUNZIP2
+  else if (magicno[0]==0x42 && magicno[1]==0x5a)        rv = RFT_BZIP2;
+#endif
 
   else if (magicno[0]==0x0a && magicno[1] <= 5)         rv = RFT_PCX;
 
@@ -2611,6 +2941,11 @@
 	   (magicno[0]=='I' && magicno[1]=='I'))        rv = RFT_TIFF;
 #endif
 
+#ifdef HAVE_PNG
+  else if (magicno[0]==0x89 && magicno[1]=='P' &&
+           magicno[2]=='N'  && magicno[3]=='G')                  rv = RFT_PNG;
+#endif
+
 #ifdef HAVE_PDS
   else if (strncmp((char *) magicno,  "NJPL1I00", (size_t) 8)==0 ||
 	   strncmp((char *) magicno+2,"NJPL1I",   (size_t) 6)==0 ||
@@ -2623,8 +2958,52 @@
 #ifdef GS_PATH
   else if (strncmp((char *) magicno, "%!",     (size_t) 2)==0 ||
 	   strncmp((char *) magicno, "\004%!", (size_t) 3)==0)   rv = RFT_PS;
+  else if (strncmp((char *) magicno, "%PDF",   (size_t) 4)==0)   rv = RFT_PS;
 #endif
 
+#ifdef HAVE_MAG
+  else if (strncmp((char *) magicno,"MAKI02  ", (size_t) 8)==0)  rv = RFT_MAG;
+#endif /* HAVE_MAG */
+
+#ifdef HAVE_MAKI
+  else if (strncmp((char *) magicno,"MAKI01A ", (size_t) 8)==0 ||
+	   strncmp((char *) magicno,"MAKI01B ", (size_t) 8)==0)  rv = RFT_MAKI;
+#endif /* HAVE_MAKI */
+
+#ifdef HAVE_PIC
+  else if (magicno[0]=='P' && magicno[1]=='I'&&magicno[2]=='C') rv = RFT_PIC;
+#endif /* HAVE_PIC */
+
+#ifdef HAVE_PI
+  else if (magicno[0]=='P' && magicno[1]=='i') rv = RFT_PI;
+#endif /* HAVE_PI */
+
+#ifdef HAVE_PCD
+  else if (magicno[0]==0xff && magicno[1]==0xff &&
+           magicno[2]==0xff && magicno[3]==0xff) rv = RFT_PCD;
+#endif /* HAVE_PCD */
+
+#ifdef MACBINARY
+    /* Now, we became handled `MacBinary' files, but it way is VERY dirty... */
+    if (macbin_alrchk == True) {
+      macb_file = True;
+      break;
+    }
+
+    if (rv != RFT_UNKNOWN)
+      break;
+
+    /* Skip MACBSIZE and recheck */
+    macbin_alrchk = True;
+    fp = xv_fopen(fname, "r");
+    if (!fp) return RFT_ERROR;
+    fseek(fp, MACBSIZE, SEEK_SET);
+    n = fread(magicno, (size_t) 1, (size_t) 30, fp);  
+    fclose(fp);
+
+    if (n<30) return RFT_UNKNOWN;    /* files less than 30 bytes long... */
+  }
+#endif
   return rv;
 }
 
@@ -2639,7 +3018,8 @@
   /* if quick is set, we're being called to generate icons, or something
      like that.  We should load the image as quickly as possible.  Currently,
      this only affects the LoadPS routine, which, if quick is set, only
-     generates the page file for the first page of the document */
+     generates the page file for the first page of the document .
+	 Also now affects PCD which now only loads a thumbnail */
 
   int rv = 0;
 
@@ -2650,7 +3030,11 @@
   switch (ftype) {
   case RFT_GIF:     rv = LoadGIF   (fname, pinfo);         break;
   case RFT_PM:      rv = LoadPM    (fname, pinfo);         break;
+#ifdef HAVE_MGCSFX
+  case RFT_PBM:     rv = LoadPBM   (fname, pinfo, -1);     break;
+#else
   case RFT_PBM:     rv = LoadPBM   (fname, pinfo);         break;
+#endif /* HAVE_MGCSFX */
   case RFT_XBM:     rv = LoadXBM   (fname, pinfo);         break;
   case RFT_SUNRAS:  rv = LoadSunRas(fname, pinfo);         break;
   case RFT_BMP:     rv = LoadBMP   (fname, pinfo);         break;
@@ -2668,7 +3052,11 @@
 #endif
 
 #ifdef HAVE_TIFF
-  case RFT_TIFF:    rv = LoadTIFF  (fname, pinfo);           break;
+  case RFT_TIFF:    rv = LoadTIFF  (fname, pinfo, quick);    break;
+#endif
+
+#ifdef HAVE_PNG
+  case RFT_PNG:     rv = LoadPNG   (fname, pinfo);         break;
 #endif
 
 #ifdef HAVE_PDS
@@ -2679,14 +3067,52 @@
   case RFT_PS:      rv = LoadPS    (fname, pinfo, quick);    break;
 #endif
 
+#ifdef HAVE_MAG
+  case RFT_MAG:     rv = LoadMAG   (fname, pinfo);  break;
+#endif /* HAVE_MAG */
+
+#ifdef HAVE_MAKI
+  case RFT_MAKI:    rv = LoadMAKI  (fname, pinfo);  break;
+#endif /* HAVE_MAKI */
+
+#ifdef HAVE_PIC
+  case RFT_PIC:     rv = LoadPIC   (fname, pinfo);  break;
+#endif /* HAVE_PIC */
+
+#ifdef HAVE_PI
+  case RFT_PI:      rv = LoadPi    (fname, pinfo);  break;
+#endif /* HAVE_PI */
+
+#ifdef HAVE_PIC2
+  case RFT_PIC2:    rv = LoadPIC2  (fname, pinfo, quick);    break;
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+  case RFT_PCD:      
+    if (quick == 1)
+      rv = LoadPCD(fname, pinfo, 0);  
+    else
+      rv = LoadPCD(fname, pinfo, PcdSize);  
+    break;
+
+	/* If quick is switched on use the smallest image size don't ask
+	*	the user.
+	*/
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+  case RFT_MGCSFX:    rv = LoadMGCSFX  (fname, pinfo);    break;
+#endif /* HAVE_MGCSFX */
+
   }
   return rv;
 }
 
 
 /********************************/
-int UncompressFile(name, uncompname)
+int UncompressFile(name, uncompname, filetype)
      char *name, *uncompname;
+     int filetype;
 {
   /* returns '1' on success, with name of uncompressed file in uncompname
      returns '0' on failure */
@@ -2725,7 +3151,12 @@
 #ifndef VMS
   sprintf(uncompname, "%s/xvuXXXXXX", tmpdir);
   mktemp(uncompname);
-  sprintf(buf,"%s -c %s >%s", UNCOMPRESS, fname, uncompname);
+  if (filetype == RFT_COMPRESS)
+      sprintf(buf,"%s -c %s >%s", UNCOMPRESS, fname, uncompname);
+#ifdef BUNZIP2
+  if (filetype == RFT_BZIP2)
+      sprintf(buf,"%s -c %s >%s", BUNZIP2, fname, uncompname);
+#endif
 #else /* it IS VMS */
   strcpy(uncompname, "[]xvuXXXXXX");
   mktemp(uncompname);
@@ -2774,6 +3205,44 @@
 }
 
 
+#ifdef MACBINARY
+/********************************/
+int RemoveMacbinary(src, dst)
+     char *src, *dst;
+{
+  char tmpname[128], buffer[8192]; /* XXX */
+  int n, eof;
+  FILE *sfp, *dfp;
+
+  sprintf(dst, "%s/xvmXXXXXX", tmpdir);
+  mktemp(dst);
+  SetISTR(ISTR_INFO, "Removing MacBinary...");
+
+  sfp = xv_fopen(src, "r"); 
+  dfp = xv_fopen(dst, "w"); 
+  if (!sfp || !dfp) {
+    SetISTR(ISTR_INFO, "Unable to remove a InfoFile header form '%s'.", src);
+    Warning();
+    return 0;
+  }
+  fseek(sfp, MACBSIZE, SEEK_SET);
+  while ((n = fread(buffer, 1, sizeof(buffer), sfp)) == 8192) /* XXX */
+    fwrite(buffer, 1, n, dfp);
+  if (eof = feof(sfp))
+    fwrite(buffer, 1, n, dfp);
+  fclose(sfp);
+  fclose(dfp);
+  if (!eof) {
+    SetISTR(ISTR_INFO, "Unable to remove a InfoFile header form '%s'.", src);
+    Warning();
+    return 0;
+  }
+
+  return 1;
+}
+#endif
+
+
 /********************************/
 void KillPageFiles(bname, numpages)
   char *bname;
@@ -4043,16 +4512,30 @@
       unsigned long nitems, nleft;
       byte *data;
 
+      if (spec_window) {
+      i = XGetWindowProperty(theDisp, spec_window,
+			     resAtom, 0L, 1L, False, 
+			     XA_STRING, &actType, &actFormat, &nitems, &nleft, 
+			     (unsigned char **) &data);
+      } else {
       i = XGetWindowProperty(theDisp, RootWindow(theDisp, 0),
 			     resAtom, 0L, 1L, False, 
 			     XA_STRING, &actType, &actFormat, &nitems, &nleft, 
 			     (unsigned char **) &data);
+      }
       if (i==Success && actType==XA_STRING && actFormat==8) {
 	if (nitems>0 && data) XFree(data);
+        if (spec_window) {
+	i = XGetWindowProperty(theDisp, spec_window, resAtom, 0L, 
+			       (long) ((nleft+4+3)/4),
+			       False, XA_STRING, &actType, &actFormat, 
+			       &nitems, &nleft, (unsigned char **) &data);
+        } else {
 	i = XGetWindowProperty(theDisp, RootWindow(theDisp, 0), resAtom, 0L, 
 			       (long) ((nleft+4+3)/4),
 			       False, XA_STRING, &actType, &actFormat, 
 			       &nitems, &nleft, (unsigned char **) &data);
+        }
 	if (i==Success && actType==XA_STRING && actFormat==8 && data) {
 	  def_resource = XrmGetStringDatabase((char *) data);
 	  XFree(data);
diff -Naur xv-3.10a.old/xv.h xv-3.10a/xv.h
--- xv-3.10a.old/xv.h	Tue Jan 24 05:22:23 1995
+++ xv-3.10a/xv.h	Tue Apr 24 09:37:06 2001
@@ -8,8 +8,11 @@
 #include "config.h"
 
 
-#define REVDATE   "Version 3.10a  Rev: 12/29/94"
-#define VERSTR    "3.10a"
+#define REVDATE   "Version 3.10a+FLmask+jp5.3.3+PNG patch 1.2d+misc  Rev: 12/29/94"
+#define VERSTR    "3.10a+FLmask+jp+png-1.2d+misc"
+
+#define __NetBSD__
+#define NeXT
 
 /*
  * uncomment the following, and modify for your site, but only if you've
@@ -68,6 +69,20 @@
 #  endif
 #endif
 
+#if defined(__sony_news) && defined(bsd43) && !defined(__bsd43)
+#  define __bsd43
+#elif defined(__sony_news) && (defined(SYSTYPE_BSD) || defined(__SYSTYPE_BSD)) && !defined(bsd43) && !defined(__bsd43)
+#  define bsd43
+#  define __bsd43
+#endif
+
+#ifndef __osf__
+#undef SIGCHLD           /* defined in both Xos.h and signal.h */
+#endif /* !__osf__ */
+#include <signal.h>      /* for interrupt handling */
+#ifdef __linux__
+/*#  define sigmask __sigmask*/
+#endif
 
 #include <X11/Xos.h>     /* need type declarations immediately */
 
@@ -99,6 +114,16 @@
 #endif
 
 
+#if defined(__sony_news) && defined(__bsd43)
+#  include <unistd.h>
+#endif
+
+
+#if defined(__FreeBSD__)
+#  include <sys/param.h>
+#endif
+
+
 /* include files */
 #include <stdio.h>
 #include <math.h>
@@ -115,8 +140,8 @@
 #ifndef VMS
 #  include <errno.h>
    extern int   errno;             /* SHOULD be in errno.h, but often isn't */
-#  ifndef __NetBSD__
-     extern char *sys_errlist[];     /* this too... */
+#  if !(defined(BSD) && (BSD >= 199103))
+/*     extern char *sys_errlist[];     /* this too... */
 #  endif
 #endif
 
@@ -128,7 +153,9 @@
 #  define ERRSTR(x) strerror(x, vaxc$errno)
 #endif
 
-
+#ifdef __linux__
+  extern char *strdup PARM((const char *));
+#endif
 
 
 #ifdef VMS   /* VMS config, hacks & kludges */
@@ -157,6 +184,8 @@
      !defined(pyr)                       && \
      !defined(__UMAXV__)                 && \
      !defined(bsd43)                     && \
+     !defined(__bsd43)                   && \
+     !(defined(BSD) && (BSD >= 199103))  && \
      !defined(aux)                       && \
      !defined(__bsdi__)                  && \
      !defined(sequent)
@@ -179,9 +208,10 @@
 #include <X11/Xatom.h>
 #include <X11/Xmd.h>
 
+#ifdef TV_L10N
+#  include <X11/Xlocale.h>
+#endif
 
-#undef SIGCHLD           /* defined in both Xos.h and signal.h */
-#include <signal.h>      /* for interrupt handling */
 
 #include <sys/types.h>
 
@@ -314,6 +344,9 @@
 #  endif
 #endif
 
+#if (defined(SYSV) || defined(SVR4)) && !defined(USE_GETCWD)
+#  define USE_GETCWD
+#endif
 
 /*****************************/
 /* END OF CONFIGURATION INFO */
@@ -327,6 +360,10 @@
 #define HAVE_TIFF
 #endif
 
+#ifdef DOPNG
+#define HAVE_PNG
+#endif
+
 #ifdef DOPDS
 #define HAVE_PDS
 #endif
@@ -383,10 +420,11 @@
 #define BCROP    19
 #define BUNCROP  20
 #define BACROP   21
-#define BABOUT   22
-#define BQUIT    23
-#define BXV      24
-#define NBUTTS   25    /* # of butts */
+#define BMASKS   22
+#define BABOUT   23
+#define BQUIT    24
+#define BXV      25
+#define NBUTTS   26    /* # of butts */
 
 
 /* buttons in the load/save window */
@@ -458,24 +496,78 @@
 #define F_TIFINC  0
 #endif
 
+#ifdef HAVE_MAG
+#define F_MAGINC  1
+#else
+#define F_MAGINC  0
+#endif /* HAVE_MAG */
+
+#ifdef HAVE_PIC
+#define F_PICINC  1
+#else
+#define F_PICINC  0
+#endif /* HAVE_PIC */
+
+#ifdef HAVE_MAKI
+#define F_MAKINC  1
+#else
+#define F_MAKINC  0
+#endif /* HAVE_MAKI */
+
+#ifdef HAVE_PI
+#define F_PAIINC  1
+#else
+#define F_PAIINC  0
+#endif /* HAVE_PI */
+
+#ifdef HAVE_PIC2
+#define F_PC2INC  1
+#else
+#define F_PC2INC  0
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_MGCSFX
+#define F_MGCSFXINC  1
+#else
+#define F_MGCSFXINC  0
+#endif /* HAVE_MGCSFX */
+
+#ifdef MACBINARY
+#define MACBSIZE 128
+#endif
+
+#ifdef HAVE_PNG
+#define F_PNGINC  1
+#else
+#define F_PNGINC  0
+#endif
 
 #define F_GIF         0
 #define F_JPEG      ( 0 + F_JPGINC)
 #define F_TIFF      ( 0 + F_JPGINC + F_TIFINC)
-#define F_PS        ( 1 + F_JPGINC + F_TIFINC)
-#define F_PBMRAW    ( 2 + F_JPGINC + F_TIFINC)
-#define F_PBMASCII  ( 3 + F_JPGINC + F_TIFINC)
-#define F_XBM       ( 4 + F_JPGINC + F_TIFINC)
-#define F_XPM       ( 5 + F_JPGINC + F_TIFINC)
-#define F_BMP       ( 6 + F_JPGINC + F_TIFINC)
-#define F_SUNRAS    ( 7 + F_JPGINC + F_TIFINC)
-#define F_IRIS      ( 8 + F_JPGINC + F_TIFINC)
-#define F_TARGA     ( 9 + F_JPGINC + F_TIFINC)
-#define F_FITS      (10 + F_JPGINC + F_TIFINC)
-#define F_PM        (11 + F_JPGINC + F_TIFINC)
-#define F_DELIM1    (12 + F_JPGINC + F_TIFINC)     /* ----- */
-#define F_FILELIST  (13 + F_JPGINC + F_TIFINC)
-#define F_MAXFMTS   (14 + F_JPGINC + F_TIFINC)     /* 15, normally */
+#define F_PNG       ( 0 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_PS        ( 1 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_PBMRAW    ( 2 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_PBMASCII  ( 3 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_XBM       ( 4 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_XPM       ( 5 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_BMP       ( 6 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_SUNRAS    ( 7 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_IRIS      ( 8 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_TARGA     ( 9 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_FITS      (10 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define F_PM        (11 + F_JPGINC + F_TIFINC + F_PNGINC)
+#define JP_EXT_F    (F_PM)
+#define F_MAG       (JP_EXT_F + F_MAGINC)
+#define F_PIC       (JP_EXT_F + F_MAGINC + F_PICINC)
+#define F_MAKI      (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC)
+#define F_PI        (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC)
+#define F_PIC2      (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC + F_PC2INC)
+#define F_MGCSFX    (JP_EXT_F + F_MAGINC + F_PICINC + F_MAKINC + F_PAIINC + F_PC2INC + F_MGCSFXINC)         /* ----- */
+#define JP_EXT_F_END  (F_MGCSFX)
+#define F_DELIM1    (JP_EXT_F_END + 1)
+#define F_FILELIST  (JP_EXT_F_END + 2)
+#define F_MAXFMTS   (JP_EXT_F_END + 3)     /* 16, normally */
 
 
 
@@ -505,6 +597,16 @@
 #define RFT_XPM      17
 #define RFT_XWD      18
 #define RFT_FITS     19
+#define RFT_PNG      20
+#define JP_EXT_RFT   (RFT_PNG)
+#define RFT_MAG      (JP_EXT_RFT + 1)
+#define RFT_MAKI     (JP_EXT_RFT + 2)
+#define RFT_PIC      (JP_EXT_RFT + 3)
+#define RFT_PI       (JP_EXT_RFT + 4)
+#define RFT_PIC2     (JP_EXT_RFT + 5)
+#define RFT_PCD      (JP_EXT_RFT + 6)
+#define RFT_MGCSFX   (JP_EXT_RFT + 7)
+#define RFT_BZIP2    (JP_EXT_RFT + 8)
 
 /* definitions for page up/down, arrow up/down list control */
 #define LS_PAGEUP   0
@@ -563,7 +665,8 @@
 #define RM_CBRICK  7     /* centered on a 'brick' bg */
 #define RM_ECENTER 8     /* symmetrical tiled */
 #define RM_ECMIRR  9     /* symmetrical mirror tiled */
-#define RM_MAX     RM_ECMIRR
+#define RM_UPLEFT 10     /* just in upper left corner */
+#define RM_MAX     RM_UPLEFT
 
 
 /* values of colorMapMode */
@@ -613,7 +716,8 @@
 #define RMB_CBRICK   8
 #define RMB_ECENTER  9
 #define RMB_ECMIRR   10
-#define RMB_MAX      11
+#define RMB_UPLEFT   11
+#define RMB_MAX      12
 
 
 /* indicies into conv24MB */
@@ -632,21 +736,33 @@
 #define PIC24 CONV24_24BIT
 
 /* indicies into algMB */
+#define MSK_NONE      0
+#define MSK_SEP1      1  /* separator */
+#define MSK_FLMASK    2 
+#define MSK_Q0MASK    3 
+#define MSK_WIN	      4 
+#define MSK_MEKO      5 
+#define MSK_CPMASK    6 
+#define MSK_RGB	      7 
+#define MSK_BITREV    8 
+#define MSK_COLREV    9 
+#define MSK_MAX	      10
+                      
 #define ALG_NONE      0
-#define ALG_SEP1      1  /* separator */
-#define ALG_BLUR      2
-#define ALG_SHARPEN   3
-#define ALG_EDGE      4
-#define ALG_TINF      5
-#define ALG_OIL       6
-#define ALG_BLEND     7
-#define ALG_ROTATE    8
-#define ALG_ROTATECLR 9
+#define ALG_SEP1      1   /* separator */
+#define ALG_BLUR      2 
+#define ALG_SHARPEN   3 
+#define ALG_EDGE      4 
+#define ALG_TINF      5 
+#define ALG_OIL       6 
+#define ALG_BLEND     7 
+#define ALG_ROTATE    8 
+#define ALG_ROTATECLR 9 
 #define ALG_PIXEL     10
 #define ALG_SPREAD    11
 #define ALG_MEDIAN    12
-#define ALG_MAX       13
-
+#define ALG_Q0        13
+#define ALG_MAX       14
 
 /* indicies into sizeMB */
 #define SZMB_NORM     0
@@ -765,9 +881,10 @@
 typedef struct { Window win;            /* window ID */
 		 int x,y,w,h;           /* window coords in parent */
 		 int active;            /* true if can do anything*/
-		 int min,max;           /* min/max values 'pos' can take */
-		 int val;               /* 'value' of dial */
-		 int page;              /* amt val change on pageup/pagedown */
+		 double min,max;        /* min/max values 'pos' can take */
+		 double val;            /* 'value' of dial */
+		 double inc;            /* amt val change on up/down */
+		 double page;           /* amt val change on pageup/pagedown */
 		 char *title;           /* title for this guage */
 		 char *units;           /* string appended to value */
 		 u_long fg,bg,hi,lo;    /* colors */
@@ -935,13 +1052,17 @@
 WHERE unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;
 WHERE unsigned int  vrWIDE, vrHIGH, maxWIDE, maxHIGH;
 WHERE Colormap      theCmap, LocalCmap;
-WHERE Window        rootW, mainW, vrootW;
+WHERE Window        spec_window, rootW, mainW, vrootW;
 WHERE GC            theGC;
 WHERE u_long        black, white, fg, bg, infofg, infobg;
 WHERE u_long        hicol, locol;
 WHERE u_long        blkRGB, whtRGB;
 WHERE Font          mfont, monofont;
 WHERE XFontStruct   *mfinfo, *monofinfo;
+#ifdef TV_L10N
+WHERE XFontSet      monofset;
+WHERE XFontSetExtents *monofsetinfo;
+#endif
 WHERE Visual        *theVisual;
 WHERE Cursor        arrow, cross, tcross, zoom, inviso;
 WHERE Pixmap        iconPix, iconmask;
@@ -960,6 +1081,10 @@
 WHERE int            picType;               /* CONV24_8BIT,CONV24_24BIT,etc.*/
 WHERE char          *picComments;           /* text comments on current pic */
 
+#ifdef TV_L10N
+WHERE int            xlocale;		    /* true if Xlib supports locale */
+#endif
+
 WHERE int            numPages, curPage;     /* for multi-page files */
 WHERE char           pageBaseName[64];      /* basename for multi-page files */
 
@@ -993,6 +1118,23 @@
 WHERE unsigned long  cols[256];    /* maps pic pixel values to X pixel vals */
 WHERE int            fc2pcol[256]; /* maps freecols into pic pixel values */
 WHERE int            numcols;      /* # of desired colors in picture */
+#ifdef MACBINARY
+WHERE char           macb_file;    /* True if this file type is MacBinary */
+WHERE int            handlemacb;   /* True if we want to handle MacBinary */
+#endif /* MACBINARY */
+#if defined(HAVE_PIC) || defined(HAVE_PIC2)
+WHERE int            nopicadjust;  /* True if we don't want to adjust aspect */
+#endif /* HAVE_PIC || HAVE_PIC2 */
+#ifdef HAVE_PIC2
+WHERE int            pic2split;    /* True if we want to split multiblocks */
+#endif /* HAVE_PIC2 */
+#ifdef VS_ADJUST
+WHERE int            vsadjust; /* True if we want to adjust aspect of icons */
+#endif /* VS_ADJUST */
+#ifdef HAVE_MGCSFX
+WHERE int            mgcsfx;    /* True if we want to force use MgcSfx */
+WHERE int            nomgcsfx;  /* True if we don't want to use MgcSfx */
+#endif /* HAVE_MGCSFX */
 
 /* Std Cmap stuff */
 WHERE byte           stdr[256], stdg[256], stdb[256];  /* std 3/3/2 cmap */
@@ -1097,6 +1239,7 @@
 WHERE MBUTT         dispMB;              /* display mode menu button */
 WHERE MBUTT         conv24MB;            /* 24-to-8 conversion mode mbutt */
 WHERE MBUTT         algMB;               /* Algorithms mbutt */
+WHERE MBUTT         flmaskMB;            /* FLmask mbutt */
 WHERE MBUTT         rootMB;
 WHERE MBUTT         sizeMB;
 WHERE MBUTT         windowMB;
@@ -1153,6 +1296,84 @@
 WHERE int           tiffUp;       /* is tiffW mapped, or what? */
 #endif
 
+#ifdef HAVE_PIC2
+/* stuff used for 'pic2' box */
+WHERE Window        pic2W;
+WHERE int           pic2Up;      /* is pic2W mapped, or what? */
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+/* stuff used for 'pcd' box */
+WHERE Window        pcdW;
+WHERE int           pcdUp;       /* is pcdW mapped, or what? */
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+/* stuff used for 'mgcsfx' box */
+WHERE Window        mgcsfxW;
+WHERE Window        mgcsfxNameW;
+WHERE int           mgcsfxUp;      /* is mgcsfxW mapped, or what? */
+#endif /* HAVE_MGCSFX */
+
+#ifdef TV_L10N
+/* stuff used for TextViewer Japanization */
+#  define LOCALE_USASCII    0
+#  define LOCALE_EUCJ       1
+#  define LOCALE_JIS        2
+#  define LOCALE_MSCODE     3
+
+#  ifndef LOCALE_DEFAULT
+#    define LOCALE_DEFAULT  0
+#  endif /* !LOCALE_DEFAULT */
+
+#  ifndef MAIN
+     extern char *localeList[];
+#  else
+#    ifndef LOCALE_NAME_EUC
+#      ifndef X_LOCALE
+#        if defined(__FreeBSD__)
+	   char *localeList[] = {"", "ja_JP.EUC", "none", "none"};
+#        elif defined(__sun) || defined(sun)
+	   char *localeList[] = {"", "ja", "none", "none"};
+#        elif defined(__sgi)	/* sgi, __sgi, __sgi__ (gcc) */
+	   char *localeList[] = {"", "ja_JP.EUC", "none", "none"};
+#        elif defined(sony_news)
+	   char *localeList[] = {"", "ja_JP.EUC", "none", "ja_JP.SJIS"};
+#        elif defined(nec)
+	   char *localeList[] = {"", "japan", "none", "none"};
+#        elif defined(__hpux)
+	   char *localeList[] = {"", "japanese.euc", "none", "japanese"};
+#        elif defined(__osf__)
+	   char *localeList[] = {"", "ja_JP.deckanji", "none", "ja_JP.SJIS"};
+#        elif defined(_AIX)
+	   char *localeList[] = {"", "ja_JP", "none", "Ja_JP" };
+#        elif defined(__bsdi)
+	   char *localeList[] = {"", "Japanese-EUC", "none", "none" };
+#        else
+	   char *localeList[] = {"", "ja_JP.EUC", "ja_JP.JIS", "ja_JP.SJIS"};
+#        endif
+#      else
+#        if (XlibSpecificationRelease > 5)
+           char *localeList[] = {"", "ja_JP.eucJP", "ja_JP.JIS7",
+				 "ja_JP.SJIS"};
+#        else
+           char *localeList[] = {"", "ja_JP.ujis", "ja_JP.jis7",
+				 "ja_JP.mscode"};
+#        endif
+#      endif /* X_LOCALE */
+#    else
+       char *localeList[] = {"", LOCALE_NAME_EUC,
+			     LOCALE_NAME_JIS, LOCALE_NAME_MSCODE};
+#    endif /* LOCALE_NAME_EUC */
+#  endif /* MAIN */
+#endif /* TV_L10N */
+
+#ifdef HAVE_PNG
+/* stuff used for 'png' box */
+WHERE Window        pngW;
+WHERE int           pngUp;        /* is pngW mapped, or what? */
+#endif
+
 
 #undef WHERE
 
@@ -1163,8 +1384,11 @@
 /****************************** XV.C ****************************/
 int   ReadFileType      PARM((char *));
 int   ReadPicFile       PARM((char *, int, PICINFO *, int));
-int   UncompressFile    PARM((char *, char *));
+int   UncompressFile    PARM((char *, char *, int));
 void  KillPageFiles     PARM((char *, int));
+#ifdef MACBINARY
+int   RemoveMacbinary   PARM((char *, char *));
+#endif
 
 void NewPicGetColors    PARM((int, int));
 void FixAspect          PARM((int, int *, int *));
@@ -1248,6 +1472,7 @@
 void xv_getwd               PARM((char *, size_t));
 char *xv_strstr             PARM((char *, char *));
 FILE *xv_fopen              PARM((char *, char *));
+void xv_mktemp              PARM((char *, char *));
 void Timer                  PARM((int));
 
 /*************************** XVCOLOR.C ***************************/
@@ -1392,6 +1617,9 @@
 int  CheckPoll             PARM((int));
 void DIRDeletedFile        PARM((char *));
 void DIRCreatedFile        PARM((char *));
+FILE *pic2_OpenOutFile     PARM((char *, int *));
+void pic2_KillNullFile     PARM((FILE *));
+int  OpenOutFileDesc       PARM((char *));
 
 
 /*************************** XVBROWSE.C ************************/
@@ -1429,6 +1657,8 @@
 int  TextCheckEvent        PARM((XEvent *, int *, int *));
 int  TextDelWin            PARM((Window));
 
+int  CharsetCheckEvent     PARM((XEvent *));
+int  CharsetDelWin         PARM((Window));
 
 
 /**************************** XVGAM.C **************************/
@@ -1465,12 +1695,12 @@
 
 
 /*************************** XVDIAL.C ***************************/
-void DCreate               PARM((DIAL *, Window, int, int, int, int, int, 
-				 int, int, int, u_long, u_long, u_long, 
-				 u_long, char *, char *));
+void DCreate               PARM((DIAL *, Window, int, int, int, int, double,
+                                 double, double, double, double, u_long,
+                                 u_long, u_long, u_long, char *, char *));
 
-void DSetRange             PARM((DIAL *, int, int, int, int));
-void DSetVal               PARM((DIAL *, int));
+void DSetRange             PARM((DIAL *, double,double,double,double,double));
+void DSetVal               PARM((DIAL *, double));
 void DSetActive            PARM((DIAL *, int));
 void DRedraw               PARM((DIAL *));
 int  DTrack                PARM((DIAL *, int, int));
@@ -1548,7 +1778,11 @@
 				 byte *, byte *, int, int, char *));
 
 /**************************** XVPBM.C ***************************/
+#ifdef HAVE_MGCSFX
+int LoadPBM                PARM((char *, PICINFO *, int));
+#else
 int LoadPBM                PARM((char *, PICINFO *));
+#endif /* HAVE_MGCSFX */
 int WritePBM               PARM((FILE *, byte *, int, int, int, byte *, 
 				 byte *, byte *, int, int, int, char *));
 
@@ -1607,12 +1841,19 @@
 void JPEGSaveParams        PARM((char *, int));
 
 /**************************** XVTIFF.C ***************************/
-int   LoadTIFF             PARM((char *, PICINFO *));
+int   LoadTIFF             PARM((char *, PICINFO *, int));
 void  CreateTIFFW          PARM((void));
 void  TIFFDialog           PARM((int));
 int   TIFFCheckEvent       PARM((XEvent *));
 void  TIFFSaveParams       PARM((char *, int));
 
+/**************************** XVPNG.C ***************************/
+int  LoadPNG               PARM((char *, PICINFO *));
+void CreatePNGW            PARM((void));
+void PNGDialog             PARM((int));
+int  PNGCheckEvent         PARM((XEvent *));
+void PNGSaveParams         PARM((char *, int));
+
 /**************************** XVPDS.C ***************************/
 int LoadPDS                PARM((char *, PICINFO *));
 
@@ -1624,6 +1865,71 @@
 void  PSResize             PARM((void));
 int   LoadPS               PARM((char *, PICINFO *, int));
 
+/*************************** XVMAG.C ***************************/
+int   LoadMAG              PARM((char *, PICINFO *));
+int   WriteMAG             PARM((FILE *, byte *, int, int, int, 
+				 byte *, byte *, byte *, int, int, char *));
+
+/*************************** XVMAKI.C ***************************/
+int   LoadMAKI             PARM((char *, PICINFO *));
+int   WriteMAKI            PARM((FILE *, byte *, int, int, int, 
+				 byte *, byte *, byte *, int, int));
+
+/*************************** XVPIC.C ***************************/
+int   LoadPIC              PARM((char *, PICINFO *));
+int   WritePIC             PARM((FILE *, byte *, int, int, int, 
+				 byte *, byte *, byte *, int, int, char *));
+
+/*************************** XVPI.C ***************************/
+int   LoadPi               PARM((char *, PICINFO *));
+int   WritePi              PARM((FILE *, byte *, int, int, int, 
+				 byte *, byte *, byte *, int, int, char *));
+
+/*************************** XVPIC2.C ***************************/
+int   LoadPIC2             PARM((char *, PICINFO *, int));
+void  CreatePIC2W          PARM((void));
+void  PIC2Dialog           PARM((int));
+int   PIC2CheckEvent       PARM((XEvent *));
+int   PIC2SetParamOptions  PARM((char *));
+
+/**************************** XVPCD.C ***************************/
+int   LoadPCD              PARM((char *, PICINFO *,int));
+void  CreatePCDW           PARM((void));
+void  PCDDialog            PARM((int));
+int   PCDCheckEvent        PARM((XEvent *));
+void  PCDSetParamOptions   PARM((char *));
+
+/*************************** XVMGCSFX.C ***************************/
+int   is_mgcsfx             PARM((char *, unsigned char *, int));
+char *mgcsfx_auto_input_com PARM((char *));
+int   LoadMGCSFX            PARM((char *, PICINFO *));
+void  CreateMGCSFXW         PARM((void));
+void  MGCSFXDialog          PARM((int));
+int   MGCSFXCheckEvent      PARM((XEvent *));
+int   MGCSFXSaveParams      PARM((char *, int));
+
+int getInputCom             PARM((void));
+int getOutputCom            PARM((void));
+
+/**************************** XVVD.C ****************************/
+void  Vdinit               PARM((void));
+void  Vdsettle             PARM((void));
+int   Chvdir               PARM((char *));
+void  Dirtovd              PARM((char *));
+void  Vdtodir              PARM((char *));
+void  Dirtosubst           PARM((char *));
+int   Mkvdir               PARM((char *));
+void  Mkvdir_force         PARM((char *));
+int   Rmvdir               PARM((char *));
+int   Movevdir             PARM((char *, char *));
+int   Isarchive            PARM((char *));
+int   Isvdir               PARM((char *));
+void  vd_HUPhandler        PARM((void));
+void  vd_handler           PARM((int));
+int   vd_Xhandler          PARM((Display *, XErrorEvent *));
+int   vd_XIOhandler        PARM((Display *));
+void  vd_handler_setup     PARM((void));
+
 /*************************** XVPOPUP.C ***************************/
 void  CenterMapWindow      PARM((Window, int, int, int, int));
 int   PopUp                PARM((char *, char **, int));
@@ -1677,3 +1983,13 @@
 void CoordP2E              PARM((int, int, int *, int *));
 void CoordE2P              PARM((int, int, int *, int *));
 
+#if defined(__mips) && defined(__SYSTYPE_BSD43)
+# define strstr(A,B) pds_strstr((A),(B))
+# undef S_IFIFO
+#endif /* !mips_bsd */
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+#endif
diff -Naur xv-3.10a.old/xv_mgcsfx.sample xv-3.10a/xv_mgcsfx.sample
--- xv-3.10a.old/xv_mgcsfx.sample	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xv_mgcsfx.sample	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,125 @@
+#/*
+# Configuration file for XV with recognition of 'Magic and Suffix'
+#
+#
+# $Id: xv_mgcsfx.sample,v 1.11 95/10/03 17:00:05 tin329 Exp Locker: tin329 $
+#
+# Author: Tetsuya INOUE  <tin329@chino.it.okayama-u.ac.jp>
+#
+#
+# MgcSfx definition should write in one line.
+#  Format:
+#      <desc>:<ms type>:<ofs>:<magic>:<suffix>:<in it>:<in c>:<out it>:<out c>
+#  If you decide to not use preprocessor, comment style is allowed.
+#      # <comment>
+#
+#   <desc>            Description of your recognized image format.
+#   <ms type>         Type ID for recognition. (You should use 'magic'.)
+#                        * magic        Data of string style.
+#                                        `\' escape for special characters:
+#                                           \b \f \n \r \t \v \\ \' \" \a \?
+#                                           \0  ...\377   octal value
+#                                           \x0 ...\xff   hexadecimal value
+#                        * suffix       Suffix of file name.
+#                                         This type check <suffix> instead
+#                                         of <magic>.
+#                        * [b|l]eint16  2 byte integer of [big|little] endian.
+#                        * [b|l]eint32  4 byte integer of [big|little] endian.
+#   <ofs>             Offset of magic number in the target image file.
+#   <magic>           Data(magic number) of <ms type> to match at <ofs>.
+#   <suffix>          Suffix of filename with '.'start.
+#
+#   <in it>           Input image format type (output from <in c>).
+#                        * PNM       (PPM, PGM, PBM)
+#                        * AUTO      Recognized by xv management, and load.
+#                                    This is different from others, because
+#                                    this write file to temporary.
+#   <out it>          Output image format type (input to <out c>).
+#                        * PNM_RAW   (PPM_RAW, PGM_RAW, PBM_RAW)
+#                        * PNM_ASCII (PPM_ASCII, PGM_ASCII, PBM_ASCII)
+#
+#   <in c>            Command to get the input image.
+#                        * Command mast read stdin or file(specified by
+#                          argument), and write to stdout.
+#                        * Use %s to represent the file name. Without %s,
+#                          get file on stdin.
+#   <out c>           Command to put the output image.
+#                        * Command mast read stdin and write to stdout.
+#
+#   <comment>         Any message.
+#*/
+
+#/*############################################################################
+#
+# definition of the rule with Magic and Suffix
+#
+#*/
+
+# /* Canon View Station Image Format */
+ViewStation(std):magic:0:VsStdImf V0.2:.vs:PNM:VStopnm %s:PNM_RAW:pnmtoVS
+ViewStation(obj):magic:0:VsObjFormat V1.0:.vs:PNM:VSobjtopnm -:PNM_RAW:pnmtoVSobj
+
+# /* CERN httpd cache */
+# /* unchc skip header of CERN httpd cache file, and write data to stdout. */
+CERN httpd cache:magic:0:HTTP/1.0::AUTO:unchc %s::
+
+# /* XLD4(Q4) image format */
+XLD(Q4):magic:11:MAJYO:.q4:PNM:q4toppm::
+
+# /* ML1 image format */
+ML1:magic:0:\1\0\0\x1a:.ml1:PNM:ml1toppm %s::
+
+# /* Pict image format, 256 color only */
+PICT:suffix:::.pict:PNM:picttoppm:PNM_RAW:ppmquant 256 | ppmtopict 
+PICT(gzip):suffix:::.pict.gz:PNM:gzip -dc | picttoppm:PNM_RAW:ppmquant 256 | ppmtopict | gzip
+PICT(compress):suffix:::.pict.Z:PNM:compress -dc | picttoppm:PNM_RAW:ppmquant 256 | ppmtopict | compress
+
+# /* Tim image format(used by SONY PlayStation) */
+TIM:magic:0:\x10\x00\x00\x00:.tim:PNM:timtoppm::
+
+# /* Cam image format(used by CASIO QV-10) */
+# /* CAM:magic:0:\x07\x20\x4d\x4d:.cam:AUTO:camtoppm -j:PNM_RAW */
+CAM:magic:0:\x07\x20\x4d\x4d:.cam:PNM:camtoppm::
+
+# /* Portable Network Graphics (PNG) format : magic is "0x89 PNG" */
+PNG:magic:0:\x89\x50\x4e\x47:.png:PNM:pngtopnm %s:PNM_RAW:pnmtopng
+# /* PNG(interlace):magic:0:\x89\x50\x4e\x47:.png:PNM:pngtopnm %s:PNM_RAW:pnmtopng -interlace */
+
+# /* DB-Z, SAURUS Freehand Memo, PV-F1 Action Board, Wiz Quick Memo format */
+# /* Use xbm2free-1.10 or later. Old version is NOT a filter. */
+# /* To show version of xbm2free, type "xbm2free" (with no argument). */
+ZAURUS:magic:19:IMG1:.zau:PBM_ASCII:free2pbm:PBM:pbmtoxbm|xbm2free -s -
+DBZ:magic:19:IMG1:.dbz:::PBM:pbmtoxbm|xbm2free -d -
+PVF1:magic:12:IMG1:.pvf1:PBM_ASCII:free2pbm:PBM:pbmtoxbm|xbm2free -v -
+# /* WIZ:magic:19:IMG1:.wiz:::PBM:pbmtoxbm|xbm2free -w - */
+
+
+
+# /* Compress:magic:0:\037\235:.Z:AUTO:uncompress %s:: */
+# /* Gzip:magic:0:\037\213:.gz:AUTO:gunzip %s:: */
+# /* Gzip(old):magic:0:\037\236:.z:AUTO:gunzip %s:: */
+
+# /* MAKI:magic:0:MAKI01A\040:.mki:::: */
+# /* MAKI:magic:0:MAKI01B\040:.mki:::: */
+# /* MAG:magic:0:MAKI02\040\040:.mag:::: */
+# /* Pi:magic:0:Pi:.pi:::: */
+# /* PIC:magic:0:PIC:.pic:::: */
+# /* PIC2:magic:0:P2DT:.p2:::: */
+# /* PhotoCD:magic:0:\xff\xff\xff\xff:.pcd:::: */
+
+# /* PBM(ascii):magic:0:P1:.pbm:::: */
+# /* PGM(ascii):magic:0:P2:.pgm:::: */
+# /* PPM(ascii):magic:0:P3:.ppm:::: */
+# /* PBM(raw):magic:0:P4:.pbm:::: */
+# /* PGM(raw):magic:0:P5:.pgm:::: */
+# /* PPM(raw):magic:0:P6:.ppm:::: */
+
+# /* Sun raster:magic:0:\131\246\152\225:.sun:::: */
+# /* JFIF(JPEG):magic:0:\xff\xd8\xff:.jpg:::: */
+# /* TIFF big-endian:magic:0:\115\115:.tif:::: */
+# /* TIFF little-endian:magic:0:\111\111:.tif:::: */
+# /* GIF(87):magic:0:GIF87a:.gif:::: */
+# /* GIF(89):magic:0:GIF89a:.gif:::: */
+# /* SGI(1):magic:0:\x01\xda:.rgb:::: */
+# /* SGI(2):magic:0:\xda\x01:.rgb:::: */
+# /* XWD:magic:0:\0\0\0\7: :::: */
diff -Naur xv-3.10a.old/xvalg.c xv-3.10a/xvalg.c
--- xv-3.10a.old/xvalg.c	Fri Dec 23 07:34:47 1994
+++ xv-3.10a/xvalg.c	Tue Apr 24 09:37:06 2001
@@ -26,7 +26,9 @@
 static void Pixelize       PARM((void));
 static void Spread         PARM((void));
 static void MedianFilter   PARM((void));
-static void saveOrigPic    PARM((void));
+static void Q0Mask         PARM((void));
+
+void saveOrigPic    PARM((void));
 
 static void doBlurConvolv  PARM((byte *,int,int,byte *, int,int,int,int, int));
 static void doSharpConvolv PARM((byte *,int,int,byte *, int,int,int,int, int));
@@ -41,7 +43,7 @@
 static void doSpread       PARM((byte *,int,int,byte *, int,int,int,int, 
 				 int, int));
 static void doMedianFilter PARM((byte *,int,int,byte *, int,int,int,int, int));
-
+static void doQ0Mask       PARM((byte *,int,int,byte *, int,int,int,int, int));
 static void add2bb         PARM((int *, int *, int *, int *, int, int));
 static void rotXfer        PARM((int, int, double *,double *,
 				 double,double, double));
@@ -50,13 +52,12 @@
 static void intsort        PARM((int *, int));
 #endif
 
-static int  start24bitAlg  PARM((byte **, byte **));
-static void end24bitAlg    PARM((byte *, byte *));
+int  start24bitAlg  PARM((byte **, byte **));
+void end24bitAlg    PARM((byte *, byte *));
+void printUTime     PARM((char *));
 
-static void printUTime     PARM((char *));
-
-static byte *origPic = (byte *) NULL;
-static int  origPicType;
+byte *origPic = (byte *) NULL;
+int  origPicType;
 static byte origrmap[256], origgmap[256], origbmap[256];
 
 
@@ -69,7 +70,7 @@
 
 
 /***************************/
-static void printUTime(str)
+void printUTime(str)
      char *str;
 {
 #ifdef TIMING_TEST
@@ -82,10 +83,6 @@
 }
 
 
-
-
-
-
 /************************************************************/
 void AlgInit()
 {
@@ -96,6 +93,7 @@
   origPic = (byte *) NULL;
 
   algMB.dim[ALG_NONE] = 1;    /* can't undo when init'ed already */
+  flmaskMB.dim[MSK_NONE]=1;
 }
 
 
@@ -107,21 +105,23 @@
      algorithm */
 
   switch (anum) {
-  case ALG_NONE:      NoAlg();        break;
-  case ALG_BLUR:      Blur();         break;
-  case ALG_SHARPEN:   Sharpen();      break;
-  case ALG_EDGE:      EdgeDetect();   break;
-  case ALG_TINF:      TinFoil();      break;
-  case ALG_OIL:       OilPaint();     break;
-  case ALG_BLEND:     Blend();        break;
-  case ALG_ROTATE:    FineRotate(0);  break;
-  case ALG_ROTATECLR: FineRotate(1);  break;
-  case ALG_PIXEL:     Pixelize();     break;
-  case ALG_SPREAD:    Spread();       break;
-  case ALG_MEDIAN:    MedianFilter(); break;
+  case ALG_NONE:      NoAlg();        	break;
+  case ALG_BLUR:      Blur();         	break;
+  case ALG_SHARPEN:   Sharpen();      	break;
+  case ALG_EDGE:      EdgeDetect();   	break;
+  case ALG_TINF:      TinFoil();      	break;
+  case ALG_OIL:       OilPaint();     	break;
+  case ALG_BLEND:     Blend();        	break;
+  case ALG_ROTATE:    FineRotate(0);  	break;
+  case ALG_ROTATECLR: FineRotate(1);  	break;
+  case ALG_PIXEL:     Pixelize();     	break;
+  case ALG_SPREAD:    Spread();       	break;
+  case ALG_MEDIAN:    MedianFilter(); 	break;
+  case ALG_Q0:        Q0Mask();      	break;
   }
 
   algMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
+  flmaskMB.dim[MSK_NONE] = (origPic == (byte *) NULL);
 }
 
 
@@ -555,6 +555,50 @@
 
 
 /************************/
+static void Q0Mask()
+{
+  /* runs Q0 Mask algorithm (for each 8*8 rect block, rotate
+     replace with negative value */
+
+  byte        *pic24, *tmpPic;
+  int          i, sx,sy,sw,sh, n;
+  static char *labels[] = { "\nOk", "\033Cancel" };
+  char         txt[256];
+  static char  buf[64] = { '8', '\0' };
+  
+  sprintf(txt, "Q0 Mask:                          \n\n%s",
+	  "Enter mask size (8 or 16)");
+
+  i = GetStrPopUp(txt, labels, 2, buf, 64, "0123456789", 1);
+  if (i==1 || strlen(buf)==0) return;
+  n = atoi(buf);
+
+  if (n != 8 && n!=16) {
+    ErrPopUp("Error:  The value entered must be 8 or 16.", 
+	     "\nOh!");
+    return;
+  }
+
+  WaitCursor();
+
+  if (HaveSelection()) GetSelRCoords(&sx,&sy,&sw,&sh);
+  else { sx = 0;  sy = 0;  sw = pWIDE;  sh = pHIGH; }
+  CropRect2Rect(&sx,&sy,&sw,&sh, 0,0,pWIDE,pHIGH);
+
+  SetISTR(ISTR_INFO, "Q0 Masking %s with %dx%d mask...",
+	  (HaveSelection() ? "selection" : "image"), n,n);
+
+  if (start24bitAlg(&pic24, &tmpPic)) return;
+  xvbcopy((char *) pic24, (char *) tmpPic, (size_t) (pWIDE*pHIGH*3));
+    
+  doQ0Mask(pic24, pWIDE,pHIGH, tmpPic, sx,sy,sw,sh, n);
+
+  end24bitAlg(pic24, tmpPic);
+}
+
+
+
+/************************/
 static void doBlurConvolv(pic24, w, h, results, selx,sely,selw,selh, n)
      byte *pic24, *results;
      int   w,h, selx,sely,selw,selh, n;
@@ -1544,6 +1588,53 @@
 }
 
 
+
+/************************/
+static void doQ0Mask(pic24, w, h, results, selx,sely,selw,selh, n)
+     byte *pic24, *results;
+     int   w,h, selx,sely,selw,selh, n;
+{
+  /* runs the Q0 masking algorithm
+     Operates on rectangular region 'selx,sely,selw,selh' (in pic coords)
+     Region is guaranteed to be completely within pic boundaries
+     'n' must be 8 or 16 */
+
+  register byte *p24;
+  byte          *rp;
+  int            x,y,bx,by,bx1,by1,bx2,by2;
+
+  printUTime("start of doQ0Mask");
+
+  bx1 = selx/n;
+  by1 = sely/n;
+  bx2 = (selx + selw - 1)/n;
+  by2 = (sely + selh - 1)/n;
+  if (w < (bx2 * n + n))
+    bx2--;
+  if (h < (by2 * n + n))
+    by2--;
+
+  for (by=by1; by<=by2; by++) {
+    ProgressMeter(by1, by2, by, "Q0Mask");
+    WaitCursor();
+
+    for (bx=bx1; bx<=bx2; bx++) {
+      for (y=0; y < n; y++) {
+	p24 = pic24   + (by*n+y)*w*3 + bx*n*3;
+	rp  = results + (by*n+n-y-1)*w*3 + (bx*n+n-1)*3;
+	for (x = 0; x < n; x++) {
+	  *rp++ = ~(*p24++);
+	  *rp++ = ~(*p24++);
+	  *rp++ = ~(*p24++);
+	  rp -= 2 * 3;
+	}
+      }
+    }
+  }
+  printUTime("end of doQ0Mask");
+}
+
+
 #ifdef FOO
 /***********************************************/
 static void intsort(a, n)
@@ -1567,7 +1658,7 @@
 
 
 /***********************************************/
-static int start24bitAlg(pic24, tmpPic)
+int start24bitAlg(pic24, tmpPic)
      byte **pic24, **tmpPic;
 {
   /* generates a 24-bit version of 'pic', if neccessary, and also mallocs
@@ -1600,7 +1691,7 @@
 
 
 /***********************************************/
-static void end24bitAlg(pic24, outPic)
+void end24bitAlg(pic24, outPic)
      byte *pic24, *outPic;
 {
   /* given pic24, and outPic, which has the new 24-bit image, installs it */
@@ -1629,7 +1720,7 @@
 
 
 /************************/
-static void saveOrigPic()
+void saveOrigPic()
 {
   /* saves original picture into origPic, if it hasn't already been done.
      This allows us to undo algorithms...  
@@ -1669,6 +1760,4 @@
     pic = NULL;
   }
 }
-
-
 
diff -Naur xv-3.10a.old/xvbmp.c xv-3.10a/xvbmp.c
--- xv-3.10a.old/xvbmp.c	Fri Dec 23 07:34:42 1994
+++ xv-3.10a/xvbmp.c	Tue Apr 24 09:37:05 2001
@@ -32,7 +32,7 @@
 static int   loadBMP1   PARM((FILE *, byte *, u_int, u_int));
 static int   loadBMP4   PARM((FILE *, byte *, u_int, u_int, u_int));
 static int   loadBMP8   PARM((FILE *, byte *, u_int, u_int, u_int));
-static int   loadBMP24  PARM((FILE *, byte *, u_int, u_int));
+static int   loadBMP24  PARM((FILE *, byte *, u_int, u_int, u_int));
 static u_int getshort   PARM((FILE *));
 static u_int getint     PARM((FILE *));
 static void  putshort   PARM((FILE *, int));
@@ -127,7 +127,8 @@
 
 
   /* error checking */
-  if ((biBitCount!=1 && biBitCount!=4 && biBitCount!=8 && biBitCount!=24) || 
+  if ((biBitCount!=1 && biBitCount!=4 && biBitCount!=8 && 
+       biBitCount!=24 && biBitCount!=32) || 
       biPlanes!=1 || biCompression>BI_RLE4) {
 
     sprintf(buf,"Bogus BMP File!  (bitCount=%d, Planes=%d, Compression=%d)",
@@ -137,7 +138,8 @@
     goto ERROR;
   }
 
-  if (((biBitCount==1 || biBitCount==24) && biCompression != BI_RGB) ||
+  if (((biBitCount==1 || biBitCount==24 || biBitCount==32)
+       && biCompression != BI_RGB) ||
       (biBitCount==4 && biCompression==BI_RLE8) ||
       (biBitCount==8 && biCompression==BI_RLE4)) {
 
@@ -159,7 +161,7 @@
   }
 
   /* load up colormap, if any */
-  if (biBitCount!=24) {
+  if (biBitCount!=24 && biBitCount!=32) {
     int i, cmaplen;
 
     cmaplen = (biClrUsed) ? biClrUsed : 1 << biBitCount;
@@ -197,7 +199,7 @@
 
   /* create pic8 or pic24 */
 
-  if (biBitCount==24) {
+  if (biBitCount==24 || biBitCount==32) {
     pic24 = (byte *) calloc((size_t) biWidth * biHeight * 3, (size_t) 1);
     if (!pic24) return (bmpError(bname, "couldn't malloc 'pic24'"));
   }
@@ -212,16 +214,18 @@
   if      (biBitCount == 1) rv = loadBMP1(fp,pic8,biWidth,biHeight);
   else if (biBitCount == 4) rv = loadBMP4(fp,pic8,biWidth,biHeight,
 					  biCompression);
-  else if (biBitCount == 8) rv = loadBMP8(fp,pic8,biWidth,biHeight,
+  else if (biBitCount == 8) rv = loadBMP8(fp,pic8,biWidth,biHeight, 
 					  biCompression);
-  else                      rv = loadBMP24(fp,pic24,biWidth,biHeight);
+  else                      rv = loadBMP24(fp,pic24,biWidth,biHeight,
+					   biBitCount);
+
 
   if (rv) bmpError(bname, "File appears truncated.  Winging it.\n");
 
   fclose(fp);
 
 
-  if (biBitCount == 24) {
+  if (biBitCount == 24 || biBitCount == 32) {
     pinfo->pic  = pic24;
     pinfo->type = PIC24;
   }
@@ -384,10 +388,12 @@
      u_int  w,h,comp;
 {
   int   i,j,c,c1,padw,x,y,rv;
-  byte *pp;
+  byte *pp, *pend;
   
   rv = 0;
 
+  pend = pic8 + w * h;
+
   if (comp == BI_RGB) {   /* read uncompressed data */
     padw = ((w + 3)/4) * 4; /* 'w' padded to a multiple of 4pix (32 bits) */
 
@@ -407,12 +413,12 @@
     x = y = 0;  
     pp = pic8 + x + (h-y-1)*w;
 
-    while (y<h) {
+    while (y<h && pp<=pend) {
       c = getc(fp);  if (c == EOF) { rv = 1;  break; }
 
       if (c) {                                   /* encoded mode */
 	c1 = getc(fp);
-	for (i=0; i<c; i++,x++,pp++) *pp = c1;
+	for (i=0; i<c && pp<=pend; i++,x++,pp++) *pp = c1;
       }
 
       else {    /* c==0x00  :  escape codes */
@@ -431,7 +437,7 @@
 	}
 
 	else {                                   /* absolute mode */
-	  for (i=0; i<c; i++, x++, pp++) {
+	  for (i=0; i<c && pp<=pend; i++, x++, pp++) {
 	    c1 = getc(fp);
 	    *pp = c1;
 	  }
@@ -454,10 +460,10 @@
 
 
 /*******************************************/
-static int loadBMP24(fp, pic24, w, h)
+static int loadBMP24(fp, pic24, w, h, bits)
      FILE *fp;
      byte *pic24;
-     u_int  w,h;
+     u_int  w,h, bits;
 {
   int   i,j,padb,rv;
   byte *pp;
@@ -465,6 +471,7 @@
   rv = 0;
 
   padb = (4 - ((w*3) % 4)) & 0x03;  /* # of pad bytes to read at EOscanline */
+  if (bits==32) padb = 0;
 
   for (i=h-1; i>=0; i--) {
     pp = pic24 + (i * w * 3);
@@ -474,6 +481,7 @@
       pp[2] = getc(fp);   /* blue */
       pp[1] = getc(fp);   /* green */
       pp[0] = getc(fp);   /* red */
+      if (bits==32) getc(fp);
       pp += 3;
     }
 
diff -Naur xv-3.10a.old/xvbrowse.c xv-3.10a/xvbrowse.c
--- xv-3.10a.old/xvbrowse.c	Fri Jan 20 02:49:17 1995
+++ xv-3.10a/xvbrowse.c	Tue Apr 24 09:37:06 2001
@@ -20,7 +20,7 @@
 #define NEEDSDIR
 #include "xv.h"
 
-#if defined(VMS) || defined(isc)
+#if defined(VMS) || defined(isc) || (defined(__sony_news) && defined(__bsd43))
 typedef unsigned int mode_t;  /* file mode bits */
 #endif
 
@@ -36,6 +36,7 @@
 #include "bits/br_error"
 #include "bits/br_unknown"
 #include "bits/br_cmpres"
+#include "bits/br_bzip2"
 
 #include "bits/br_gif"
 #include "bits/br_pm"
@@ -55,6 +56,14 @@
 #include "bits/br_xpm"
 #include "bits/br_xwd"
 #include "bits/br_fits"
+#include "bits/br_png"
+#include "bits/br_mag"
+#include "bits/br_maki"
+#include "bits/br_pic"
+#include "bits/br_pi"
+#include "bits/br_pic2"
+#include "bits/br_pcd"
+#include "bits/br_mgcsfx"
 
 #include "bits/br_trash"
 #include "bits/fcurs"
@@ -94,7 +103,18 @@
 #define BF_XPM      25
 #define BF_XWD      26
 #define BF_FITS     27
-#define BF_MAX      28    /* # of built-in icons */
+#define BF_PNG      28
+#define BF_BZIP2    29
+#define JP_EXT_BF   (BF_BZIP2)
+#define BF_MAG      (JP_EXT_BF + 1)
+#define BF_MAKI     (JP_EXT_BF + 2)
+#define BF_PIC      (JP_EXT_BF + 3)
+#define BF_PI       (JP_EXT_BF + 4)
+#define BF_PIC2     (JP_EXT_BF + 5)
+#define BF_PCD      (JP_EXT_BF + 6)
+#define BF_MGCSFX   (JP_EXT_BF + 7)
+#define JP_EXT_BF_END  (BF_MGCSFX)
+#define BF_MAX      (JP_EXT_BF_END + 1)    /* # of built-in icons */
 
 #define ISLOADABLE(ftyp) (ftyp!=BF_DIR  && ftyp!=BF_CHR && ftyp!=BF_BLK && \
 			  ftyp!=BF_SOCK && ftyp!=BF_FIFO) 
@@ -140,8 +160,14 @@
 #define BR_NBUTTS   13   /* # of command buttons */
 #define BR_SEP1     13   /* separator */
 #define BR_HIDDEN   14
+#ifdef AUTO_EXPAND
+#define BR_CLEARVD  15
+#define BR_SELFILES 16
+#define BR_NCMDS    17   /* # of menu commands */
+#else
 #define BR_SELFILES 15
 #define BR_NCMDS    16   /* # of menu commands */
+#endif
 
 #define BUTTW 80
 #define BUTTH 24
@@ -164,6 +190,9 @@
 			    "Close window\t^c",
 			    MBSEP,
 			    "Show hidden files",     /* no equiv */
+#ifdef AUTO_EXPAND
+			    "Clear virtual directory",
+#endif
 			    "Select files...\t^f"
 			    };
 
@@ -294,7 +323,11 @@
 static void cp_special       PARM((struct stat *, int));
 static void cp_fifo          PARM((struct stat *, int));
 
+#ifdef AUTO_EXPAND
+static int  stat2bf          PARM((u_int, char *));
+#else
 static int  stat2bf          PARM((u_int));
+#endif
 
 static int  selmatch         PARM((char *, char *));
 static int  selmatch1        PARM((char *, char *));
@@ -514,6 +547,8 @@
 
   bfIcons[BF_COMPRESS]= MakePix1(br->win, br_cmpres_bits,
 				 br_cmpres_width, br_cmpres_height);
+  bfIcons[BF_BZIP2]= MakePix1(br->win, br_bzip2_bits,
+				 br_bzip2_width, br_bzip2_height);
 
   bfIcons[BF_PS]  =MakePix1(br->win,br_ps_bits,  br_ps_width,  br_ps_height);
   bfIcons[BF_IFF] =MakePix1(br->win,br_iff_bits, br_iff_width, br_iff_height);
@@ -524,6 +559,16 @@
   bfIcons[BF_XPM] =MakePix1(br->win,br_xpm_bits, br_xpm_width, br_xpm_height);
   bfIcons[BF_XWD] =MakePix1(br->win,br_xwd_bits, br_xwd_width, br_xwd_height);
   bfIcons[BF_FITS]=MakePix1(br->win,br_fits_bits,br_fits_width,br_fits_height);
+  bfIcons[BF_PNG]=MakePix1(br->win,br_png_bits,br_png_width,br_png_height);
+  bfIcons[BF_MAG] = MakePix1(br->win,br_mag_bits,br_mag_width,br_mag_height);
+  bfIcons[BF_MAKI] = MakePix1(br->win,br_maki_bits,
+				 br_maki_width,br_maki_height);
+  bfIcons[BF_PIC] = MakePix1(br->win,br_pic_bits,br_pic_width,br_pic_height);
+  bfIcons[BF_PI]  = MakePix1(br->win,br_pi_bits,br_pi_width,br_pi_height);
+  bfIcons[BF_PIC2]=MakePix1(br->win,br_pic2_bits,br_pic2_width,br_pic2_height);
+  bfIcons[BF_PCD] = MakePix1(br->win,br_pcd_bits,br_pcd_width,br_pcd_height);
+  bfIcons[BF_MGCSFX] = MakePix1(br->win,br_mgcsfx_bits,
+                             br_mgcsfx_width,br_mgcsfx_height);
 
 
   /* check that they all got built */
@@ -698,6 +743,9 @@
   }
 }
 
+#ifdef VS_RESCMAP
+static int _IfTempOut=0; 
+#endif
 
 /***************************************************************/
 void KillBrowseWindows()
@@ -730,7 +778,6 @@
   return 0;
 }
 
-
 /***************************************************************/
 static int brChkEvent(br, xev)
      BROWINFO *br;
@@ -746,6 +793,23 @@
 
   if (!hasBeenSized) return 0;  /* ignore evrythng until we get 1st Resize */
 
+
+#ifdef VS_RESCMAP
+  /* force change color map if have LocalCmap */
+  if (browPerfect && browCmap && (_IfTempOut==2)) 
+    {
+	XSetWindowAttributes  xswa;
+	if(LocalCmap)
+	      xswa.colormap = LocalCmap;
+	else
+	      xswa.colormap = theCmap;
+	for(i=0;i<MAXBRWIN;i++)
+	  XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
+	XFlush(theDisp);
+	_IfTempOut=1;
+    }
+#endif
+  
   if (xev->type == Expose) {
     int x,y,w,h;
     XExposeEvent *e = (XExposeEvent *) xev;
@@ -807,7 +871,20 @@
     int i,x,y;
     x = e->x;  y = e->y;
 
-    if (e->button == Button1) {
+#ifdef VS_RESCMAP
+    if (browCmap && browPerfect && (_IfTempOut!=0)) 
+      {
+	  XSetWindowAttributes  xswa;
+	  _IfTempOut--;
+	  xswa.colormap = browCmap;
+	  for(i=0;i<MAXBRWIN;i++)
+	    XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
+	  XFlush(theDisp);
+      }
+
+#endif
+
+  if (e->button == Button1) {
       if      (e->window == br->win)      clickBrow(br,x,y);
       else if (e->window == br->scrl.win) SCTrack(&(br->scrl),x,y);
       else if (e->window == br->iconW) {
@@ -956,6 +1033,7 @@
      char *str;
 {
   strncpy(br->dispstr, str, (size_t) 256);
+  br->dispstr[255] = '\0';
   drawBrowStr(br);
   XFlush(theDisp);
 }
@@ -1101,6 +1179,10 @@
   case BR_SELFILES: doSelFilesCmd(br);   break;
 
   case BR_RECURSUP: doRecurseCmd(br);    break;
+
+#ifdef AUTO_EXPAND
+  case BR_CLEARVD:  Vdsettle();          break;
+#endif
   }
 }
 
@@ -1250,6 +1332,18 @@
   int i, allowtext;
 
   if (!nostr) setSelInfoStr(br, sel);
+#ifdef AUTO_EXPAND
+  if (Isvdir(br->path)) {
+    BTSetActive(&br->but[BR_DELETE],  0);
+    br->cmdMB.dim[BR_DELETE] = 1;
+
+    BTSetActive(&br->but[BR_RENAME],  0);
+    br->cmdMB.dim[BR_RENAME] = 1;
+
+    BTSetActive(&br->but[BR_MKDIR],  0);
+    br->cmdMB.dim[BR_MKDIR] = 1;
+  } else {
+#endif
   BTSetActive(&br->but[BR_DELETE],  br->numlit>0);
   br->cmdMB.dim[BR_DELETE] = !(br->numlit>0);
 
@@ -1258,6 +1352,11 @@
 
   BTSetActive(&br->but[BR_GENICON], br->numlit>0);
   br->cmdMB.dim[BR_GENICON] = !(br->numlit>0);
+#ifdef AUTO_EXPAND
+  BTSetActive(&br->but[BR_MKDIR],  1);
+  br->cmdMB.dim[BR_MKDIR] = 0;
+  }
+#endif
 
   /* turn on 'text view' cmd if exactly one non-dir is lit */
   allowtext = 0;
@@ -1318,6 +1417,9 @@
 	  struct stat st;
 	      
 	  sprintf(buf, "%s%s", br->path, bf->name);  /* build filename */
+#ifdef AUTO_EXPAND
+	  Dirtovd(buf);
+#endif
 	  if (stat(buf, &st) == 0) {
 	    sprintf(buf, "%s:  %ld bytes", bf->name, st.st_size);
 	    strcat(buf, buf1);
@@ -1490,6 +1592,7 @@
   if (StringWidth(str) > ISPACE_WIDE-6) {
     int dotpos; 
     strncpy(tmpstr, str, (size_t) 56);
+    tmpstr[56] = '\0'; /* MR: otherwise it dies on long file names */
     dotpos = strlen(tmpstr);
     strcat(tmpstr,"...");
 
@@ -1505,7 +1608,7 @@
     nstr = tmpstr;
   }
   else nstr = str;
-  
+ 
 
   /* draw the title */
   sw = StringWidth(nstr);
@@ -2165,13 +2268,32 @@
     else sprintf(buf, "%s%s", br->path, br->bfList[sel].name);
 #endif
 
+#ifdef AUTO_EXPAND
+    if (Chvdir(buf)) {
+#else
     if (chdir(buf)) {
+#endif
       char str[512];
       sprintf(str,"Unable to cd to '%s'\n", br->bfList[sel].name);
       setBrowStr(br, str);
       XBell(theDisp, 50);
     }
     else {
+#ifdef AUTO_EXPAND
+      if (Isvdir(buf)) {
+	BTSetActive(&br->but[BR_DELETE],  0);
+	br->cmdMB.dim[BR_DELETE] = 1;
+
+	BTSetActive(&br->but[BR_RENAME],  0);
+	br->cmdMB.dim[BR_RENAME] = 1;
+
+	BTSetActive(&br->but[BR_MKDIR],  0);
+	br->cmdMB.dim[BR_MKDIR] = 1;
+      } else {
+	BTSetActive(&br->but[BR_MKDIR],  1);
+	br->cmdMB.dim[BR_MKDIR] = 0;
+      }
+#endif
       scanDir(br);
       SCSetVal(&(br->scrl), 0);  /* reset to top on a chdir */
     }
@@ -2193,7 +2315,29 @@
       *event_retP = THISNEXT;
     }
     else { *event_retP = LOADPIC;  SetDirFName(buf);  }
-    
+
+#ifdef VS_RESCMAP
+    /* Change Colormap for browser */
+    if (browPerfect && browCmap) 
+      {
+	  int i;
+	  XSetWindowAttributes  xswa;
+	  if(LocalCmap)
+	    {
+		xswa.colormap = LocalCmap;
+		_IfTempOut=2;
+	    }
+	  else
+	    {
+		xswa.colormap = theCmap;
+		_IfTempOut=2;
+	    }
+	  for(i=0;i<MAXBRWIN;i++)
+	    XChangeWindowAttributes(theDisp, binfo[i].win, CWColormap, &xswa);
+	  XFlush(theDisp);
+      }
+#endif
+
     *event_doneP = 1;     /* make MainLoop load image */
   }
 }
@@ -2348,6 +2492,9 @@
 
 	  /* try to open this file */
 	  sprintf(foo, "%s%s", br->path, br->bfList[i].name);
+#ifdef AUTO_EXPAND
+	Dirtovd(foo);
+#endif
 	  for (j=0; j<numnames && strcmp(namelist[j],foo); j++);
 	  if (j<numnames) {
 	    curname = nList.selected = j;
@@ -2363,6 +2510,9 @@
       else {          /* not SPACE, or SPACE and lit=1 and not shift */
 	for (i=0; i<br->bfLen && !br->bfList[i].lit; i++);  /* find lit one */
 	sprintf(fname, "%s%s", br->path, br->bfList[i].name);
+#ifdef AUTO_EXPAND
+	Dirtovd(fname);
+#endif
 	viewsel = !(strcmp(fname, fullfname));
 	
 	if (viewsel) {
@@ -2554,7 +2704,11 @@
     }
 #endif
 
+#ifdef AUTO_EXPAND
+    if (Chvdir(tmppath)) {
+#else
     if (chdir(tmppath)) {
+#endif
       char str[512];
       sprintf(str,"Unable to cd to '%s'\n", tmppath);
       MBRedraw(&(br->dirMB));
@@ -2562,6 +2716,21 @@
       XBell(theDisp, 50);
     }
     else {
+#ifdef AUTO_EXPAND
+      if (Isvdir(tmppath)) {
+	BTSetActive(&br->but[BR_DELETE],  0);
+	br->cmdMB.dim[BR_DELETE] = 1;
+
+	BTSetActive(&br->but[BR_RENAME],  0);
+	br->cmdMB.dim[BR_RENAME] = 1;
+
+	BTSetActive(&br->but[BR_MKDIR],  0);
+	br->cmdMB.dim[BR_MKDIR] = 1;
+      } else {
+	BTSetActive(&br->but[BR_MKDIR],  1);
+	br->cmdMB.dim[BR_MKDIR] = 0;
+      }
+#endif
       scanDir(br);
       SCSetVal(&br->scrl, 0);  /* reset to top of window on a chdir */
     }
@@ -2582,7 +2751,11 @@
   if ((strlen(br->path) > (size_t) 2) && br->path[strlen(br->path)-1] == '/')
     br->path[strlen(br->path)-1] = '\0';
 
+#ifdef AUTO_EXPAND
+  rv = Chvdir(br->path);
+#else
   rv = chdir(br->path);
+#endif
   if (rv) {
     char str[512];
     sprintf(str, "Unable to cd to '%s'\n", br->path);
@@ -2590,6 +2763,22 @@
     XBell(theDisp, 50);
   }
 
+#ifdef AUTO_EXPAND
+  if (Isvdir(br->path)) {
+    BTSetActive(&br->but[BR_DELETE],  0);
+    br->cmdMB.dim[BR_DELETE] = 1;
+
+    BTSetActive(&br->but[BR_RENAME],  0);
+    br->cmdMB.dim[BR_RENAME] = 1;
+
+    BTSetActive(&br->but[BR_MKDIR],  0);
+    br->cmdMB.dim[BR_MKDIR] = 1;
+  } else {
+    BTSetActive(&br->but[BR_MKDIR],  1);
+    br->cmdMB.dim[BR_MKDIR] = 0;
+  }
+#endif
+
   strcat(br->path, "/");   /* put trailing '/' back on */
   return rv;
 }
@@ -2616,8 +2805,10 @@
     strcpy(dstbr->mblist[i], srcbr->mblist[i]);
   }
 
-  dstbr->dirMB.list  = srcbr->mblist;
-  dstbr->dirMB.nlist = srcbr->ndirs;
+/*  dstbr->dirMB.list  = srcbr->mblist;  /* original bug..? */
+/*  dstbr->dirMB.nlist = srcbr->ndirs;                      */
+  dstbr->dirMB.list  = dstbr->mblist;    /* fixed by        */
+  dstbr->dirMB.nlist = dstbr->ndirs;     /*   jp-extension. */
 
   XClearArea(theDisp, dstbr->dirMB.win, dstbr->dirMB.x, dstbr->dirMB.y, 
 	     dstbr->dirMB.w+3, dstbr->dirMB.h+3, False);
@@ -2975,7 +3166,11 @@
 	
 
   if (stat(bf->name, &st)==0) {
+#ifdef AUTO_EXPAND
+    bf->ftype = stat2bf((u_int) st.st_mode , bf->name);
+#else
     bf->ftype = stat2bf((u_int) st.st_mode);
+#endif
     if (bf->ftype == BF_FILE && (st.st_mode & 0111)) bf->ftype = BF_EXE;
 
     switch (bf->ftype) {
@@ -3014,12 +3209,21 @@
     case RFT_TIFF:     bf->ftype = BF_TIFF;     break;
     case RFT_PDSVICAR: bf->ftype = BF_PDS;      break;
     case RFT_COMPRESS: bf->ftype = BF_COMPRESS; break;
+    case RFT_BZIP2:    bf->ftype = BF_BZIP2;    break;
     case RFT_PS:       bf->ftype = BF_PS;       break;
     case RFT_IFF:      bf->ftype = BF_IFF;      break;
     case RFT_TARGA:    bf->ftype = BF_TARGA;    break;
     case RFT_XPM:      bf->ftype = BF_XPM;      break;
     case RFT_XWD:      bf->ftype = BF_XWD;      break;
     case RFT_FITS:     bf->ftype = BF_FITS;     break;
+    case RFT_PNG:      bf->ftype = BF_PNG;      break;
+    case RFT_MAG:      bf->ftype = BF_MAG;      break;
+    case RFT_MAKI:     bf->ftype = BF_MAKI;     break;
+    case RFT_PIC:      bf->ftype = BF_PIC;      break;
+    case RFT_PI:       bf->ftype = BF_PI;       break;
+    case RFT_PIC2:     bf->ftype = BF_PIC2;     break;
+    case RFT_PCD:      bf->ftype = BF_PCD;      break;
+    case RFT_MGCSFX:   bf->ftype = BF_MGCSFX;   break;
     }
   }
 }
@@ -3406,7 +3610,7 @@
   double  wexpand,hexpand;
   int     iwide, ihigh;
   byte   *icon24, *icon8;
-  char    str[256], str1[256], *readname, uncompname[128];
+  char    str[256], str1[256], readname[128], uncompname[128];
   char    basefname[128], *uncName;
   
   
@@ -3415,7 +3619,7 @@
   basefname[0] = '\0';
   pinfo.pic = (byte *) NULL;
   pinfo.comment = (char *) NULL;
-  readname = bf->name;
+  strcpy(readname, bf->name);
   
   /* free any old info in 'bf' */
   if (bf->imginfo) free          (bf->imginfo);
@@ -3432,7 +3636,7 @@
   
   filetype = ReadFileType(bf->name);
   
-  if (filetype == RFT_COMPRESS) {
+  if ((filetype == RFT_COMPRESS) || (filetype == RFT_BZIP2)) {
 #if (defined(VMS) && !defined(GUNZIP))
     /* VMS decompress doesn't like the file to have a trailing .Z in fname
        however, GUnZip is OK with it, which we are calling UnCompress */
@@ -3443,9 +3647,9 @@
     uncName = bf->name;
 #endif
     
-    if (UncompressFile(uncName, uncompname)) {
+    if (UncompressFile(uncName, uncompname, filetype)) {
       filetype = ReadFileType(uncompname);
-      readname = uncompname;
+      strcpy(readname, uncompname);
     }
     else {
       sprintf(str, "Couldn't uncompress file '%s'", bf->name);
@@ -3454,6 +3658,51 @@
     }
   }
   
+#ifdef MACBINARY
+  if (handlemacb && macb_file == True && bf->ftype != BF_ERROR) {
+    if (RemoveMacbinary(readname, uncompname)) {
+      if (strcmp(readname, bf->name)!=0) unlink(readname);
+      strcpy(readname, uncompname);
+    }
+    else {
+      sprintf(str, "Unable to remove a InfoFile header form '%s'.", bf->name);
+      setBrowStr(br, str);
+      bf->ftype = BF_ERROR;
+    }
+  }
+#endif
+
+#ifdef HAVE_MGCSFX_AUTO
+  if (bf->ftype != BF_ERROR) {
+    if(filetype == RFT_MGCSFX){
+      char tmpname[128];
+      char *icom;
+
+      if((icom = mgcsfx_auto_input_com(bf->name)) != NULL){
+	sprintf(tmpname, "%s/xvmsautoXXXXXX", tmpdir);
+	mktemp(tmpname);
+	SetISTR(ISTR_INFO, "Converting to known format by MgcSfx auto...");
+	sprintf(str,"%s >%s", icom, tmpname);
+      }else goto ms_auto_no;
+
+#ifndef VMS
+      if (system(str)) {
+#else
+      if (!system(str)) {
+#endif
+        sprintf(str, "Unable to convert '%s' by MgcSfx auto.", bf->name);
+        setBrowStr(br, str);
+        bf->ftype = BF_ERROR;
+      } else {
+        filetype = ReadFileType(tmpname);
+        if (strcmp(readname, bf->name)!=0) unlink(readname);
+        strcpy(readname, tmpname);
+      }
+    }
+  }
+ms_auto_no:
+#endif /* HAVE_MGCSFX_AUTO */
+
   /* get rid of comments.  don't need 'em */
   if (pinfo.comment) free(pinfo.comment);  pinfo.comment = (char *) NULL;
   
@@ -3471,6 +3720,9 @@
   else {
     /* otherwise it's a known filetype... do the *hard* part now... */
     
+#ifdef VS_ADJUST
+    normaspect = defaspect;
+#endif /* VS_ADJUST */
     i = ReadPicFile(readname, filetype, &pinfo, 1);
     KillPageFiles(pinfo.pagebname, pinfo.numpages);
     
@@ -3490,7 +3742,7 @@
   }
   
   /* if we made an uncompressed file, we can rm it now */
-  if (readname != bf->name) unlink(readname);
+  if (strcmp(readname, bf->name)!=0) unlink(readname);
   
   
   /* at this point either BF_ERROR, BF_UNKNOWN, BF_EXE or pic */
@@ -3508,21 +3760,39 @@
   
   /* compute size of icon  (iwide,ihigh) */
   
+#ifdef VS_ADJUST
+  if (!vsadjust) normaspect = 1;
+
+  wexpand = (double) (pinfo.w * normaspect) / (double) ISIZE_WIDE;
+#else
   wexpand = (double) pinfo.w / (double) ISIZE_WIDE;
+#endif /* VS_ADJUST */
   hexpand = (double) pinfo.h / (double) ISIZE_HIGH;
 
   if (wexpand >= 1.0 || hexpand >= 1.0) {   /* don't expand small icons */
     if (wexpand>hexpand) {
+#ifdef VS_ADJUST
+      iwide = (int) ((pinfo.w * normaspect) / wexpand + 0.5);
+#else
       iwide = (int) (pinfo.w / wexpand + 0.5);
+#endif /* VS_ADJUST */
       ihigh = (int) (pinfo.h / wexpand + 0.5);
     }
     else {
+#ifdef VS_ADJUST
+      iwide = (int) ((pinfo.w * normaspect) / hexpand + 0.5);
+#else
       iwide = (int) (pinfo.w / hexpand + 0.5);
+#endif /* VS_ADJUST */
       ihigh = (int) (pinfo.h / hexpand + 0.5);
     }
   }
   else {  /* smaller than ISIZE.  Leave it that way. */
+#ifdef VS_ADJUST
+    iwide = pinfo.w * normaspect;  ihigh = pinfo.h;
+#else
     iwide = pinfo.w;  ihigh = pinfo.h;
+#endif /* VS_ADJUST */
   }
 
 
@@ -3567,6 +3837,14 @@
   case RFT_XPM:      strcat(str,"XPM file");              break;
   case RFT_XWD:      strcat(str,"XWD file");              break;
   case RFT_FITS:     strcat(str,"FITS file");             break;
+  case RFT_PNG:      strcat(str,"PNG file");              break;
+  case RFT_MAG:      strcat(str,"MAG file");              break;
+  case RFT_MAKI:     strcat(str,"MAKI file");             break;
+  case RFT_PIC:      strcat(str,"PIC file");              break;
+  case RFT_PI:       strcat(str,"PI file");               break;
+  case RFT_PIC2:     strcat(str,"PIC2 file");             break;
+  case RFT_PCD:      strcat(str,"Photo CD file");         break;
+  case RFT_MGCSFX:   strcat(str,"Magic Suffix file");     break;
   default:           strcat(str,"file of unknown type");  break;
   }
   
@@ -3670,6 +3948,10 @@
 
   sprintf(thFname, "%s%s/%s", br->path, THUMBDIR, bf->name);
 
+#ifdef AUTO_EXPAND
+  Dirtovd(thFname);
+#endif
+
   fp = fopen(thFname, "r");
   if (!fp) return;            /* nope, it doesn't have one */
 
@@ -3785,6 +4067,10 @@
 
   sprintf(thFname, "%s%s/%s", br->path, THUMBDIR, bf->name);
 
+#ifdef AUTO_EXPAND
+  Dirtovd(thFname);
+#endif
+
   fp = fopen(thFname, "w");
   if (!fp) {
     sprintf(buf, "Can't create thumbnail file '%s':  %s", thFname, 
@@ -3849,15 +4135,30 @@
 
   sprintf(thFname, "%s%s", br->path, THUMBDIRNAME);
 
+#ifdef AUTO_EXPAND
+  Dirtovd(thFname);
+#endif
+
   i = stat(thFname, &st);
   if (i) {                      /* failed, let's create it */
     sprintf(thFname, "%s.", br->path);
+#ifdef AUTO_EXPAND
+  Dirtovd(thFname);
+#endif
     i = stat(thFname, &st);     /* get permissions of parent dir */
     if (!i) perm = st.st_mode & 07777;
        else perm = 0755;
 
     sprintf(thFname, "%s%s", br->path, THUMBDIRNAME);
+#ifdef AUTO_EXPAND
+    Dirtovd(thFname);
+#  ifdef VIRTUAL_TD
+    if (mkdir(thFname, (mode_t) perm) < 0)
+      Mkvdir_force(thFname);
+#  else
     mkdir(thFname, (mode_t) perm);
+#  endif
+#endif
   }
 }
 
@@ -3964,7 +4265,11 @@
       sprintf(thfname, "%s/%s", THUMBDIR, dp->d_name);
       if (stat(thfname, &thumbst)==0) {  /* success */
 	int tmp;
+#ifdef AUTO_EXPAND
+	tmp  = stat2bf((u_int) thumbst.st_mode , thfname);
+#else
 	tmp  = stat2bf((u_int) thumbst.st_mode);
+#endif
 
 	if (tmp == BF_FILE) {  /* a plain file */
 	  /* see if this thumbfile has an associated pic file */
@@ -4043,6 +4348,15 @@
   static char *labels[] = { "\nOk", "\033Cancel" };
   struct stat st;
 
+#ifdef AUTO_EXPAND
+  if (Isvdir(br->path)) {
+    sprintf(buf,"Sorry, you can't rename file in the virtual directory, '%s'",
+	    br->path);
+    ErrPopUp(buf, "\nBummer!");
+    return;
+  }
+#endif
+
   if (cdBrow(br)) return;
 
   /* find the selected file */
@@ -4130,6 +4444,15 @@
   static char *labels[] = { "\nOk", "\033Cancel" };
   struct stat  st;
 
+#ifdef AUTO_EXPAND
+  if (Isvdir(br->path)) {
+    sprintf(buf,"Sorry, you can't mkdir in the virtual directory, '%s'",
+	    br->path);
+    ErrPopUp(buf, "\nBummer!");
+    return;
+  }
+#endif
+
   if (cdBrow(br)) return;
 
   buf[0] = '\0';
@@ -4198,12 +4521,31 @@
     if (cdBrow(br)) return;     /* prints its own error message */
   }
 
+#ifdef AUTO_EXPAND
+  if (Chvdir(buf)) {
+#else
   if (chdir(buf)) {
+#endif
     sprintf(str,"Unable to cd to '%s'\n", buf);
     setBrowStr(br, str);
     XBell(theDisp, 50);
   }
   else {
+#ifdef AUTO_EXPAND
+      if (Isvdir(buf)) {
+	BTSetActive(&br->but[BR_DELETE],  0);
+	br->cmdMB.dim[BR_DELETE] = 1;
+
+	BTSetActive(&br->but[BR_RENAME],  0);
+	br->cmdMB.dim[BR_RENAME] = 1;
+
+	BTSetActive(&br->but[BR_MKDIR],  0);
+	br->cmdMB.dim[BR_MKDIR] = 1;
+      } else {
+	BTSetActive(&br->but[BR_MKDIR],  1);
+	br->cmdMB.dim[BR_MKDIR] = 0;
+      }
+#endif
     scanDir(br);
     SCSetVal(&(br->scrl), 0);	/* reset to top on a chdir */
   }
@@ -4230,6 +4572,15 @@
   char   buf[512];
   static char *yesno[]  = { "\004Delete", "\033Cancel" };
 
+#ifdef AUTO_EXPAND
+  if (Isvdir(br->path)) {
+    sprintf(buf,"Sorry, you can't delete file at the virtual directory, '%s'",
+	    br->path);
+    ErrPopUp(buf, "\nBummer!");
+    return;
+  }
+#endif
+
   if (!br->bfLen || !br->bfList || !br->numlit) return;
 
   if (cdBrow(br)) return;     /* can't cd to this directory.  screw it! */
@@ -4252,7 +4603,11 @@
   for (i=0, bf=br->bfList; i<br->bfLen; i++,bf++) {
     if (bf->lit) {
       if (firstdel == -1) firstdel = i;
-      if (bf->ftype == BF_DIR) numdirs++;
+      if (bf->ftype == BF_DIR
+#ifdef AUTO_EXPAND
+	  && (!Isarchive(bf->name))
+#endif
+			     ) numdirs++;
       else numfiles++;
     }
   }
@@ -4266,7 +4621,12 @@
     slen = strlen(buf);
 
     for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
+#ifdef AUTO_EXPAND
+      if (bf->lit && (bf->ftype != BF_DIR || Isarchive(bf->name))) {
+#else
       if (bf->lit && bf->ftype != BF_DIR) {
+#endif
+					
 	if ( (slen + strlen(bf->name) + 1) > 256) {
 	  strcat(buf,"...");
 	  break;
@@ -4291,7 +4651,11 @@
     slen = strlen(buf);
 
     for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
+#ifdef AUTO_EXPAND
+      if (bf->lit && (bf->ftype == BF_DIR || !Isarchive(bf->name))) {
+#else
       if (bf->lit && bf->ftype == BF_DIR) {
+#endif
 	if ( (slen + strlen(bf->name) + 1) > 256) {
 	  strcat(buf,"...");
 	  break;
@@ -4312,7 +4676,11 @@
   
   for (i=0, bf=br->bfList;  i<br->bfLen;  i++,bf++) {
     if (bf->lit) {
-      if (bf->ftype == BF_DIR) rm_dir (br, bf->name);
+      if (bf->ftype == BF_DIR
+#ifdef AUTO_EXPAND
+	  && !Isarchive(bf->name)
+#endif
+			     ) rm_dir (br, bf->name);
                           else rm_file(br, bf->name);
     }
   }
@@ -4441,7 +4809,11 @@
   xv_getwd(orgDir, sizeof(orgDir));
 
   sprintf(curDir, "%s%s", br->path, subdir);
+#ifdef AUTO_EXPAND
+  if (Chvdir(curDir)) {
+#else
   if (chdir(curDir)) {
+#endif
     char str[512];
     sprintf(str, "Unable to cd to '%s'\n", curDir);
     setBrowStr(br, str);
@@ -4453,14 +4825,22 @@
   /* have we looped? */
   for (i=0; i<dirStackLen && strcmp(curDir, dirStack[i]); i++);
   if (i<dirStackLen) {   /* YES */
+#ifdef AUTO_EXPAND
+    Chvdir(orgDir);
+#else
     chdir(orgDir);
+#endif
     return;
   }
 
   sp = (char *) malloc((size_t) strlen(curDir) + 1);
   if (!sp) {
     setBrowStr(br, "malloc() error in recurseUpdate()\n");
+#ifdef AUTO_EXPAND
+    Chvdir(orgDir);
+#else
     chdir(orgDir);
+#endif
     return;
   }
 
@@ -4495,7 +4875,11 @@
 
   xv_getwd(curDir, sizeof(curDir));
   if (strcmp(orgDir, curDir)) {   /* change back to orgdir */
+#ifdef AUTO_EXPAND
+    Chvdir(orgDir);
+#else
     chdir(orgDir);
+#endif
     scanDir(br);
   }
 }
@@ -4519,6 +4903,13 @@
     setBrowStr(br, buf);
   }
 
+#ifdef AUTO_EXPAND
+  if (Rmvdir(name)) {
+    sprintf(buf, "fail to remove virturl directory: %s", name);
+    setBrowStr(br, buf);
+  }
+#endif
+
   /* try to delete a thumbnail file, as well.  ignore errors */
   strcpy(buf1, name);          /* tmp1 = leading path of name */
   tmp = (char *) rindex(buf1, '/');
@@ -4587,7 +4978,12 @@
 	goto done;
       }
 	
+#ifdef AUTO_EXPAND
+      if ((stat2bf((u_int) st.st_mode , rmdirPath) == BF_DIR)
+	  && !Isarchive(rmdirPath)) {  /* skip, for now */
+#else
       if (stat2bf((u_int) st.st_mode) == BF_DIR) {  /* skip, for now */
+#endif
 	rmdirPath[oldpathlen] = '\0';
 	continue;   /* don't remove from list */
       }
@@ -4677,11 +5073,26 @@
   }
   else if (strcmp(dstdir,".")!=0) sprintf(dstp, "%s%s/", dstpath, dstdir);
 
+#ifdef AUTO_EXPAND
+  if (Isvdir(dstp)) {
+    sprintf(buf,"Sorry, you can't %s to the virtual directory, '%s'",
+	    cpymode ? "copy" : "move", dstp);
+    ErrPopUp(buf, "\nBummer!");
+    SetCursors(-1);
+    return;
+  }
+  if (Isvdir(srcpath))
+      cpymode = 1;
+#endif
+
 
 
   /* if there is a thumbnail directory in 'srcpath', make one for dstpath */
   sprintf(src,"%s%s", srcpath, THUMBDIR);
   dothumbs = 0;
+#ifdef AUTO_EXPAND
+  Dirtovd(src);
+#endif
   if (stat(src, &st)==0) {
     sprintf(dst,"%s%s", dstp, THUMBDIR);
     mkdir(dst, st.st_mode & 07777);
@@ -4712,6 +5123,14 @@
     if (overwrite == OWRT_CANCEL) break;         /* abort move */
     if (j==1) fail++;
 
+#ifdef AUTO_EXPAND
+    if (!cpymode && j==0)
+      if (Movevdir(src,dst)) {
+	sprintf(buf, "fail to move virturl directory: %s", names[i]);
+	setBrowStr(srcBr, buf);
+      }
+#endif
+
     if (dothumbs && j==0) {
       sprintf(src,"%s%s/%s", srcpath, THUMBDIR, names[i]);
       sprintf(dst,"%s%s/%s", dstp,    THUMBDIR, names[i]);
@@ -4816,12 +5235,25 @@
 
   if (DEBUG) fprintf(stderr,"moveFile %s %s\n", src, dst);
 
+#ifdef AUTO_EXPAND
+  Dirtosubst(src);
+#endif
+
   if (stat(src, &st)) return 0;    /* src doesn't exist, it would seem */
+#ifdef AUTO_EXPAND
+  srcdir = (stat2bf((u_int) st.st_mode , src) == BF_DIR);
+#else
   srcdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
+#endif
 
   /* see if destination exists */
+
   if (stat(dst, &st)==0) {
-    dstdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
+#ifdef AUTO_EXPAND
+  dstdir = (stat2bf((u_int) st.st_mode , dst) == BF_DIR);
+#else
+  dstdir = (stat2bf((u_int) st.st_mode) == BF_DIR);
+#endif
 
     if (overwrite==OWRT_ASK) {
       sprintf(buf, "%s '%s' exists.\n\nOverwrite?", 
@@ -4915,13 +5347,22 @@
 
   if (DEBUG) fprintf(stderr,"copyFile %s %s\n", src, dst);
 
+#ifdef AUTO_EXPAND
+  Dirtosubst(src);
+#endif
+
   if (stat(src,&srcSt)) return 0;  /* source doesn't exist, it would seem */
 
   dstExists = (stat(dst, &dstSt)==0);
 
   if (dstExists) {   /* ask about overwriting... */
-    srcdir = (stat2bf((u_int) srcSt.st_mode) == BF_DIR);
-    dstdir = (stat2bf((u_int) dstSt.st_mode) == BF_DIR);
+#ifdef AUTO_EXPAND
+  srcdir = (stat2bf((u_int) srcSt.st_mode , src) == BF_DIR);
+  dstdir = (stat2bf((u_int) dstSt.st_mode , dst) == BF_DIR);
+#else
+  srcdir = (stat2bf((u_int) srcSt.st_mode) == BF_DIR);
+  dstdir = (stat2bf((u_int) dstSt.st_mode) == BF_DIR);
+#endif
 
     sprintf(buf, "%s '%s' already exists.  Replace it with %s '%s'?",
 	    (dstdir) ? "Directory" : "File", dst,
@@ -5037,7 +5478,11 @@
   }
 
 
+#ifdef AUTO_EXPAND
+  switch(stat2bf((u_int) srcSt.st_mode , cpDstPath)) {   
+#else
   switch(stat2bf((u_int) srcSt.st_mode)) {   
+#endif
     /* determine how to copy, by filetype */
 
     /* NOTE:  There is no S_IFLNK case here, since we're using 'stat()' and
@@ -5053,7 +5498,11 @@
     }
   }
   else {
+#ifdef AUTO_EXPAND
+    if (stat2bf((u_int) dstSt.st_mode , cpDstPath) != BF_DIR) {
+#else
     if (stat2bf((u_int) dstSt.st_mode) != BF_DIR) {
+#endif
       SetISTR(ISTR_WARNING,"%s: not a directory", cpDstPath);
       copyerr++;
       return;
@@ -5131,7 +5580,11 @@
       goto done;
     }
      
-    if (stat2bf((u_int) srcSt.st_mode) == BF_DIR) {
+#ifdef AUTO_EXPAND
+    if (stat2bf((u_int) srcSt.st_mode , cpSrcPath) == BF_DIR) {
+#else
+     if (stat2bf((u_int) srcSt.st_mode) == BF_DIR) {
+#endif
       cpSrcPath[oldsrclen] = '\0';
       continue;                     /* don't remove from list, just skip */
     }
@@ -5304,8 +5757,14 @@
 
   
 /*********************************/
+#ifdef AUTO_EXPAND
+static int stat2bf(uistmode, path)
+     u_int uistmode;
+     char *path;
+#else
 static int stat2bf(uistmode)
      u_int uistmode;
+#endif
 {
   /* given the 'st.st_mode' field from a successful stat(), returns 
      BF_FILE, BF_DIR, BF_BLK, BF_CHR, BF_FIFO, or BF_SOCK.  Does *NOT*
@@ -5319,6 +5778,9 @@
   else if (S_ISBLK(stmode))  rv = BF_BLK;
   else if (S_ISFIFO(stmode)) rv = BF_FIFO;
   else if (S_ISSOCK(stmode)) rv = BF_SOCK;
+#ifdef AUTO_EXPAND
+  else if (Isarchive(path))  rv = BF_DIR;
+#endif
   else                       rv = BF_FILE;
 
   return rv;
diff -Naur xv-3.10a.old/xvcpmask.c xv-3.10a/xvcpmask.c
--- xv-3.10a.old/xvcpmask.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvcpmask.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,108 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "xv.h"
+
+typedef struct { int n; char flg; } CPS;
+
+static unsigned char CPTbl[] = {
+    0x10, 0x17, 0x13, 0x15, 0x09,
+    0x08, 0x0a, 0x14, 0x06, 0x05,
+    0x16, 0x02, 0x0d, 0x03, 0x01,
+    0x04, 0x19, 0x0c, 0x0f, 0x0e,
+    0x12, 0x07, 0x0b, 0x18, 0x11, 0x1a
+};
+
+void cpcode(char *filename,unsigned char *buff,int code_num)
+{
+	int i,j,fd;
+  	unsigned char *wp, *cp;
+  	unsigned char *CP_KEY = "kIUCHIuCHINO";
+
+	if(code_num>=3) return;
+	if((fd=open(filename,O_RDONLY))==-1) return;
+
+	lseek(fd,20+16*code_num,SEEK_SET);
+	read(fd,buff,16);
+
+  	wp = buff;
+  	cp = CP_KEY;
+
+      	for ( i = 0; i < 16; i++ ) {
+          	*wp ^= *cp;
+          	if ( *wp & 0x80 ) *wp = '\0';
+		cp++;
+          	wp++;
+        	if ( *cp == '\0' ) cp = CP_KEY;
+   	}
+
+	for (i=0;i<16;i++) {
+		if (buff[i]<'A' || 'Z'<buff[i]){
+			buff[i]=0;
+			break;
+		}
+	}
+	close(fd);
+}
+
+
+static void GetCPTbl(int nTbl, char *CPcode, int *tbl, CPS *cps)
+{
+    int i, k, vl1, vl2, len;
+
+    for(i = 0; i < nTbl; i++) {
+        tbl[i] = -1;
+        cps[i].n = i;
+        cps[i].flg = 0;
+    }
+    len = strlen(CPcode);
+    vl1 = nTbl - 1;
+    vl2 = len + nTbl % len;
+    for(k = 0; k < nTbl; k++) {
+        vl1 = CPTbl[CPcode[k % len] - 'A'] + vl1 + vl2;
+        if(vl1 >= nTbl) vl1 %= nTbl;
+         while(tbl[vl1] != -1) {
+            if(k & 01) {
+                if(vl1 == 0) vl1 = nTbl;
+                vl1--;
+            }
+            else {
+                if(++vl1 >= nTbl) vl1 = 0;
+            }
+        }
+        tbl[vl1] = k;
+        vl2++;
+    }
+    for(i = 0, k = nTbl - 1; i < k; i++, k--) {
+        cps[tbl[i]].n = tbl[k];
+        cps[tbl[k]].n = tbl[i];
+        if((tbl[i] ^ tbl[k]) & 0x01)
+            cps[tbl[i]].flg = cps[tbl[k]].flg = 1;
+    }
+}
+
+
+CPS *calcCPmask(char *code, int ntbl)
+{
+    int *tbl;
+    int len,i;
+    CPS *cps;
+
+    len = strlen(code);
+    tbl = (int *)malloc(sizeof(int) * ntbl);
+    cps = (CPS *)malloc(sizeof(CPS) * ntbl);
+    if(!tbl || !cps) {
+	ErrPopUp ("Error:  No memory!!", "\nOk");
+        if(tbl) free(tbl);
+        exit(1);
+    }
+    GetCPTbl(ntbl, code, tbl, cps);
+    
+    free(tbl);
+    return(cps);
+}
+
diff -Naur xv-3.10a.old/xvctrl.c xv-3.10a/xvctrl.c
--- xv-3.10a.old/xvctrl.c	Fri Dec 23 07:34:41 1994
+++ xv-3.10a/xvctrl.c	Tue Apr 24 09:37:06 2001
@@ -101,7 +101,8 @@
 			     "Root: centered, warp",
 			     "Root: centered, brick",
     		             "Root: symmetrical tiled",
-			     "Root: symmetrical mirrored" };
+			     "Root: symmetrical mirrored",
+			     "Root: upper left corner" };
 
 static char *conv24MList[] = { "8-bit mode\t\2448",
 			       "24-bit mode\t\2448",
@@ -112,6 +113,17 @@
 			       "Slow 24->8",
 			       "Best 24->8" };
 
+static char *mskMList[]    = { "Undo All\t\244u",
+			       MBSEP,
+			       "FLmask\t\244f",
+			       "Q0mask\t\244g",
+			       "WIN\t\244h",
+			       "MEKO\t\244i",
+			       "CPmask\t\244j",
+			       "RGB\t\244l",
+			       "BitRev.\t\244n",
+			       "ColRev.\t\244w"};
+
 static char *algMList[]    = { "Undo All\t\244u",
 			       MBSEP,
  			       "Blur...\t\244b",
@@ -124,7 +136,8 @@
 			       "Clear Rotate...\t\244T",
 			       "Pixelize...\t\244p",
 			       "Spread...\t\244S",
-			       "DeSpeckle...\t\244k"};
+			       "DeSpeckle...\t\244k",
+			       "Q0 Masking\t\244Q"};
 
 static char *sizeMList[]   = { "Normal\tn",
 			       "Max Size\tm",
@@ -303,9 +316,11 @@
   BTCreate(&but[BPAD],    ctrlW,BX0,          BY1,BUTTW/2,BUTTH,"",BCLS);
   BTCreate(&but[BANNOT],  ctrlW,BX0+BUTTW/2+1,BY1,BUTTW/2,BUTTH,"",BCLS);
 
-  BTCreate(&but[BCROP],   ctrlW,BX1,  BY1,BUTTW,BUTTH,"Crop",    BCLS);
-  BTCreate(&but[BUNCROP], ctrlW,BX2,  BY1,BUTTW,BUTTH,"UnCrop",  BCLS);
-  BTCreate(&but[BACROP],  ctrlW,BX3,  BY1,BUTTW,BUTTH,"AutoCrop",BCLS);
+#define NEW_BUTW BUTTW*3/4
+  BTCreate(&but[BCROP],   ctrlW,BX1            ,BY1,NEW_BUTW,BUTTH,"Crp",    BCLS);
+  BTCreate(&but[BUNCROP], ctrlW,BX1+NEW_BUTW+1   ,BY1,NEW_BUTW,BUTTH,"UCrp",  BCLS);
+  BTCreate(&but[BACROP],  ctrlW,BX1+NEW_BUTW*2+2,BY1,NEW_BUTW,BUTTH,"ACrp",BCLS);
+  BTCreate(&but[BMASKS],  ctrlW,BX1+NEW_BUTW*3+3,BY1,NEW_BUTW,BUTTH,"Mask",BCLS);
   BTCreate(&but[BABOUT],  ctrlW,BX4,  BY1,BUTTW,BUTTH,"About XV",BCLS);
   BTCreate(&but[BQUIT],   ctrlW,BX5,  BY1,BUTTW,BUTTH,"Quit",    BCLS);
 
@@ -341,16 +356,18 @@
   /* have to create menu buttons after XMapSubWindows, as we *don't* want 
      the popup menus mapped */
 
-  MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5,112,19, 
+  MBCreate(&dispMB,   ctrlW, CTRLWIDE - 8 - 84 - 3*(84+2), 5,84,19, 
 	   "Display",    dispMList,   DMB_MAX,    BCLS);
-  MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5,112,19, 
+  MBCreate(&conv24MB, ctrlW, CTRLWIDE - 8 - 84 - 2*(84+2), 5,84,19, 
 	   "24/8 Bit",   conv24MList, CONV24_MAX, BCLS);
-  MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 112,             5,112,19, 
-	   "Algorithms", algMList,    ALG_MAX,    BCLS);
+  MBCreate(&algMB,    ctrlW, CTRLWIDE - 8 - 84 - (84+2),   5,84,19, 
+	   "Algo.", algMList,    ALG_MAX,    BCLS);
+  MBCreate(&flmaskMB, ctrlW, CTRLWIDE - 8 - 84,          5,84,19, 
+	   "FLmask", mskMList,    MSK_MAX,    BCLS);
 
-  MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+2), 5+21,112,19, 
+  MBCreate(&rootMB,   ctrlW, CTRLWIDE - 8 - 112 - 2*(112+3), 5+21,112,19, 
 	   "Root",       rootMList,   RMB_MAX,    BCLS);
-  MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+2),   5+21,112,19, 
+  MBCreate(&windowMB, ctrlW, CTRLWIDE - 8 - 112 - (112+3),   5+21,112,19, 
 	   "Windows",    windowMList, WMB_MAX,    BCLS);
   MBCreate(&sizeMB,   ctrlW, CTRLWIDE - 8 - 112,             5+21,112,19, 
 	   "Image Size", sizeMList,   SZMB_MAX,   BCLS);
@@ -437,6 +454,7 @@
   MBRedraw(&dispMB);
   MBRedraw(&conv24MB);
   MBRedraw(&algMB);
+  MBRedraw(&flmaskMB);
   MBRedraw(&rootMB);
   MBRedraw(&windowMB);
   MBRedraw(&sizeMB);
diff -Naur xv-3.10a.old/xvcut.c xv-3.10a/xvcut.c
--- xv-3.10a.old/xvcut.c	Sat Jan 14 04:55:48 1995
+++ xv-3.10a/xvcut.c	Tue Apr 24 09:37:05 2001
@@ -101,7 +101,8 @@
 static Cursor cutcurs  = (Cursor) 0;
 
 
-
+/* FLmask: Mask Select. */
+void MaskSelect (int,int,int,int);
 
 /********************************************/
 int CutAllowed()
@@ -1859,4 +1860,11 @@
   CoordC2P(cx, cy, px_ret, py_ret);
 }
 
+
+void MaskSelect (x1,x2,y1,y2)
+int x1,x2,y1,y2;
+{
+	selrx = x1;  selry = y1;  selrw = x2;  selrh = y2;
+	EnableSelection(1);
+}
 
diff -Naur xv-3.10a.old/xvdflt.c xv-3.10a/xvdflt.c
--- xv-3.10a.old/xvdflt.c	Fri Dec 23 07:34:42 1994
+++ xv-3.10a/xvdflt.c	Tue Apr 24 09:37:05 2001
@@ -18,6 +18,8 @@
 #include "bits/xf_left"
 #include "bits/xf_right"
 #include "bits/font5x9.h"
+#include "bits/xv_jpext"
+#include "bits/xv_jprev"
 
 
 #ifndef USEOLDPIC
@@ -101,21 +103,34 @@
 
 
   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2+1, 203+1, 252);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2+1, 186+1, 252);
   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2,   203, 250);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2,   186, 250);
 
   i = xv_ver_width + xv_rev_width + 30;
 
   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
-       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2+1, 220+1,252);
+       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2+1, 203+1,252);
   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
-       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2+1, 220+1,252);
+       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2+1, 203+1,252);
 
   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 250);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 203, 250);
   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 250);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 203, 250);
+
+  /* Japanese Extension Revision */
+  i = xv_jpext_width + xv_jprev_width + 30;
+
+  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
+       dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2+1, 220+1,252);
+  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
+       dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2+1, 220+1,252);
+
+  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2, 220, 250);
+  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2, 220, 250);
 
   strcpy(str,"Press <right> mouse button for menu.");
   DrawStr2Pic(str, DWIDE/2+1, 241+1, dfltpic, DWIDE, DHIGH, 252);
@@ -194,15 +209,23 @@
 	   dfltpic, DWIDE, DHIGH, DWIDE/2, 160, 102);
 
   xbm2pic((byte *) xv_cpyrt_bits, xv_cpyrt_width, xv_cpyrt_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2, 203, 102);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2, 194, 102);
 
   i = xv_ver_width + xv_rev_width + 30;
 
   xbm2pic((byte *) xv_ver_bits, xv_ver_width, xv_ver_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 220, 102);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_ver_width/2, 209, 102);
 
   xbm2pic((byte *) xv_rev_bits, xv_rev_width, xv_rev_height, 
-	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 220, 102);
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_rev_width/2, 209, 102);
+
+  /* Japanese Extension Revision */
+  i = xv_jpext_width + xv_jprev_width + 30;
+
+  xbm2pic((byte *) xv_jpext_bits, xv_jpext_width, xv_jpext_height, 
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 - (i/2) + xv_jpext_width/2, 222, 102);
+  xbm2pic((byte *) xv_jprev_bits, xv_jprev_width, xv_jprev_height, 
+	   dfltpic, DWIDE, DHIGH, DWIDE/2 + (i/2) - xv_jprev_width/2, 222, 102);
 
   strcpy(str,"Press <right> mouse button for menu.");
   DrawStr2Pic(str, DWIDE/2, 241, dfltpic, DWIDE, DHIGH, 102);
diff -Naur xv-3.10a.old/xvdial.c xv-3.10a/xvdial.c
--- xv-3.10a.old/xvdial.c	Wed Jan  4 06:20:31 1995
+++ xv-3.10a/xvdial.c	Tue Apr 24 09:37:06 2001
@@ -41,20 +41,21 @@
 
 
 /* local functions */
-static int  whereInDial     PARM((DIAL *, int, int));
-static void drawArrow       PARM((DIAL *));
-static void drawValStr      PARM((DIAL *));
-static void drawButt        PARM((DIAL *, int, int));
-static int  computeDialVal  PARM((DIAL *, int, int));
-static void dimDial         PARM((DIAL *));
+static int    whereInDial     PARM((DIAL *, int, int));
+static void   drawArrow       PARM((DIAL *));
+static void   drawValStr      PARM((DIAL *));
+static void   drawButt        PARM((DIAL *, int, int));
+static double computeDialVal  PARM((DIAL *, int, int));
+static void   dimDial         PARM((DIAL *));
 
 
 /***************************************************/
-void DCreate(dp, parent, x, y, w, h, minv, maxv, curv, page, 
+void DCreate(dp, parent, x, y, w, h, minv, maxv, curv, inc, page, 
 	          fg, bg, hi, lo, title, units)
 DIAL         *dp;
 Window        parent;
-int           x,y,w,h,minv,maxv,curv,page;
+int           x,y,w,h;
+double        minv,maxv,curv,inc,page;
 unsigned long fg,bg,hi,lo;
 char         *title, *units;
 {
@@ -98,18 +99,18 @@
 				1,fg,bg);
   if (!dp->win) FatalError("can't create dial window");
 
-  DSetRange(dp, minv, maxv, curv, page);
+  DSetRange(dp, minv, maxv, curv, inc, page);
   XSelectInput(theDisp, dp->win, ExposureMask | ButtonPressMask);
 }
 
 
 /***************************************************/
-void DSetRange(dp, minv, maxv, curv, page)
-DIAL *dp;
-int   minv, maxv, curv, page;
+void DSetRange(dp, minv, maxv, curv, inc, page)
+DIAL   *dp;
+double  minv, maxv, curv, inc, page;
 {
   if (maxv<minv) maxv=minv;
-  dp->min = minv;    dp->max = maxv;    dp->page = page;
+  dp->min = minv; dp->max = maxv; dp->inc = inc; dp->page = page;
   dp->active =  (minv < maxv);
 
   DSetVal(dp, curv);
@@ -118,8 +119,8 @@
 
 /***************************************************/
 void DSetVal(dp, curv)
-DIAL *dp;
-int   curv;
+DIAL  *dp;
+double curv;
 {
   RANGE(curv, dp->min, dp->max);   /* make sure curv is in-range */
 
@@ -129,7 +130,7 @@
   XSetForeground(theDisp, theGC, dp->bg); 
   drawArrow(dp);
 
-  dp->val = curv;
+  dp->val = (double)((int)(curv / dp->inc + (curv > 0 ? 0.5 : -0.5))) * dp->inc;
 
   /* draw new arrow and string */
   XSetForeground(theDisp, theGC, dp->fg);
@@ -202,7 +203,8 @@
 int mx,my;
 {
   Window       rW,cW;
-  int          rx,ry, x,y, ipos, pos, lit, i, origval;
+  int          rx, ry, x, y, ipos, pos, lit;
+  double       origval;
   unsigned int mask;
 
   lit = 0;
@@ -224,9 +226,9 @@
   if (ipos != INDIAL) {
     drawButt(dp, ipos, 1);
     switch (ipos) {
-    case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+1); break;
+    case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+dp->inc);  break;
     case INCW2:  if (dp->val < dp->max) DSetVal(dp, dp->val+dp->page); break;
-    case INCCW1: if (dp->val > dp->min) DSetVal(dp, dp->val-1); break;
+    case INCCW1: if (dp->val > dp->min) DSetVal(dp, dp->val-dp->inc);  break;
     case INCCW2: if (dp->val > dp->min) DSetVal(dp, dp->val-dp->page); break;
     }
     if (dp->drawobj != NULL) (dp->drawobj)();  
@@ -235,8 +237,9 @@
   }
 
   else { 
-    i = computeDialVal(dp, mx, my);
-    DSetVal(dp, i);
+    double v;
+    v = computeDialVal(dp, mx, my);
+    DSetVal(dp, v);
     if (dp->drawobj != NULL) (dp->drawobj)();  
   }
 
@@ -246,11 +249,11 @@
     if (!(mask & Button1Mask)) break;    /* button released */
 
     if (ipos == INDIAL) {
-      int j;
-      i = computeDialVal(dp, x, y);
-      j = dp->val;
-      DSetVal(dp, i);
-      if (j != dp->val) {
+      double v, w;
+      v = computeDialVal(dp, x, y);
+      w = dp->val;
+      DSetVal(dp, v);
+      if (w != dp->val) {
 	/* track whatever dial controls */
 	if (dp->drawobj != NULL) (dp->drawobj)();  
       }
@@ -266,11 +269,11 @@
 
       if (lit) {
 	switch (ipos) {
-	case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+1); 
+	case INCW1:  if (dp->val < dp->max) DSetVal(dp, dp->val+dp->inc); 
 	             break;
 	case INCW2:  if (dp->val < dp->max) DSetVal(dp, dp->val+dp->page);
                      break;
-	case INCCW1: if (dp->val > dp->min) DSetVal(dp, dp->val-1);
+	case INCCW1: if (dp->val > dp->min) DSetVal(dp, dp->val-dp->inc);
                      break;
 	case INCCW2: if (dp->val > dp->min) DSetVal(dp, dp->val-dp->page);
                      break;
@@ -320,19 +323,20 @@
 static void drawArrow(dp)
 DIAL *dp;
 {
-  int i, rad, cx, cy;
+  int rad, cx, cy;
+  double v;
   XPoint arrow[4];
 
   rad = dp->rad;  cx = dp->cx;  cy = dp->cy;
 
   /* map pos (range minv..maxv) into degrees (range 240..-60) */
-  i = 240 + (-300 * (dp->val - dp->min)) / (dp->max - dp->min);
-  arrow[0].x = cx + (int) ((double) rad * .80 * cos(i * DEG2RAD));
-  arrow[0].y = cy - (int) ((double) rad * .80 * sin(i * DEG2RAD));
-  arrow[1].x = cx + (int) ((double) rad * .33 * cos((i+160) * DEG2RAD));
-  arrow[1].y = cy - (int) ((double) rad * .33 * sin((i+160) * DEG2RAD));
-  arrow[2].x = cx + (int) ((double) rad * .33 * cos((i-160) * DEG2RAD));
-  arrow[2].y = cy - (int) ((double) rad * .33 * sin((i-160) * DEG2RAD));
+  v = 240 + (-300 * (dp->val - dp->min)) / (dp->max - dp->min);
+  arrow[0].x = cx + (int) ((double) rad * .80 * cos(v * DEG2RAD));
+  arrow[0].y = cy - (int) ((double) rad * .80 * sin(v * DEG2RAD));
+  arrow[1].x = cx + (int) ((double) rad * .33 * cos((v+160) * DEG2RAD));
+  arrow[1].y = cy - (int) ((double) rad * .33 * sin((v+160) * DEG2RAD));
+  arrow[2].x = cx + (int) ((double) rad * .33 * cos((v-160) * DEG2RAD));
+  arrow[2].y = cy - (int) ((double) rad * .33 * sin((v-160) * DEG2RAD));
   arrow[3].x = arrow[0].x;
   arrow[3].y = arrow[0].y;
   XDrawLines(theDisp, dp->win, theGC, arrow, 4, CoordModeOrigin);
@@ -343,23 +347,37 @@
 static void drawValStr(dp)
 DIAL *dp;
 {
-  int  i, x1, x2;
+  int  tot, i, x1, x2;
   char foo[60], foo1[60];
 
   /* compute longest string necessary so we can right-align this thing */
-  sprintf(foo,"%d",dp->min);    x1 = strlen(foo);
-  sprintf(foo,"%d",dp->max);    x2 = strlen(foo);
+  sprintf(foo,"%d",(int)dp->min);    x1 = strlen(foo);
+  sprintf(foo,"%d",(int)dp->max);    x2 = strlen(foo);
   if (dp->min < 0 && dp->max > 0) x2++;   /* put '+' at beginning */
   i = x1;  if (x2>x1) i = x2;
   if (dp->units) i += strlen(dp->units);
 
-  if (dp->min < 0 && dp->max > 0) sprintf(foo,"%+d", dp->val);
-  else sprintf(foo,"%d", dp->val);
+  sprintf(foo,"%g",dp->inc);   /* space for decimal values */
+  tot = i + strlen(foo) - 1;   /* Take away the 0 from the beginning */
+
+  if (dp->min < 0.0 && dp->max > 0.0) sprintf(foo,"%+g", dp->val);
+  else sprintf(foo,"%g", dp->val);
+
+  if (dp->inc < 1.0)
+  {
+    int j;
+
+    if (dp->val == (double)((int)dp->val))
+      strcat(foo,".");
+
+    for (j = strlen(foo); j < tot; j++)
+      strcat(foo,"0");
+  }
 
   if (dp->units) strcat(foo,dp->units);
   foo1[0] = '\0';
   if (strlen(foo) < (size_t) i) {
-    for (i = i - strlen(foo); i>0; i--) strcat(foo1," ");
+    for (i-=strlen(foo);i>0;i--) strcat(foo1," ");
   }
   strcat(foo1, foo);
 
@@ -411,12 +429,13 @@
 
 
 /***************************************************/
-static int computeDialVal(dp, x, y)
+static double computeDialVal(dp, x, y)
 DIAL *dp;
 int x, y;
 {
-  int dx, dy, val;
-  double angle;
+  int dx, dy;
+ 
+  double angle, val;
 
   /* compute dx, dy (distance from cx, cy).  Note: +dy is *up* */
   dx = x - dp->cx;  dy = dp->cy - y;
@@ -436,8 +455,10 @@
   if (angle > 270.0) angle -= 360.0;
   if (angle < -90.0) angle += 360.0;
 
-  val = (int) ((dp->max - dp->min) * (240.0 - angle) / 300.0) + dp->min;
+  val = ((dp->max - dp->min) * (240.0 - angle) / 300.0) + dp->min;
 
+  /* round value to be an even multiple of dp->inc */
+  val = (double)((int)(val / dp->inc + 0.5)) * dp->inc;
   return val;
 }
 
diff -Naur xv-3.10a.old/xvdir.c xv-3.10a/xvdir.c
--- xv-3.10a.old/xvdir.c	Wed Jan  4 06:21:39 1995
+++ xv-3.10a/xvdir.c	Tue Apr 24 09:37:06 2001
@@ -62,6 +62,9 @@
 #ifdef HAVE_TIFF
 			       "TIFF",
 #endif
+#ifdef HAVE_PNG
+			       "PNG",
+#endif
 			       "PostScript",
 			       "PBM/PGM/PPM (raw)",
 			       "PBM/PGM/PPM (ascii)",
@@ -73,6 +76,24 @@
 			       "Targa (24-bit)",
 			       "FITS",
 			       "PM",
+#ifdef HAVE_MAG
+			       "MAG",
+#endif /* HAVE_MAG */
+#ifdef HAVE_PIC
+			       "PIC",
+#endif /* HAVE_PIC */
+#ifdef HAVE_MAKI
+			       "MAKI",
+#endif /* HAVE_MAKI */
+#ifdef HAVE_PI
+			       "PI",
+#endif /* HAVE_PI */
+#ifdef HAVE_PIC2
+			       "PIC2",
+#endif /* HAVE_PIC2 */
+#ifdef HAVE_MGCSFX
+			       "MgcSfx",
+#endif /* HAVE_MGCSFX */
 			       MBSEP,
 			       "Filename List"};
 
@@ -571,7 +592,11 @@
     }
 #endif
 
+#ifdef AUTO_EXPAND
+    if (Chvdir(tmppath)) {
+#else
     if (chdir(tmppath)) {
+#endif
       char str[512];
       sprintf(str,"Unable to cd to '%s'\n", tmppath);
       *trunc_point = '/';  /* restore the path */
@@ -636,7 +661,11 @@
   xv_getwd(path, sizeof(path));
 #endif
 
+#ifdef AUTO_EXPAND
+  if (Chvdir(path)) {
+#else
   if (chdir(path)) {
+#endif
     ErrPopUp("Current load/save directory seems to have gone away!",
 	     "\nYikes!");
 #ifdef apollo
@@ -644,7 +673,11 @@
 #else
     strcpy(path,"/");
 #endif
+#ifdef AUTO_EXPAND
+    Chvdir(path);
+#else
     chdir(path);
+#endif
   }
 
   changedDir = strcmp(path, oldpath);
@@ -749,6 +782,9 @@
 	else if (S_ISFIFO(ftype)) fnames[i][0] = C_FIFO;
 	else if (S_ISSOCK(ftype)) fnames[i][0] = C_SOCK;
         else if (fnames[i][0] == C_REG && (mode&0111)) fnames[i][0] = C_EXE;
+#ifdef AUTO_EXPAND
+	else if (Isarchive(fnames[i]+1)) fnames[i][0] = C_DIR;
+#endif
       }
       else {
 	/* fprintf(stderr,"problems 'stat-ing' files\n");*/
@@ -1054,12 +1090,40 @@
 
   fullname = GetDirFullName();
 
+#ifdef AUTO_EXPAND
+  {
+      char path[MAXPATHLEN];
+
+      GetDirPath(path);
+      Mkvdir(path);
+      if ((i = Isvdir(fullname)) & 01) {
+	  char buf[128];
+	  sprintf(buf,
+		  "Sorry, you can't save file in the virtual directory, '%s'",
+		  path);
+	  ErrPopUp(buf, "\nBummer!");
+	  return -1;
+      }
+      if (i & 06)
+	  Rmvdir(fullname);
+  }
+#endif
+
   fmt = MBWhich(&fmtMB);
   col = MBWhich(&colMB);
 
   if (fmt<0 || col<0) 
     FatalError("xv: no 'checked' format or color.  shouldn't happen!\n");
 
+#ifdef HAVE_PNG
+  else if (fmt == F_PNG) {   /* PNG */
+    PNGSaveParams(fullname, col);
+    PNGDialog(1);                   /* open PNG Dialog box */
+    dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
+    return 0;                      /* always 'succeeds' */
+  }
+#endif
+
 
   if (fmt == F_FILELIST) {       /* write filename list */
     fp = OpenOutFile(fullname);
@@ -1115,7 +1179,25 @@
   }
 #endif
 
+#ifdef HAVE_PIC2
+  else if (fmt == F_PIC2) {   /* PIC2 */
+    if (PIC2SaveParams(fullname, col) < 0)
+	return 0;
+    PIC2Dialog(1);                   /* open PIC2 Dialog box */
+    dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
+    return 0;                      /* always 'succeeds' */
+  }
+#endif /* HAVE_PIC2 */
 
+#ifdef HAVE_MGCSFX
+  else if (fmt == F_MGCSFX) {   /* MGCSFX */
+    if (MGCSFXSaveParams(fullname, col) < 0)
+	return 0;
+    MGCSFXDialog(1);                   /* open MGCSFX Dialog box */
+    dbut[S_BOK].lit = 0;  BTRedraw(&dbut[S_BOK]);
+    return 0;                      /* always 'succeeds' */
+  }
+#endif /* HAVE_MGCSFX */
 
 
   WaitCursor();
@@ -1169,12 +1251,34 @@
   case F_XPM:
     rv = WriteXPM   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
 		     fullname, picComments);    
+    break;
   case F_FITS:
     rv = WriteFITS  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
 		     picComments);    
     break;
+#ifdef HAVE_MAG
+  case F_MAG:
+    rv = WriteMAG   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
+		     picComments);    break;
+#endif /* HAVE_MAG */
+#ifdef HAVE_PIC
+  case F_PIC:
+    rv = WritePIC   (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
+		     picComments);    break;
+#endif /* HAVE_PIC */
+#ifdef HAVE_MAKI
+  case F_MAKI:
+    rv = WriteMAKI  (fp, thepic, ptype, w, h, rp, gp, bp, nc, col);    break;
+#endif /* HAVE_MAKI */
+
+#ifdef HAVE_PI
+  case F_PI:
+    rv = WritePi    (fp, thepic, ptype, w, h, rp, gp, bp, nc, col, 
+		     picComments);    break;
+#endif /* HAVE_PI */
+
   }
-  
+
 
   if (CloseOutFile(fp, fullname, rv) == 0) {
     DirBox(0);
@@ -1200,6 +1304,7 @@
      char *st;
 {
   strncpy(deffname, st, (size_t) MAXFNLEN-1);
+  deffname[MAXFNLEN-1] = '\0';
   setFName(st);
 }
 
@@ -1383,11 +1488,24 @@
       (strcmp(lowsuf,"xpm" )==0) ||
       (strcmp(lowsuf,"fits")==0) ||
       (strcmp(lowsuf,"fts" )==0) ||
+#ifdef HAVE_JPEG
       (strcmp(lowsuf,"jpg" )==0) ||
       (strcmp(lowsuf,"jpeg")==0) ||
       (strcmp(lowsuf,"jfif")==0) ||
+#endif
+#ifdef HAVE_TIFF
       (strcmp(lowsuf,"tif" )==0) ||
-      (strcmp(lowsuf,"tiff")==0)) {
+      (strcmp(lowsuf,"tiff")==0) ||
+#endif
+#ifdef HAVE_PNG
+      (strcmp(lowsuf,"png" )==0) ||
+#endif
+      (strcmp(lowsuf,"mag" )==0) ||
+      (strcmp(lowsuf,"pic" )==0) ||
+      (strcmp(lowsuf,"mki" )==0) ||
+      (strcmp(lowsuf,"pi"  )==0) ||
+      (strcmp(lowsuf,"p2"  )==0) ||
+      (strcmp(lowsuf,"pcd" )==0)){
 
     /* found one.  set lowsuf = to the new suffix, and tack on to filename */
 
@@ -1423,8 +1541,33 @@
 #ifdef HAVE_TIFF
     case F_TIFF:     strcpy(lowsuf,"tif");  break;
 #endif
+
+#ifdef HAVE_PNG
+    case F_PNG:      strcpy(lowsuf,"png");  break;
+#endif
+
+#ifdef HAVE_MAG
+    case F_MAG:      strcpy(lowsuf,"mag");  break;
+#endif /* HAVE_MAG */
+
+#ifdef HAVE_PIC
+    case F_PIC:      strcpy(lowsuf,"pic");  break;
+#endif /* HAVE_PIC */
+
+#ifdef HAVE_MAKI
+    case F_MAKI:     strcpy(lowsuf,"mki");  break;
+#endif /* HAVE_MAKI */
+
+#ifdef HAVE_PI
+    case F_PI:       strcpy(lowsuf,"pi");   break;
+#endif /* HAVE_PI */
+
+#ifdef HAVE_PIC2
+    case F_PIC2:     strcpy(lowsuf,"p2");   break;
+#endif /* HAVE_PIC2 */
     }
 
+
     if (allcaps) {  /* upper-caseify lowsuf */
       for (sp=lowsuf; *sp; sp++) 
 	*sp = (islower(*sp)) ? toupper(*sp) : *sp;
@@ -1490,6 +1633,11 @@
   }
 #endif
 
+#ifdef AUTO_EXPAND
+  Mkvdir(newpath);
+  Dirtovd(newpath);
+#endif
+
   if (stat(newpath, &st)==0) {
     int isdir;
 
@@ -1587,7 +1735,11 @@
   dopipe = 0;
 
   /* make sure we're in the correct directory */
+#ifdef AUTO_EXPAND
+  if (strlen(path)) Chvdir(path);
+#else
   if (strlen(path)) chdir(path);
+#endif
 
   if (ISPIPE(filename[0])) {   /* do piping */
     /* make up some bogus temp file to put this in */
@@ -2062,3 +2214,150 @@
 }
 
 
+#ifdef HAVE_PIC2
+/**** Stuff for PIC2Dialog box ****/
+FILE *pic2_OpenOutFile(filename, append)
+char *filename;
+int *append;
+{
+    /* opens file for output.  does various error handling bits.  Returns
+       an open file pointer if success, NULL if failure */
+
+    FILE *fp;
+    struct stat st;
+
+    if (!filename || filename[0] == '\0')
+	return (NULL);
+    strcpy(outFName, filename);
+    dopipe = 0;
+
+    /* make sure we're in the correct directory */
+#ifdef AUTO_EXPAND
+    if (strlen(path)) Chvdir(path);
+#else
+    if (strlen(path)) chdir(path);
+#endif
+
+    if (ISPIPE(filename[0])) {   /* do piping */
+	/* make up some bogus temp file to put this in */
+#ifndef VMS
+	sprintf(outFName, "%s/xvXXXXXX", tmpdir);
+#else
+	strcpy(outFName, "[]xvXXXXXX.lis");
+#endif
+	mktemp(outFName);
+	dopipe = 1;
+    }
+
+
+    /* see if file exists (ie, we're overwriting) */
+    *append = 0;
+    if (stat(outFName, &st)==0)     /* stat succeeded, file must exist */
+	if (ReadFileType(outFName) != RFT_PIC2) {
+	    static char *foo[] = { "\nOk", "\033Cancel" };
+	    char str[512];
+
+	    sprintf(str,"Overwrite existing file '%s'?", outFName);
+	    if (PopUp(str, foo, 2))
+		return (NULL);
+	} else {
+	    static char *foo[] = { "\nOk", "\033Cancel" };
+	    char str[512];
+
+	    sprintf(str,"Append to existing file '%s'?", outFName);
+	    if (PopUp(str, foo, 2)) {
+		sprintf(str,"Overwrite existing file '%s'?", outFName);
+		if (PopUp(str, foo, 2))
+		    return (NULL);
+	    } else
+		*append = 1;
+	}
+
+    
+    /* Open file */
+    fp = *append ? fopen(outFName, "r+") : fopen(outFName, "w");
+    if (!fp) {
+	char  str[512];
+	sprintf(str,"Can't write file '%s'\n\n  %s.",outFName, ERRSTR(errno));
+	ErrPopUp(str, "\nBummer");
+	return (NULL);
+    }
+
+    return (fp);
+}
+
+
+/***************************************/
+void pic2_KillNullFile(fp)
+FILE *fp;
+{
+    fseek(fp, (size_t) 0, SEEK_END);
+    if (ftell(fp) > 0) {
+	fclose(fp);
+	return;
+    } else {
+	fclose(fp);
+	unlink(outFName);
+	return;
+    }
+}
+#endif /* HAVE_PIC2 */
+
+
+#ifdef HAVE_MGCSFX
+/**** Stuff for MGCSFX Dialog box ****/
+/***************************************/
+int OpenOutFileDesc(filename)
+     char *filename;
+{
+  /* opens file for output.  does various error handling bits.  Returns
+     an open file pointer if success, NULL if failure */
+
+  int         fd;
+  struct stat st;
+
+  if (!filename || filename[0] == '\0') return -1;
+  strcpy(outFName, filename);
+  dopipe = 0;
+
+  /* make sure we're in the correct directory */
+#ifdef AUTO_EXPAND
+  if (strlen(path)) Chvdir(path);
+#else
+  if (strlen(path)) chdir(path);
+#endif
+
+  if (ISPIPE(filename[0])) {   /* do piping */
+    /* make up some bogus temp file to put this in */
+#ifndef VMS
+    sprintf(outFName, "%s/xvXXXXXX", tmpdir);
+#else
+    strcpy(outFName, "[]xvXXXXXX.lis");
+#endif
+    mktemp(outFName);
+    dopipe = 1;
+  }
+
+
+  /* see if file exists (ie, we're overwriting) */
+  if (stat(outFName, &st)==0) {   /* stat succeeded, file must exist */
+    static char *foo[] = { "\nOk", "\033Cancel" };
+    char str[512];
+
+    sprintf(str,"Overwrite existing file '%s'?", outFName);
+    if (PopUp(str, foo, 2)) return -1;
+  }
+
+
+  /* Open file */
+  fd = open(outFName, O_WRONLY | O_CREAT | O_TRUNC, (0644));
+  if (fd < 0) {
+    char  str[512];
+    sprintf(str,"Can't write file '%s'\n\n  %s.",outFName, ERRSTR(errno));
+    ErrPopUp(str, "\nBummer");
+    return -1;
+  }
+
+  return fd;
+}
+#endif /* HAVE_MGCSFX */
diff -Naur xv-3.10a.old/xvevent.c xv-3.10a/xvevent.c
--- xv-3.10a.old/xvevent.c	Tue Jan 24 08:20:24 1995
+++ xv-3.10a/xvevent.c	Tue Apr 24 09:37:06 2001
@@ -154,7 +154,9 @@
      int    *donep;
 {
   static int wasInfoUp=0, wasCtrlUp=0, wasDirUp=0, wasGamUp=0, wasPsUp=0;
-  static int wasJpegUp=0, wasTiffUp=0;
+  static int wasJpegUp=0, wasTiffUp=0, wasPngUp=0;
+  static int wasPic2Up=0, wasPcdUp=0;
+  static int wasMgcSfxUp=0;
 
   static int mainWKludge=0;  /* force first mainW expose after a mainW config
 				to redraw all of mainW */
@@ -233,6 +235,26 @@
     if (TIFFCheckEvent(event)) break;   /* event has been processed */
 #endif
 
+#ifdef HAVE_PIC2
+    if (PIC2CheckEvent(event)) break;   /* event has been processed */
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+    if (PCDCheckEvent (event)) break;   /* event has been processed */
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+    if (MGCSFXCheckEvent(event)) break; /* event has been processed */
+#endif /* HAVE_MGCSFX */
+
+#ifdef TV_MULTILINGUAL
+    if (CharsetCheckEvent(event)) break; /* event has been processed */
+#endif
+
+#ifdef HAVE_PNG
+    if (PNGCheckEvent (event)) break;   /* event has been processed */
+#endif
+
     if (GamCheckEvent (event)) break;   /* event has been processed */
     if (BrowseCheckEvent (event, &retval, &done)) break;   /* event eaten */
     if (TextCheckEvent   (event, &retval, &done)) break;   /* event eaten */
@@ -344,6 +366,9 @@
 
       if (BrowseDelWin(client_event->window)) break;
       if (TextDelWin(client_event->window)) break;
+#ifdef TV_MULTILINGUAL
+      if (CharsetDelWin(client_event->window)) break;
+#endif
 
       if      (client_event->window == infoW) InfoBox(0);
       else if (client_event->window == gamW)  GamBox(0);
@@ -359,6 +384,22 @@
       else if (client_event->window == tiffW) TIFFDialog(0);
 #endif
 
+#ifdef HAVE_PIC2
+      else if (client_event->window == pic2W) PIC2Dialog(0);
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+      else if (client_event->window == pcdW)  PCDDialog(0);
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+      else if (client_event->window == mgcsfxW) MGCSFXDialog(0);
+#endif /* HAVE_MGCSFX */
+
+#ifdef HAVE_PNG
+      else if (client_event->window == pngW)  PNGDialog(0);
+#endif
+
       else if (client_event->window == mainW) Quit(0);
     }
   }
@@ -538,6 +579,23 @@
 #ifdef HAVE_TIFF
 	if (wasTiffUp) { TIFFDialog(wasTiffUp);  wasTiffUp=0; }
 #endif
+
+#ifdef HAVE_PNG
+	if (wasPngUp)  { PNGDialog(wasJpegUp);   wasPngUp=0; }
+#endif
+
+#ifdef HAVE_PIC2
+	if (wasPic2Up) { PIC2Dialog(wasPic2Up);  wasPic2Up=0; }
+#endif /* HAVE_PIC2 */
+ 
+#ifdef HAVE_PCD
+	if (wasPcdUp)  { PCDDialog(wasPcdUp);    wasPcdUp=0; }
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+	if (wasMgcSfxUp) { MGCSFXDialog(wasMgcSfxUp);  wasMgcSfxUp=0; }
+#endif /* HAVE_MGCSFX */
+
       }
     }
   }
@@ -576,6 +634,23 @@
 #ifdef HAVE_TIFF
 	  if (tiffUp) { wasTiffUp = tiffUp;  TIFFDialog(0); }
 #endif
+
+#ifdef HAVE_PNG
+	if (pngUp)  { wasPngUp  = pngUp;   PNGDialog(0); }
+#endif
+
+#ifdef HAVE_PIC2
+	  if (pic2Up) { wasPic2Up = pic2Up;  PIC2Dialog(0); }
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+	  if (pcdUp)  { wasPcdUp = pcdUp;    PCDDialog(0); }
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+	  if (mgcsfxUp) { wasMgcSfxUp = mgcsfxUp;  MGCSFXDialog(0); }
+#endif /* HAVE_MGCSFX */
+
 	}
       }
     }
@@ -1146,7 +1221,31 @@
 #ifdef HAVE_TIFF
     if (TIFFCheckEvent(event)) break;
 #endif
+
+#ifdef HAVE_PNG
+    if (PNGCheckEvent (event)) break;
+#endif
     
+#ifdef HAVE_PIC2
+    if (PIC2CheckEvent(event)) break;
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+    if (PCDCheckEvent (event)) break;
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+    if (MGCSFXCheckEvent(event)) break;
+#endif /* HAVE_MGCSFX */
+
+#ifdef TV_MULTILINGUAL
+    if (CharsetCheckEvent(event)) break;
+#endif
+
+#ifdef HAVE_PNG
+    if (PNGCheckEvent (event)) break;
+#endif
+
     if (GamCheckEvent (event)) break;
     if (BrowseCheckEvent (event, &retval, &done)) break;
     if (TextCheckEvent   (event, &retval, &done)) break;
@@ -1170,6 +1269,12 @@
 	  if (i>=0) DoAlg(i);
 	  break;
 	}
+
+	else if (MBClick(&flmaskMB, x,y)) {
+	  i = MBTrack(&flmaskMB);
+	  if (i>=0) DoMask(i);
+	  break;
+	}
 	
 	i=ClickCtrl(x,y);
 	
@@ -1196,6 +1301,7 @@
 	case BCROP:   Crop();                       break;
 	case BUNCROP: UnCrop();                     break;
 	case BACROP:  AutoCrop();                   break;
+	case BMASKS:  MaskCr();			    break;	
 	  
 	case BPAD:
 	  {
@@ -1366,6 +1472,18 @@
     if (TIFFCheckEvent(event)) break;
 #endif
 
+#ifdef HAVE_PIC2
+    if (PIC2CheckEvent(event)) break;
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+    if (PCDCheckEvent (event)) break;
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+    if (MGCSFXCheckEvent(event)) break;
+#endif /* HAVE_MGCSFX */
+
     if (GamCheckEvent (event)) break;
     if (BrowseCheckEvent (event, &retval, &done)) break;
     if (TextCheckEvent   (event, &retval, &done)) break;
@@ -1500,12 +1618,23 @@
       else if (ks==XK_d) FakeButtonPress(&but[BCLEAR]);
 
       else if (ks==XK_u) DoAlg(ALG_NONE);
+
+      else if (ks==XK_f) DoMask(MSK_FLMASK);
+      else if (ks==XK_g) DoMask(MSK_Q0MASK);
+      else if (ks==XK_h) DoMask(MSK_WIN);
+      else if (ks==XK_i) DoMask(MSK_MEKO);
+      else if (ks==XK_j) DoMask(MSK_CPMASK);
+      else if (ks==XK_l) DoMask(MSK_RGB);
+      else if (ks==XK_n) DoMask(MSK_BITREV);
+      else if (ks==XK_w) DoMask(MSK_COLREV);
+
       else if (ks==XK_b) DoAlg(ALG_BLUR);
       else if (ks==XK_s) DoAlg(ALG_SHARPEN);
       else if (ks==XK_e) DoAlg(ALG_EDGE);
       else if (ks==XK_m) DoAlg(ALG_TINF);
       else if (ks==XK_o) DoAlg(ALG_OIL);
       else if (ks==XK_k) DoAlg(ALG_MEDIAN);
+      else if (ks==XK_q) DoAlg(ALG_Q0);
 
       else if ((ks==XK_B  || (ks==XK_b && shift)) && HaveSelection())
 	                                        DoAlg(ALG_BLEND);
@@ -1538,7 +1667,7 @@
     }
     else {                               /* commands valid in any window */
       switch (buf[0]) {
-	
+
 	/* things in dispMB */
       case 'r':    SelectDispMB(DMB_RAW);           break;
       case 'd':    SelectDispMB(DMB_DITH);          break;
@@ -1602,6 +1731,7 @@
       case 'c':    FakeButtonPress(&but[BCROP]);    break;
       case 'u':    FakeButtonPress(&but[BUNCROP]);  break;
       case 'C':    FakeButtonPress(&but[BACROP]);   break;
+      case 'f':    FakeButtonPress(&but[BMASKS]);   break;
       case 'P':    FakeButtonPress(&but[BPAD]);     break;
       case 'A':    FakeButtonPress(&but[BANNOT]);   break;
 	
@@ -2371,6 +2501,22 @@
 #ifdef HAVE_TIFF
   if (tiffUp) TIFFDialog(0);  /* close tiff window */
 #endif
+
+#ifdef HAVE_PNG
+  if (pngUp) PNGDialog(0);    /* close png window */
+#endif
+
+#ifdef HAVE_PIC2
+  if (pic2Up) PIC2Dialog(0);  /* close pic2 window */
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+  if (pcdUp)  PCDDialog(0);   /* close pcd window */
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+  if (mgcsfxUp) MGCSFXDialog(0);  /* close mgcsfx window */
+#endif /* HAVE_MGCSFX */
 
   ClosePopUp();
 
diff -Naur xv-3.10a.old/xvgam.c xv-3.10a/xvgam.c
--- xv-3.10a.old/xvgam.c	Sat Jan 14 04:51:14 1995
+++ xv-3.10a/xvgam.c	Tue Apr 24 09:37:06 2001
@@ -265,11 +265,11 @@
   BTCreate(&gbut[G_BRNDCOL], cmapF,  5 + 66 + 67 + 2, 189, 66, BUTTH, 
 	   "Random", infofg, infobg, hicol, locol);
 
-  DCreate(&rhDial, cmapF, 5, 215, 66, 100,   0,360,180, 5, 
+  DCreate(&rhDial, cmapF, 5, 215, 66, 100,   0.0, 360.0, 180.0, 1.0, 5.0, 
 	  infofg, infobg, hicol, locol, "Hue", NULL);
-  DCreate(&gsDial, cmapF, 72, 215, 66, 100,  0,360,180, 5, 
+  DCreate(&gsDial, cmapF, 72, 215, 66, 100,  0.0, 360.0, 180.0, 1.0, 5.0, 
 	  infofg, infobg, hicol, locol, "Sat.", NULL);
-  DCreate(&bvDial, cmapF, 139, 215, 66, 100,   0,360,180, 5, 
+  DCreate(&bvDial, cmapF, 139, 215, 66, 100, 0.0, 360.0, 180.0, 1.0, 5.0, 
 	  infofg, infobg, hicol, locol, "Value", NULL);
 
   rhDial.drawobj = gsDial.drawobj = bvDial.drawobj = dragEditColor;
@@ -359,7 +359,7 @@
 
   srcHD.drawobj = dstHD.drawobj = whtHD.drawobj = dragHueDial;
 
-  DCreate(&satDial, hsvF, 100, 199, 100, 121, -100, 100, 0, 5, 
+  DCreate(&satDial, hsvF, 100, 199, 100, 121, -100.0, 100.0, 0.0, 1.0, 5.0, 
 	   infofg, infobg,hicol,locol, "Saturation", "%");
 
   hueRB = RBCreate(NULL, hsvF,  7, 153, "1", 
@@ -722,7 +722,7 @@
 
   if (whtHD.enabCB.val && whtHD.satval) hsvnonlinear++;
 
-  if (satDial.val != 0) hsvnonlinear++;
+  if (satDial.val != 0.0) hsvnonlinear++;
 
   /* check intensity graf */
   for (i=0; i<256 && intGraf.func[i]==i; i++);
@@ -1291,14 +1291,14 @@
     rgb2hsv(rcmap[editColor], gcmap[editColor], bcmap[editColor], &h, &s, &v);
     if (h<0) h = 0;
 
-    DSetVal(&rhDial, (int) h);
-    DSetVal(&gsDial, (int) (s*100));
-    DSetVal(&bvDial, (int) (v*100));
+    DSetVal(&rhDial, h);
+    DSetVal(&gsDial, s*100);
+    DSetVal(&bvDial, v*100);
   }
   else {
-    DSetVal(&rhDial, rcmap[editColor]);
-    DSetVal(&gsDial, gcmap[editColor]);
-    DSetVal(&bvDial, bcmap[editColor]);
+    DSetVal(&rhDial, (double)rcmap[editColor]);
+    DSetVal(&gsDial, (double)gcmap[editColor]);
+    DSetVal(&bvDial, (double)bcmap[editColor]);
   }
 }
   
@@ -1310,16 +1310,15 @@
 
   if (hsvmode) {
     int rv, gv, bv;
-    hsv2rgb((double) rhDial.val, ((double) gsDial.val) / 100.0, 
-	    ((double) bvDial.val) / 100.0, &rv, &gv, &bv);
+    hsv2rgb(rhDial.val, gsDial.val / 100.0, bvDial.val / 100.0, &rv, &gv, &bv);
     rcmap[editColor] = rv;
     gcmap[editColor] = gv;
     bcmap[editColor] = bv;
   }
   else {
-    rcmap[editColor] = rhDial.val;
-    gcmap[editColor] = gsDial.val;
-    bcmap[editColor] = bvDial.val;
+    rcmap[editColor] = (int)rhDial.val;
+    gcmap[editColor] = (int)gsDial.val;
+    bcmap[editColor] = (int)bvDial.val;
   }
 }
 
@@ -1561,9 +1560,9 @@
     gsDial.title = "Green";
     bvDial.title = "Blue";
 		   
-    DSetRange(&rhDial, 0, 255, rcmap[editColor], 16);
-    DSetRange(&gsDial, 0, 255, gcmap[editColor], 16);
-    DSetRange(&bvDial, 0, 255, bcmap[editColor], 16);
+    DSetRange(&rhDial, 0.0, 255.0, (double)rcmap[editColor], 1.0, 16.0);
+    DSetRange(&gsDial, 0.0, 255.0, (double)gcmap[editColor], 1.0, 16.0);
+    DSetRange(&bvDial, 0.0, 255.0, (double)bcmap[editColor], 1.0, 16.0);
 
     XClearWindow(theDisp, rhDial.win);    DRedraw(&rhDial);
     XClearWindow(theDisp, gsDial.win);    DRedraw(&gsDial);
@@ -1581,9 +1580,9 @@
 	    &h, &s, &v);
 
     if (h<0.0) h = 0.0;
-    DSetRange(&rhDial, 0, 360, (int) h, 5);
-    DSetRange(&gsDial, 0, 100, (int) (s*100), 5);
-    DSetRange(&bvDial, 0, 100, (int) (v*100), 5);
+    DSetRange(&rhDial, 0.0, 360.0,     h, 1.0, 5.0);
+    DSetRange(&gsDial, 0.0, 100.0, s*100, 1.0, 5.0);
+    DSetRange(&bvDial, 0.0, 100.0, v*100, 1.0, 5.0);
 
     XClearWindow(theDisp, rhDial.win);    DRedraw(&rhDial);
     XClearWindow(theDisp, gsDial.win);    DRedraw(&gsDial);
@@ -1891,7 +1890,7 @@
     }
 
     /* apply satDial value to s */
-    s = s + ((double) satDial.val) / 100.0;
+    s = s + satDial.val / 100.0;
     if (s<0.0) s = 0.0;
     if (s>1.0) s = 1.0;
 
@@ -2007,7 +2006,7 @@
 
   gs->hueRBnum = RBWhich(hueRB);
 
-  gs->satval = satDial.val;
+  gs->satval = (int)satDial.val;
   GetGrafState(&intGraf,&gs->istate);
   GetGrafState(&rGraf,  &gs->rstate);
   GetGrafState(&gGraf,  &gs->gstate);
@@ -2064,8 +2063,8 @@
     changed++;
   }
     
-  if (gs->satval != satDial.val) {
-    DSetVal(&satDial,gs->satval);
+  if (gs->satval != (int)satDial.val) {
+    DSetVal(&satDial,(double)gs->satval);
     changed++;
   }
 
@@ -3200,7 +3199,7 @@
 
   if (whtHD.enabCB.val && whtHD.satval) hsvmod++;
 
-  if (satDial.val != 0) hsvmod++;
+  if (satDial.val != 0.0) hsvmod++;
 
   /* check intensity graf */
   for (i=0; i<256; i++) {
@@ -3284,7 +3283,7 @@
       }
 
       /* apply satDial value to s */
-      s = s + satDial.val;
+      s = s + (int)satDial.val;
       if (s<  0) s =   0;
       if (s>100) s = 100;
 
diff -Naur xv-3.10a.old/xvgif.c xv-3.10a/xvgif.c
--- xv-3.10a.old/xvgif.c	Wed Jan 11 04:54:41 1995
+++ xv-3.10a/xvgif.c	Tue Apr 24 09:37:05 2001
@@ -113,7 +113,8 @@
   int            aspect, gotimage;
 
   /* initialize variables */
-  BitOffset = XC = YC = Pass = OutCount = gotimage = 0;
+  BitOffset = XC = YC = OutCount = gotimage = 0;
+  Pass = -1;
   RawGIF = Raster = pic8 = NULL;
   gif89 = 0;
 
@@ -692,7 +693,12 @@
 {
   static byte *ptr = NULL;
   static int   oldYC = -1;
-  
+
+  if (Pass == -1) {  /* first time through - init stuff */
+    oldYC = -1;
+    Pass = 0;
+  }
+
   if (oldYC != YC) {  ptr = pic8 + YC * Width;  oldYC = YC; }
   
   if (YC<Height)
diff -Naur xv-3.10a.old/xvgrab.c xv-3.10a/xvgrab.c
--- xv-3.10a.old/xvgrab.c	Fri Dec 23 07:34:47 1994
+++ xv-3.10a/xvgrab.c	Tue Apr 24 09:37:06 2001
@@ -341,16 +341,16 @@
 	 ConfigureNotify on mainW */
 
       state = 0;
-      while (1) {
+      while (state != 3) {
 	XEvent event;
 	XNextEvent(theDisp, &event);
 	HandleEvent(&event, &i);
 
-	if (state==0 && event.type == MapNotify &&
-	    event.xmap.window == mainW) state = 1;
+	if (!(state&1) && event.type == MapNotify &&
+	    event.xmap.window == mainW) state |= 1;
 
-	if (state==1 && event.type == ConfigureNotify && 
-	    event.xconfigure.window == mainW) break;
+	if (!(state&2) && event.type == ConfigureNotify && 
+	    event.xconfigure.window == mainW) state |= 2;
       }
 
       if (DEBUG) fprintf(stderr,"==after remapping mainW, GOT Config.\n");
@@ -641,8 +641,27 @@
 
 
   bits_per_item = image->bitmap_unit;
-  bits_used = bits_per_item;
   bits_per_pixel = image->bits_per_pixel;
+
+
+  /* add code for freako 'exceed' server, where bitmapunit = 8
+     and bitsperpix = 32 (and depth=24)... */
+
+  if (bits_per_item < bits_per_pixel) {
+    bits_per_item = bits_per_pixel;
+  
+    /* round bits_per_item up to next legal value, if necc */
+    if      (bits_per_item <  8) bits_per_item = 8;
+    else if (bits_per_item < 16) bits_per_item = 16;
+    else                         bits_per_item = 32;
+  }
+
+
+  /* which raises the question:  how (can?) you ever have a 24 bits per pix,
+     (ie, 3 bytes, no alpha/padding) */
+
+
+  bits_used = bits_per_item;  /* so it will get a new item first time */
 
   if (bits_per_pixel == 32) pixmask = 0xffffffff;
   else pixmask = (((CARD32) 1) << bits_per_pixel) - 1;
diff -Naur xv-3.10a.old/xvimage.c xv-3.10a/xvimage.c
--- xv-3.10a.old/xvimage.c	Sat Jan 14 09:11:36 1995
+++ xv-3.10a/xvimage.c	Tue Apr 24 09:37:06 2001
@@ -45,7 +45,8 @@
 static int  doPadPaste        PARM((byte *, int, int, int, int));
 static int  ReadImageFile1    PARM((char *, PICINFO *));
 
-
+byte *origPic;
+int  origPicType;
 
 #define DO_CROP 0
 #define DO_ZOOM 1
@@ -910,6 +911,12 @@
   /* dir=0: 90 degrees clockwise, else 90 degrees counter-clockwise */
   WaitCursor();
   
+  if (origPic!=NULL) {
+	  int tmp_pw,tmp_ph;
+	  tmp_pw=pWIDE;
+	  tmp_ph=pHIGH;
+	  RotatePic(origPic,origPicType,&tmp_pw,&tmp_ph,dir);
+  }
   RotatePic(pic, picType, &pWIDE, &pHIGH, dir);
   
   /* rotate clipped version and modify 'clip' coords */
@@ -1736,10 +1743,12 @@
     if (xim->byte_order == MSBFirst) {
       for (i=wide*high, ip=imagedata; i>0; i--,pp++) {
 	if (((i+1)&0x1ffff) == 0) WaitCursor();
-	if (dithpic) {
-	  *ip++ = ((*pp) ? white : black) & 0xffff;
-	}
-	else *ip++ = xcolors[*pp] & 0xffff;
+
+	if (dithpic) xcol = ((*pp) ? white : black) & 0xffff;
+		else xcol = xcolors[*pp] & 0xffff;
+
+	*((unsigned char *)ip)++ = (xcol>>8) & 0xff;
+	*((unsigned char *)ip)++ = (xcol) & 0xff;
       }
     }
     else {   /* LSBFirst */
@@ -1749,8 +1758,8 @@
 	if (dithpic) xcol = ((*pp) ? white : black) & 0xffff;
 	        else xcol = xcolors[*pp];
 
-	/*  WAS *ip++ = ((xcol>>8) & 0xff) | ((xcol&0xff) << 8);  */
-	*ip++ = (unsigned short) (xcol);
+	*((unsigned char *)ip)++ = (xcol) & 0xff;
+	*((unsigned char *)ip)++ = (xcol>>8) & 0xff;
       }
     }
   }
@@ -2530,7 +2539,7 @@
 
   rv = 1;
 
-  if ((mode != PAD_LOAD) && (wide == pWIDE && high == pHIGH && opaque==100)) {
+  if ((mode != PAD_LOAD) && (wide == cWIDE && high == cHIGH && opaque==100)) {
     ErrPopUp("Padding to same size as pic while fully opaque has no effect.", 
 	     "\nI see");
     return 0;
@@ -2806,27 +2815,27 @@
 
   /* copy 'pic' centered onto pic24.  */
 
-  sx = (wide - pWIDE) / 2;
-  sy = (high - pHIGH) / 2;
+  sx = (wide - cWIDE) / 2;
+  sy = (high - cHIGH) / 2;
   
-  for (py = 0; py<pHIGH; py++) {
-    ProgressMeter(0, pHIGH-1, py, "Pad");
+  for (py = 0; py<cHIGH; py++) {
+    ProgressMeter(0, cHIGH-1, py, "Pad");
     if ((py & 0x1f)==0) WaitCursor();
 
     p24y = sy + py;
     if (p24y >= 0 && p24y < high) {
-      for (px=0; px<pWIDE; px++) {
+      for (px=0; px<cWIDE; px++) {
 	p24x = sx + px;
 	if (p24x >= 0 && p24x < wide) {
 	  p24 = pic24 + (p24y*wide  + p24x)*3;
 	  
 	  
 	  if (picType == PIC24) {                       /* src is PIC24 */
-	    pp  = pic + (py * pWIDE + px)  *3;
+	    pp  = cpic + (py * cWIDE + px)  *3;
 	    r = pp[0];  g = pp[1];  b = pp[2];
 	  }
 	  else {                                        /* src is PIC8 */
-	    pp  = pic + (py*pWIDE + px);
+	    pp  = cpic + (py*cWIDE + px);
 	    r = rMap[*pp];  g = gMap[*pp];  b = bMap[*pp];
 	  }
 	  
@@ -2967,7 +2976,7 @@
 
   ftype = ReadFileType(name);
 
-  if (ftype == RFT_COMPRESS) {    /* handle compressed/gzipped files */
+  if ((ftype == RFT_COMPRESS) || (ftype == RFT_BZIP2)) {    /* handle compressed/gzipped files */
 #ifdef VMS
     basefname[0] = '\0';
     strcpy(basefname, name);     /* remove trailing .Z */
@@ -2977,7 +2986,7 @@
     uncName = name;
 #endif
     
-    if (UncompressFile(uncName, uncompname)) {
+    if (UncompressFile(uncName, uncompname, ftype)) {
       ftype = ReadFileType(uncompname);
       readname = uncompname;
     }
diff -Naur xv-3.10a.old/xvjpeg.c xv-3.10a/xvjpeg.c
--- xv-3.10a.old/xvjpeg.c	Thu Jan  5 17:17:13 1995
+++ xv-3.10a/xvjpeg.c	Tue Apr 24 09:37:06 2001
@@ -51,11 +51,11 @@
 static    void         clickJD            PARM((int, int));
 static    void         doCmd              PARM((int));
 static    void         writeJPEG          PARM((void));
-METHODDEF void         xv_error_exit      PARM((j_common_ptr));
-METHODDEF void         xv_error_output    PARM((j_common_ptr));
-METHODDEF void         xv_prog_meter      PARM((j_common_ptr));
+METHODDEF(void)        xv_error_exit      PARM((j_common_ptr));
+METHODDEF(void)        xv_error_output    PARM((j_common_ptr));
+METHODDEF(void)        xv_prog_meter      PARM((j_common_ptr));
 static    unsigned int j_getc             PARM((j_decompress_ptr));
-METHODDEF boolean      xv_process_comment PARM((j_decompress_ptr));
+METHODDEF(boolean)     xv_process_comment PARM((j_decompress_ptr));
 static    int          writeJFIF          PARM((FILE *, byte *, int,int,int));
 
 
@@ -87,10 +87,10 @@
   
   XSelectInput(theDisp, jpegW, ExposureMask | ButtonPressMask | KeyPressMask);
   
-  DCreate(&qDial, jpegW, 10, 10, 80, 100, 1, 100, 75, 5, 
+  DCreate(&qDial, jpegW, 10, 10, 80, 100, 1.0, 100.0, 75.0, 1.0, 5.0, 
 	  infofg, infobg, hicol, locol, "Quality", "%");
   
-  DCreate(&smDial, jpegW, 120, 10, 80, 100, 0, 100, 0, 5, 
+  DCreate(&smDial, jpegW, 120, 10, 80, 100, 0.0, 100.0, 0.0, 1.0, 5.0, 
 	  infofg, infobg, hicol, locol, "Smoothing", "%");
   
   BTCreate(&jbut[J_BOK], jpegW, JWIDE-180-1, JHIGH-10-BUTTH-1, 80, BUTTH, 
@@ -400,7 +400,7 @@
 
 
 /**************************************************/
-METHODDEF void xv_error_exit(cinfo) 
+METHODDEF(void) xv_error_exit(cinfo) 
      j_common_ptr cinfo;
 {
   my_error_ptr myerr;
@@ -412,7 +412,7 @@
 
 
 /**************************************************/
-METHODDEF void xv_error_output(cinfo) 
+METHODDEF(void) xv_error_output(cinfo) 
      j_common_ptr cinfo;
 {
   my_error_ptr myerr;
@@ -426,7 +426,7 @@
 
 
 /**************************************************/
-METHODDEF void xv_prog_meter(cinfo)
+METHODDEF(void) xv_prog_meter(cinfo)
      j_common_ptr cinfo;
 {
   struct jpeg_progress_mgr *prog;
@@ -671,7 +671,7 @@
 
 
 /**************************************************/
-METHODDEF boolean xv_process_comment(cinfo)
+METHODDEF(boolean) xv_process_comment(cinfo)
      j_decompress_ptr cinfo;
 {
   int          length, hasnull;
@@ -759,8 +759,8 @@
 
 
   jpeg_set_defaults(&cinfo);
-  jpeg_set_quality(&cinfo, qDial.val, TRUE);
-  cinfo.smoothing_factor = smDial.val;
+  jpeg_set_quality(&cinfo, (int)qDial.val, TRUE);
+  cinfo.smoothing_factor = (int)smDial.val;
 
 
   jpeg_start_compress(&cinfo, TRUE);
@@ -769,7 +769,7 @@
   /*** COMMENT HANDLING ***/
 
   sprintf(xvcmt, "%sXV %s  Quality = %d, Smoothing = %d\n",
-	  CREATOR_STR, REVDATE, qDial.val, smDial.val);
+	  CREATOR_STR, REVDATE, (int)qDial.val, (int)smDial.val);
   
   if (picComments) {   /* append XV comment */
     char *sp, *sp1;  int done;
diff -Naur xv-3.10a.old/xvmag.c xv-3.10a/xvmag.c
--- xv-3.10a.old/xvmag.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvmag.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,867 @@
+/*
+ *  xvmag.c - load routine for `MAG' format pictures.
+ *
+ *  The `MAG' format is used by many Japanese personal computer users.
+ *  This program is based on MAGBIBLE.DOC which is the specification
+ *  for `MAG' format written by Woody RINN.  It is written in Japanese,
+ *  and exists in some anon-ftp sites.
+ */
+
+#include "xv.h"
+#include <setjmp.h>
+
+#ifdef HAVE_MAG
+
+typedef unsigned short data16;
+
+struct mag {
+    jmp_buf jmp;
+    FILE *fp;
+    long fsize;
+    int m_256, m_dig, m_8, m_200;
+    int x1, y1, x2, y2, left_pad, right_pad;
+    int p_width, p_height, width, height;
+    long h_off, a_off, a_size, b_off, b_size, p_off, p_size;
+    byte *a, *b, *p;
+};
+
+static void mag_open_file       PARM((struct mag*, char*));
+static void mag_read_check_data PARM((struct mag*));
+static void mag_read_comment    PARM((struct mag*, char**));
+static void mag_read_header     PARM((struct mag*));
+static void mag_read_palette    PARM((struct mag*, byte*, byte*, byte*));
+static void mag_read_flags      PARM((struct mag*));
+static void mag_read_pixel_data PARM((struct mag*));
+static void mag_expand_body     PARM((struct mag*, byte**));
+
+static void mag_compress_data    PARM((struct mag*, byte*));
+static void mag_write_check_data PARM((struct mag*));
+static void mag_write_comment    PARM((struct mag*, char *));
+static void mag_write_palette    PARM((struct mag*, int,
+				       byte*, byte*, byte*, int));
+static void mag_write_flags      PARM((struct mag*));
+static void mag_write_pixel_data PARM((struct mag*));
+static void mag_write_header     PARM((struct mag*));
+static void mag_set_double_word  PARM((long, byte *));
+
+static void mag_init_info        PARM((struct mag*));
+static void mag_cleanup_mag_info PARM((struct mag*, int));
+static void mag_cleanup_pinfo    PARM((PICINFO*));
+static void mag_memory_error     PARM((char*, char*));
+static void mag_error            PARM((struct mag*, int));
+static void mag_file_error       PARM((struct mag*, int));
+static void mag_file_warning     PARM((struct mag*, int));
+static void mag_show_struct      PARM((struct mag*));
+static void *mag_malloc          PARM((size_t, char*));
+static void *mag_realloc         PARM((void*, size_t, char*));
+
+
+static char *mag_id = "MAKI02  ";
+static struct{
+    int dx, dy;
+}points[16] = {
+    { 0,  0}, { 1,  0}, { 2,  0}, { 4,  0},
+    { 0,  1}, { 1,  1},
+    { 0,  2}, { 1,  2}, { 2,  2},
+    { 0,  4}, { 1,  4}, { 2,  4},
+    { 0,  8}, { 1,  8}, { 2,  8},
+    { 0, 16},
+};
+static int try[15] = {1, 4, 5, 6, 7, 9, 10, 2, 8, 11, 12, 13, 14, 3, 15};
+
+static char *mag_msgs[] = {
+    NULL,
+#define MAG_OPEN 1
+    "can't open file",
+#define MAG_CORRUPT 2
+    "file currupted.",
+#define MAG_FORMAT 3
+    "not MAG format.",
+#define MAG_WRITE 4
+    "write failed.",
+};
+
+
+#define H4(x) (((int) (x) >> 4) & 0x0f)	/* operates on a byte */
+#define L4(x) ((x) & 0x0f)
+#define H8(x) (((x) >> 8) & 0xff)	/* operates on a data16 */
+#define L8(x) ((x) & 0xff)
+
+#define error(msgnum) longjmp(mi->jmp, msgnum)
+
+
+/* The main routine to load a MAG file. */
+int LoadMAG(fname, pinfo)
+    char *fname;
+    PICINFO *pinfo;
+{
+    struct mag mag;
+    int e;
+    
+    if(DEBUG) fputs("LoadMAG:\n", stderr);
+    
+    pinfo->comment = NULL;
+    mag_init_info(&mag);
+    if((e = setjmp(mag.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	mag_cleanup_mag_info(&mag, 0);
+	mag_cleanup_pinfo(pinfo);
+	return 0;
+    }
+    
+    mag_open_file(&mag, fname);
+    mag_read_check_data(&mag);
+    mag_read_comment(&mag, &pinfo->comment);
+    mag_read_header(&mag);
+    mag_read_palette(&mag, pinfo->r, pinfo->g, pinfo->b);
+    mag_read_flags(&mag);
+    mag_read_pixel_data(&mag);
+    mag_expand_body(&mag, &pinfo->pic);
+    
+    pinfo->w = pinfo->normw = mag.width;
+    pinfo->h = pinfo->normh = mag.height;
+    pinfo->type = PIC8;
+    pinfo->frmType = F_MAG;
+    pinfo->colType = F_FULLCOLOR;
+    sprintf(pinfo->fullInfo, "MAG, %d colors%s (%ld bytes)",
+	    mag.m_256 ? 256 : (mag.m_8 ? 8 : 16),
+	    mag.m_200 ? ", aspect 0.5" : "", mag.fsize);
+    sprintf(pinfo->shrtInfo, "%dx%d MAG", mag.width, mag.height);
+    if(mag.m_200)
+	normaspect = 0.5;
+    
+    mag_cleanup_mag_info(&mag, 0);
+    return 1;
+}
+
+static void mag_open_file(mi, fname)
+    struct mag *mi;
+    char *fname;
+{
+    if((mi->fp = fopen(fname, "rb")) == NULL)
+	mag_file_error(mi, MAG_OPEN);
+    fseek(mi->fp, (size_t) 0, SEEK_END);
+    mi->fsize = ftell(mi->fp);
+    fseek(mi->fp, (size_t) 0, SEEK_SET);
+}
+
+static void mag_read_check_data(mi)
+    struct mag *mi;
+{
+    char buffer[8];
+    
+    if(fread(buffer, (size_t) 8, (size_t) 1, mi->fp) != 1)
+	mag_file_error(mi, MAG_CORRUPT);
+    if(strncmp(buffer, mag_id, (size_t) 8) != 0)
+	mag_error(mi, MAG_FORMAT);
+}
+
+static void mag_read_comment(mi, p)
+    struct mag *mi;
+    char **p;
+{
+    int max = -1, i = 0;
+    int c;
+    
+    while((c = fgetc(mi->fp)) != EOF){
+	if(c == 0x1a)
+	    break;
+	if(max < i){
+	    max += 16;
+	    *p = mag_realloc(*p, (size_t) max + 1, "mag_read_comment#1");
+	}
+	(*p)[i++] = c;
+    }
+    
+    if(c == EOF)
+	mag_file_error(mi, MAG_CORRUPT);
+    
+    if(max < i){
+	*p = mag_realloc(*p, (size_t) max + 2, "mag_read_comment#2");
+    }
+    if(i > 24){
+	(*p)[i] = '\0';
+	strcpy(*p, &(*p)[24]);
+    }else{
+	(*p)[0] = '\0';
+    }
+}
+
+static void mag_read_header(mi)
+    struct mag *mi;
+{
+    byte buf[32];
+    
+    mi->h_off = ftell(mi->fp);
+    
+    if(fread(buf, (size_t) 32, (size_t) 1, mi->fp) != 1)
+	mag_file_error(mi, MAG_CORRUPT);
+    
+    mi->m_256 = buf[3] & 0x80;
+    mi->m_dig = buf[3] & 0x04;
+    mi->m_8   = buf[3] & 0x02;
+    mi->m_200 = buf[3] & 0x01;
+    
+    mi->x1 = buf[ 4] + buf[ 5] * 256;
+    mi->y1 = buf[ 6] + buf[ 7] * 256;
+    mi->x2 = buf[ 8] + buf[ 9] * 256;
+    mi->y2 = buf[10] + buf[11] * 256;
+    
+#define get_dword(a, b, c, d) \
+    ((long)(a) << 24 | (long)(b) << 16 | (long)(c) << 8 | (long)(d))
+
+    mi->a_off  = get_dword(buf[15], buf[14], buf[13], buf[12]);
+    mi->b_off  = get_dword(buf[19], buf[18], buf[17], buf[16]);
+    mi->b_size = get_dword(buf[23], buf[22], buf[21], buf[20]);
+    mi->p_off  = get_dword(buf[27], buf[26], buf[25], buf[24]);
+    mi->p_size = get_dword(buf[31], buf[30], buf[29], buf[28]);
+#undef get_dword
+    
+    mi->a_size = mi->b_off - mi->a_off;
+    mi->a_off += mi->h_off;
+    mi->b_off += mi->h_off;
+    mi->p_off += mi->h_off;
+    
+    mi->width     = mi->x2 - mi->x1 + 1;
+    mi->height    = mi->y2 - mi->y1 + 1;
+    mi->left_pad  =       mi->x1 & 07;
+    mi->right_pad = 07 - (mi->x2 & 07);
+    mi->x1       -= mi->left_pad;		/* x1 = 8m   */
+    mi->x2       += mi->right_pad;		/* x2 = 8n+7 */
+    mi->p_width   = ((mi->x2 + 1) - mi->x1) / (mi->m_256 ? 2 : 4);
+    mi->p_height  =  (mi->y2 + 1) - mi->y1;
+    
+    if(DEBUG) mag_show_struct(mi);
+}
+
+static void mag_read_palette(mi, r, g, b)
+    struct mag *mi;
+    byte *r, *g, *b;
+{
+    int num_palettes;
+    int i;
+    byte *buf;
+    
+    if(mi->m_256)
+	num_palettes = 256;
+    else
+	num_palettes = 16;
+    
+    buf = mag_malloc((size_t)num_palettes * 3, "mag_read_palette");
+    
+    if(fread(buf, (size_t) 3, (size_t) num_palettes, mi->fp) != num_palettes){
+	free(buf);
+	mag_file_error(mi, MAG_CORRUPT);
+    }
+    
+    for(num_palettes--; num_palettes >= 0; num_palettes--){
+	g[num_palettes] = buf[num_palettes * 3    ];
+	r[num_palettes] = buf[num_palettes * 3 + 1];
+	b[num_palettes] = buf[num_palettes * 3 + 2];
+    }
+    
+    free(buf);
+}
+
+static void mag_read_flags(mi)
+     struct mag *mi;
+{
+    mi->a = mag_malloc((size_t) mi->a_size, "mag_read_flags#1");
+    mi->b = mag_malloc((size_t) mi->b_size, "mag_read_flags#2");
+    
+    fseek(mi->fp, mi->a_off, SEEK_SET);
+    if(fread(mi->a, (size_t) mi->a_size, (size_t) 1, mi->fp) != 1)
+	mag_file_warning(mi, MAG_CORRUPT);
+    if(fread(mi->b, (size_t) mi->b_size, (size_t) 1, mi->fp) != 1)
+	mag_file_warning(mi, MAG_CORRUPT);
+}
+
+static void mag_read_pixel_data(mi)
+    struct mag *mi;
+{
+    mi->p = mag_malloc((size_t) mi->p_size, "mag_read_pixel_data");
+    
+    fseek(mi->fp, mi->p_off, SEEK_SET);
+    if(fread(mi->p, (size_t) mi->p_size, (size_t) 1, mi->fp) != 1)
+	mag_file_warning(mi, MAG_CORRUPT);
+}
+
+/* MAG expanding routine */
+static void mag_expand_body(mi, pic0)
+    struct mag *mi;
+    byte **pic0;
+{
+    int ai, bi, fi, pi, i;
+    int px, py, x, y;
+    byte *flag;
+    byte mask;
+    data16 *pixel0;
+    
+    flag   = mag_malloc((size_t) mi->p_width / 2, "mag_expand_body#1");
+    *pic0  = mag_malloc((size_t) mi->width * mi->height, "mag_expand_body#2");
+    pixel0 = mag_malloc((size_t) 2 * mi->p_width * 17, "mag_expand_body#3");
+    
+#define pixel(x, y) pixel0[(y) % 17 * mi->p_width + (x)]
+    
+    ai = bi = pi = 0;
+    mask = 0x80;
+    for(y = py = 0; py < mi->p_height; py++){
+	for(fi = 0; fi < mi->p_width / 2; fi++){
+	    if(py == 0){
+		if(mi->a[ai] & mask)
+		    flag[fi] = mi->b[bi++];
+		else
+		    flag[fi] = 0;
+	    }else{
+		if(mi->a[ai] & mask)
+		    flag[fi] ^= mi->b[bi++];
+	    }
+	    if((mask >>= 1) == 0){
+		mask = 0x80;
+		ai++;
+	    }
+	}
+	
+	for(px = fi = 0; fi < mi->p_width / 2; fi++){
+	    int f = H4(flag[fi]);
+	    if(f == 0){
+		pixel(px, py) = mi->p[pi] + mi->p[pi + 1] * 256;
+		px++;
+		pi+=2;
+	    }else{
+		int dx = points[f].dx, dy = points[f].dy;
+		pixel(px, py) = pixel(px - dx, py - dy);
+		px++;
+	    }
+	    
+	    f = L4(flag[fi]);
+	    if(f == 0){
+		pixel(px, py) = mi->p[pi] + mi->p[pi + 1] * 256;
+		px++;
+		pi+=2;
+	    }else{
+		int dx = points[f].dx, dy = points[f].dy;
+		pixel(px, py) = pixel(px - dx, py - dy);
+		px++;
+	    }
+	}
+	
+#define inside(x) ((unsigned int)(x) < mi->width)
+#define  pic(x, y) (*pic0)[(y) * mi->width + (x)]
+	for(x = -mi->left_pad, px = 0; px < mi->p_width; px++){
+	    data16 p = pixel(px, py);
+	    if(mi->m_256){
+		if(inside(x))
+		    pic(x, y) = L8(p);
+		x++;
+		if(inside(x))
+		    pic(x, y) = H8(p);
+		x++;
+	    }else{
+		if(inside(x))
+		    pic(x, y) = H4(L8(p));
+		x++;
+		if(inside(x))
+		    pic(x, y) = L4(L8(p));
+		x++;
+		if(inside(x))
+		    pic(x, y) = H4(H8(p));
+		x++;
+		if(inside(x))
+		    pic(x, y) = L4(H8(p));
+		x++;
+	    }
+	}
+	y++;
+    }
+#undef pic
+#undef inside
+#undef pixel
+    
+    free(flag);
+    free(pixel0);
+}
+
+
+/* The main routine to write a MAG file. */
+int WriteMAG(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
+	      comment)
+    FILE *fp;
+    byte *pic;
+    int ptype, w, h;
+    byte *rmap, *gmap, *bmap;
+    int numcols, colorstyle;
+    char *comment;
+{
+    byte rtemp[256], gtemp[256], btemp[256];
+    struct mag mag;
+    int e;
+    
+    if(DEBUG) fputs("WriteMag\n", stderr);
+    
+    mag_init_info(&mag);
+    mag.fp = fp;
+    
+    if(ptype == PIC24){
+	if(!(pic = Conv24to8(pic, w, h, 256, rtemp, gtemp, btemp)))
+	    mag_memory_error("Conv24to8", "WriteMAG");
+	rmap = rtemp;
+	gmap = gtemp;
+	bmap = btemp;
+	numcols = 256;
+	mag.m_256 = 1;
+    }else{
+	if(numcols > 16)
+	    mag.m_256 = 1;
+    }
+    
+    if((e = setjmp(mag.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	mag_cleanup_mag_info(&mag, 1);
+	return -1;
+    }
+    
+    mag.x2 = w - 1;
+    mag.y2 = h - 1;
+    mag.right_pad = 07 - (mag.x2 & 07);
+    mag.p_width = (w + mag.right_pad) / (mag.m_256 ? 2 : 4);
+    mag.p_height = h;
+    mag.width = w;
+    mag.height = h;
+    mag.a_size = (mag.p_width * mag.p_height + 15) / 16;	/* x/2/8 */
+    if(mag.a_size % 2)
+	mag.a_size++;
+    
+    mag_compress_data(&mag, pic);
+    mag_write_check_data(&mag);
+    mag_write_comment(&mag, comment);
+    
+    mag.h_off = ftell(mag.fp);
+    
+    mag_write_palette(&mag, numcols, rmap, gmap, bmap,
+		      colorstyle == F_GREYSCALE);
+    mag_write_flags(&mag);
+    mag_write_pixel_data(&mag);
+    mag_write_header(&mag);
+    
+    mag_cleanup_mag_info(&mag, 1);
+    return 0;
+}
+
+/* MAG compressing routine */
+static void mag_compress_data(mi, pic0)
+    struct mag *mi;
+    byte *pic0;
+{
+    int ai, bi, pi, i;
+    int bmax, pmax;
+    byte mask;
+    byte *flag0;
+    data16 *pixel0;
+    int px, py, x, y;
+    
+    pixel0 = mag_malloc((size_t) 2 * mi->p_width * mi->p_height,
+			"mag_compress_data#1");
+    flag0 = mag_malloc((size_t) mi->p_width * mi->p_height,
+		       "mag_compress_data#2");
+    
+#define pic(x, y) pic0[(y) * mi->width + (x)]
+    /* convert dots to pixels */
+    i = 0; 
+    for(y = py = 0; py < mi->p_height; py++){
+	for(x = px = 0; px < mi->p_width; px++){
+	    data16 p = 0;
+	    if(mi->m_256){
+		if(x < mi->width)
+		    p += pic(x, y);
+		x++;
+		if(x < mi->width)
+		    p += pic(x, y) * 256;
+		x++;
+	    }else{
+		if(x < mi->width)
+		    p += pic(x, y) * 16;
+		x++;
+		if(x < mi->width)
+		    p += pic(x, y);
+		x++;
+		if(x < mi->width)
+		    p += pic(x, y) * 4096;
+		x++;
+		if(x < mi->width)
+		    p += pic(x, y) * 256;
+		x++;
+	    }
+	    pixel0[i++] = p;
+	}
+	y++;
+    }
+#undef pic
+    
+#define pixel(x, y) pixel0[(y) * mi->p_width + (x)]
+#define  flag(x, y)  flag0[(y) * mi->p_width + (x)]
+    /* get flags */
+    pmax = pi = 0;
+    for(py = 0; py < mi->p_height; py++){
+	for(px = 0; px < mi->p_width; px++){
+	    int t;
+	    for(t = 0; t < 15; t++){
+		int dx = points[try[t]].dx, dy = points[try[t]].dy;
+		if(dx <= px && dy <= py){
+		    if(pixel(px - dx, py - dy) == pixel(px, py))
+			break;
+		}
+	    }
+	    if(t < 15){
+		flag(px, py) = try[t];
+	    }else{
+		flag(px, py) = 0;
+		if(pmax <= pi + 1){
+		    pmax += 128;
+		    mi->p = mag_realloc(mi->p, (size_t) pmax,
+					"mag_compress_data#3");
+		}
+		mi->p[pi++] = L8(pixel(px, py));
+		mi->p[pi++] = H8(pixel(px, py));
+	    }
+	}
+    }
+#undef flag
+#undef pixel
+    
+    /* pack 2 flags into 1 byte */
+    for(i = 0; i < mi->p_width / 2 * mi->p_height; i++)
+	flag0[i] = flag0[i * 2] * 16 + flag0[i * 2 + 1];
+    
+#define flag(x, y)  flag0[(y) * mi->p_width / 2 + (x)]
+    for(py = mi->p_height - 1; py >= 1; py--){
+	for(px = 0; px < mi->p_width / 2; px++)
+	    flag(px, py) ^= flag(px, py - 1);
+    }
+#undef flag
+    
+    mask = 0x80;
+    ai = bi = bmax = 0;
+    mi->a = mag_malloc((size_t) mi->a_size, "mag_compress_data#4");
+    for(i = 0; i < mi->p_width / 2 * mi->p_height; i++){
+	if(flag0[i] == 0){
+	    mi->a[ai] &= ~mask;
+	}else{
+	    if(bmax == bi){
+		bmax += 128;
+		mi->b = mag_realloc(mi->b, (size_t) bmax,
+				    "mag_compress_data#4");
+	    }
+	    mi->b[bi++] = flag0[i];
+	    mi->a[ai] |= mask;
+	}
+	
+	if((mask >>= 1) == 0){
+	    mask = 0x80;
+	    ai++;
+	}
+    }
+    
+    if(bi % 2)
+	bi++;
+    mi->b_size = bi;
+    
+    mi->p_size = pi;
+    
+    free(pixel0);
+    free(flag0);
+}
+
+static void mag_write_check_data(mi)
+    struct mag *mi;
+{
+    if(fwrite(mag_id, (size_t) 8, (size_t) 1, mi->fp) != 1)
+	mag_file_error(mi, MAG_WRITE);
+}
+
+static void mag_write_comment(mi, comment)
+    struct mag *mi;
+    char *comment;
+{
+    char *p;
+    int i;
+    
+    if(fputs("XV   ", mi->fp) == EOF)
+	mag_file_error(mi, MAG_WRITE);
+    
+    if((p = (char *) getenv("USER")) == NULL)
+	p = "????????";
+    for(i = 5; i < 24; i++){
+	if(*p == '\0')
+	    break;
+	if(fputc(*p++, mi->fp) == EOF)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+    for( ; i < 24; i++){
+	if(fputc(' ', mi->fp) == EOF)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+    
+    if(comment){
+	int l = strlen(comment);
+	if(l > 0){
+	    int i;
+	    for(i = 0; i < l; i++){
+		if(comment[i] == 0x1a)
+		    comment[i] = ' ';
+	    }
+	    if(fwrite(comment, (size_t) l, (size_t) 1, mi->fp) != 1)
+		mag_file_error(mi, MAG_WRITE);
+	}
+    }
+    
+    if(fputc(0x1a, mi->fp) == EOF)
+	mag_file_error(mi, MAG_WRITE);
+}
+
+static void mag_write_palette(mi, num, r, g, b, grey)
+    struct mag *mi;
+    int num;
+    byte *r, *g, *b;
+    int grey;
+{
+    int i, left;
+    char buf[3];
+    
+    fseek(mi->fp, 32L, SEEK_CUR);	/* skip header area */
+    for(i = 0; i < num; i++){
+	buf[0] = *g++;
+	buf[1] = *r++;
+	buf[2] = *b++;
+	if(grey)
+	    buf[0] = buf[1] = buf[2] = MONO(buf[1], buf[0], buf[2]);
+	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+    if(num < 16){
+	left = 16 - num;
+    }else if(num == 16){
+	left = 0;
+    }else if(num < 256){
+	left = 256 - num;
+    }else if(num == 256){
+	left = 0;
+    }else
+	left = 0;	/* shouldn't happen */
+    
+    if(left > 0){
+	for(i = 0; i < left; i++){
+	    if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
+		mag_file_error(mi, MAG_WRITE);
+	}
+    }
+}
+
+static void mag_write_flags(mi)
+    struct mag *mi;
+{
+    int i;
+    
+    mi->a_off = ftell(mi->fp);
+    for(i = 0; i < mi->a_size; i++){
+	if(fputc(mi->a[i], mi->fp) == EOF)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+    
+    mi->b_off = ftell(mi->fp);
+    for(i = 0; i < mi->b_size; i++){
+	if(fputc(mi->b[i], mi->fp) == EOF)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+}
+
+static void mag_write_pixel_data(mi)
+    struct mag *mi;
+{
+    int i;
+    
+    mi->p_off = ftell(mi->fp);
+    for(i = 0; i < mi->p_size; i++){
+	if(fputc(mi->p[i], mi->fp) == EOF)
+	    mag_file_error(mi, MAG_WRITE);
+    }
+}
+
+static void mag_write_header(mi)
+    struct mag *mi;
+{
+    byte buf[32];
+    
+    if(DEBUG) mag_show_struct(mi);
+    
+    mi->a_off -= mi->h_off;
+    mi->b_off -= mi->h_off;
+    mi->p_off -= mi->h_off;
+    
+    buf[ 0] = buf[1] = buf[2] = 0;
+    buf[ 3] = (mi->m_256 ? 0x80 : 0);
+    buf[ 4] = buf[5] = 0;
+    buf[ 6] = buf[7] = 0;
+    buf[ 8] = L8(mi->x2);
+    buf[ 9] = H8(mi->x2);
+    buf[10] = L8(mi->y2);
+    buf[11] = H8(mi->y2);
+    mag_set_double_word(mi->a_off,  &buf[12]);
+    mag_set_double_word(mi->b_off,  &buf[16]);
+    mag_set_double_word(mi->b_size, &buf[20]);
+    mag_set_double_word(mi->p_off,  &buf[24]);
+    mag_set_double_word(mi->p_size, &buf[28]);
+    
+    fseek(mi->fp, mi->h_off, SEEK_SET);
+    if(fwrite(buf, (size_t) 32, (size_t) 1, mi->fp) != 1)
+	mag_file_error(mi, MAG_WRITE);
+}
+
+static void mag_set_double_word(n, p)
+    long n;
+    byte *p;
+{
+    p[0] = n % 256;
+    p[1] = n / 256 % 256;
+    p[2] = n / 256 / 256 % 256;
+    p[3] = n / 256 / 256 / 256 % 256;
+}
+
+/*
+ * The routines to initialize or clean up.
+ * mag_init_info:
+ *	initializes a mag structure.
+ * mag_cleanup_mag_info:
+ *	cleans up a mag structure.
+ * mag_cleanup_pinfo:
+ *	cleans up a PICINFO structure.
+ */
+static void mag_init_info(mi)
+    struct mag *mi;
+{
+    mi->fp = NULL;
+    mi->fsize = 0;
+    mi->m_256 = mi->m_dig = mi->m_8 = mi->m_200 = 0;
+    mi->x1 = mi->y1 = mi->x2 = mi->y2 = 0;
+    mi->left_pad = mi->right_pad = 0;
+    mi->p_width = mi->p_height = mi->width = mi->height = 0;
+    mi->h_off = mi->p_off = mi->p_size = 0;
+    mi->a_off = mi->a_size = mi->b_off = mi->b_size = 0;
+    mi->a = NULL;
+    mi->b = NULL;
+    mi->p = NULL;
+}
+
+static void mag_cleanup_mag_info(mi, writing)
+    struct mag *mi;
+    int writing;
+{
+    if(mi->fp && !writing)
+	fclose(mi->fp);
+    if(mi->a)
+	free(mi->a);
+    if(mi->b)
+	free(mi->b);
+    if(mi->p)
+	free(mi->p);
+}
+
+static void mag_cleanup_pinfo(pinfo)
+    PICINFO *pinfo;
+{
+    if(pinfo->comment){
+	free(pinfo->comment);
+	pinfo->comment = NULL;
+    }
+    if(pinfo->pic){
+	free(pinfo->pic);
+	pinfo->pic = NULL;
+    }
+}
+
+/*
+ * Error handler.
+ * mag_memory_error:
+ *	shows an error message, and terminates.
+ * mag_error:
+ *	shows an non-file error message, and jumps to the entry for errors.
+ * mag_file_error:
+ *	shows an file error message, and jumps to the entry for errors.
+ * mag_file_warning:
+ *	shows an file warning message.
+ */
+static void mag_memory_error(scm, fn)
+    char *scm, *fn;
+{
+    char buf[128];
+    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
+    FatalError(buf);
+}
+
+static void mag_error(mi, mn)
+    struct mag *mi;
+    int mn;
+{
+    SetISTR(ISTR_WARNING, "%s", mag_msgs[mn]);
+    longjmp(mi->jmp, 1);
+}
+
+static void mag_file_error(mi, mn)
+    struct mag *mi;
+    int mn;
+{
+    if(feof(mi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", mag_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", mag_msgs[mn], ERRSTR(errno));
+    longjmp(mi->jmp, 1);
+}
+
+static void mag_file_warning(mi, mn)
+    struct mag *mi;
+    int mn;
+{
+    if(feof(mi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", mag_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", mag_msgs[mn], ERRSTR(errno));
+}
+
+static void mag_show_struct (mi)
+    struct mag *mi;
+{
+    fprintf(stderr, "  256 colors: %s\n", mi->m_256 ? "true" : "false");
+    fprintf(stderr, "  8 colors: %s\n", mi->m_8 ? "true" : "false");
+    fprintf(stderr, "  digital colors: %s\n", mi->m_dig ? "true" : "false");
+    fprintf(stderr, "  aspect ratio: %f\n", mi->m_200 ? 0.5 : 1.0);
+    fprintf(stderr, "  image size: %dx%d\n", mi->width, mi->height);
+    fprintf(stderr, "  left pad: %d\n", mi->left_pad);
+    fprintf(stderr, "  right pad: %d\n", mi->right_pad);
+    fprintf(stderr, "  h_off: %ld\n", mi->h_off);
+    fprintf(stderr, "  A: off:%ld, size:%ld\n", mi->a_off, mi->a_size);
+    fprintf(stderr, "  B: off:%ld, size:%ld\n", mi->b_off, mi->b_size);
+    fprintf(stderr, "  P: off:%ld, size:%ld\n", mi->p_off, mi->p_size);
+}
+
+/* Memory related routines. */
+static void *mag_malloc(n, fn)
+    size_t n;
+    char *fn;
+{
+    void *r = (void *) malloc(n);
+    if(r == NULL)
+	mag_memory_error("malloc", fn);
+    return r;
+}
+
+static void *mag_realloc(p, n, fn)
+    void *p;
+    size_t n;
+    char *fn;
+{
+    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
+    if(r == NULL)
+	mag_memory_error("realloc", fn);
+    return r;
+}
+#endif /* HAVE_MAG */
diff -Naur xv-3.10a.old/xvmaki.c xv-3.10a/xvmaki.c
--- xv-3.10a.old/xvmaki.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvmaki.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,789 @@
+/*
+ * xvmaki.c - load routine for `MAKI' format pictures.
+ *
+ * The `MAKI' format was used by some Japanese personal computer users.
+ */
+
+#include "xv.h"
+#include <setjmp.h>
+
+#ifdef HAVE_MAKI
+
+typedef unsigned short data16;
+typedef unsigned int data32;
+
+struct maki_info {
+    jmp_buf jmp;
+    FILE *fp;
+    long fsize;
+    int x0, y0, x1, y1;
+    int width, height;
+    float aspect;
+    long fb_size;
+    long pa_size, pb_size;
+    int m_maki01b, m_200, m_dig8;
+    data16 ext_flag;
+    byte *fa, *fb, *pa, *pb;
+    byte *vs;
+    int numcols;
+    byte *forma, *formb;
+};
+
+
+static void maki_open_file             PARM((struct maki_info*, char*));
+static void maki_check_id              PARM((struct maki_info*));
+static void maki_skip_comment          PARM((struct maki_info*));
+static void maki_read_header           PARM((struct maki_info*));
+static void maki_read_palette          PARM((struct maki_info*,
+					     byte*, byte*, byte*));
+static void maki_read_flags            PARM((struct maki_info*));
+static void maki_read_pixel_data       PARM((struct maki_info*));
+static void maki_expand_virtual_screen PARM((struct maki_info*));
+static void maki_expand_pixel_data     PARM((struct maki_info*, byte**));
+static void maki_init_info             PARM((struct maki_info*));
+
+static void maki_make_pixel_data       PARM((struct maki_info*, byte*));
+static void maki_make_virtual_screen   PARM((struct maki_info*));
+static void maki_make_flags            PARM((struct maki_info*));
+static void maki_write_check_id        PARM((struct maki_info*));
+static void maki_write_comment         PARM((struct maki_info*));
+static void maki_write_header          PARM((struct maki_info*));
+static void maki_write_palette         PARM((struct maki_info*,
+					     byte*, byte*, byte*, int));
+static void maki_write_flags           PARM((struct maki_info*));
+static void maki_write_pixel_data      PARM((struct maki_info*));
+
+static void maki_cleanup_maki_info     PARM((struct maki_info*, int));
+static void maki_cleanup_pinfo         PARM((PICINFO*));
+static void maki_memory_error          PARM((char*, char*));
+static void maki_error                 PARM((struct maki_info*, int));
+static void maki_file_error            PARM((struct maki_info*, int));
+static void maki_file_warning          PARM((struct maki_info*, int));
+static void maki_show_maki_info        PARM((struct maki_info*));
+static void *maki_malloc               PARM((size_t, char*));
+static void *maki_realloc              PARM((void *, size_t, char*));
+
+static char maki_id_a[] = "MAKI01A ";
+static char maki_id_b[] = "MAKI01B ";
+
+static char *maki_msgs[] = {
+    NULL,
+#define MAKI_OPEN 1
+    "can't open file.",
+#define MAKI_CORRUPT 2
+    "file corrupted.",
+#define MAKI_FORMAT 3
+    "not MAKI format.",
+#define MAKI_BAD_DATA 4
+    "bad data.",
+#define MAKI_COMMENT 5
+    "no '^Z' after comment.",
+#define MAKI_SIZE 6
+    "bad size.",
+#define MAKI_WRITE 7
+    "write failed.",
+};
+
+#define H4(b) ((b) >> 4 & 0xf)
+#define L4(b) ((b)      & 0xf)
+#define error(msg_num) longjmp(mi->jmp, msg_num)
+
+int LoadMAKI(fname, pinfo)
+    char *fname;
+    PICINFO *pinfo;
+{
+    struct maki_info maki;
+    int e;
+    
+    if(DEBUG) fputs("LoadMAKI:\n", stderr);
+    
+    pinfo->comment = NULL;
+    maki_init_info(&maki);
+    if((e = setjmp(maki.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	maki_cleanup_maki_info(&maki, 0);
+	maki_cleanup_pinfo(pinfo);
+	return 0;
+    }
+    
+    maki_open_file(&maki, fname);
+    maki_check_id(&maki);
+    maki_skip_comment(&maki);
+    maki_read_header(&maki);
+    maki_read_palette(&maki, pinfo->r, pinfo->g, pinfo->b);
+    maki_read_flags(&maki);
+    maki_read_pixel_data(&maki);
+    maki_expand_virtual_screen(&maki);
+    maki_expand_pixel_data(&maki, &pinfo->pic);
+    
+    pinfo->w = pinfo->normw = maki.width;
+    pinfo->h = pinfo->normh = maki.height;
+    pinfo->type = PIC8;
+    pinfo->frmType = F_MAKI;
+    pinfo->colType = F_FULLCOLOR;
+    sprintf(pinfo->fullInfo, "MAKI, 16 colors (%ld bytes)", maki.fsize);
+    sprintf(pinfo->shrtInfo, "%dx%d MAKI", maki.width, maki.height);
+    normaspect = maki.aspect;
+    
+    maki_cleanup_maki_info(&maki, 0);
+    return 1;
+}
+
+static void maki_open_file(mi, fname)
+    struct maki_info *mi;
+    char *fname;
+{
+    if((mi->fp = fopen(fname, "rb")) == NULL)
+	maki_file_error(mi, MAKI_OPEN);
+    fseek(mi->fp, (size_t) 0, SEEK_END);
+    mi->fsize = ftell(mi->fp);
+    fseek(mi->fp, (size_t) 0, SEEK_SET);
+}
+
+static void maki_check_id(mi)
+    struct maki_info *mi;
+{
+    char buf[8];
+    if(fread(buf, (size_t) 8, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_CORRUPT);
+    if(strncmp(buf, maki_id_a, (size_t) 8) != 0 &&
+       strncmp(buf, maki_id_b, (size_t) 8) != 0)
+	maki_error(mi, MAKI_FORMAT);
+    mi->m_maki01b = (buf[6] == 'B');
+}
+
+static void maki_skip_comment(mi)
+    struct maki_info *mi;
+{
+    int i;
+    int c;
+    
+    for(i = 0; i < 24; i++){
+	if((c = fgetc(mi->fp)) == EOF)
+	    maki_file_error(mi, MAKI_CORRUPT);
+	if(c == '\032')	/* ^Z, 0x1a */
+	    break;
+    }
+    if(c != '\032')
+	maki_file_error(mi, MAKI_COMMENT);
+    
+    fseek(mi->fp, 32L, SEEK_SET);
+}
+
+static void maki_read_header(mi)
+    struct maki_info *mi;
+{
+    byte buf[16];
+    
+    if(fread(buf, (size_t) 16, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_CORRUPT);
+    
+    mi->fb_size  = (long)buf[ 0] << 8 | (long)buf[ 1];
+    mi->pa_size  = (long)buf[ 2] << 8 | (long)buf[ 3];
+    mi->pb_size  = (long)buf[ 4] << 8 | (long)buf[ 5];
+    mi->ext_flag = (long)buf[ 6] << 8 | (long)buf[ 7];
+    mi->x0       = (long)buf[ 8] << 8 | (long)buf[ 9];
+    mi->y0       = (long)buf[10] << 8 | (long)buf[11];
+    mi->x1       = (long)buf[12] << 8 | (long)buf[13];
+    mi->y1       = (long)buf[14] << 8 | (long)buf[15];
+    
+    mi->width  = mi->x1-- - mi->x0;
+    mi->height = mi->y1-- - mi->y0;
+    mi->m_200  = mi->ext_flag & 1;
+    mi->m_dig8 = mi->ext_flag & 2;
+    mi->aspect = mi->m_200 ? 0.5 : 1.0;
+    
+    if(DEBUG) maki_show_maki_info(mi);
+}
+
+static void maki_read_palette(mi, r, g, b)
+    struct maki_info *mi;
+    byte *r, *g, *b;
+{
+    byte buf[48], *p;
+    
+    if(fread(buf, (size_t) 48, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_CORRUPT);
+    
+    for(p = buf; p < &buf[48]; ){
+	*g++ = *p++;
+	*r++ = *p++;
+	*b++ = *p++;
+    }
+}
+
+static void maki_read_flags(mi)
+    struct maki_info *mi;
+{
+    mi->fa = maki_malloc((size_t) 1000       , "maki_read_flags#1");
+    mi->fb = maki_malloc((size_t) mi->fb_size, "maki_read_flags#2");
+    
+    if(fread(mi->fa, (size_t) 1000, (size_t) 1, mi->fp) != 1)
+	maki_file_warning(mi, MAKI_CORRUPT);
+    if(fread(mi->fb, (size_t) mi->fb_size, (size_t) 1, mi->fp) != 1)
+	maki_file_warning(mi, MAKI_CORRUPT);
+}
+
+static void maki_read_pixel_data(mi)
+    struct maki_info *mi;
+{
+    mi->pa = maki_malloc((size_t) mi->pa_size, "maki_read_pixel_data#1");
+    mi->pb = maki_malloc((size_t) mi->pb_size, "maki_read_pixel_data#2");
+    
+    if(fread(mi->pa, (size_t) mi->pa_size, (size_t) 1, mi->fp) != 1)
+	maki_file_warning(mi, MAKI_CORRUPT);
+    if(fread(mi->pb, (size_t) mi->pb_size, (size_t) 1, mi->fp) != 1)
+	maki_file_warning(mi, MAKI_CORRUPT);
+}
+
+static void maki_expand_virtual_screen(mi)
+    struct maki_info *mi;
+{
+    int x, y, fai, fbi;
+    int bpl = mi->width / 2 / 8;		/* bytes per line */
+    byte mask;
+    mi->vs = maki_malloc((size_t) bpl * mi->height,
+			 "maki_expand_virtual_screen");
+    
+    fai = fbi = 0;
+    mask = 0x80;
+    for(y = 0; y < mi->height; y += 4){
+	for(x = 0; x < mi->width / 2; x += 4){
+	    if(mi->fa[fai] & mask){
+		byte bh, bl;
+		bh = mi->fb[fbi++];
+		bl = mi->fb[fbi++];
+		if(x % 8 == 0){
+		    mi->vs[ y      * bpl + x / 8] = H4(bh) << 4;
+		    mi->vs[(y + 1) * bpl + x / 8] = L4(bh) << 4;
+		    mi->vs[(y + 2) * bpl + x / 8] = H4(bl) << 4;
+		    mi->vs[(y + 3) * bpl + x / 8] = L4(bl) << 4;
+		}else{
+		    mi->vs[ y      * bpl + x / 8] |= H4(bh);
+		    mi->vs[(y + 1) * bpl + x / 8] |= L4(bh);
+		    mi->vs[(y + 2) * bpl + x / 8] |= H4(bl);
+		    mi->vs[(y + 3) * bpl + x / 8] |= L4(bl);
+		}
+	    }else{
+		if(x % 8 == 0){
+		    mi->vs[ y      * bpl + x / 8] = 0;
+		    mi->vs[(y + 1) * bpl + x / 8] = 0;
+		    mi->vs[(y + 2) * bpl + x / 8] = 0;
+		    mi->vs[(y + 3) * bpl + x / 8] = 0;
+		}else{
+/*		    mi->vs[ y      * bpl + x / 8] |= 0;
+		    mi->vs[(y + 1) * bpl + x / 8] |= 0;
+		    mi->vs[(y + 2) * bpl + x / 8] |= 0;
+		    mi->vs[(y + 3) * bpl + x / 8] |= 0; */
+		}
+	    }
+	    
+	    if((mask >>= 1) == 0){
+		mask = 0x80;
+		fai++;
+	    }
+	}
+    }
+}
+
+static void maki_expand_pixel_data(mi, pic)
+    struct maki_info *mi;
+    byte **pic;
+{
+    int x, y;
+    int vsi, pi, max_pi;
+    byte *p;
+    byte mask;
+    int gap;
+    *pic = maki_malloc((size_t) mi->width * mi->height,
+		       "maki_expand_pixel_data");
+    
+    vsi = pi = 0;
+    p = mi->pa;
+    max_pi = mi->pa_size - 1;
+    mask = 0x80;
+    for(y = 0; y < mi->height; y++){
+	for(x = 0; x < mi->width; x += 2){
+	    if(mi->vs[vsi] & mask){
+		if(pi > max_pi){
+		    if(p == mi->pb)
+			maki_error(mi, MAKI_BAD_DATA);
+		    pi = 0;
+		    p = mi->pb;
+		    max_pi = mi->pb_size - 1;
+		}
+		(*pic)[y * mi->width + x    ] = H4(p[pi]);
+		(*pic)[y * mi->width + x + 1] = L4(p[pi]);
+		pi++;
+	    }else{
+		(*pic)[y * mi->width + x    ] = 0;
+		(*pic)[y * mi->width + x + 1] = 0;
+	    }
+	    
+	    if((mask >>= 1) == 0){
+		mask = 0x80;
+		vsi++;
+	    }
+	}
+    }
+    
+    gap = mi->m_maki01b ? 4 : 2;
+    
+    for(y = gap; y < mi->height; y++){
+	for(x = 0; x < mi->width; x++)
+	    (*pic)[y * mi->width + x] ^= (*pic)[(y - gap) * mi->width + x];
+    }
+}
+
+
+int WriteMAKI(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle)
+    FILE *fp;
+    byte *pic;
+    int ptype, w, h;
+    byte *rmap, *gmap, *bmap;
+    int numcols, colorstyle;
+{
+    byte rtemp[256], gtemp[256], btemp[256];
+    struct maki_info maki, *mi = &maki;
+    int e;
+    
+    if(DEBUG) fputs("WriteMAKI:\n", stderr);
+    
+    maki_init_info(&maki);
+    if((e = setjmp(maki.jmp)) != 0){
+	/* An error occurs */
+	maki_cleanup_maki_info(&maki, 1);
+	return -1;
+    }
+    
+    if(w != 640 || h != 400)
+	maki_error(mi, MAKI_SIZE);
+    
+    maki.fp = fp;
+    maki.width = w;
+    maki.height = h;
+    maki.x1 = w - 1;
+    maki.y1 = h - 1;
+    
+    if(ptype == PIC24){
+	if(!(pic = Conv24to8(pic, w, h, 16, rtemp, gtemp, btemp)))
+	    maki_memory_error("Conv24to8#1", "WriteMAKI");
+	rmap = rtemp;
+	gmap = gtemp;
+	bmap = btemp;
+    }else if(numcols > 16){
+	if(!(pic = Conv8to24(pic, w, h, rmap, gmap, bmap)))
+	    maki_memory_error("Conv8to24", "WriteMAKI");
+	if(!(pic = Conv24to8(pic, w, h, 16, rtemp, gtemp, btemp)))
+	    maki_memory_error("Conv24to8#2", "WriteMAKI");
+	rmap = rtemp;
+	gmap = gtemp;
+	bmap = btemp;
+    }else
+	maki.numcols = numcols;
+    
+    maki_make_pixel_data(&maki, pic);
+    maki_make_virtual_screen(&maki);
+    maki_make_flags(&maki);
+    maki_write_check_id(&maki);
+    maki_write_comment(&maki);
+    maki_write_header(&maki);
+    maki_write_palette(&maki, rmap, gmap, bmap, colorstyle == F_GREYSCALE);
+    maki_write_flags(&maki);
+    maki_write_pixel_data(&maki);
+    
+    maki_cleanup_maki_info(&maki, 1);
+    return 0;
+}
+
+static void maki_make_pixel_data(mi, pic)
+    struct maki_info *mi;
+    byte *pic;
+{
+    int x, y, i;
+    int nza, nzb;
+    
+    mi->forma = maki_malloc((size_t) mi->width / 2 * mi->height,
+			    "maki_make_pixel_data#1");
+    mi->formb = maki_malloc((size_t) mi->width / 2 * mi->height,
+			    "maki_make_pixel_data#2");
+    
+    for(y = 0; y < mi->height; y++){
+	for(x = 0; x < mi->width; x += 2){
+	    byte b;
+	    b = pic[y * mi->width + x] << 4 | pic[y * mi->width + x + 1];
+	    mi->forma[y * mi->width / 2 + x / 2] = b;
+	    mi->formb[y * mi->width / 2 + x / 2] = b;
+	}
+    }
+    
+    for(y = mi->height - 1; y >= 2; y--){
+	for(x = 0; x < mi->width / 2; x++){
+	    mi->forma[y * mi->width / 2 + x] ^=
+		mi->forma[(y - 2) * mi->width / 2 + x];
+	}
+    }
+    
+    for(y = mi->height - 1; y >= 4; y--){
+	for(x = 0; x < mi->width / 2; x++){
+	    mi->formb[y * mi->width / 2 + x] ^=
+		mi->formb[(y - 4) * mi->width / 2 + x];
+	}
+    }
+    
+    nza = nzb = 0;
+    for(i = 0; i < mi->width / 2 * mi->height; i++){
+	if(mi->forma[i] != 0)
+	    nza++;
+	if(mi->formb[i] != 0)
+	    nzb++;
+    }
+    if(nza > nzb){
+	mi->m_maki01b = 1;
+	free(mi->forma);
+	mi->forma = NULL;
+    }else{
+	mi->m_maki01b = 0;
+	free(mi->formb);
+	mi->formb = NULL;
+    }
+}
+
+static void maki_make_virtual_screen(mi)
+    struct maki_info *mi;
+{
+    int bpl = mi->width / 2 / 8;
+    int vsi, pai, pbi, max_pai, max_pbi;
+    byte mask;
+    byte *pixels;
+    int x, y;
+    
+    mi->vs = maki_malloc((size_t) bpl * mi->height,
+			 "maki_make_virtual_screen#1");
+    
+    if(mi->m_maki01b)
+	pixels = mi->formb;
+    else
+	pixels = mi->forma;
+    
+    vsi = pai = pbi = 0;
+    max_pai = max_pbi = -1;
+    mask = 0x80;
+    for(y = 0; y < mi->height; y++){
+	for(x = 0; x < mi->width / 2; x++){
+	    if(pixels[y * mi->width / 2 + x] == 0){
+		mi->vs[vsi] &= ~mask;
+	    }else{
+		mi->vs[vsi] |= mask;
+		if(y < 200){
+		    if(pai > max_pai){
+			max_pai += 1024;
+			mi->pa = maki_realloc(mi->pa, (size_t) max_pai + 1,
+					      "maki_make_virtual_screen#2");
+		    }
+		    mi->pa[pai++] = pixels[y * mi->width / 2 + x];
+		}else{
+		    if(pbi > max_pbi){
+			max_pbi += 1024;
+			mi->pb = maki_realloc(mi->pb, (size_t) max_pbi + 2,
+					      "maki_make_virtual_screen#3");
+		    }
+		    mi->pb[pbi++] = pixels[y * mi->width / 2 + x];
+		}
+	    }
+	    
+	    if((mask >>= 1) == 0){
+		mask = 0x80;
+		vsi++;
+	    }
+	}
+    }
+    
+    mi->pa_size = pai;
+    mi->pb_size = pbi;
+}
+
+static void maki_make_flags(mi)
+    struct maki_info *mi;
+{
+    int bpl = mi->width / 2 / 8;
+    int fbi, max_fbi;
+    int fai;
+    int x, y;
+    byte mask;
+    
+    mi->fa = maki_malloc((size_t) bpl * mi->height, "maki_make_flags#1");
+    
+    fbi = fai = 0;
+    max_fbi = -1;
+    mask = 0x80;
+    for(y = 0; y < mi->height; y += 4){
+	for(x = 0; x < mi->width / 2; x += 4){
+	    if(x % 8 == 0){
+		if(H4(mi->vs[ y      * bpl + x / 8]) == 0 &&
+		   H4(mi->vs[(y + 1) * bpl + x / 8]) == 0 &&
+		   H4(mi->vs[(y + 2) * bpl + x / 8]) == 0 &&
+		   H4(mi->vs[(y + 3) * bpl + x / 8]) == 0){
+		    mi->fa[fai] &= ~mask;
+		}else{
+		    mi->fa[fai] |= mask;
+		    if(fbi + 1 > max_fbi){
+			max_fbi += 1024;
+			mi->fb = maki_realloc(mi->fb, (size_t) max_fbi + 1,
+					      "maki_make_flags#2");
+		    }
+		    mi->fb[fbi++] = H4(mi->vs[ y      * bpl + x / 8]) << 4
+				  | H4(mi->vs[(y + 1) * bpl + x / 8]);
+		    mi->fb[fbi++] = H4(mi->vs[(y + 2) * bpl + x / 8]) << 4
+				  | H4(mi->vs[(y + 3) * bpl + x / 8]);
+		}
+	    }else{
+		if(L4(mi->vs[ y      * bpl + x / 8]) == 0 &&
+		   L4(mi->vs[(y + 1) * bpl + x / 8]) == 0 &&
+		   L4(mi->vs[(y + 2) * bpl + x / 8]) == 0 &&
+		   L4(mi->vs[(y + 3) * bpl + x / 8]) == 0){
+		    mi->fa[fai] &= ~mask;
+		}else{
+		    mi->fa[fai] |= mask;
+		    if(fbi + 1 > max_fbi){
+			max_fbi += 1024;
+			mi->fb = maki_realloc(mi->fb, (size_t) max_fbi + 1,
+					      "maki_make_flags#3");
+		    }
+		    mi->fb[fbi++] = L4(mi->vs[ y      * bpl + x / 8]) << 4
+				  | L4(mi->vs[(y + 1) * bpl + x / 8]);
+		    mi->fb[fbi++] = L4(mi->vs[(y + 2) * bpl + x / 8]) << 4
+				  | L4(mi->vs[(y + 3) * bpl + x / 8]);
+		}
+	    }
+	    
+	    if((mask >>= 1) == 0){
+		mask = 0x80;
+		fai++;
+	    }
+	}
+    }
+    
+    mi->fb_size = fbi;
+}
+
+static void maki_write_check_id(mi)
+    struct maki_info *mi;
+{
+    char *id = mi->m_maki01b ? maki_id_b : maki_id_a;
+    if(fwrite(id, (size_t) 8, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+}
+
+static void maki_write_comment(mi)
+    struct maki_info *mi;
+{
+    char buf[24];
+    char *p;
+    int i = 0;
+    
+    strcpy(buf, "XV   ");
+    
+    if((p = (char *) getenv("USER")) == NULL)
+	p = "????????";
+    for(i = 5; i < 23; i++){
+	if(*p == '\0')
+	    break;
+	buf[i] = *p++;
+    }
+    for( ; i < 23; i++)
+	buf[i] = ' ';
+    
+    buf[i] = '\032';	/* ^Z, 0x1a */
+    
+    if(fwrite(buf, (size_t) 24, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+}
+
+static void maki_write_header(mi)
+    struct maki_info *mi;
+{
+    byte buf[16];
+    
+    if(DEBUG) maki_show_maki_info(mi);
+    
+#define set_word(i, v) {buf[i]=(v)>>8&0xff;buf[i+1]=(v)&0xff;}
+    set_word(0, mi->fb_size);
+    set_word(2, mi->pa_size);
+    set_word(4, mi->pb_size);
+    set_word(6, mi->ext_flag);
+    set_word(8, mi->x0);
+    set_word(10, mi->y0);
+    set_word(12, mi->x1 + 1);
+    set_word(14, mi->y1 + 1);
+#undef set_word
+    
+    if(fwrite(buf, (size_t) 16, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+}
+
+static void maki_write_palette(mi, r, g, b, grey)
+    struct maki_info *mi;
+    byte *r, *g, *b;
+    int grey;
+{
+    int i;
+    char buf[3];
+    for(i = 0; i < mi->numcols; i++){
+	buf[0] = *g++;
+	buf[1] = *r++;
+	buf[2] = *b++;
+	if(grey)
+	    buf[0] = buf[1] = buf[2] = MONO(buf[1], buf[0], buf[2]);
+	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
+	    maki_file_error(mi, MAKI_WRITE);
+    }
+    for( ; i < 16; i++){
+	if(fwrite(buf, (size_t) 3, (size_t) 1, mi->fp) != 1)
+	    maki_file_error(mi, MAKI_WRITE);
+    }
+}
+
+static void maki_write_flags(mi)
+    struct maki_info *mi;
+{
+    int bpl = mi->width / 2 / 8;
+    if(fwrite(mi->fa, (size_t) bpl * mi->height / 16, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+    
+    if(fwrite(mi->fb, (size_t) mi->fb_size, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+}
+
+static void maki_write_pixel_data(mi)
+    struct maki_info *mi;
+{
+    if(fwrite(mi->pa, (size_t) mi->pa_size, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+    
+    if(fwrite(mi->pb, (size_t) mi->pb_size, (size_t) 1, mi->fp) != 1)
+	maki_file_error(mi, MAKI_WRITE);
+}
+
+
+
+static void maki_init_info(mi)
+    struct maki_info *mi;
+{
+    mi->fp = NULL;
+    mi->fsize = 0;
+    mi->x0 = mi->y0 = mi->x1 = mi->y1 = 0;
+    mi->width = mi->height = 0;
+    mi->aspect = 1.0;
+    mi->fb_size = mi->pa_size = mi->pb_size = 0;
+    mi->m_maki01b = mi->m_200 = mi->m_dig8 = 0;
+    mi->ext_flag = 0;
+    mi->fa = mi->fb = mi->pa = mi->pb = NULL;
+    mi->vs = NULL;
+    mi->numcols = 16;
+    mi->forma = mi->formb = NULL;
+}
+
+static void maki_cleanup_maki_info(mi, writing)
+    struct maki_info *mi;
+    int writing;
+{
+    if(mi->fp && !writing)
+	fclose(mi->fp);
+    if(mi->fa)
+	free(mi->fa);
+    if(mi->fb)
+	free(mi->fb);
+    if(mi->pa)
+	free(mi->pa);
+    if(mi->pb)
+	free(mi->pb);
+    if(mi->vs)
+	free(mi->vs);
+    if(mi->forma)
+	free(mi->forma);
+    if(mi->formb)
+	free(mi->formb);
+}
+
+static void maki_cleanup_pinfo(pi)
+    PICINFO *pi;
+{
+    if(pi->pic){
+	free(pi->pic);
+	pi->pic = NULL;
+    }
+}
+
+static void maki_memory_error(scm, fn)
+    char *scm, *fn;
+{
+    char buf[128];
+    sprintf(buf, "%s: coulndn't allocate memory. (%s)", scm, fn);
+    FatalError(buf);
+}
+
+static void maki_error(mi, mn)
+    struct maki_info *mi;
+    int mn;
+{
+    SetISTR(ISTR_WARNING, "%s", maki_msgs[mn]);
+    longjmp(mi->jmp, 1);
+}
+
+static void maki_file_error(mi, mn)
+    struct maki_info *mi;
+    int mn;
+{
+    if(feof(mi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", maki_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", maki_msgs[mn], ERRSTR(errno));
+    longjmp(mi->jmp, 1);
+}
+
+static void maki_file_warning(mi, mn)
+    struct maki_info *mi;
+    int mn;
+{
+    if(feof(mi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", maki_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", maki_msgs[mn], ERRSTR(errno));
+}
+
+static void maki_show_maki_info(mi)
+    struct maki_info *mi;
+{
+    fprintf(stderr, "  file size: %ld.\n", mi->fsize);
+    fprintf(stderr, "  image size: %dx%d.\n", mi->width, mi->height);
+    fprintf(stderr, "  aspect: %f.\n", mi->aspect);
+    fprintf(stderr, "  flag B size: %ld.\n", mi->fb_size);
+    fprintf(stderr, "  pixel data size: A:%ld, B:%ld.\n",
+	    mi->pa_size, mi->pb_size);
+    fprintf(stderr, "  MAKI01B: %s.\n", mi->m_maki01b ? "true" : "false");
+    fprintf(stderr, "  200 line mode: %s.\n", mi->m_200 ? "true" : "false");
+    fprintf(stderr, "  digital 8 colors: %s.\n", mi->m_dig8 ? "true" : "false");
+}
+
+static void *maki_malloc(n, fn)
+    size_t n;
+    char *fn;
+{
+    void *r = (void *) malloc(n);
+    if(r == NULL)
+	maki_memory_error("malloc", fn);
+    return r;
+}
+
+static void *maki_realloc(p, n, fn)
+    void *p;
+    size_t n;
+    char *fn;
+{
+    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
+    if(r == NULL)
+	maki_memory_error("realloc", fn);
+    return r;
+}
+#endif /* HAVE_MAKI */
diff -Naur xv-3.10a.old/xvmask.c xv-3.10a/xvmask.c
--- xv-3.10a.old/xvmask.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvmask.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,912 @@
+/*
+ * xvmask.c - image mask algorithms (FLmask, etc.)
+ *
+ *  Contains:
+ *         void DoMask(int algnum);
+ */
+
+#include "copyright.h"
+#include "xv.h"
+
+typedef struct { int n; char flg; } CPS;
+typedef struct { int n; unsigned short int r; } MKT;
+
+/* Flmask */
+void cpcode 		PARM ((char *, unsigned char *, int));
+void MaskCr 		PARM ((void));
+static void FLmask 	PARM ((void));
+static void Q0mask 	PARM ((void));
+static void WINmask 	PARM ((void));
+static void MEKOmask 	PARM ((void));
+static void CPmask 	PARM ((void));
+static void XOR80 	PARM ((void));
+static void RGBchange 	PARM ((void));
+static void BitReverse 	PARM ((void));
+static void ColReverse 	PARM ((void));
+
+/***** Flmask *****/
+static void doMaskCr 		PARM ((byte *, int, int, int, int, int, int));
+static void doFLmask 		PARM ((byte *, int, int, byte *, int, int, int, int));
+static void doCPmask 		PARM ((byte *, int, int, byte *, int, int, int, int, char *));
+static void doMEKOmask 		PARM ((byte *, int, int, byte *, int, int, int, int, int));
+static void doColReverse 	PARM ((byte *, int, int, byte *, int, int, int, int, int));
+static void doRGBchange 	PARM ((byte *, int, int, byte *, int, int, int, int));
+static void doQ0mask 		PARM ((byte *, int, int, byte *, int, int, int, int, int, int));
+static int *calcFLmask 		PARM ((int, int));
+static void move8bit 		PARM ((byte *, byte *, int));
+static void move16bit 		PARM ((byte *, byte *, int));
+static void moveCP 		PARM ((byte *, byte *, int, int));
+static void doWINmask 		PARM ((byte *, int, int, byte *, int, int, int, int));
+static void wincp 		PARM ((int, int, byte *, byte *));
+
+/******************/
+
+int start24bitAlg 		PARM ((byte **, byte **));
+void end24bitAlg 		PARM ((byte *, byte *));
+void saveOrigPic 		PARM ((void));
+void printUTime 		PARM ((char *));
+
+byte *origPic;
+
+#undef TIMING_TEST
+
+#ifdef TIMING_TEST
+#include <sys/time.h>
+#include <sys/resource.h>
+#endif
+
+/************************/
+void
+DoMask (anum)
+     int anum;
+{
+    switch (anum)
+    {
+    case MSK_NONE: 	DoAlg (ALG_NONE); 	break;
+    case MSK_FLMASK: 	FLmask (); 		break;
+    case MSK_Q0MASK: 	Q0mask (); 		break;
+    case MSK_WIN: 	WINmask (); 		break;
+    case MSK_MEKO: 	MEKOmask (); 		break;
+    case MSK_CPMASK: 	CPmask (); 		break;
+    case MSK_RGB: 	RGBchange (); 		break;
+    case MSK_BITREV: 	BitReverse (); 		break;
+    case MSK_COLREV: 	ColReverse (); 		break;
+    }
+
+    algMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
+    flmaskMB.dim[ALG_NONE] = (origPic == (byte *) NULL);
+}
+
+
+/******************************
+      Flmask:  FLMASK.
+******************************/
+static void
+FLmask ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    str = "Doing FLMASK...";
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic))
+	return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doFLmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
+
+    end24bitAlg (pic24, tmpPic);
+}
+
+/******************************
+      Flmask:  BitReverse.
+******************************/
+static void
+BitReverse ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    str = "Doing reverse bit...";
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic))
+	return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doColReverse (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, 1);
+
+    end24bitAlg (pic24, tmpPic);
+}
+
+/******************************
+      Flmask:  ColReverse.
+******************************/
+static void
+ColReverse ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    str = "Doing reverse colormap...";
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic))
+	return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doColReverse (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, 0);
+    end24bitAlg (pic24, tmpPic);
+}
+
+
+/******************************
+      Flmask:  Q0 MASK.
+******************************/
+static void
+Q0mask ()
+{
+    int pixX, pixY, err;
+    static char *labels[] = {"\nOk", "\033Cancel"};
+    char txt[256];
+    static char buf[64] = {'8', '\0'};
+    byte *pic24, *p24, *tmpPic, *tp, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    sprintf (txt, "FLmask: Q0mask        \n\nEnter mask pixels size: %s\n", "(ex. '8', '8x16')");
+
+    i = GetStrPopUp (txt, labels, 2, buf, 64, "0123456789x", 1);
+    if (i == 1 || strlen (buf) == 0) return;
+
+    pixX = pixY = err = 0;
+
+    if (index (buf, 'x'))
+    {
+	if (sscanf (buf, "%d x %d", &pixX, &pixY) != 2) err++;
+    }
+    else
+    {
+	if (sscanf (buf, "%d", &pixX) != 1) err++;
+	pixY = pixX;
+    }
+
+    if (pixX < 1 || pixY < 1 || err)
+    {
+	ErrPopUp ("Error:  The entered string is not valid.",
+		  "\nWho Cares!");
+	return;
+    }
+    WaitCursor ();
+
+    str = "Doing Q0 MASK...";
+    SetISTR (ISTR_INFO, str);
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doQ0mask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, pixX, pixY);
+    end24bitAlg (pic24, tmpPic);
+}
+
+/******************************
+      Flmask:  RGBchange.
+******************************/
+static void
+RGBchange ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    str = "Doing RGB change...";
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doRGBchange (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
+
+    end24bitAlg (pic24, tmpPic);
+}
+
+/******************************
+      Flmask:  WINmask.
+******************************/
+static void
+WINmask ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    str = "Doing WIN mask...";
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doWINmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh);
+
+    end24bitAlg (pic24, tmpPic);
+}
+
+/******************************
+      Flmask:  MEKOmask.
+******************************/
+static
+void
+MEKOmask ()
+{
+    static char *labels[] = {"\nForward", "\nBackward"};
+    char txt[256], key[48];
+    byte *pic24, *p24, *tmpPic, *tp, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    memset (key, 0, 48);
+
+    sprintf (txt, "FLmask: MEKO mask  \n\n    Select MEKOmask type ",
+	     key);
+    i = PopUp (txt, labels, 2);
+
+    WaitCursor ();
+    str = "Doing MEKOmask...";
+    SetISTR (ISTR_INFO, str);
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+    doMEKOmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, i);
+    end24bitAlg (pic24, tmpPic);
+}
+
+/************************/
+static void
+doMEKOmask (pic24, w, h, results, selx, sely, selw, selh, flag)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh, flag;
+{
+    register byte *dst, *src;
+    register int x, y, i;
+    register int xmax, ymax;
+    MKT *mt;
+
+    printUTime ("start of MEKOmask.");
+
+    xmax = selw / 16;
+    ymax = selh / 16;
+
+    mt = (MKT *) calcMEKO (xmax * ymax);
+    if (mt == NULL)
+	return;
+
+    for (i = 0; i < xmax * ymax; i++)
+    {
+	ProgressMeter (1, (xmax * ymax) - 1, i, "MEKOmask");
+	if ((i & 63) == 0)
+	    WaitCursor ();
+
+	if (flag == 0)
+	{
+	    dst = results + ((sely + ((mt[i].n - 1) / xmax) * 16) * w
+			     + selx + ((mt[i].n - 1) % xmax) * 16) * 3;
+	    src = pic24 + ((sely + (i / xmax) * 16) * w
+			   + selx + (i % xmax) * 16) * 3;
+	}
+	else
+	{
+	    src = pic24 + ((sely + ((mt[i].n - 1) / xmax) * 16) * w
+			   + selx + ((mt[i].n - 1) % xmax) * 16) * 3;
+	    dst = results + ((sely + (i / xmax) * 16) * w
+			     + selx + (i % xmax) * 16) * 3;
+	}
+	move16bit (dst, src, w);
+    }
+
+    free (mt);
+    printUTime ("end of MEKOmask.");
+}
+
+static void
+move16bit (byte * dest, byte * src, int w)
+{
+    int y, x;
+    byte *tmp1, *tmp2;
+
+    for (y = 0; y < 16; y++)
+    {
+	tmp1 = dest + y * w * 3;
+	tmp2 = src + y * w * 3;
+	for (x = 0; x < 16 * 3; x++)
+	{
+	    *tmp1 = *tmp2;
+	    tmp1++;
+	    tmp2++;
+	}
+    }
+}
+
+/******************************
+      Flmask:  CP MASK.
+******************************/
+static void
+CPmask ()
+{
+    static char *labels[] = {"\nOk", "\033Cancel"};
+    char buf[64];
+    char txt[256], key[48];
+    byte *pic24, *p24, *tmpPic, *tp, *tlp;
+    char *str;
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    memset (key, 0, 48);
+    cpcode (fullfname, key, 0);
+    if (key[0] == 0)
+    {
+	memset (key, 0, 48);
+	cpcode (fullfname, key, 1);
+	if (key[0] == 0)
+	{
+	    memset (key, 0, 48);
+	    cpcode (fullfname, key, 2);
+	}
+    }
+
+    strcpy(buf,key);
+    if (strlen(buf)==0)strcpy(buf,"SAMPLE");
+    sprintf (txt, "FLmask: CPmask          \n\nEnter CPmask code: %s \n",
+    	"(ex. 'SAMPLE')");
+
+    i = GetStrPopUp (txt, labels, 2, buf, 64, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1);
+    if (i == 1 || strlen (buf) == 0) return; 
+    strcpy(key,buf);
+
+    /*  Old version.
+    sprintf (txt, "FLmask: CP mask  \n\n   CP code = %s ", key);
+    i = PopUp (txt, labels, 2);
+    if (i == 1) return;
+    */
+
+    WaitCursor ();
+    str = "Doing CP mask...";
+    SetISTR (ISTR_INFO, str);
+
+    if (HaveSelection ()) GetSelRCoords (&sx, &sy, &sw, &sh);
+    else { sx = 0; sy = 0; sw = pWIDE; sh = pHIGH; }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+    doCPmask (pic24, pWIDE, pHIGH, tmpPic, sx, sy, sw, sh, key);
+    end24bitAlg (pic24, tmpPic);
+}
+
+/************************/
+static void
+doCPmask (pic24, w, h, results, selx, sely, selw, selh, key)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh;
+     char *key;
+{
+    register byte *dst, *src;
+    register int x, y, i;
+    register int xmax, ymax;
+    CPS *cps;
+
+    printUTime ("start of CPmask.");
+
+    xmax = selw / 8;
+    ymax = selh / 8;
+
+    cps = (CPS *) calcCPmask (key, xmax * ymax);
+
+    for (i = 0; i < xmax * ymax; i++)
+    {
+	ProgressMeter (1, (xmax * ymax) - 1, i, "CPmask");
+	if ((i & 63) == 0) WaitCursor ();
+
+	dst = results + ((sely + (cps[i].n / xmax) * 8) * w
+			 + selx + (cps[i].n % xmax) * 8) * 3;
+	src = pic24 + ((sely + (i / xmax) * 8) * w
+		       + selx + (i % xmax) * 8) * 3;
+	moveCP (dst, src, w, cps[i].flg);
+    }
+
+    free (cps);
+    printUTime ("end of CPmask.");
+}
+
+static void
+moveCP (byte * dest, byte * src, int w, int cp_flag)
+{
+    int y, x;
+    byte *tmp1, *tmp2;
+
+    if (cp_flag == 0)
+    {
+	for (y = 0; y < 8; y++)
+	{
+	    tmp1 = dest + y * w * 3;
+	    tmp2 = src + y * w * 3;
+	    for (x = 0; x < 8 * 3; x += 3)
+	    {
+		tmp1[0] = (byte) ~ tmp2[1];
+		tmp1[1] = (byte) ~ tmp2[0];
+		tmp1[2] = (byte) ~ tmp2[2];
+		tmp1 += 3;
+		tmp2 += 3;
+	    }
+	}
+    }
+    else
+    {
+	for (y = 0; y < 8; y++)
+	{
+	    tmp1 = dest + y * 3;
+	    tmp2 = src + y * w * 3;
+	    for (x = 0; x < 8 * 3; x += 3)
+	    {
+		tmp1[0] = (byte) ~ tmp2[1];
+		tmp1[1] = (byte) ~ tmp2[0];
+		tmp1[2] = (byte) ~ tmp2[2];
+		tmp1 += w * 3;
+		tmp2 += 3;
+	    }
+	}
+    }
+}
+
+/************************/
+static void
+doFLmask (pic24, w, h, results, selx, sely, selw, selh)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh;
+{
+    register byte *dst, *src;
+    register int x, y, i;
+    register int *ar, xmax, ymax;
+
+    printUTime ("start of FLMASK.");
+
+    xmax = selw / 8;
+    ymax = selh / 8;
+    ar = (int *) calcFLmask (xmax, ymax);
+
+    for (i = 0; i < xmax * ymax; i++)
+    {
+	ProgressMeter (1, (xmax * ymax * 2) - 1,
+		i + xmax * ymax, "FLMASK");
+	if ((i & 63) == 0) WaitCursor ();
+
+	dst=results+((sely+(ar[xmax*ymax-i-1]/xmax)*8)*w
+		+selx+(ar[xmax*ymax-i-1]%xmax)*8)*3;
+	src=pic24+((sely+(ar[i]/xmax)*8)*w
+		+selx+(ar[i]%xmax)*8)*3;
+	if (ar[i] != ar[xmax * ymax - i - 1])
+	    move8bit (dst, src, w);
+    }
+
+    free (ar);
+    printUTime ("end of FLMASK.");
+}
+
+static int *
+calcFLmask (int xmax, int ymax)
+{
+    int *spc, *tmp_ar;
+    int i, l, x, y, c;
+    struct direction { int x; int y; } dir[4];
+
+    dir[0].x = 0;  dir[0].y = -1;
+    dir[1].x = -1; dir[1].y = 0;
+    dir[2].x = 0;  dir[2].y = 1;
+    dir[3].x = 1;  dir[3].y = 0;
+
+    spc = (int *) malloc (sizeof (int) * xmax * ymax);
+    tmp_ar = (int *) malloc (sizeof (int) * xmax * ymax);
+
+    c = 0;
+    for (l = 0; l < ymax; l++)
+    {
+	for (i = 0; i < xmax; i++)
+	{
+	    spc[c] = c;
+	    c++;
+	}
+    }
+
+    c = 3;
+    x = 0;
+    y = ymax - 1;
+    for (i = 0; i < xmax * ymax; i++)
+    {
+	ProgressMeter (1, (xmax * ymax * 2) - 1, i, "FLmask");
+	if ((i & 63) == 0) WaitCursor ();
+
+	tmp_ar[i] = spc[x + y * xmax];
+	if ((x + dir[c].x) == xmax || (x + dir[c].x) < 0)
+	{
+	    c++;
+	    if (c == 4) c = 0;
+	}
+	if ((y + dir[c].y) == ymax || (y + dir[c].y) < 0)
+	{
+	    c++;
+	    if (c == 4) c = 0;
+	}
+	for (l = 0; l < i; l++)
+	{
+		if(spc[x+(dir[c].x)+(y+(dir[c].y))*xmax]==tmp_ar[l])
+	    {
+		c++;
+		if (c == 4) c = 0;
+		break;
+	    }
+	}
+	x = x + dir[c].x;
+	y = y + dir[c].y;
+    }
+    free (spc);
+    return (tmp_ar);
+}
+
+static void
+move8bit (byte * dest, byte * src, int w)
+{
+    int y, x;
+    byte *tmp1, *tmp2;
+
+    for (y = 0; y < 8; y++)
+    {
+	tmp1 = dest + y * w * 3;
+	tmp2 = src + y * w * 3;
+	for (x = 0; x < 8 * 3; x++)
+	{
+	    *tmp1 = (byte) ~ (*tmp2);
+	    tmp1++;
+	    tmp2++;
+	}
+    }
+}
+
+/************************/
+static void
+doColReverse (pic24, w, h, results, selx, sely, selw, selh, bit_flag)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh, bit_flag;
+{
+    register byte *p24;
+    register byte *rp;
+    register int x, y;
+
+    printUTime ("start of Reverse.");
+
+    for (y = sely; y < sely + selh; y++)
+    {
+
+	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Reverse");
+	if ((y & 63) == 0) WaitCursor ();
+
+	rp = results + (y * w + selx) * 3;
+	p24 = pic24 + (y * w + selx) * 3;
+
+	if (bit_flag == 1)
+	{
+	    /* BitReverse. */
+	    for (x = selx; x < selx + selw * 3; x++, p24++, rp++)
+		*rp = (byte) ~ (*p24);
+
+	}
+	else
+	{
+	    /* ColReverse. */
+	    for (x = selx; x < selx + selw * 3; x++, p24++, rp++)
+		*rp = *p24 ^ 0x80;
+	}
+    }
+    printUTime ("end of Reverse.");
+}
+
+/************************/
+static void
+doQ0mask (pic24, w, h, results, selx, sely, selw, selh, pixX, pixY)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh, pixX, pixY;
+{
+    register byte *p24;
+    register int bperlin, rsum, gsum, bsum;
+    byte *rp;
+    int i, x, y;
+    int skip, y0, x0;
+
+    printUTime ("start of Q0mask.");
+
+    bperlin = w * 3;
+
+    for (y = sely; y < sely + ((selh / pixY) * pixY); y++)
+    {
+	ProgressMeter(sely+1,(sely+((selh/pixY)*pixY))-1,y,"Q0mask");
+	if ((y & 63) == 0) WaitCursor ();
+
+	rp = results + (y * w + selx) * 3;
+	y0 = y - sely;
+	p24=pic24+((((y0/pixY+1)*pixY)-1-(y0%pixY)+sely)*w+selx)*3;
+
+	for(x=selx;x<selx+((selw/pixX)*pixX);x++,p24+=3,rp+=3)
+	{
+	    x0 = x - selx;
+	    skip = (pixX - 1 - 2 * (x0 % pixX)) * 3;
+
+	    rp[0] = (byte) ~ p24[skip];
+	    rp[1] = (byte) ~ p24[skip + 1];
+	    rp[2] = (byte) ~ p24[skip + 2];
+	}
+    }
+    printUTime ("end of Q0 MASK.");
+}
+
+/************************/
+static void
+doWINmask (pic24, w, h, results, selx, sely, selw, selh)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh;
+{
+    register byte *p24;
+    register byte *rp;
+    register int x, y;
+
+    printUTime ("start of WIN mask.");
+
+    for (y = sely; y < sely + selh; y++)
+    {
+
+	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "WINmask");
+	if ((y & 63) == 0) WaitCursor ();
+
+	rp = results + (y * w + selx) * 3;
+	p24 = pic24 + (y * w + selx) * 3;
+
+	for(x=selx;x<selx+(selw/16)*16*3;x+=48,p24+=48,rp+=48)
+	{
+	    wincp ( 0,12, p24, rp);
+	    wincp ( 1, 8, p24, rp);
+	    wincp ( 2, 6, p24, rp);
+	    wincp ( 3,15, p24, rp);
+	    wincp ( 4, 9, p24, rp);
+	    wincp ( 5,13, p24, rp);
+	    wincp ( 6, 2, p24, rp);
+	    wincp ( 7,11, p24, rp);
+	    wincp ( 8, 1, p24, rp);
+	    wincp ( 9, 4, p24, rp);
+	    wincp (10,14, p24, rp);
+	    wincp (11, 7, p24, rp);
+	    wincp (12, 0, p24, rp);
+	    wincp (13, 5, p24, rp);
+	    wincp (14,10, p24, rp);
+	    wincp (15, 3, p24, rp);
+	}
+    }
+    printUTime ("end of WIN mask.");
+}
+
+static void
+wincp (int src, int dst, byte * p24, byte * rp)
+{
+    *(rp + dst * 3) = *(p24 + src * 3);
+    *(rp + dst * 3 + 1) = *(p24 + src * 3 + 1);
+    *(rp + dst * 3 + 2) = *(p24 + src * 3 + 2);
+}
+
+/************************/
+static void
+doRGBchange (pic24, w, h, results, selx, sely, selw, selh)
+     byte *pic24, *results;
+     int w, h, selx, sely, selw, selh;
+{
+    register byte *p24;
+    register byte *rp;
+    register int x, y;
+
+    printUTime ("start of RGB change.");
+
+    for (y = sely; y < sely + selh; y++)
+    {
+
+	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Change");
+	if ((y & 63) == 0) WaitCursor ();
+
+	rp = results + (y * w + selx) * 3;
+	p24 = pic24 + (y * w + selx) * 3;
+
+	for (x = selx; x < selx + selw * 3; x += 3, p24 += 3, rp += 3)
+	{
+	    *rp = *(p24 + 1);
+	    *(rp + 1) = *(p24 + 2);
+	    *(rp + 2) = *(p24);
+	}
+    }
+    printUTime ("end of Reverse.");
+}
+
+
+/******************************
+      Flmask:  MaskCrop.
+******************************/
+void
+MaskCr ()
+{
+    byte *pic24, *p24, *tmpPic, *tlp;
+    char str[] = "Doing AutoMaskCrop...";
+    int i, j, v, maxv, sx, sy, sw, sh;
+
+    WaitCursor ();
+
+    if (HaveSelection ())
+	GetSelRCoords (&sx, &sy, &sw, &sh);
+    else
+    {
+	sx = 0;
+	sy = 0;
+	sw = pWIDE - 1;
+	sh = pHIGH - 1;
+    }
+
+    CropRect2Rect (&sx, &sy, &sw, &sh, 0, 0, pWIDE, pHIGH);
+
+    SetISTR (ISTR_INFO, str);
+
+    if (start24bitAlg (&pic24, &tmpPic)) return;
+    xvbcopy ((char *) pic24, (char *) tmpPic,
+	     (size_t) (pWIDE * pHIGH * 3));
+
+    doMaskCr (pic24, pWIDE, pHIGH, sx, sy, sw, sh);
+
+    end24bitAlg (pic24, tmpPic);
+}
+
+/************************/
+static void
+doMaskCr (pic24, w, h, selx, sely, selw, selh)
+     byte *pic24;
+     int w, h, selx, sely, selw, selh;
+{
+    register byte *p24, *p24u;
+    register int x, y;
+    double edge, *edgeX, *edgeY, maxX, maxY, tmp;
+    int x1, x2, y1, y2, i;
+    int xp1, xp2, yp1, yp2;
+
+    printUTime ("start of MaskCrop.");
+
+    edgeX = (double *) malloc (sizeof (edge) * selw);
+    edgeY = (double *) malloc (sizeof (edge) * selh);
+    memset (edgeX, 0, sizeof (edge) * selw);
+    memset (edgeY, 0, sizeof (edge) * selh);
+
+    for (y = sely + 1; y < sely + selh - 1; y++)
+    {
+	ProgressMeter (sely + 1, (sely + selh - 1) - 1, y, "Search");
+	if ((y & 63) == 0) WaitCursor ();
+
+	p24u = pic24 + ((y - 1) * w + selx) * 3;
+	p24 = pic24 + (y * w + selx) * 3;
+
+#define DBL(x)	((x)*(x))
+	for (x = selx; x < selx + selw * 3; x += 3)
+	{
+	    edgeX[(x - selx) / 3] += (double) DBL (p24[3] - p24[0]) +
+		DBL (p24[4] - p24[1]) + DBL (p24[5] - p24[2]);
+	    edgeY[y - sely] += (double) DBL (p24[0] - p24u[0]) +
+		DBL (p24[1] - p24u[1]) + DBL (p24[2] - p24u[2]);
+	    p24u += 3;
+	    p24 += 3;
+	}
+    }
+
+    maxX = 0;
+    for (x = 0; x < selw; x++)
+    {
+	if (maxX < edgeX[x])
+	    maxX = edgeX[x];
+    }
+    maxY = 0;
+    for (y = 0; y < selh; y++)
+    {
+	if (maxY < edgeY[y])
+	    maxY = edgeY[y];
+    }
+
+    tmp = 0.3;	/* ←↓この辺の数値は適当に決定されました(?)。 */
+    for (;;)
+    {
+	xp1 = 0; xp2 = 0;
+	yp1 = 0; yp2 = 0;
+	for (x = 1; x < selw - 1; x++) {
+	    if (edgeX[x] > maxX * tmp) { xp1 = x; break; }
+	}
+	for (x = selw - 1; x >= 1; x--) {
+	    if (edgeX[x] > maxX * tmp) { xp2 = x; break; }
+	}
+	for (y = 1; y < selh - 1; y++) {
+	    if (edgeY[y] >= maxY * tmp) { yp1 = y; break; }
+	}
+	for (y = selh - 1; y >= 1; y--) {
+	    if (edgeY[y] >= maxY * tmp) { yp2 = y; break; }
+	}
+	if(xp2-xp1 > 4 && yp2-yp1 > 4 && xp1*xp2*yp1*yp2 != 0) break;
+
+	if (tmp <= 0.01) return;
+	else tmp = tmp / 2.0;
+    }
+
+    free (edgeY);
+    free (edgeX);
+
+    x1 = xp1 + selx + 1;
+    x2 = xp2 - xp1;
+    y1 = yp1 + sely;
+    y2 = yp2 - yp1;
+
+    /* crop1(x1,y1,x2,y2,0);  <-- DO_CROP  */
+    MaskSelect (x1, x2, y1, y2);
+
+    printUTime ("end of MaskSearch.");
+}
diff -Naur xv-3.10a.old/xvmeko.c xv-3.10a/xvmeko.c
--- xv-3.10a.old/xvmeko.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvmeko.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,962 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+unsigned short int mekornd[9216] = {
+    0x2064,0x16F2,0x0AD2,0x0E1F,0x0A31,0x17CE,0x0DE8,0x1C41,0x0878,0x1349,
+    0x184B,0x1B51,0x0841,0x19A3,0x0820,0x0C12,0x1117,0x2117,0x1BC1,0x1F13,
+    0x19ED,0x0230,0x040D,0x1957,0x116D,0x0FD6,0x1E4F,0x0C28,0x1D28,0x077A,
+    0x205E,0x053D,0x0686,0x13AC,0x1A0E,0x16DE,0x1607,0x1504,0x0CED,0x088F,
+    0x159D,0x0EF4,0x0C3F,0x1120,0x225D,0x0B43,0x1B2D,0x184C,0x043D,0x1221,
+    0x0A12,0x225C,0x04F0,0x1399,0x1289,0x1899,0x1B0B,0x1A2B,0x1383,0x084A,
+    0x1DEE,0x118C,0x2395,0x00F5,0x16CD,0x0A9C,0x0E73,0x1FF9,0x0288,0x0014,
+    0x0EA9,0x17B3,0x13AF,0x03A7,0x0CE7,0x20AC,0x0E93,0x1F1E,0x207D,0x00B4,
+    0x1833,0x1DD4,0x09FD,0x0819,0x052A,0x16C9,0x1893,0x2134,0x0D8F,0x1597,
+    0x1573,0x22B5,0x1B55,0x04CE,0x0BB1,0x02FD,0x0685,0x0AAD,0x18DA,0x0A6C,
+    0x0E92,0x15C5,0x0695,0x0A70,0x1D67,0x11D0,0x0CC9,0x1E8A,0x12AC,0x0EF1,
+    0x220D,0x04FB,0x1034,0x00F4,0x0E6D,0x1F90,0x1649,0x108C,0x0AAA,0x1160,
+    0x238F,0x056C,0x0E0C,0x20A7,0x0658,0x0502,0x1973,0x0FB2,0x12D8,0x0D94,
+    0x1201,0x03BA,0x167E,0x237F,0x0D38,0x00E0,0x2183,0x201B,0x1192,0x08C1,
+    0x1240,0x20CB,0x073F,0x10DE,0x1379,0x163A,0x1D2E,0x0A15,0x19DB,0x02CD,
+    0x01BC,0x032C,0x23B9,0x1FD2,0x1E7D,0x1518,0x2148,0x0E72,0x235E,0x1DF0,
+    0x0538,0x1BCB,0x0926,0x1C17,0x0134,0x175A,0x1872,0x0ECF,0x06EB,0x0045,
+    0x100D,0x06EF,0x1EFE,0x0777,0x006C,0x0386,0x1DA4,0x1351,0x07AB,0x21EA,
+    0x1FF2,0x1017,0x182B,0x047B,0x1531,0x19DE,0x0F3A,0x186C,0x052E,0x1A15,
+    0x23E5,0x1901,0x0B44,0x0458,0x20E8,0x20AF,0x0793,0x23DD,0x1F3B,0x17D4,
+    0x1879,0x2262,0x101D,0x224A,0x0D12,0x01F0,0x1B7D,0x1BEE,0x224F,0x04C7,
+    0x1D8F,0x132F,0x1E94,0x0F26,0x2193,0x164A,0x1B0A,0x22F2,0x0393,0x00DA,
+    0x0924,0x1DCD,0x17A2,0x038D,0x0263,0x10AA,0x2344,0x089B,0x0085,0x0C80,
+    0x196A,0x16E7,0x09C5,0x0903,0x08D3,0x21AE,0x0255,0x049D,0x1F67,0x207C,
+    0x0CCA,0x055C,0x0E8F,0x1FD3,0x15A9,0x1B9E,0x1640,0x0983,0x08CC,0x0CE6,
+    0x0E5E,0x15CF,0x2248,0x0BDB,0x1FB4,0x1BD6,0x08B2,0x092B,0x10B7,0x1832,
+    0x1558,0x214F,0x005A,0x1E9D,0x15DC,0x1DAB,0x0435,0x199F,0x0B42,0x23DA,
+    0x1BCD,0x1339,0x095C,0x1A89,0x08FA,0x2379,0x0F74,0x060A,0x1408,0x0EB3,
+    0x1559,0x00AC,0x0D0D,0x14D4,0x07B1,0x1ACC,0x1707,0x03C4,0x0FBE,0x0C76,
+    0x21A8,0x0A0B,0x0D60,0x1E97,0x1625,0x117A,0x0415,0x008F,0x1F9C,0x00A6,
+    0x19C5,0x04E7,0x21F2,0x0E08,0x17BA,0x10B9,0x0656,0x22C4,0x2048,0x070E,
+    0x15CB,0x01F3,0x0488,0x1167,0x14A2,0x08CF,0x0AC2,0x12BE,0x20A1,0x0501,
+    0x01B2,0x004B,0x10E2,0x09C9,0x01FA,0x05B7,0x0E20,0x0D55,0x003B,0x1413,
+    0x1F7E,0x1A03,0x06CB,0x21C4,0x1FA5,0x1E15,0x0C14,0x0A93,0x133B,0x0498,
+    0x1EB7,0x0BFB,0x1774,0x1F14,0x21D0,0x1930,0x04FF,0x0245,0x1B0C,0x2368,
+    0x198C,0x1487,0x08C2,0x20A0,0x18BE,0x010B,0x16AE,0x1C65,0x08EA,0x23E8,
+    0x09D0,0x158B,0x237D,0x1F72,0x2051,0x188E,0x04A7,0x2074,0x1E91,0x1557,
+    0x07DC,0x2136,0x0F50,0x234C,0x1602,0x0572,0x20DB,0x00B8,0x1929,0x17A5,
+    0x0E82,0x0D86,0x03BD,0x1B02,0x2323,0x0445,0x1AB6,0x02B4,0x0D1A,0x1524,
+    0x03FE,0x1231,0x189A,0x18DE,0x15F6,0x17EB,0x0B89,0x14CA,0x0910,0x09B9,
+    0x1380,0x0559,0x169D,0x22A0,0x00D0,0x0F7A,0x0FB7,0x1FFF,0x1996,0x06FF,
+    0x0FA5,0x1C83,0x0C61,0x1ECE,0x061F,0x193E,0x232E,0x048E,0x0B5A,0x03D4,
+    0x1CF9,0x0B0F,0x2274,0x18EF,0x1CB5,0x1CAF,0x18B1,0x0FF3,0x0712,0x19CD,
+    0x1E6E,0x0A25,0x1375,0x0525,0x19DA,0x0042,0x0BF4,0x1FFC,0x03D0,0x1974,
+    0x1C33,0x0DB3,0x0180,0x0E8C,0x22EB,0x1121,0x00A1,0x02FC,0x1B3C,0x1D68,
+    0x15FD,0x22BF,0x1C5D,0x15AB,0x1BB7,0x00F6,0x2219,0x09FB,0x18DF,0x19D5,
+    0x1396,0x044A,0x1381,0x218D,0x1AEF,0x0603,0x22E1,0x237B,0x0BD3,0x110B,
+    0x171A,0x201F,0x0C92,0x059C,0x1B10,0x14AB,0x21E1,0x074B,0x1C8D,0x083E,
+    0x1684,0x117C,0x0D73,0x1740,0x0F45,0x016C,0x153E,0x15FE,0x08C5,0x2080,
+    0x166E,0x05A2,0x1897,0x18EB,0x0038,0x1F4B,0x1EBA,0x07F5,0x0DB4,0x22E9,
+    0x0977,0x0724,0x0287,0x0DCB,0x0EFD,0x11A7,0x0C66,0x1393,0x078E,0x2017,
+    0x1849,0x03B6,0x175F,0x1E05,0x1FB7,0x0AF6,0x03AC,0x02FF,0x10EE,0x07E6,
+    0x1529,0x1EC1,0x005D,0x14BB,0x074F,0x098E,0x214B,0x0EB2,0x0B96,0x1940,
+    0x11FB,0x0721,0x180F,0x2346,0x1163,0x1BE9,0x1BC4,0x1B7E,0x03D7,0x19C0,
+    0x23F6,0x0C0C,0x1F60,0x0CD4,0x1882,0x22FB,0x21EB,0x0948,0x122B,0x0474,
+    0x121B,0x09C2,0x17CF,0x1993,0x2112,0x2259,0x2292,0x142A,0x00D2,0x125B,
+    0x0E63,0x0F81,0x0E2E,0x01EC,0x0D11,0x1791,0x2353,0x0BC5,0x239B,0x1B97,
+    0x1F68,0x173C,0x1DAD,0x0778,0x165C,0x09E2,0x0D5D,0x0E9C,0x1FBB,0x22FF,
+    0x14DF,0x0F96,0x1D08,0x1ECD,0x2114,0x10EF,0x21F4,0x0F04,0x040B,0x07D6,
+    0x01E1,0x1C95,0x0441,0x163D,0x17EE,0x032B,0x0FE6,0x2273,0x18F5,0x21FA,
+    0x0ED3,0x18DC,0x0001,0x014C,0x1144,0x032A,0x0717,0x1D14,0x04F1,0x0225,
+    0x14E3,0x026F,0x147D,0x076C,0x135B,0x1966,0x15BF,0x12D3,0x0785,0x097D,
+    0x036F,0x1B88,0x1CE2,0x1360,0x0A8B,0x1FBC,0x101F,0x005B,0x0A29,0x1303,
+    0x1CD5,0x0706,0x066E,0x04D7,0x0D9C,0x1B25,0x014F,0x1182,0x1FF0,0x1452,
+    0x0683,0x096C,0x0F79,0x0C1C,0x2394,0x1306,0x1FAD,0x081F,0x1A7D,0x181F,
+    0x0D45,0x219A,0x167A,0x1813,0x0329,0x1876,0x126D,0x097C,0x0EB6,0x1820,
+    0x1374,0x2121,0x11E4,0x0AB4,0x071E,0x03AB,0x0FA1,0x1E0A,0x1E59,0x1C85,
+    0x0197,0x1CCA,0x1148,0x1A81,0x0D04,0x1955,0x1705,0x0ED9,0x01D9,0x102E,
+    0x0480,0x0475,0x1641,0x0101,0x18A1,0x09B3,0x1B5F,0x1CFD,0x054E,0x06D5,
+    0x1A95,0x0301,0x05F6,0x150C,0x0086,0x04DC,0x05BD,0x004E,0x043C,0x1020,
+    0x136B,0x0B6D,0x00B3,0x0FCA,0x1CFC,0x16D4,0x1E32,0x09E3,0x1588,0x1B58,
+    0x0A9A,0x036A,0x0C8B,0x11EF,0x1823,0x0AF3,0x1448,0x1DCA,0x1931,0x05D6,
+    0x0CF9,0x1207,0x063F,0x0F88,0x0D46,0x1FCE,0x162F,0x08CD,0x13A6,0x181B,
+    0x2107,0x2197,0x01AF,0x09A1,0x07AA,0x01BF,0x1932,0x118F,0x1EB0,0x0A7F,
+    0x087D,0x0E2F,0x1FE0,0x12EF,0x1BEF,0x1D4D,0x1C19,0x1856,0x1D19,0x1294,
+    0x1D57,0x176C,0x02DC,0x101C,0x22B7,0x0135,0x17B5,0x0310,0x1548,0x1D2A,
+    0x1626,0x0B31,0x1E7C,0x1BE7,0x140C,0x1B81,0x019E,0x1F11,0x11C6,0x0939,
+    0x2182,0x05BB,0x06C8,0x00E4,0x0529,0x1B26,0x13FC,0x1202,0x1A32,0x07F3,
+    0x098D,0x0E58,0x01B7,0x1DB0,0x0152,0x189C,0x2073,0x0D56,0x1D5B,0x0D36,
+    0x09CC,0x18A8,0x0E5D,0x143C,0x1063,0x16CA,0x13CA,0x1E38,0x2359,0x1B9C,
+    0x0A8A,0x0A84,0x046C,0x0FF5,0x0D97,0x0A27,0x0E6B,0x10C2,0x1619,0x0DEE,
+    0x1DDC,0x0576,0x01C8,0x1069,0x0D4F,0x20AD,0x198B,0x09D5,0x0B22,0x033F,
+    0x20AA,0x1CCC,0x005F,0x0D68,0x19CB,0x1081,0x1D97,0x0AE2,0x1C5C,0x0F05,
+    0x123C,0x0B20,0x2371,0x0CEB,0x00CB,0x1F06,0x00BB,0x191B,0x0117,0x2376,
+    0x17BC,0x19CE,0x216D,0x1F07,0x1455,0x14B8,0x1C6A,0x1B80,0x0E5B,0x1851,
+    0x0172,0x23AA,0x0A22,0x0D7F,0x0720,0x0136,0x0666,0x1019,0x13FE,0x1ACE,
+    0x0B51,0x0C24,0x050E,0x1873,0x08AE,0x16AB,0x1A90,0x0A76,0x1552,0x19C4,
+    0x0FAB,0x0ABC,0x06C1,0x050A,0x0E49,0x1FCB,0x11A1,0x1387,0x0C47,0x2174,
+    0x0570,0x1BA2,0x1104,0x00AD,0x1444,0x2383,0x08C7,0x1127,0x056D,0x0D7E,
+    0x1CB9,0x02FA,0x100A,0x0C51,0x0FBA,0x1A94,0x128B,0x1859,0x2190,0x1B20,
+    0x1F56,0x186F,0x01D8,0x01F2,0x10A3,0x192C,0x0528,0x211B,0x1C92,0x0239,
+    0x0334,0x14C0,0x1D5A,0x1DE9,0x12F2,0x0A44,0x17CA,0x0F62,0x15D8,0x069F,
+    0x1D07,0x11FA,0x0816,0x153C,0x1C81,0x02F1,0x2342,0x23F7,0x0160,0x117F,
+    0x1BB9,0x1039,0x2063,0x1E3B,0x0C57,0x13E1,0x139A,0x1F12,0x15EA,0x1D48,
+    0x19C3,0x1A31,0x050C,0x13C5,0x0091,0x13A7,0x1765,0x01F8,0x1B75,0x0EA2,
+    0x1B6D,0x09EC,0x0312,0x113D,0x012D,0x18C3,0x08A0,0x0452,0x0D87,0x167D,
+    0x1DA9,0x0FF6,0x2340,0x19AD,0x007B,0x0CBC,0x1D1A,0x1AE4,0x09B4,0x11B2,
+    0x1B2C,0x14CE,0x1C5E,0x0222,0x162D,0x0C63,0x0584,0x0040,0x1D1F,0x1AF7,
+    0x0C96,0x132C,0x086B,0x136F,0x19E1,0x0DDA,0x22A5,0x22F7,0x2249,0x20C5,
+    0x0A19,0x0FDC,0x1834,0x0C58,0x1C56,0x01DC,0x1D84,0x0A66,0x2336,0x0955,
+    0x0900,0x1ED6,0x0361,0x0D58,0x1D4B,0x10C0,0x1852,0x040E,0x0F0B,0x1978,
+    0x12E8,0x2261,0x05FE,0x0BD2,0x13C8,0x0F3C,0x07A4,0x18CC,0x0A00,0x0642,
+    0x0D65,0x1DA8,0x0D15,0x2168,0x05B5,0x0DF8,0x2352,0x0408,0x07D9,0x15FA,
+    0x0E88,0x0C85,0x1FAB,0x16F5,0x1798,0x12BD,0x1FB3,0x09B6,0x12C2,0x17FA,
+    0x1BE6,0x1434,0x1DD6,0x0E18,0x08F5,0x07A7,0x0AA9,0x0099,0x1E5B,0x09F4,
+    0x1C02,0x0737,0x08B9,0x0504,0x0C05,0x0813,0x1716,0x06BE,0x1ECA,0x1995,
+    0x0D63,0x0745,0x1870,0x221D,0x0C6E,0x20D2,0x23C0,0x11D8,0x0D23,0x1924,
+    0x0D34,0x10AF,0x2339,0x1F37,0x0ACC,0x228E,0x20B1,0x127E,0x0293,0x0294,
+    0x18D2,0x0F77,0x1C89,0x035F,0x1441,0x0143,0x219C,0x042F,0x092E,0x1AC0,
+    0x0932,0x1D93,0x1AE6,0x1E03,0x0F87,0x16B4,0x15B1,0x066F,0x07A1,0x21A6,
+    0x20BD,0x201C,0x10F2,0x16B2,0x13B8,0x0C90,0x013E,0x191C,0x1ACA,0x10E0,
+    0x12DA,0x0047,0x15B8,0x1E51,0x0693,0x02CF,0x169A,0x1571,0x2167,0x022F,
+    0x2150,0x11A0,0x137D,0x143A,0x02D9,0x07AC,0x0B18,0x1730,0x0E1B,0x0BC3,
+    0x2178,0x1656,0x1041,0x1FDE,0x044C,0x21EC,0x1CF0,0x04A0,0x17F2,0x1D8B,
+    0x172B,0x0826,0x0B38,0x1FB6,0x07BA,0x1632,0x0BFF,0x12B8,0x0073,0x1D94,
+    0x0457,0x05B8,0x0CA6,0x08EC,0x1663,0x07CF,0x0E04,0x2116,0x23D6,0x1F6F,
+    0x0884,0x17D1,0x0B14,0x1222,0x0774,0x16C8,0x16A8,0x1DCF,0x1E21,0x1A42,
+    0x0CF4,0x184F,0x1AD3,0x1DA5,0x04F9,0x0F39,0x2173,0x091B,0x0648,0x21A7,
+    0x1481,0x15FB,0x0C69,0x064B,0x00BE,0x08D5,0x211D,0x07E5,0x22F6,0x10A7,
+    0x0791,0x1F88,0x0FB6,0x2004,0x014E,0x187E,0x17D7,0x2345,0x0C83,0x0DE6,
+    0x12B6,0x0365,0x1D4A,0x1C43,0x1266,0x083D,0x1A5F,0x0029,0x223B,0x1809,
+    0x0589,0x001C,0x0F90,0x1B77,0x10CC,0x12CB,0x0703,0x0471,0x0E6E,0x05E6,
+    0x0E95,0x0912,0x18DD,0x1EEA,0x02CA,0x04C2,0x0BDC,0x0EE6,0x158A,0x189B,
+    0x17AD,0x0CD8,0x1246,0x1457,0x0938,0x1D87,0x175C,0x0A85,0x1F20,0x17EC,
+    0x08E7,0x0678,0x0978,0x145E,0x00CF,0x001F,0x0D90,0x09F6,0x20E4,0x217D,
+    0x13E7,0x1CE0,0x1400,0x156D,0x084C,0x1881,0x0140,0x208B,0x21E5,0x041A,
+    0x02A0,0x0F23,0x22CA,0x0520,0x087A,0x1FAC,0x0FE2,0x15CD,0x05CF,0x1C34,
+    0x0BA3,0x033D,0x14DB,0x1251,0x0071,0x15FF,0x0139,0x21FB,0x003C,0x0629,
+    0x008A,0x03ED,0x0EA7,0x018B,0x146D,0x19D4,0x167F,0x1F24,0x21FC,0x04E9,
+    0x057F,0x0CB5,0x0F76,0x1B1A,0x19B0,0x1CDB,0x211E,0x0775,0x17D9,0x0494,
+    0x0C1F,0x0DB6,0x2184,0x1702,0x1165,0x1C4A,0x1043,0x0A5A,0x1004,0x03BE,
+    0x0B33,0x151A,0x038B,0x12ED,0x1287,0x2205,0x1F05,0x1AC8,0x19E3,0x1506,
+    0x0891,0x05DA,0x1C04,0x1ED3,0x0A11,0x061C,0x0DC5,0x01D5,0x1459,0x032E,
+    0x1A7B,0x12E3,0x1A8B,0x17D3,0x1391,0x0ADA,0x0A24,0x13E9,0x05DB,0x2050,
+    0x12C9,0x216A,0x0A09,0x149D,0x142B,0x0FD3,0x229D,0x19FA,0x0547,0x1984,
+    0x0E06,0x1827,0x0477,0x19D1,0x05DF,0x1248,0x12FF,0x01A2,0x10E8,0x095B,
+    0x2227,0x1262,0x00DC,0x0354,0x07E8,0x03DF,0x01FC,0x1AC1,0x0272,0x1AED,
+    0x090B,0x209E,0x1CCB,0x1AA5,0x218B,0x1D9C,0x1467,0x12B2,0x0D2C,0x1B3D,
+    0x0EC1,0x13F3,0x1330,0x1629,0x1576,0x2275,0x0684,0x0C41,0x0CD9,0x1836,
+    0x1280,0x104D,0x168D,0x1DE8,0x0E66,0x0A8C,0x2027,0x0448,0x0DA8,0x0A50,
+    0x1A4F,0x1A1A,0x0CF1,0x2180,0x03C5,0x1CAA,0x0B84,0x18EE,0x026B,0x1E44,
+    0x1F92,0x14F6,0x210E,0x0444,0x030A,0x140E,0x0F6B,0x0F44,0x0894,0x1407,
+    0x085A,0x091E,0x02B7,0x0B83,0x2238,0x1E25,0x0A32,0x19F5,0x06A9,0x239E,
+    0x10D9,0x2019,0x21A2,0x08A7,0x17DF,0x1A82,0x138F,0x08AA,0x12E6,0x074D,
+    0x1CDD,0x1FE1,0x0691,0x1F89,0x0810,0x05A9,0x00AB,0x0AD4,0x0623,0x02D4,
+    0x09D3,0x1232,0x2002,0x1FC3,0x1B73,0x0704,0x0150,0x197D,0x1646,0x0595,
+    0x1BAD,0x2146,0x0AD5,0x074C,0x03FD,0x1018,0x1F08,0x0989,0x1204,0x0499,
+    0x17E4,0x001E,0x0A23,0x13BC,0x1150,0x119C,0x056B,0x0BD7,0x0B8A,0x0AD7,
+    0x05A1,0x0AA6,0x1B27,0x18D1,0x0D42,0x14E9,0x0779,0x027A,0x1C76,0x01A7,
+    0x1FB0,0x1270,0x16C6,0x0142,0x1FF6,0x1172,0x11EB,0x212C,0x071D,0x1543,
+    0x170C,0x0F2F,0x1F9D,0x0F95,0x1CC7,0x043B,0x12EA,0x0F10,0x1D6E,0x0722,
+    0x00D6,0x1829,0x1244,0x1E0B,0x18CF,0x1C16,0x22DE,0x093B,0x01FD,0x15EF,
+    0x2087,0x1E24,0x02FB,0x1F1A,0x009D,0x0C20,0x0A35,0x18F9,0x0363,0x16ED,
+    0x0F4C,0x22B3,0x20A6,0x23C9,0x0C9D,0x10CF,0x0FC2,0x0AB1,0x1514,0x1D88,
+    0x1637,0x0844,0x06AF,0x06A7,0x0400,0x1F96,0x15D3,0x1566,0x0A06,0x1A38,
+    0x006A,0x03EA,0x1E4B,0x119F,0x1B8B,0x1049,0x1080,0x1B21,0x13BE,0x0F57,
+    0x18F6,0x22E4,0x1E9F,0x1BE1,0x1353,0x1644,0x0A45,0x1AA3,0x01C9,0x06F7,
+    0x10EB,0x0032,0x07F8,0x1CED,0x202C,0x0957,0x17B2,0x006B,0x1456,0x03DA,
+    0x061B,0x1A60,0x1C9A,0x137B,0x1EA2,0x1D61,0x0000,0x17FB,0x1BE2,0x046A,
+    0x1CBF,0x2192,0x1F0E,0x1968,0x0AE9,0x1508,0x0182,0x2324,0x2113,0x13CC,
+    0x09F5,0x0B62,0x1283,0x0FFC,0x150B,0x0794,0x0A0D,0x236B,0x1590,0x0808,
+    0x05D2,0x105A,0x1C80,0x207F,0x05CB,0x12FB,0x22BE,0x012A,0x0DC3,0x01CF,
+    0x023C,0x063D,0x060F,0x0447,0x2257,0x01C2,0x050B,0x03A1,0x0780,0x1782,
+    0x12E7,0x1E52,0x135C,0x151C,0x14EB,0x1B4E,0x2250,0x168C,0x118D,0x031D,
+    0x0680,0x2088,0x12D7,0x2133,0x14E0,0x1BE5,0x201E,0x0C3B,0x23AC,0x1B22,
+    0x01D0,0x0B17,0x1904,0x139F,0x1DAA,0x1418,0x0327,0x1527,0x0920,0x0715,
+    0x03C3,0x052C,0x0E8A,0x0812,0x017D,0x0C1D,0x02AA,0x1A7F,0x1DE4,0x058F,
+    0x194E,0x2343,0x0F11,0x1F18,0x0B05,0x2271,0x08E1,0x1CC6,0x1D38,0x20E7,
+    0x12DE,0x00E5,0x180C,0x0AC7,0x0C27,0x1C97,0x2304,0x10E6,0x071F,0x0C03,
+    0x0249,0x1FAA,0x0374,0x1E99,0x1FD5,0x2254,0x1B4C,0x0A92,0x2172,0x0B36,
+    0x011B,0x1CB2,0x0560,0x18F4,0x0460,0x0B24,0x1910,0x0596,0x1C30,0x0BE5,
+    0x1B79,0x1E40,0x21CA,0x0997,0x0F89,0x0173,0x215C,0x0D4E,0x1E14,0x1A45,
+    0x227E,0x18F7,0x1314,0x0C71,0x1D55,0x02B8,0x0C45,0x2232,0x10DC,0x155A,
+    0x1581,0x14A6,0x1683,0x108B,0x0247,0x2247,0x1F69,0x1EC7,0x0F1D,0x0A2A,
+    0x10FA,0x1660,0x16CE,0x0D18,0x0DDD,0x0BC6,0x0269,0x1911,0x187B,0x16F7,
+    0x188A,0x1FA0,0x1EA6,0x11B5,0x04C9,0x214E,0x065F,0x017A,0x05CE,0x1C32,
+    0x194D,0x1C44,0x02C1,0x1BCF,0x235B,0x228D,0x1A2C,0x03A3,0x017B,0x12D0,
+    0x19E8,0x08EF,0x1F25,0x1E65,0x0BA9,0x0DD9,0x1CF8,0x103A,0x1E22,0x15DD,
+    0x03D3,0x1EDE,0x1CF7,0x03C1,0x04F3,0x2240,0x1FFE,0x03BB,0x0D7D,0x1EBF,
+    0x1BA5,0x18E6,0x1CCF,0x1D8C,0x202E,0x0BA2,0x1A75,0x0065,0x104E,0x0661,
+    0x1B85,0x1A7A,0x0DD5,0x0450,0x1CEE,0x026E,0x1C0C,0x10B2,0x20F2,0x0AA7,
+    0x12F4,0x08EB,0x23AB,0x07B3,0x130B,0x094D,0x1EA3,0x18F2,0x0C9C,0x1363,
+    0x2036,0x13A8,0x16B1,0x1428,0x1F02,0x01E8,0x039E,0x1BED,0x1D98,0x08E2,
+    0x14D6,0x1E56,0x2388,0x0C1E,0x19EE,0x04AA,0x0EB8,0x09E5,0x233E,0x1D66,
+    0x07C5,0x211A,0x1088,0x0954,0x0E2A,0x1BC8,0x07A3,0x1E1E,0x1D36,0x1B87,
+    0x1544,0x0137,0x11DB,0x01C0,0x0845,0x216B,0x1BFC,0x08F6,0x0A5D,0x1EDF,
+    0x0FDE,0x0731,0x110A,0x0FB9,0x0E86,0x1415,0x14E7,0x17A3,0x02BC,0x0C60,
+    0x2111,0x0B41,0x234B,0x1C60,0x118A,0x0FDF,0x17CD,0x1323,0x087F,0x0025,
+    0x165D,0x1606,0x0823,0x1368,0x07F2,0x0743,0x02E4,0x23D0,0x0803,0x14AE,
+    0x1465,0x0FE3,0x02BB,0x0ACF,0x137F,0x2212,0x1272,0x01B6,0x0C07,0x08AB,
+    0x11E1,0x0274,0x171F,0x1126,0x09D2,0x1C01,0x23C5,0x1AB0,0x0F3E,0x0DAC,
+    0x00D5,0x14C2,0x17C1,0x028F,0x0DE9,0x06C3,0x0DE2,0x1A70,0x1AEC,0x1638,
+    0x1727,0x15ED,0x1532,0x13FD,0x123F,0x207E,0x0825,0x0066,0x14EC,0x1EE4,
+    0x1FE9,0x14B3,0x1692,0x0557,0x07A0,0x11D6,0x21DD,0x05FA,0x2014,0x0A0C,
+    0x152B,0x0425,0x00D7,0x00F2,0x0316,0x0ECA,0x1B14,0x0896,0x15B3,0x0B80,
+    0x1D20,0x0AF5,0x09C8,0x0BF6,0x134F,0x0E00,0x1B99,0x0953,0x2341,0x21C7,
+    0x1811,0x1032,0x1898,0x1286,0x1998,0x06B0,0x19FB,0x0790,0x15A6,0x16FB,
+    0x16C4,0x0B28,0x0C7B,0x0FED,0x19AC,0x113F,0x1EC3,0x0A52,0x132A,0x048D,
+    0x1B07,0x11D1,0x1F75,0x0838,0x04A5,0x04CB,0x046E,0x0A58,0x076E,0x12DB,
+    0x0AE8,0x185F,0x15E3,0x18A5,0x18CE,0x0236,0x0A46,0x1886,0x0B69,0x03CD,
+    0x17E6,0x0A21,0x06D1,0x0964,0x0630,0x231B,0x1642,0x19FF,0x1880,0x1B6B,
+    0x105C,0x0FCC,0x0043,0x1A4E,0x1554,0x0781,0x0034,0x1D16,0x1522,0x1ABF,
+    0x0F03,0x1B47,0x1A21,0x1E8E,0x007A,0x1E3E,0x0EB0,0x0DD7,0x0534,0x0241,
+    0x051D,0x0C8F,0x0B55,0x1589,0x0256,0x194B,0x1D31,0x0828,0x09AD,0x075F,
+    0x02AF,0x0BAF,0x1C49,0x20ED,0x1D21,0x0E6A,0x1723,0x19F6,0x114E,0x1419,
+    0x1952,0x0F40,0x0B0D,0x2201,0x1D29,0x19C9,0x0A2F,0x1515,0x1F27,0x1CDE,
+    0x0DD3,0x1768,0x0E56,0x1A9C,0x12A4,0x11BE,0x0B46,0x0DAE,0x0AFC,0x164B,
+    0x08D7,0x003A,0x0BDD,0x1E4E,0x0BCF,0x105E,0x2000,0x1BA1,0x19F4,0x2100,
+    0x20D7,0x2398,0x1C2E,0x04BE,0x0199,0x221E,0x0532,0x07B7,0x155B,0x006D,
+    0x16C1,0x1C74,0x0D61,0x17E2,0x0AFF,0x1AC4,0x00E9,0x09E4,0x11BB,0x0674,
+    0x22BD,0x1186,0x0578,0x202A,0x123B,0x15E8,0x0E8B,0x0403,0x097A,0x0105,
+    0x14ED,0x14CB,0x0FDD,0x03FF,0x17AF,0x1E39,0x02F3,0x13D3,0x0C89,0x20BC,
+    0x20B2,0x15BC,0x1CAC,0x2372,0x1B48,0x08D2,0x0446,0x1177,0x0D1F,0x17C6,
+    0x1989,0x0516,0x0DDC,0x024D,0x16AA,0x09EE,0x1062,0x0B50,0x1F77,0x037F,
+    0x07D2,0x093C,0x238A,0x0583,0x2375,0x0CA3,0x18EA,0x182A,0x0621,0x1036,
+    0x02B5,0x01E2,0x22DB,0x0963,0x2399,0x060C,0x1152,0x0F91,0x048A,0x1A7E,
+    0x1E87,0x1BB0,0x15C4,0x1112,0x1021,0x11E2,0x0C56,0x07DD,0x1D46,0x0210,
+    0x04F5,0x1C0E,0x0B8E,0x1040,0x1A6C,0x1AF8,0x08D8,0x1313,0x1C8A,0x20B8,
+    0x0B54,0x08A4,0x0094,0x131E,0x0A86,0x0A28,0x0D10,0x0A74,0x1AD2,0x0653,
+    0x172C,0x21C1,0x1490,0x04FC,0x0BFA,0x1347,0x0B2F,0x1DC4,0x23DB,0x0FB8,
+    0x23BB,0x0C72,0x03E5,0x186A,0x0F9D,0x1295,0x1808,0x04C6,0x1960,0x1FA7,
+    0x0DE0,0x239F,0x1D5F,0x0EED,0x1F79,0x2068,0x06B8,0x0D99,0x15F5,0x1028,
+    0x0202,0x0BAD,0x0098,0x060D,0x0E84,0x18FB,0x1549,0x1E63,0x0ED6,0x009A,
+    0x0B72,0x0B7B,0x06B1,0x0341,0x08F4,0x112A,0x18D5,0x0919,0x1731,0x19A5,
+    0x16FA,0x0195,0x0F9C,0x123D,0x0968,0x0E17,0x0EBF,0x0D27,0x1A33,0x17FD,
+    0x221B,0x208C,0x0694,0x1713,0x1696,0x0692,0x0006,0x1C3E,0x1617,0x0267,
+    0x111D,0x2122,0x025E,0x200E,0x0D22,0x1627,0x1329,0x0048,0x1265,0x0D7A,
+    0x1402,0x149C,0x02A1,0x022C,0x0F75,0x0783,0x124A,0x1134,0x0E1E,0x1C4C,
+    0x1CB0,0x17F1,0x046F,0x0280,0x068B,0x1C46,0x1FDA,0x0D82,0x1CD1,0x0590,
+    0x056E,0x015A,0x121F,0x0B1D,0x019D,0x1EB5,0x0A82,0x16E8,0x117D,0x098F,
+    0x1513,0x122A,0x0C18,0x0FA0,0x1EB1,0x0DD0,0x0E4A,0x23F8,0x190B,0x2053,
+    0x16C0,0x18A3,0x0127,0x0AE1,0x0F52,0x12AF,0x0E24,0x0C32,0x08A6,0x1D3F,
+    0x00CA,0x229B,0x11F6,0x1A46,0x1BF3,0x1EC6,0x0275,0x13B4,0x1210,0x0A49,
+    0x057C,0x0E3F,0x206B,0x05DC,0x21D5,0x18A7,0x14D3,0x1F57,0x1FF8,0x2220,
+    0x0962,0x1BFF,0x2301,0x08AF,0x1EEC,0x20CF,0x17E9,0x2302,0x0FBD,0x1BC9,
+    0x0585,0x0784,0x17BE,0x1B2B,0x111A,0x0AB3,0x1F1F,0x0505,0x0019,0x235F,
+    0x0B59,0x039A,0x03F7,0x193C,0x1994,0x1C1E,0x0CBB,0x0D72,0x1706,0x1C37,
+    0x0002,0x098B,0x2046,0x056A,0x0A1E,0x0A04,0x11C2,0x0883,0x06B3,0x0B48,
+    0x07DF,0x1122,0x04EE,0x215D,0x11D7,0x12A9,0x0F9A,0x0104,0x1618,0x175E,
+    0x1A28,0x1D13,0x1DC9,0x0111,0x110C,0x1779,0x146E,0x1928,0x15B0,0x072C,
+    0x0773,0x1CA2,0x0C3C,0x0BF2,0x1587,0x2269,0x10B0,0x0A6F,0x214D,0x0EEC,
+    0x1EF6,0x14EE,0x20C4,0x1A65,0x1A0B,0x23FA,0x0336,0x1603,0x0946,0x0D6B,
+    0x0545,0x1B9A,0x0605,0x0C95,0x2185,0x0EE3,0x1F98,0x1EB3,0x0A39,0x05EC,
+    0x1A5C,0x123A,0x0848,0x234E,0x023A,0x183E,0x16BD,0x014D,0x106A,0x0EF5,
+    0x213C,0x0046,0x0395,0x2321,0x238D,0x1AEE,0x1170,0x03DD,0x1C70,0x1D65,
+    0x0CF0,0x224D,0x1F87,0x1D0A,0x09A4,0x14CF,0x0A02,0x0093,0x121A,0x02EF,
+    0x22CC,0x0B8D,0x1E00,0x0B58,0x0FF9,0x1D62,0x1E6B,0x2387,0x138B,0x052D,
+    0x081C,0x10A0,0x0194,0x22F9,0x1E5F,0x1E3D,0x06C9,0x167C,0x0096,0x1570,
+    0x19A7,0x0B98,0x18BA,0x12AA,0x11CC,0x22C7,0x0064,0x0440,0x0B7E,0x23BF,
+    0x01A6,0x09ED,0x000B,0x0834,0x008E,0x0A7E,0x0D32,0x0744,0x207A,0x03AF,
+    0x062B,0x21DB,0x1B37,0x1FB1,0x1653,0x1807,0x141F,0x18AF,0x1343,0x0D28,
+    0x221A,0x1064,0x1BAB,0x199D,0x19E9,0x23FF,0x22EF,0x0CB1,0x0EC2,0x0958,
+    0x09D7,0x20EE,0x1AAF,0x1267,0x020B,0x1E58,0x0F2A,0x1B2F,0x0A7B,0x0EF2,
+    0x2334,0x0131,0x164D,0x238E,0x0352,0x1C71,0x1B9B,0x1F54,0x08DD,0x069C,
+    0x0C65,0x1FEB,0x21C2,0x0C38,0x1743,0x23E1,0x10C1,0x110E,0x13EE,0x239A,
+    0x125D,0x21DC,0x057B,0x1B1F,0x0D26,0x0121,0x02C5,0x0189,0x0867,0x190F,
+    0x0A8E,0x064E,0x0C31,0x2149,0x0A5C,0x1B06,0x0A6D,0x2277,0x0DFC,0x1B2A,
+    0x0FBC,0x051A,0x0767,0x00BF,0x1862,0x1414,0x1CDA,0x1484,0x1098,0x0657,
+    0x1C29,0x1C9F,0x0DBF,0x1B28,0x1AAD,0x204C,0x077B,0x0888,0x0ACA,0x1575,
+    0x1780,0x1AC5,0x085E,0x14CD,0x1CB3,0x033C,0x1E62,0x1650,0x0F7E,0x1CE4,
+    0x059E,0x20D6,0x072D,0x1371,0x2332,0x115F,0x204E,0x0282,0x11BF,0x08CE,
+    0x1C10,0x11AD,0x10FF,0x15BD,0x04E1,0x22D9,0x1634,0x048B,0x0346,0x185A,
+    0x083B,0x06F9,0x2124,0x072E,0x1ABA,0x050D,0x18BC,0x003E,0x090A,0x1F2C,
+    0x1734,0x0EE7,0x131A,0x0BB5,0x042E,0x12AD,0x1D5E,0x20EF,0x0C7F,0x1245,
+    0x1AD5,0x0895,0x00ED,0x2314,0x19B9,0x055D,0x20A5,0x112C,0x0436,0x16DA,
+    0x0E12,0x0276,0x178B,0x0EBD,0x0B2E,0x23D5,0x0941,0x1C14,0x1FA2,0x0A90,
+    0x1A99,0x1891,0x02BF,0x1305,0x1B18,0x0E0F,0x0BC1,0x0CD7,0x05AB,0x1ED5,
+    0x1D53,0x04D0,0x0D98,0x062F,0x0BCC,0x0B88,0x2031,0x0295,0x1F29,0x1ECB,
+    0x0DB9,0x00C8,0x2396,0x0A17,0x1773,0x1AC9,0x0459,0x1AD6,0x22CF,0x1DC2,
+    0x1BB8,0x1A23,0x1DFE,0x0604,0x213A,0x1357,0x1EA1,0x20D3,0x1137,0x1233,
+    0x198D,0x1B04,0x041E,0x200D,0x233A,0x02A5,0x0CA7,0x0E15,0x17FE,0x216E,
+    0x07C0,0x0BB0,0x0B9C,0x0A8F,0x0B15,0x0BDA,0x14B0,0x15CA,0x189E,0x19DC,
+    0x1ED9,0x0076,0x0A97,0x0918,0x0BED,0x0B81,0x0E0A,0x11DC,0x165A,0x037D,
+    0x1B74,0x1438,0x1129,0x22A2,0x0373,0x0D43,0x20F0,0x0DDE,0x0AB2,0x0771,
+    0x22F5,0x05F5,0x0662,0x1B39,0x16B0,0x1EF3,0x0AF2,0x0E44,0x0221,0x0A6E,
+    0x0D47,0x1DAC,0x18F1,0x10F6,0x2094,0x2294,0x0B21,0x0192,0x1A1E,0x03C9,
+    0x1777,0x1462,0x2089,0x0A4F,0x1A12,0x1A6B,0x1737,0x1D18,0x0C98,0x2207,
+    0x1FDD,0x2176,0x0109,0x0537,0x00BD,0x1916,0x1C2A,0x1377,0x1094,0x1D72,
+    0x00EE,0x0057,0x1463,0x171B,0x00EB,0x1AF0,0x15B9,0x0368,0x04CC,0x05AC,
+    0x07CA,0x1A62,0x0AFD,0x0C00,0x0548,0x153B,0x00AE,0x08F1,0x17C9,0x0428,
+    0x07F0,0x23D8,0x0DD4,0x201D,0x0C4D,0x04EA,0x0161,0x0C02,0x016D,0x145D,
+    0x1CA8,0x02F7,0x17F3,0x1FEC,0x1933,0x0E23,0x0639,0x1CD8,0x20B7,0x0284,
+    0x1016,0x0DC7,0x05A5,0x0E70,0x1A43,0x1DCB,0x09E8,0x13A9,0x06F5,0x1454,
+    0x033A,0x1E82,0x088D,0x0736,0x14C5,0x14FB,0x190E,0x0B60,0x13EA,0x1260,
+    0x0F8D,0x140B,0x1EDC,0x1E93,0x1095,0x2258,0x088E,0x22F0,0x08F2,0x2364,
+    0x1F97,0x1024,0x064F,0x0C5F,0x2052,0x1BE4,0x1EE9,0x1FE3,0x15A8,0x0DB1,
+    0x0D1D,0x17F7,0x20D8,0x07F6,0x2077,0x15E0,0x1C2F,0x1709,0x05BE,0x1B1B,
+    0x2162,0x1A39,0x1C2C,0x13F7,0x19EC,0x20D4,0x0655,0x049C,0x17AA,0x20E6,
+    0x04F4,0x01DE,0x038F,0x21FF,0x12BB,0x14C3,0x1D23,0x0730,0x0E5A,0x1ADD,
+    0x2300,0x1118,0x21D7,0x0FC5,0x0497,0x0390,0x11EA,0x18E5,0x1EF4,0x1EAE,
+    0x028A,0x102B,0x1365,0x05B1,0x18ED,0x0016,0x0012,0x0887,0x1E68,0x0933,
+    0x1166,0x0F5D,0x1297,0x06B9,0x18C5,0x0F80,0x2305,0x12A0,0x0AA8,0x1766,
+    0x1E2C,0x021D,0x1B30,0x0D3C,0x1585,0x1815,0x1B8D,0x00C1,0x02DD,0x0BD6,
+    0x06DC,0x06AD,0x025B,0x0A59,0x1D6B,0x15E2,0x1388,0x1AE3,0x1E26,0x21AF,
+    0x1CAD,0x02B0,0x09B8,0x0CFA,0x1DED,0x2267,0x0ABA,0x21F9,0x0AB8,0x1278,
+    0x1C58,0x1BCA,0x1042,0x1F4D,0x1F5B,0x1B09,0x0B08,0x0217,0x2097,0x05BC,
+    0x1219,0x1C6B,0x1885,0x1A69,0x01D1,0x0246,0x077C,0x13C4,0x11E9,0x01DD,
+    0x206F,0x0A41,0x16DD,0x08E9,0x1578,0x0846,0x0B99,0x0C4E,0x03A6,0x17F5,
+    0x13AB,0x1D2D,0x1B03,0x1F7F,0x0A96,0x1726,0x1AD9,0x1180,0x0B0C,0x0796,
+    0x1718,0x0CEA,0x0D8B,0x1B78,0x1C66,0x1BFA,0x07C3,0x1195,0x06C2,0x041C,
+    0x11EC,0x148E,0x0E52,0x1987,0x08BC,0x0B7C,0x02C8,0x073D,0x23DE,0x1A8E,
+    0x1D7C,0x220E,0x01E0,0x14C7,0x18B7,0x20E0,0x0739,0x088B,0x0CF5,0x1498,
+    0x0487,0x1699,0x035D,0x0416,0x0406,0x0C67,0x1188,0x1A30,0x00F7,0x063C,
+    0x09B7,0x030F,0x09BD,0x0D5F,0x022D,0x1D00,0x1C45,0x1AFA,0x0D16,0x0325,
+    0x1794,0x21E0,0x18AD,0x09FC,0x0F48,0x1F49,0x0463,0x11E0,0x1BF4,0x2169,
+    0x077D,0x0644,0x1497,0x1A51,0x0FC0,0x14DE,0x2049,0x0110,0x0A3D,0x062D,
+    0x08BE,0x16B3,0x0021,0x20C3,0x0BA5,0x21B4,0x05AA,0x0B16,0x19C1,0x2128,
+    0x0468,0x0E07,0x1F3A,0x052B,0x1161,0x0B9A,0x13FF,0x17D8,0x161B,0x2029,
+    0x0FA3,0x0E29,0x0B70,0x1605,0x1A3F,0x1E78,0x1EC4,0x1429,0x1906,0x19BF,
+    0x07EC,0x1DFA,0x2035,0x0A67,0x22A8,0x1863,0x21E4,0x04E2,0x1175,0x0411,
+    0x1B56,0x037C,0x0262,0x0865,0x000A,0x2287,0x1279,0x1FD9,0x1667,0x1DC1,
+    0x1AF3,0x0148,0x0C59,0x199A,0x0943,0x0D07,0x233C,0x073A,0x14AD,0x12CF,
+    0x0971,0x19EB,0x1EF9,0x15F9,0x0ADC,0x1101,0x1AD4,0x0540,0x0727,0x0986,
+    0x0D69,0x0A20,0x21A5,0x10CA,0x21C6,0x0EAA,0x06FC,0x0E47,0x15F4,0x222C,
+    0x02C2,0x0580,0x05C0,0x11DA,0x10D4,0x0DCF,0x0451,0x021A,0x228C,0x2104,
+    0x1E7A,0x150F,0x043F,0x1B4B,0x0B76,0x1384,0x0208,0x0F33,0x001B,0x1A04,
+    0x21BD,0x006E,0x1889,0x00AA,0x12C5,0x03FC,0x11F8,0x0D2F,0x0CDF,0x1F8C,
+    0x0526,0x1659,0x17EA,0x0BCA,0x119D,0x12B7,0x1392,0x0AB6,0x1331,0x1198,
+    0x15EC,0x01C1,0x22AB,0x130C,0x14F0,0x227B,0x07E9,0x1E4C,0x016B,0x0A13,
+    0x0E37,0x1136,0x1C8E,0x112F,0x1CE8,0x18D8,0x0372,0x011A,0x1411,0x07D1,
+    0x076B,0x085C,0x0084,0x0714,0x0E3C,0x21F7,0x0F6C,0x23E9,0x0385,0x1B17,
+    0x179C,0x159A,0x0506,0x135A,0x0882,0x1C36,0x1AA6,0x1E11,0x1A1F,0x1EF5,
+    0x0E9D,0x0335,0x1658,0x04B8,0x06A2,0x061E,0x17B6,0x1DB6,0x12BF,0x0443,
+    0x220A,0x1983,0x07B0,0x1890,0x177A,0x038A,0x1496,0x1220,0x18B3,0x1149,
+    0x0FA4,0x10EA,0x0620,0x11B1,0x01B1,0x08BA,0x0081,0x0FEC,0x111C,0x0C1B,
+    0x1382,0x0427,0x1582,0x1D54,0x0EE2,0x022A,0x0AAB,0x23EA,0x1922,0x0399,
+    0x2127,0x06CA,0x12D5,0x0A0A,0x1745,0x1F8F,0x009B,0x21B6,0x1BC2,0x0EEE,
+    0x00B6,0x0672,0x16D7,0x13E4,0x0ABF,0x0F29,0x03D2,0x20E3,0x185B,0x08FE,
+    0x0FB0,0x1CBC,0x2024,0x0A16,0x0C2C,0x0B23,0x134A,0x0ADE,0x03E2,0x0A0F,
+    0x2102,0x0CAA,0x19D0,0x220F,0x06E2,0x2391,0x13CF,0x1EDD,0x15B4,0x1012,
+    0x1F15,0x23DF,0x0735,0x223F,0x144B,0x12FC,0x1C86,0x1CE7,0x0DA7,0x082F,
+    0x1720,0x15C7,0x0212,0x22FD,0x133F,0x068C,0x169E,0x0C4F,0x1C31,0x139B,
+    0x0DA6,0x1A91,0x1D99,0x1493,0x160A,0x0077,0x1F45,0x1473,0x1B1E,0x028E,
+    0x0FAC,0x137C,0x2390,0x10A6,0x0129,0x0B67,0x1F53,0x0B97,0x21AC,0x0792,
+    0x0758,0x1AB2,0x0C44,0x1482,0x1436,0x0036,0x1B3A,0x1CC9,0x1AF4,0x152A,
+    0x2355,0x0519,0x1747,0x1275,0x10B3,0x2086,0x14D1,0x20E9,0x12CD,0x0EA4,
+    0x1F48,0x0DBD,0x0265,0x0A55,0x145F,0x2216,0x0D0F,0x103B,0x2381,0x0994,
+    0x1337,0x0CF7,0x06E8,0x2253,0x0936,0x1ECC,0x2208,0x10C3,0x0DE4,0x0A2D,
+    0x09DD,0x1690,0x234D,0x031E,0x0824,0x04A2,0x0F46,0x17B9,0x1F81,0x02E2,
+    0x04D5,0x13A2,0x0A10,0x01B3,0x1523,0x2013,0x0B06,0x1108,0x0244,0x06F6,
+    0x041B,0x03A5,0x21EF,0x052F,0x08FF,0x0855,0x1FC4,0x1E1D,0x2385,0x0B77,
+    0x1B86,0x2123,0x018C,0x2203,0x181A,0x01EB,0x07E1,0x1334,0x1D12,0x0A9D,
+    0x01ED,0x1EDA,0x1A2E,0x18AA,0x0598,0x1A83,0x162A,0x1A84,0x072B,0x2397,
+    0x0166,0x00C0,0x091C,0x2350,0x010A,0x157E,0x142C,0x1F4F,0x1B93,0x1355,
+    0x08F9,0x218E,0x1C57,0x0627,0x06AE,0x2186,0x230D,0x0C6F,0x1229,0x02C9,
+    0x0972,0x0F68,0x217B,0x1130,0x0CDB,0x06B5,0x1045,0x1321,0x0AA0,0x0CCE,
+    0x121E,0x0C0A,0x07EF,0x02D8,0x061D,0x1003,0x0761,0x20FE,0x1519,0x027B,
+    0x1105,0x174A,0x028B,0x0300,0x1EFD,0x1711,0x03BC,0x1FCC,0x1DFF,0x21FE,
+    0x1AE0,0x12C0,0x2266,0x1DEC,0x15E4,0x036B,0x0382,0x01B5,0x2067,0x20C6,
+    0x0B2C,0x0F7F,0x1BEB,0x0988,0x1491,0x0697,0x0F12,0x1096,0x0E78,0x103D,
+    0x02A3,0x21BB,0x1563,0x11D2,0x150D,0x2308,0x21B3,0x0333,0x1213,0x009F,
+    0x08A5,0x10EC,0x0E60,0x009E,0x1530,0x0FC6,0x110F,0x1BA3,0x027E,0x2223,
+    0x009C,0x1B4D,0x1F62,0x1CF6,0x1E86,0x0FB1,0x0332,0x1BAF,0x0C1A,0x0E2C,
+    0x0360,0x197A,0x01D3,0x10F3,0x1B76,0x02EB,0x18CA,0x065B,0x1164,0x103E,
+    0x0C39,0x0F8C,0x073E,0x07CE,0x183C,0x04EC,0x0E9A,0x0BDE,0x0738,0x1093,
+    0x0F0D,0x076A,0x0349,0x0DA9,0x19F9,0x1154,0x1DD0,0x0ED0,0x1D22,0x22D3,
+    0x015B,0x0052,0x0A5B,0x0CE2,0x1D89,0x1565,0x1752,0x0254,0x028C,0x18FD,
+    0x12B9,0x1CA4,0x1F73,0x0567,0x1B01,0x0414,0x1510,0x1ED8,0x05FD,0x1ACF,
+    0x19EA,0x0163,0x0B73,0x1CBE,0x07B6,0x10D1,0x050F,0x1635,0x0413,0x17ED,
+    0x1C40,0x1336,0x0EFF,0x1199,0x1236,0x07BD,0x2312,0x04B1,0x2163,0x1AD1,
+    0x0764,0x21D1,0x14DD,0x0CE8,0x1728,0x0348,0x236D,0x1BA6,0x2119,0x1405,
+    0x0625,0x034C,0x0A1F,0x09E0,0x231C,0x0D4C,0x0839,0x04AF,0x2153,0x12AB,
+    0x0D8C,0x148F,0x03CE,0x2081,0x05A6,0x0F02,0x1D41,0x090F,0x0D8D,0x1CE5,
+    0x0BF5,0x0358,0x0BBD,0x1981,0x1A5E,0x1312,0x103F,0x0347,0x23B0,0x0FAD,
+    0x08D1,0x00D8,0x08E0,0x212A,0x0DC4,0x1EBE,0x169F,0x07A6,0x1BF5,0x1FA3,
+    0x0EE8,0x17B1,0x14A8,0x0EC8,0x2057,0x0586,0x19AF,0x1C1A,0x1D10,0x15D7,
+    0x06CD,0x0901,0x163C,0x1A20,0x1107,0x0879,0x1533,0x1EDB,0x0E94,0x1FC9,
+    0x20F5,0x00A9,0x20BE,0x1011,0x1AFE,0x21DF,0x1D7E,0x0D25,0x13D1,0x099C,
+    0x0A64,0x1729,0x113B,0x17C4,0x21DE,0x0D8A,0x0B4B,0x00E2,0x0C10,0x2358,
+    0x162E,0x1470,0x1DDE,0x0050,0x1468,0x213B,0x106E,0x0490,0x09F2,0x0190,
+    0x1F7A,0x03FB,0x215E,0x02EC,0x01CD,0x0F83,0x1503,0x00A0,0x17E8,0x0ABE,
+    0x019F,0x053A,0x2278,0x1A66,0x12A3,0x0B04,0x23D7,0x144F,0x131B,0x2099,
+    0x0159,0x1D3E,0x1FE4,0x14D8,0x0100,0x130F,0x23F0,0x1623,0x1F40,0x0F13,
+    0x1082,0x221F,0x12FE,0x0B9D,0x080B,0x1EE6,0x14B9,0x2351,0x05D7,0x065E,
+    0x09BB,0x0209,0x0FDA,0x03D5,0x1B82,0x204B,0x1073,0x131C,0x1358,0x230B,
+    0x1BC0,0x1EB9,0x166A,0x11AA,0x1D85,0x08BB,0x1B7B,0x05F7,0x1B40,0x0E11,
+    0x02DB,0x13A3,0x0C15,0x14EA,0x0AB9,0x22E7,0x013A,0x07F4,0x0696,0x1228,
+    0x0FCF,0x1561,0x09E7,0x2221,0x039F,0x028D,0x1171,0x098C,0x1B5B,0x0F93,
+    0x1789,0x1269,0x0A3C,0x14A4,0x1864,0x16A9,0x0493,0x0B5E,0x0BD1,0x0646,
+    0x1A52,0x11FC,0x0934,0x0CA1,0x16C5,0x045B,0x0EAC,0x0EE1,0x1671,0x1918,
+    0x0C4C,0x1D9A,0x2062,0x160D,0x1555,0x0677,0x0F58,0x1621,0x17AB,0x0DB7,
+    0x0F63,0x094B,0x1902,0x23BE,0x0C35,0x0F51,0x149A,0x08FB,0x021F,0x1970,
+    0x0995,0x19E2,0x1DBD,0x1E48,0x0B90,0x02CC,0x15DB,0x2022,0x0CEE,0x2161,
+    0x0A57,0x11AE,0x0B6F,0x05CA,0x1450,0x19B8,0x0F4F,0x1F5A,0x1E2E,0x229A,
+    0x15EB,0x074E,0x2317,0x0ECB,0x0B6C,0x0510,0x091F,0x0F85,0x101B,0x1BD3,
+    0x0E7C,0x11FF,0x0F2C,0x1F9A,0x2382,0x232F,0x23DC,0x0DF7,0x01CB,0x0DCA,
+    0x21D3,0x1857,0x0C6D,0x0FEE,0x0509,0x0543,0x2331,0x1424,0x08FD,0x01E9,
+    0x1CA9,0x23EF,0x100C,0x029A,0x1065,0x1078,0x0F9B,0x14DA,0x0D09,0x0998,
+    0x088C,0x019C,0x10C4,0x20AB,0x20E5,0x16A4,0x0682,0x0424,0x1C15,0x0C13,
+    0x0A36,0x0856,0x07A5,0x1AD7,0x05D0,0x020C,0x16CC,0x1D8D,0x07DA,0x2204,
+    0x1D9F,0x1797,0x1C67,0x09C0,0x0237,0x1BB6,0x10A9,0x0417,0x0949,0x1E49,
+    0x017E,0x0979,0x1753,0x0AA2,0x0362,0x0B8B,0x0536,0x1EA7,0x0EE5,0x04CA,
+    0x2285,0x0DEB,0x05A0,0x0853,0x12BA,0x0491,0x0423,0x11C0,0x0E36,0x1674,
+    0x2010,0x1DC5,0x0709,0x125F,0x0C33,0x2349,0x0481,0x108A,0x0404,0x094F,
+    0x09CB,0x0D3F,0x18C4,0x0EA3,0x060E,0x0654,0x1814,0x09CA,0x1CA3,0x0C34,
+    0x1A17,0x1406,0x14FF,0x0F0E,0x0204,0x0C0F,0x11CB,0x1925,0x16B9,0x1488,
+    0x1D01,0x0E96,0x0562,0x0C04,0x185E,0x0D2D,0x23D4,0x2328,0x030C,0x19A9,
+    0x01EF,0x20FF,0x08F7,0x122E,0x1AC2,0x0C52,0x0296,0x1A59,0x0326,0x1089,
+    0x1DD3,0x1C63,0x06BB,0x146F,0x1237,0x1950,0x203B,0x17A8,0x01A5,0x09D1,
+    0x0591,0x1B15,0x0147,0x0F20,0x17B4,0x1A36,0x1FC5,0x1F5F,0x0C37,0x1BAE,
+    0x06BC,0x12C1,0x10D2,0x0A14,0x0875,0x120A,0x182D,0x0D6D,0x0F1B,0x0FA2,
+    0x1CC2,0x1A64,0x11C4,0x1CF3,0x1FBD,0x0027,0x0C49,0x21CB,0x0462,0x107C,
+    0x0CFD,0x1398,0x0633,0x06A5,0x00B0,0x0BFD,0x1665,0x102A,0x1915,0x150E,
+    0x23A0,0x1344,0x0F69,0x097B,0x023F,0x18BF,0x1423,0x1290,0x22DF,0x1060,
+    0x0168,0x04FA,0x1B72,0x03C0,0x0B49,0x202D,0x227F,0x0D31,0x121C,0x0762,
+    0x1980,0x05EE,0x20DA,0x04BB,0x06FB,0x16E5,0x117B,0x079F,0x1BF1,0x02A6,
+    0x0A5F,0x22ED,0x1517,0x034E,0x1628,0x1A72,0x02F2,0x1761,0x1E2D,0x161C,
+    0x05C1,0x0757,0x138C,0x0438,0x1193,0x1A68,0x0340,0x111F,0x1440,0x1CDF,
+    0x0634,0x23F9,0x064A,0x0C8A,0x1059,0x13A5,0x1B23,0x13D4,0x2210,0x12E4,
+    0x0E03,0x0CA0,0x0355,0x0E0D,0x1D24,0x2155,0x0B93,0x0531,0x0B1C,0x1CFE,
+    0x22BB,0x1B64,0x1D02,0x1F83,0x0C2A,0x01D4,0x000C,0x2213,0x2151,0x1F3C,
+    0x200F,0x0469,0x0B79,0x086F,0x139E,0x1ADA,0x00C4,0x07E0,0x1005,0x013C,
+    0x1869,0x05B6,0x0944,0x0652,0x1EBB,0x047E,0x0D3A,0x05F0,0x2085,0x0342,
+    0x0165,0x236A,0x03DB,0x1E69,0x120B,0x0EDB,0x156A,0x00CD,0x1F2F,0x0797,
+    0x066C,0x0AE7,0x063A,0x1C7D,0x18A4,0x07B5,0x0E87,0x092F,0x213E,0x10D6,
+    0x1F0A,0x1DD7,0x1B4F,0x0E68,0x1958,0x158D,0x14B6,0x0CB8,0x23E2,0x15D0,
+    0x1249,0x1562,0x03D6,0x0513,0x1A3E,0x171E,0x1F09,0x0DF9,0x0A07,0x12AE,
+    0x0690,0x05C6,0x120D,0x20D1,0x17A0,0x2189,0x1D34,0x1799,0x1E5E,0x20C7,
+    0x1B45,0x1359,0x174B,0x0CCC,0x0187,0x21D9,0x15A7,0x1E1F,0x13B1,0x05FF,
+    0x10D5,0x1905,0x01A8,0x0277,0x1FF4,0x0EB5,0x1476,0x1E1C,0x1390,0x018E,
+    0x0484,0x0FCB,0x146B,0x151B,0x1DC6,0x1A76,0x169B,0x0B64,0x0024,0x187A,
+    0x1230,0x2132,0x0ECE,0x149F,0x109A,0x1839,0x0568,0x1F84,0x0BF0,0x092D,
+    0x0C77,0x13EF,0x14F9,0x138D,0x0832,0x0C68,0x0A37,0x0248,0x16EF,0x0125,
+    0x087B,0x09A9,0x17C8,0x02DF,0x06A0,0x0FC3,0x0D75,0x1A10,0x0EAB,0x0D96,
+    0x0CC2,0x1DA2,0x13AA,0x1760,0x0146,0x1636,0x0082,0x1255,0x1206,0x19DF,
+    0x1D71,0x0D67,0x1DB4,0x0F15,0x065C,0x20C0,0x12F9,0x1796,0x1997,0x13B5,
+    0x087E,0x19FC,0x173B,0x163F,0x06CC,0x05F1,0x19B1,0x1D1E,0x16E1,0x1A3B,
+    0x0C3D,0x07C1,0x1A7C,0x00A5,0x181C,0x1593,0x0259,0x167B,0x0120,0x0889,
+    0x0A51,0x0DA1,0x129D,0x1F76,0x045D,0x1471,0x03CC,0x07B2,0x07EE,0x16AF,
+    0x0549,0x1046,0x2217,0x0BBF,0x12C6,0x0AA5,0x1C51,0x1C94,0x0DF4,0x22B8,
+    0x0DBA,0x1284,0x1D15,0x1433,0x1D17,0x15AE,0x0387,0x1052,0x0880,0x107B,
+    0x09E9,0x2012,0x1151,0x0641,0x0ECC,0x156E,0x1771,0x1972,0x09F9,0x12C3,
+    0x0C42,0x0B9E,0x02A4,0x12EB,0x16B7,0x054D,0x1742,0x0600,0x0BF1,0x11C5,
+    0x223E,0x0B35,0x1843,0x1A5D,0x081B,0x1DB2,0x0020,0x0BC7,0x155F,0x015E,
+    0x1341,0x1FD0,0x136D,0x062A,0x1E6C,0x1DA3,0x00C3,0x12EC,0x03C2,0x10D7,
+    0x15F3,0x1489,0x19FD,0x067D,0x12D6,0x1847,0x0F9F,0x0ED7,0x1D9E,0x1ADB,
+    0x10A4,0x0710,0x1866,0x0F32,0x1EC0,0x2309,0x00E8,0x025F,0x135F,0x0C54,
+    0x0FFF,0x0BF9,0x0959,0x14F3,0x17A1,0x0EE9,0x20F3,0x10BE,0x0DF6,0x1D49,
+    0x1111,0x0D2B,0x0226,0x1AB4,0x2337,0x021B,0x019A,0x22C0,0x1C06,0x08E5,
+    0x2047,0x07F9,0x1612,0x0822,0x0E31,0x00F3,0x134C,0x1919,0x189D,0x23FB,
+    0x0EFE,0x07D8,0x10F5,0x1143,0x22D1,0x0476,0x10F9,0x16CB,0x0053,0x16D3,
+    0x0366,0x1B6A,0x0074,0x1DF6,0x165B,0x0308,0x116E,0x0837,0x1A0D,0x15F8,
+    0x0D57,0x1875,0x1A8C,0x0EC0,0x239C,0x0BBE,0x0FB4,0x0009,0x1698,0x0AFE,
+    0x1992,0x23BA,0x0EE0,0x2096,0x00FE,0x1BF7,0x1239,0x23FD,0x1F8E,0x113C,
+    0x084F,0x09B1,0x0931,0x1E2F,0x0976,0x07AF,0x0B45,0x0ABD,0x0F37,0x0C7E,
+    0x06D3,0x238B,0x0759,0x17AC,0x0923,0x1D05,0x14FA,0x1755,0x187C,0x0E02,
+    0x0B03,0x02AE,0x1735,0x0283,0x033B,0x1C77,0x23C1,0x185C,0x0010,0x1595,
+    0x1C96,0x09E1,0x1055,0x19F7,0x1226,0x1790,0x01A9,0x1A8A,0x06B7,0x1A48,
+    0x1A96,0x121D,0x14BE,0x1681,0x131D,0x00BC,0x0D52,0x1401,0x0610,0x1A6F,
+    0x1354,0x0DD6,0x0155,0x07D4,0x017F,0x2154,0x1C9D,0x176B,0x1C4B,0x1C68,
+    0x1F33,0x082D,0x0616,0x23A4,0x0C86,0x1B00,0x0097,0x2357,0x10E4,0x149B,
+    0x0B8F,0x0E71,0x0636,0x062E,0x14AC,0x07C7,0x20FD,0x12BC,0x0228,0x106D,
+    0x0AB0,0x140F,0x2214,0x0C30,0x143B,0x1D77,0x1241,0x1FDB,0x1757,0x17E3,
+    0x0CB4,0x1F93,0x1C75,0x02B3,0x237A,0x0928,0x0CDE,0x12B4,0x11D4,0x1ADC,
+    0x2105,0x1B5C,0x1DF5,0x22FC,0x085F,0x08BF,0x0E1A,0x1564,0x06BF,0x1D59,
+    0x0B7A,0x22D7,0x0AED,0x10F8,0x0D48,0x1B33,0x20C2,0x205D,0x1801,0x228F,
+    0x13BD,0x0F5C,0x062C,0x1F2B,0x1AB7,0x09BE,0x0914,0x0C97,0x1941,0x151E,
+    0x0676,0x01BA,0x0207,0x09F3,0x1F4E,0x1B7A,0x07C2,0x0059,0x1BB4,0x1BA4,
+    0x1025,0x1102,0x0617,0x074A,0x0AF9,0x0915,0x1D3C,0x0B1B,0x0E05,0x0D66,
+    0x06C6,0x1C4D,0x0708,0x21C9,0x08E6,0x1DD9,0x235D,0x1D90,0x0095,0x0814,
+    0x0E4D,0x21C5,0x1DC3,0x0430,0x1E0D,0x235A,0x15DE,0x1B89,0x0729,0x066B,
+    0x23A3,0x2028,0x0398,0x229E,0x1845,0x212F,0x0740,0x029E,0x1D0F,0x1D11,
+    0x151D,0x023E,0x1B05,0x188F,0x0185,0x1584,0x044F,0x0033,0x0133,0x178D,
+    0x0C9A,0x10BC,0x0815,0x2206,0x1AC3,0x0CBA,0x115E,0x1772,0x0909,0x161A,
+    0x015C,0x1E83,0x1E96,0x0A1A,0x1D75,0x179E,0x2175,0x143E,0x17C5,0x12E9,
+    0x0F09,0x0885,0x0D71,0x18F8,0x0359,0x1615,0x0C6C,0x0809,0x1F10,0x1C18,
+    0x199C,0x1553,0x0D1B,0x0C0B,0x1ADF,0x0E4B,0x1B35,0x0B66,0x1264,0x22CB,
+    0x0181,0x154F,0x0D74,0x134D,0x18C1,0x0E43,0x13EC,0x1E37,0x01BE,0x0755,
+    0x0579,0x154B,0x0893,0x19D6,0x2072,0x208E,0x22C2,0x0719,0x04E6,0x00D3,
+    0x02C0,0x194A,0x0486,0x0DC1,0x06FD,0x1A86,0x0BEC,0x1191,0x0840,0x196C,
+    0x1959,0x12A5,0x08F8,0x17B0,0x16CF,0x0602,0x0D85,0x1F21,0x13A4,0x1946,
+    0x06E1,0x14BA,0x20F9,0x182C,0x0E09,0x13D8,0x159C,0x0881,0x0542,0x1948,
+    0x0829,0x1668,0x2060,0x1138,0x172D,0x17C3,0x0013,0x08E8,0x034F,0x1D80,
+    0x018D,0x0E90,0x0551,0x1CAE,0x0643,0x0ECD,0x005C,0x0223,0x0B29,0x10F1,
+    0x0B5D,0x0C5B,0x132B,0x02D1,0x2316,0x147F,0x1335,0x0679,0x06C4,0x04A3,
+    0x108D,0x02C3,0x075A,0x01EA,0x23AE,0x22B6,0x2138,0x232A,0x23EC,0x02AC,
+    0x227C,0x0E39,0x168F,0x0F35,0x06DA,0x0782,0x0556,0x042D,0x11AB,0x224C,
+    0x0F1E,0x0561,0x17A4,0x1B42,0x0AC6,0x1B91,0x0483,0x118B,0x1EED,0x0741,
+    0x177C,0x21E8,0x1AFC,0x209D,0x0FE0,0x1AD0,0x13B2,0x0637,0x20A4,0x1C1D,
+    0x0EAF,0x03E8,0x15F7,0x1686,0x21B2,0x2215,0x1091,0x01CE,0x135E,0x18C8,
+    0x1E46,0x2322,0x0618,0x23CA,0x1795,0x1F03,0x1A3D,0x0C5D,0x2298,0x01AE,
+    0x02E1,0x0D41,0x09D4,0x219D,0x2084,0x0F98,0x0375,0x13C9,0x0AC4,0x09FE,
+    0x1D81,0x0FF0,0x11C7,0x1FA9,0x1301,0x0BEF,0x1031,0x0B07,0x1FBF,0x1370,
+    0x1AA1,0x1956,0x15C0,0x1858,0x13BB,0x0937,0x1804,0x109D,0x03D8,0x0635,
+    0x1E41,0x0999,0x1079,0x15CC,0x15FC,0x09A2,0x1DA7,0x142E,0x03EC,0x1954,
+    0x1215,0x15E9,0x05C5,0x0831,0x13DA,0x14EF,0x22FE,0x1A54,0x06FE,0x23F1,
+    0x17A6,0x1CD2,0x068A,0x0E4C,0x03C8,0x007C,0x02E5,0x0C25,0x0C48,0x0A26,
+    0x1A9F,0x09B2,0x20F6,0x14AF,0x1B6F,0x233F,0x11F7,0x00B2,0x1076,0x1E70,
+    0x0726,0x1F59,0x222D,0x175D,0x1986,0x0AD8,0x2095,0x0214,0x231F,0x10C6,
+    0x1944,0x1816,0x093A,0x1EA5,0x0B4F,0x174E,0x1087,0x0C0E,0x1DDD,0x1CF2,
+    0x15AA,0x2231,0x22E8,0x0B52,0x040C,0x1CE3,0x0B7D,0x197C,0x0234,0x05EF,
+    0x1BDB,0x124E,0x1E95,0x03B4,0x226A,0x0149,0x137A,0x1AF5,0x20D5,0x1D4F,
+    0x0CDA,0x145B,0x026A,0x0473,0x0FF1,0x168A,0x16A5,0x23E4,0x13C6,0x0EB7,
+    0x0D7B,0x0D76,0x178E,0x23B7,0x05E2,0x16EB,0x0535,0x071B,0x2293,0x06E6,
+    0x1903,0x1526,0x1C23,0x0EC7,0x0CCB,0x1F65,0x0D89,0x147C,0x23F5,0x1446,
+    0x228B,0x0063,0x19DD,0x10FE,0x2023,0x0BAC,0x096A,0x22A4,0x1770,0x176D,
+    0x01C7,0x0E83,0x1E08,0x213F,0x2365,0x1EBD,0x1A16,0x0818,0x11FD,0x0E30,
+    0x024E,0x2256,0x0314,0x02D7,0x129B,0x0303,0x1BC7,0x01CC,0x1586,0x0752,
+    0x194C,0x168E,0x1099,0x10A5,0x1009,0x016A,0x0BA6,0x0DCC,0x0124,0x15A3,
+    0x2152,0x1072,0x0EBC,0x2018,0x1EEE,0x1139,0x0CCF,0x1FA1,0x035B,0x19D9,
+    0x1029,0x1048,0x1397,0x18D0,0x075B,0x0C55,0x0188,0x19CA,0x2229,0x20D9,
+    0x132D,0x0179,0x14A9,0x1A9D,0x1F6C,0x173F,0x18FF,0x12B0,0x00F8,0x14D9,
+    0x0CE4,0x0732,0x0169,0x21AA,0x1F0B,0x1F0F,0x16AD,0x0869,0x1DB7,0x0BA8,
+    0x1A55,0x0F6D,0x01BD,0x1DDA,0x1E1B,0x096B,0x09FF,0x2327,0x107D,0x0530,
+    0x11E3,0x0558,0x16A1,0x0CB0,0x1C7E,0x160F,0x1840,0x187D,0x0EEB,0x14B1,
+    0x079E,0x0C22,0x049E,0x0AE3,0x15BB,0x08E4,0x0F4A,0x1920,0x1ECF,0x12DD,
+    0x1A01,0x0C2B,0x0507,0x0AF7,0x04B9,0x0E35,0x209F,0x1805,0x1E66,0x1169,
+    0x2041,0x1EFC,0x1DDB,0x1E89,0x1EF2,0x1430,0x1DFC,0x1E98,0x0D9A,0x0D03,
+    0x0BDF,0x09DC,0x15D5,0x08DB,0x1250,0x0DC6,0x099B,0x07ED,0x1FEE,0x0753,
+    0x1C20,0x1EB8,0x17D2,0x23B2,0x1E34,0x22A3,0x0B5F,0x0ED1,0x0960,0x029B,
+    0x1977,0x0A7D,0x12A1,0x00C9,0x04D3,0x1271,0x1A74,0x08B8,0x1035,0x231A,
+    0x1300,0x047D,0x2202,0x0338,0x115C,0x01A3,0x2209,0x1CFB,0x193F,0x0BE3,
+    0x1E1A,0x1445,0x06A8,0x1F9B,0x1307,0x0916,0x0E34,0x1806,0x23CC,0x144C,
+    0x214A,0x1CE9,0x22B4,0x198A,0x126E,0x0F82,0x0D80,0x0167,0x0AC9,0x04A1,
+    0x184D,0x0E8E,0x190A,0x0268,0x1395,0x20BA,0x170F,0x16E6,0x0601,0x1E81,
+    0x1662,0x19B2,0x165E,0x0E3A,0x0D0B,0x0EDC,0x1235,0x23EE,0x0E28,0x0C88,
+    0x0C8E,0x2196,0x10B5,0x0BEB,0x230F,0x2367,0x0392,0x1404,0x0AEA,0x1A9B,
+    0x0439,0x03FA,0x1DB9,0x1100,0x11C1,0x222B,0x0787,0x007E,0x0E76,0x0261,
+    0x06D4,0x18B5,0x1B4A,0x0647,0x0DDB,0x1976,0x05AE,0x0F34,0x0186,0x0068,
+    0x1075,0x151F,0x0C3A,0x002C,0x233B,0x0A56,0x0DFA,0x0857,0x137E,0x12B1,
+    0x100B,0x0C21,0x0AA4,0x08B4,0x11ED,0x0EEA,0x13EB,0x0614,0x1BD2,0x0356,
+    0x16BA,0x1403,0x0AAE,0x0F00,0x1FFD,0x054A,0x01BB,0x2181,0x21CD,0x013B,
+    0x1F8D,0x2369,0x08C3,0x1669,0x195B,0x1884,0x02EA,0x1090,0x053C,0x11F2,
+    0x0472,0x034A,0x042A,0x223C,0x10AE,0x19A2,0x147E,0x0D6F,0x13AE,0x1CD0,
+    0x1FB5,0x093D,0x19D2,0x10C7,0x0258,0x0106,0x1D44,0x1ABC,0x0B3D,0x1F86,
+    0x1598,0x12E5,0x013D,0x1234,0x0F8A,0x0C6A,0x2318,0x0993,0x222E,0x1CC1,
+    0x106F,0x1A61,0x05BF,0x19B4,0x0EA8,0x03B1,0x1C6C,0x2030,0x0725,0x0E62,
+    0x064D,0x1469,0x2211,0x0004,0x1525,0x0B9F,0x0CB9,0x0EFC,0x0D02,0x1A1B,
+    0x17C0,0x1C50,0x14C4,0x0C0D,0x1CF1,0x02D0,0x1A92,0x0B26,0x0FDB,0x109E,
+    0x0905,0x0E8D,0x1D60,0x1C91,0x23F2,0x111E,0x06F2,0x1A88,0x22F3,0x0AB5,
+    0x1D83,0x0FEA,0x05EB,0x1E55,0x056F,0x08B7,0x18E1,0x1CD3,0x0A94,0x0E3E,
+    0x0E5F,0x1282,0x0CC7,0x0AB7,0x1DBF,0x0213,0x1BD1,0x044D,0x20EC,0x19E0,
+    0x071A,0x0DF1,0x07D5,0x1311,0x0007,0x0F92,0x00C5,0x0433,0x0465,0x073B,
+    0x0851,0x1542,0x05E9,0x0D39,0x0A1B,0x17F6,0x114D,0x0A9F,0x00A4,0x1A98,
+    0x0ACD,0x1835,0x1D8A,0x0649,0x1002,0x1038,0x1E7B,0x0FF2,0x1CF4,0x21B8,
+    0x1A58,0x0FE4,0x038E,0x1458,0x1538,0x1550,0x025A,0x0B82,0x16F0,0x0191,
+    0x171D,0x081E,0x0BD4,0x15DA,0x0849,0x21E2,0x0B7F,0x1A0F,0x18B6,0x1FD7,
+    0x02B9,0x04C1,0x0289,0x1F55,0x13DD,0x0FE1,0x1B1D,0x191D,0x17BB,0x0E4E,
+    0x0175,0x1AC6,0x0044,0x23AD,0x1D03,0x210F,0x17C7,0x05E8,0x0CC0,0x00D1,
+    0x0A60,0x0B3A,0x2299,0x2311,0x13E8,0x0BC8,0x0AC8,0x1E07,0x0380,0x0D50,
+    0x0B56,0x0555,0x2143,0x0479,0x1545,0x1285,0x13E6,0x1926,0x2042,0x2075,
+    0x1D79,0x2362,0x206A,0x187F,0x14B7,0x138E,0x1AA0,0x1C2D,0x0899,0x22CD,
+    0x115B,0x00D4,0x1014,0x1701,0x02CB,0x0028,0x1A2F,0x1FFA,0x21EE,0x16C3,
+    0x1158,0x15CE,0x1831,0x1639,0x04B7,0x00CE,0x0431,0x011F,0x1D35,0x23ED,
+    0x093F,0x0B91,0x0ED2,0x0EDA,0x0369,0x1BC3,0x0B1A,0x21C3,0x040A,0x206C,
+    0x17F9,0x1FB9,0x0CAD,0x1938,0x1661,0x0E19,0x1C1F,0x0A68,0x079B,0x1580,
+    0x0005,0x1D56,0x0CBD,0x0306,0x1F3E,0x0872,0x1D2C,0x0A3A,0x06E9,0x1B43,
+    0x0C8D,0x0113,0x0023,0x1675,0x0218,0x026D,0x1622,0x22A1,0x03F0,0x177F,
+    0x20F4,0x0EF3,0x1D96,0x2281,0x053E,0x0CD2,0x0C70,0x159E,0x1691,0x0713,
+    0x1F5E,0x205B,0x15C6,0x1C09,0x16E0,0x04CF,0x1C1C,0x0C74,0x15E5,0x12F7,
+    0x16D8,0x2245,0x07E2,0x0566,0x0345,0x1FE2,0x2093,0x114B,0x19D8,0x0313,
+    0x2108,0x1E09,0x2110,0x1FA8,0x03F6,0x0D93,0x0BD8,0x067F,0x06DE,0x2242,
+    0x2282,0x120F,0x04E5,0x0E97,0x05DE,0x1D9B,0x09C1,0x19C8,0x029D,0x19A4,
+    0x18BB,0x12F5,0x13D5,0x1AB3,0x11CF,0x0D59,0x094A,0x1574,0x16F6,0x0C08,
+    0x22C3,0x20BB,0x18E3,0x0A73,0x1842,0x093E,0x1114,0x1211,0x1733,0x09DA,
+    0x1ABE,0x1BD0,0x202F,0x0E41,0x222F,0x1F94,0x0D21,0x0553,0x08F0,0x10DA,
+    0x0711,0x11FE,0x1B52,0x07BC,0x0BF3,0x076F,0x0AD1,0x0D1E,0x004F,0x170D,
+    0x107A,0x1103,0x0681,0x02D2,0x0FA7,0x10DD,0x12D4,0x2083,0x0D9F,0x1DEB,
+    0x0422,0x1776,0x1767,0x029F,0x0C7A,0x10E1,0x1C11,0x08D6,0x069A,0x1F47,
+    0x14AA,0x1810,0x0CF6,0x09A3,0x0235,0x180A,0x1708,0x0A72,0x1BEC,0x1026,
+    0x1754,0x0B0B,0x043A,0x2040,0x1119,0x0612,0x0628,0x1187,0x14B4,0x157F,
+    0x1DB3,0x0156,0x01F9,0x082C,0x13FB,0x1218,0x0003,0x19CC,0x1764,0x14DC,
+    0x1F30,0x0011,0x0AA1,0x096F,0x14FE,0x23C3,0x0CAE,0x04DB,0x0F18,0x1F4A,
+    0x039B,0x15E1,0x08CB,0x0ADF,0x1FDF,0x1B50,0x08ED,0x1721,0x2296,0x040F,
+    0x1A29,0x128E,0x0C84,0x218A,0x01CA,0x1D78,0x05D8,0x0D19,0x0B94,0x13C0,
+    0x02E8,0x0426,0x2272,0x10ED,0x1179,0x1E4D,0x1781,0x0219,0x21A9,0x0088,
+    0x2091,0x19E4,0x115A,0x1116,0x17D0,0x1A49,0x14B2,0x0DAD,0x0608,0x1F6E,
+    0x2001,0x1BE0,0x17F0,0x0897,0x004C,0x11C3,0x22E3,0x05C8,0x06E5,0x1678,
+    0x140D,0x1BA9,0x05FC,0x08E3,0x096D,0x03A9,0x092C,0x17F8,0x04BF,0x0902,
+    0x16DB,0x1EE2,0x15E7,0x12E2,0x05AF,0x0C64,0x1345,0x03F2,0x128A,0x0811,
+    0x0716,0x0582,0x031F,0x13DF,0x1E47,0x1B1C,0x0E77,0x1EE3,0x22B2,0x1FBA,
+    0x0E2D,0x2082,0x1A8D,0x1596,0x11B4,0x129C,0x1F95,0x1710,0x1A57,0x1736,
+    0x0D84,0x1B34,0x1D30,0x0D95,0x0B6E,0x1F2A,0x0E64,0x060B,0x0A91,0x0CE9,
+    0x14A7,0x20B3,0x1442,0x1803,0x195C,0x06B2,0x11F9,0x10DF,0x1784,0x0B53,
+    0x10BA,0x1317,0x1420,0x114F,0x1871,0x17C2,0x0742,0x16A2,0x06EC,0x19B7,
+    0x0367,0x0C2E,0x129E,0x06CF,0x0D01,0x0FE7,0x03A8,0x08C4,0x124D,0x139C,
+    0x04AB,0x1CC5,0x0574,0x082B,0x1C79,0x126C,0x216F,0x023B,0x17D5,0x066A,
+    0x0F01,0x0AE6,0x06F0,0x13B6,0x1227,0x0A78,0x230E,0x2348,0x222A,0x0FF4,
+    0x1E9B,0x1FD8,0x136A,0x2335,0x10AC,0x134B,0x1939,0x0273,0x0BC4,0x01E3,
+    0x1D37,0x1AA8,0x0123,0x0609,0x069E,0x03B5,0x1874,0x1896,0x22DA,0x08B3,
+    0x04B4,0x0304,0x1FCD,0x0F6F,0x04B6,0x0A77,0x02A2,0x2109,0x2393,0x23B5,
+    0x21B5,0x2330,0x1CD7,0x15D6,0x0ACB,0x0F94,0x20DE,0x0836,0x1C7A,0x0FFE,
+    0x1645,0x15AD,0x188B,0x184A,0x1B41,0x158E,0x046D,0x173E,0x0B40,0x0378,
+    0x0281,0x0F3D,0x11AC,0x1D70,0x1BF9,0x101E,0x145C,0x0083,0x058E,0x160C,
+    0x1FA6,0x1364,0x1FF1,0x0E48,0x0992,0x086C,0x16D6,0x08DA,0x0C40,0x0253,
+    0x03F9,0x2065,0x2032,0x03B0,0x1281,0x2118,0x1F23,0x1722,0x22FA,0x0328,
+    0x01AA,0x146A,0x12C4,0x2329,0x03EF,0x0DF3,0x0C53,0x09EA,0x01C4,0x1FCA,
+    0x1792,0x09D9,0x1540,0x1F6A,0x0279,0x0145,0x1AA7,0x013F,0x1E19,0x15B6,
+    0x000D,0x0A53,0x186E,0x217F,0x0CE3,0x1853,0x1A11,0x1936,0x1828,0x08BD,
+    0x08DF,0x1EA8,0x12EE,0x1D0C,0x1664,0x20DF,0x04DE,0x083A,0x0D24,0x2361,
+    0x0F2B,0x2354,0x126F,0x109B,0x1DF8,0x174F,0x09A0,0x0D53,0x00C2,0x06BA,
+    0x087C,0x0CC3,0x21B9,0x128C,0x01A1,0x0688,0x1162,0x0C7C,0x1C27,0x20D0,
+    0x0A6B,0x1B44,0x002D,0x119B,0x1855,0x102F,0x19BB,0x20FB,0x11C8,0x05FB,
+    0x058A,0x1C5F,0x1CE6,0x09C7,0x192F,0x0E1D,0x03CB,0x20EA,0x1CC3,0x01DB,
+    0x05C9,0x1B60,0x069B,0x001D,0x2295,0x1C4E,0x0A40,0x105F,0x0141,0x01AC,
+    0x0640,0x032D,0x15B5,0x229F,0x1E17,0x19F0,0x194F,0x0102,0x0675,0x0B5B,
+    0x203A,0x1010,0x1412,0x02E7,0x155C,0x176A,0x0866,0x21A1,0x18E9,0x0565,
+    0x12CA,0x1F44,0x1274,0x1B32,0x0260,0x196F,0x1838,0x13C3,0x003F,0x19C6,
+    0x01C6,0x1600,0x0EDF,0x0FD1,0x0A69,0x0062,0x1ED0,0x0F56,0x0377,0x2333,
+    0x0EA5,0x0350,0x1DF1,0x19A6,0x224B,0x0EA0,0x112D,0x204D,0x04D2,0x1613,
+    0x1793,0x0817,0x1D4E,0x1BF2,0x1913,0x0233,0x0B34,0x0A71,0x109C,0x1775,
+    0x0CDD,0x02DE,0x1EB4,0x1C28,0x021C,0x1D1C,0x1C93,0x1189,0x1999,0x16AC,
+    0x1670,0x1738,0x1E2A,0x2078,0x14BD,0x00EA,0x0898,0x1015,0x0EFA,0x19D7,
+    0x113E,0x1630,0x1DBB,0x0EC9,0x1560,0x1FC8,0x16EC,0x10E3,0x0CF2,0x07C8,
+    0x1174,0x0C5A,0x002E,0x1DB1,0x01D6,0x07E7,0x18CD,0x19A8,0x0CC5,0x0D5C,
+    0x1541,0x12CC,0x0BE9,0x0A1C,0x21CF,0x0171,0x067B,0x1DE3,0x1EE8,0x022B,
+    0x17A9,0x19AB,0x0D20,0x1C03,0x1E45,0x0E80,0x0B19,0x107F,0x124F,0x18AE,
+    0x1907,0x1614,0x18BD,0x0A9B,0x059B,0x0D70,0x12F3,0x10C5,0x2140,0x0BB4,
+    0x2384,0x01F7,0x0748,0x0FFB,0x13B3,0x01AD,0x076D,0x1083,0x1125,0x0018,
+    0x1C39,0x0925,0x19EF,0x0E4F,0x210C,0x159F,0x037E,0x0A62,0x219E,0x211C,
+    0x1C54,0x0BE0,0x1E02,0x09BA,0x1CBB,0x147B,0x1389,0x0B68,0x1023,0x23CB,
+    0x0E75,0x1086,0x1145,0x0BE4,0x1BFD,0x2059,0x2007,0x0022,0x05D5,0x1BF6,
+    0x02F0,0x1D1D,0x129A,0x06E4,0x0F47,0x0673,0x0ADD,0x0871,0x1C52,0x1449,
+    0x232C,0x1E67,0x085B,0x20AE,0x0B74,0x16A7,0x0B85,0x1717,0x0FC7,0x0DFB,
+    0x097F,0x0624,0x1CD6,0x15AF,0x0EFB,0x0E42,0x03B9,0x1369,0x0927,0x047C,
+    0x0D5A,0x0982,0x0E7F,0x217C,0x02D5,0x06DD,0x1E79,0x0D9D,0x1964,0x1153,
+    0x1F70,0x04CD,0x1123,0x22F1,0x1F2D,0x1EA4,0x19B6,0x1C3B,0x1356,0x0E01,
+    0x16C7,0x11C9,0x191A,0x09AC,0x1DE6,0x1FDC,0x0581,0x1F04,0x1178,0x06AB,
+    0x1D06,0x0A48,0x0F5B,0x1E4A,0x15D2,0x0FF8,0x01C3,0x1A14,0x0D17,0x086D,
+    0x0CEF,0x1D50,0x03CF,0x0B3E,0x003D,0x06AC,0x008B,0x1185,0x1732,0x11BD,
+    0x12F8,0x03B8,0x1068,0x18A2,0x1BA0,0x10F0,0x0868,0x03E6,0x1DC8,0x1AA2,
+    0x1B13,0x1C82,0x0055,0x099F,0x2222,0x034B,0x179D,0x1E6F,0x1261,0x0FC8,
+    0x166D,0x1F42,0x127F,0x0C9B,0x00B9,0x1D26,0x181D,0x1320,0x09AE,0x01DA,
+    0x1A35,0x05E3,0x04D6,0x1141,0x1BB2,0x0669,0x1B70,0x1F22,0x1B9D,0x19BE,
+    0x0D2A,0x1057,0x0A3B,0x11D3,0x157B,0x1B49,0x14F7,0x095D,0x0A88,0x0126,
+    0x031B,0x03DE,0x1422,0x0BF8,0x1030,0x1F34,0x210B,0x1B12,0x0379,0x0806,
+    0x1252,0x18A0,0x1778,0x1EE7,0x23C6,0x1611,0x22EC,0x0BE8,0x0950,0x1008,
+    0x0906,0x1D51,0x10A2,0x1DAE,0x22D8,0x1499,0x152F,0x0D08,0x00DB,0x0860,
+    0x0162,0x0AD3,0x2233,0x18A6,0x0DD2,0x1477,0x11B3,0x1CBD,0x2043,0x183A,
+    0x1077,0x15E6,0x1FEA,0x0FE8,0x0396,0x0B0A,0x1296,0x0049,0x2303,0x1818,
+    0x03A2,0x03F8,0x1225,0x05ED,0x15D4,0x030D,0x089D,0x107E,0x0A43,0x14A0,
+    0x235C,0x1426,0x0733,0x0D1C,0x1B96,0x09CE,0x155D,0x0F6E,0x238C,0x0876,
+    0x1DE0,0x1223,0x0FEF,0x078B,0x1EC2,0x09BF,0x1D52,0x1FA4,0x202B,0x14E1,
+    0x0864,0x1F78,0x0FA9,0x1821,0x0E38,0x06A6,0x0211,0x1F9E,0x020A,0x1AF2,
+    0x0981,0x1CC0,0x0766,0x1047,0x1EA9,0x0C16,0x1BE8,0x0464,0x22C8,0x183B,
+    0x0B32,0x2106,0x0D79,0x14F5,0x0A33,0x18D4,0x0482,0x0158,0x13E2,0x1651,
+    0x03C6,0x1750,0x1A5A,0x1C3C,0x1825,0x1DFB,0x1D76,0x2218,0x1F16,0x08EE,
+    0x210A,0x0747,0x0DF5,0x0CD3,0x10D3,0x1BBA,0x1F5D,0x1A78,0x19C7,0x177E,
+    0x13F0,0x2315,0x1F82,0x0922,0x22C6,0x17CC,0x1A50,0x1FE5,0x193D,0x122D,
+    0x03E3,0x07C9,0x20B0,0x217A,0x23F4,0x0DFD,0x1268,0x080E,0x192D,0x0698,
+    0x1EAF,0x170A,0x1E60,0x1947,0x1CE1,0x10BB,0x1505,0x016E,0x207B,0x11E7,
+    0x1F85,0x0F72,0x191E,0x2015,0x04AD,0x0AC1,0x1D73,0x2003,0x02F9,0x1C26,
+    0x1F64,0x0C7D,0x0B2D,0x004D,0x1E2B,0x1432,0x026C,0x1E04,0x218C,0x0CE1,
+    0x000F,0x0A01,0x16D0,0x20C8,0x0E25,0x0C09,0x2199,0x091A,0x0E3B,0x0F5F,
+    0x0D5E,0x223D,0x025D,0x0699,0x00DD,0x20EB,0x1352,0x1B92,0x21A4,0x1E10,
+    0x05E5,0x1292,0x0750,0x0552,0x0061,0x0058,0x07CB,0x02B6,0x12F0,0x0F67,
+    0x070D,0x1837,0x196B,0x09F7,0x153F,0x0BEE,0x1769,0x0B00,0x1142,0x1AE9,
+    0x1B98,0x1B8A,0x11A8,0x1DD2,0x16D2,0x1C7C,0x0F38,0x0F3B,0x1601,0x0151,
+    0x0320,0x1085,0x0B61,0x0DAF,0x1308,0x0E21,0x0371,0x1F7C,0x04DD,0x0F49,
+    0x1146,0x169C,0x1E31,0x1258,0x1E50,0x1F8B,0x205F,0x145A,0x084D,0x23B8,
+    0x0FAF,0x2055,0x160E,0x13D7,0x0908,0x0A7C,0x1022,0x0AC5,0x02DA,0x1962,
+    0x1F9F,0x0467,0x1E9C,0x04E3,0x0F4E,0x1DF9,0x23A5,0x10E7,0x11A9,0x215F,
+    0x117E,0x223A,0x149E,0x01E6,0x18D6,0x03B7,0x104B,0x0FBB,0x1273,0x18C9,
+    0x0A4A,0x215A,0x024C,0x1378,0x1ED2,0x212D,0x0F22,0x1F99,0x212E,0x2044,
+    0x10D0,0x22D2,0x20F7,0x19B5,0x1416,0x1741,0x20B6,0x1159,0x23A6,0x186D,
+    0x0515,0x04A8,0x2171,0x0E9E,0x2325,0x111B,0x1EC8,0x1620,0x1687,0x22BC,
+    0x059F,0x06E7,0x11DD,0x1C88,0x2125,0x0FAA,0x10DB,0x1854,0x1410,0x141C,
+    0x23AF,0x21D6,0x0B8C,0x0AD9,0x0B6B,0x0597,0x0C06,0x0619,0x198F,0x0339,
+    0x0802,0x0859,0x0107,0x0410,0x208A,0x2291,0x0E10,0x1DA6,0x19AA,0x0324,
+    0x10FB,0x049A,0x0CAC,0x2252,0x0299,0x0FD0,0x1DE7,0x086E,0x0FFA,0x09FA,
+    0x23C8,0x18C7,0x0489,0x2195,0x1802,0x19F2,0x1967,0x0FBF,0x02EE,0x0AE4,
+    0x0B63,0x1509,0x178F,0x0843,0x05E7,0x0613,0x1739,0x065A,0x0201,0x06D7,
+    0x21DA,0x11F4,0x0503,0x090D,0x0E32,0x09A8,0x1B5A,0x1EFB,0x20BF,0x11F1,
+    0x1D40,0x1DF2,0x1E75,0x01B0,0x0BCE,0x1346,0x1D5C,0x0546,0x1B0E,0x07B4,
+    0x11E8,0x018A,0x19E6,0x0177,0x134E,0x18E2,0x1546,0x0861,0x054C,0x0119,
+    0x1A77,0x1CEF,0x1110,0x1953,0x1CD9,0x0B65,0x0CD0,0x1E5A,0x1E0F,0x07EB,
+    0x13C2,0x1949,0x16E3,0x0409,0x007F,0x1CFF,0x0485,0x14D0,0x0CD1,0x0E46,
+    0x055E,0x1C48,0x016F,0x1C7B,0x1109,0x18B2,0x0ED5,0x13B0,0x0DFF,0x2061,
+    0x0795,0x2076,0x1A4A,0x029C,0x13BF,0x119A,0x1819,0x227A,0x0388,0x1C24,
+    0x036E,0x1D82,0x0F4B,0x084E,0x23EB,0x13A1,0x0632,0x13DC,0x150A,0x0112,
+    0x05A4,0x073C,0x161D,0x04AC,0x2283,0x0D0A,0x172E,0x2142,0x0319,0x1673,
+    0x17D6,0x0F73,0x0E26,0x14E6,0x1F46,0x13E0,0x1841,0x130E,0x2363,0x10CE,
+    0x0980,0x15A2,0x1FC7,0x04D9,0x11A2,0x0CA8,0x00EF,0x07BF,0x1C12,0x09DE,
+    0x0AE0,0x00DF,0x0D49,0x06C0,0x206E,0x1EE1,0x0A38,0x22F8,0x1DC7,0x0A79,
+    0x1800,0x179B,0x1386,0x1A22,0x01D2,0x094E,0x125C,0x2244,0x1746,0x0EDE,
+    0x002A,0x1CA7,0x099A,0x07E4,0x0264,0x1C6F,0x2389,0x0987,0x1F3D,0x1E88,
+    0x02E0,0x0D44,0x0E6C,0x1E8F,0x0F55,0x2066,0x1CC4,0x0917,0x1DB8,0x089F,
+    0x0615,0x11A5,0x12C8,0x0A42,0x079C,0x0D13,0x0B6A,0x131F,0x136C,0x04AE,
+    0x130D,0x16F8,0x01A0,0x13C7,0x0B4C,0x2279,0x0196,0x1464,0x0F60,0x0231,
+    0x19A0,0x1E9A,0x0397,0x170B,0x133C,0x2265,0x017C,0x1C78,0x048C,0x08D0,
+    0x06A4,0x071C,0x0BBA,0x0DE7,0x0B3F,0x0229,0x1EAD,0x140A,0x037B,0x0EC6,
+    0x0E16,0x0442,0x1894,0x156C,0x0F8F,0x23A1,0x0DCE,0x13CD,0x1AA4,0x0E59,
+    0x162B,0x1AA9,0x1BFB,0x09A7,0x1703,0x0A81,0x2056,0x21BC,0x078F,0x07AD,
+    0x1A24,0x0F31,0x19F3,0x09E6,0x11CD,0x23B6,0x234F,0x0FD2,0x196D,0x06D6,
+    0x035A,0x0AFA,0x005E,0x035C,0x1AB9,0x15A4,0x1318,0x0132,0x08D9,0x0512,
+    0x1693,0x0DB0,0x16A6,0x07FC,0x0B02,0x1D0D,0x09F0,0x21F5,0x0799,0x13E3,
+    0x0768,0x0EF9,0x1176,0x014A,0x15C1,0x0BA1,0x0E99,0x112B,0x1AAE,0x1C0B,
+    0x0178,0x1C69,0x1C0F,0x0130,0x1FC2,0x0E45,0x1694,0x1F0D,0x1A79,0x0911,
+    0x0FE9,0x09AF,0x18C2,0x1B67,0x1DF3,0x0B01,0x14B5,0x1DFD,0x0DCD,0x161E,
+    0x19A1,0x19E5,0x1500,0x14C9,0x0B2A,0x2366,0x1B46,0x14F4,0x0B5C,0x063E,
+    0x03E1,0x0CA5,0x04F7,0x1409,0x0EC3,0x1D5D,0x012C,0x1277,0x1310,0x1214,
+    0x112E,0x1F80,0x0AD6,0x1FD6,0x105B,0x226C,0x1F41,0x19CF,0x2033,0x0D29,
+    0x03CA,0x1A47,0x0756,0x125A,0x06F4,0x1B53,0x0527,0x1D91,0x20CE,0x1975,
+    0x0072,0x1431,0x1EEF,0x0BD0,0x0BE1,0x0C01,0x00E1,0x0A7A,0x23E6,0x0323,
+    0x219F,0x1367,0x07A2,0x1CB6,0x2191,0x0CB2,0x234A,0x1288,0x17DD,0x030B,
+    0x15F2,0x02A8,0x0D83,0x04BD,0x2347,0x0522,0x051B,0x225A,0x228A,0x1B9F,
+    0x13F9,0x1B7C,0x1D7F,0x0A30,0x0220,0x1C3F,0x22EA,0x1680,0x0FC9,0x1190,
+    0x1EF1,0x21CC,0x155E,0x20DD,0x0F27,0x13F6,0x07FF,0x0F71,0x1E6A,0x05B9,
+    0x0F0A,0x2228,0x02E9,0x0ACE,0x205C,0x01E5,0x200B,0x002F,0x1E27,0x0116,
+    0x1B38,0x190C,0x2307,0x07EA,0x152C,0x04C8,0x01FE,0x199B,0x1001,0x1535,
+    0x0930,0x1EC9,0x086A,0x0080,0x141E,0x1066,0x16DF,0x0C79,0x1E42,0x0A4C,
+    0x0667,0x1B7F,0x1679,0x1A3C,0x1A25,0x00E6,0x0611,0x0518,0x0B87,0x16F9,
+    0x22B0,0x1C3A,0x14FD,0x04BC,0x080F,0x21BF,0x1943,0x0266,0x1124,0x002B,
+    0x0670,0x01AB,0x1EC5,0x08B6,0x091D,0x0FA6,0x0541,0x20DC,0x0E65,0x0128,
+    0x08C9,0x11E5,0x1647,0x0D3D,0x01B8,0x1C61,0x2319,0x200C,0x1053,0x1027,
+    0x05F8,0x1A27,0x1133,0x210D,0x11E6,0x0935,0x054B,0x0754,0x02C6,0x0723,
+    0x0852,0x106B,0x161F,0x10B1,0x0E81,0x2054,0x156B,0x1113,0x22C5,0x21B7,
+    0x0AC0,0x042B,0x17DB,0x01B9,0x0CA2,0x055B,0x1A87,0x0D62,0x0A47,0x077F,
+    0x1D25,0x0FB5,0x1F3F,0x04E0,0x16C2,0x011D,0x158C,0x209C,0x0D6E,0x18FE,
+    0x05DD,0x1C05,0x123E,0x1BC6,0x0892,0x232B,0x1E3F,0x11B6,0x10B6,0x144A,
+    0x203F,0x02AD,0x2237,0x1BB3,0x03EB,0x0BBC,0x0311,0x1054,0x011E,0x1712,
+    0x05C2,0x2129,0x0292,0x22D0,0x0E6F,0x1F17,0x2234,0x16B6,0x00B5,0x1502,
+    0x0B0E,0x1299,0x2170,0x08C0,0x1BD4,0x1475,0x141B,0x0D00,0x2026,0x0318,
+    0x1567,0x0A4E,0x03E9,0x1CDC,0x23A8,0x1D8E,0x0DD8,0x0470,0x0286,0x1C22,
+    0x1315,0x1785,0x048F,0x1786,0x1EE0,0x0B37,0x0952,0x02BE,0x0873,0x04DF,
+    0x2101,0x0FCD,0x04B0,0x059D,0x1FCF,0x05E0,0x1C7F,0x0CBE,0x0461,0x024A,
+    0x027C,0x05F4,0x092A,0x0DC9,0x01E7,0x1147,0x03B2,0x1AB8,0x0238,0x174C,
+    0x02B2,0x1C6E,0x04D8,0x0DBC,0x1AB1,0x17FF,0x1443,0x054F,0x1128,0x0370,
+    0x14CC,0x1F35,0x1173,0x0A03,0x1D32,0x12D1,0x02AB,0x09DB,0x153D,0x1425,
+    0x122F,0x06BD,0x17B8,0x1579,0x0890,0x1B0F,0x1050,0x0DDF,0x23E3,0x1860,
+    0x1203,0x11D5,0x0EBB,0x0A80,0x00B7,0x1951,0x15B7,0x1FF3,0x0D14,0x143D,
+    0x164C,0x0E67,0x0C91,0x01F4,0x2243,0x1474,0x03A4,0x2147,0x0270,0x10C9,
+    0x116F,0x127D,0x0B1E,0x10FC,0x1A0A,0x1846,0x1F63,0x1067,0x0BB3,0x191F,
+    0x0EA6,0x0EEF,0x1E29,0x18B9,0x2079,0x090C,0x16FD,0x0EB4,0x0BC9,0x2098,
+    0x080A,0x0183,0x1BFE,0x1631,0x0769,0x1DD8,0x142F,0x0F66,0x1316,0x02A9,
+    0x22EE,0x1C4F,0x0285,0x1013,0x065D,0x0C2D,0x0466,0x033E,0x00E7,0x1900,
+    0x226F,0x1276,0x03AE,0x0EA1,0x23E7,0x174D,0x216C,0x1CA1,0x1A06,0x0665,
+    0x1461,0x2260,0x1F7D,0x1156,0x14E8,0x1327,0x0257,0x089A,0x15DF,0x16F4,
+    0x0EB9,0x03B3,0x0EAD,0x0FD9,0x085D,0x1259,0x1BA8,0x1E90,0x114C,0x2236,
+    0x02C7,0x1E53,0x2115,0x1D33,0x1FF5,0x1AFD,0x185D,0x06EE,0x0DC0,0x078C,
+    0x0AF4,0x15D1,0x0030,0x2131,0x1EB6,0x06E0,0x06B6,0x038C,0x05A8,0x080C,
+    0x0E98,0x1682,0x1DC0,0x1340,0x13B7,0x1C1B,0x0434,0x1AB5,0x1CAB,0x1A1C,
+    0x07D0,0x1ABB,0x22C1,0x0F08,0x027D,0x1238,0x1591,0x07F7,0x0D30,0x13F8,
+    0x1909,0x212B,0x1826,0x0749,0x0D06,0x0D2E,0x104F,0x1F39,0x09EB,0x0EF6,
+    0x22E6,0x16F1,0x0AEE,0x116B,0x17DE,0x0B12,0x0322,0x0BEA,0x064C,0x03D9,
+    0x2374,0x0CA4,0x1293,0x0E5C,0x04B3,0x03A0,0x13AD,0x0E33,0x0353,0x081A,
+    0x0BB2,0x0DA3,0x1E01,0x1322,0x0EBE,0x0D0E,0x0DBB,0x11A3,0x1B57,0x16FF,
+    0x0298,0x1A8F,0x09EF,0x08AD,0x1877,0x22AC,0x147A,0x1B36,0x095A,0x1B08,
+    0x0455,0x10AD,0x0343,0x1B16,0x0CF8,0x082E,0x144D,0x1A37,0x1B5D,0x0702,
+    0x09C4,0x1E16,0x157A,0x1965,0x0A63,0x1C6D,0x0D9E,0x0ED8,0x1E57,0x05CC,
+    0x1758,0x008D,0x0BFE,0x1168,0x04ED,0x1917,0x2251,0x1074,0x2356,0x1719,
+    0x1D3B,0x1FBE,0x22AA,0x14C8,0x211F,0x16D1,0x124B,0x2241,0x1C08,0x0AAC,
+    0x0F06,0x12B5,0x01FB,0x1C72,0x0089,0x23B3,0x02BA,0x15A5,0x1A00,0x1483,
+    0x13F2,0x2016,0x1AEB,0x2187,0x0BF7,0x07FA,0x2005,0x1516,0x13D6,0x0122,
+    0x0420,0x039D,0x0193,0x193B,0x2360,0x0453,0x0A75,0x0BD9,0x1197,0x1923,
+    0x1DB5,0x2225,0x1194,0x2058,0x0E9F,0x1106,0x06A1,0x02F5,0x1B63,0x00FF,
+    0x1F4C,0x2289,0x0CE0,0x1F1D,0x1247,0x19AE,0x1FC0,0x182E,0x05B3,0x0DB2,
+    0x229C,0x0E3D,0x232D,0x1961,0x1B95,0x0CA9,0x1A9E,0x183F,0x0203,0x1E76,
+    0x16BB,0x00B1,0x0A3F,0x237E,0x08A8,0x1B6E,0x0B2B,0x215B,0x119E,0x0945,
+    0x0F86,0x0A4B,0x12C7,0x1616,0x046B,0x20A3,0x0454,0x0405,0x0C19,0x1A08,
+    0x1E33,0x10BD,0x1861,0x2135,0x0C23,0x0F36,0x0C5C,0x049B,0x032F,0x1A19,
+    0x03DC,0x1E84,0x011C,0x1E61,0x096E,0x1F66,0x0798,0x104C,0x1C62,0x1E73,
+    0x03E4,0x0638,0x190D,0x1AF6,0x17EF,0x10FD,0x1B0D,0x1263,0x1512,0x09A5,
+    0x1439,0x0EF7,0x041D,0x04BA,0x08D4,0x1714,0x1B62,0x164F,0x1787,0x114A,
+    0x05B2,0x1812,0x0D33,0x176E,0x1480,0x12FA,0x0E61,0x084B,0x0801,0x079A,
+    0x2034,0x154A,0x23BC,0x20A9,0x1985,0x2286,0x148C,0x0DC2,0x06D8,0x1D4C,
+    0x183D,0x1A41,0x22DD,0x21F1,0x103C,0x14BC,0x0827,0x0850,0x157D,0x02BD,
+    0x03BF,0x00DE,0x0C9E,0x1CB7,0x1BF8,0x0805,0x20A8,0x1DA1,0x1F50,0x1DA0,
+    0x0DA0,0x068E,0x1979,0x0650,0x1F52,0x2239,0x0594,0x1534,0x1C38,0x0351,
+    0x0DE3,0x1672,0x21E3,0x10AB,0x11BC,0x1788,0x1547,0x2071,0x07DE,0x012F,
+    0x22AF,0x2377,0x179A,0x12B3,0x0CF3,0x0B92,0x0BB7,0x070F,0x11CA,0x2039,
+    0x0DAA,0x1521,0x0278,0x0F4D,0x0C87,0x0956,0x0967,0x067E,0x08B0,0x11AF,
+    0x051F,0x099E,0x0C78,0x0E27,0x19BD,0x1DCC,0x15F1,0x01F5,0x1453,0x043E,
+    0x1E8C,0x018F,0x1B54,0x2166,0x1BBC,0x1FE8,0x059A,0x0C6B,0x00C7,0x1E92,
+    0x13DE,0x0B3B,0x05E4,0x15EE,0x22A9,0x2090,0x2276,0x0631,0x105D,0x2038,
+    0x195A,0x17E5,0x1AFF,0x10A8,0x0384,0x0886,0x0456,0x1599,0x0B4E,0x1D47,
+    0x1830,0x051E,0x1C3D,0x20E1,0x1895,0x2092,0x10E9,0x07C6,0x23BD,0x201A,
+    0x209A,0x04C4,0x0315,0x019B,0x237C,0x047A,0x23FC,0x11A6,0x195F,0x2006,
+    0x1328,0x1CCE,0x1DEA,0x0970,0x0067,0x058D,0x1934,0x2120,0x01C5,0x2263,
+    0x04FD,0x1AE1,0x125E,0x1CA0,0x19BC,0x226E,0x0734,0x0BB8,0x0A54,0x19FE,
+    0x0E85,0x1FC6,0x0224,0x171C,0x1FFB,0x1115,0x0524,0x133E,0x0EDD,0x2280,
+    0x1D2F,0x0200,0x0CB3,0x23FE,0x0F19,0x1569,0x1537,0x19C2,0x08DC,0x1F6D,
+    0x068D,0x10F4,0x055A,0x1E30,0x21F0,0x1CF5,0x0D35,0x04A6,0x139D,0x23D3,
+    0x0A8D,0x1D3D,0x0763,0x0575,0x1511,0x1676,0x1304,0x0E13,0x10CD,0x0E55,
+    0x199E,0x236E,0x1257,0x2288,0x13E5,0x0037,0x1D04,0x04EF,0x100E,0x0FAE,
+    0x1E9E,0x067A,0x2320,0x0539,0x21D8,0x07C4,0x045F,0x1D0B,0x1196,0x020E,
+    0x1B68,0x04B5,0x031C,0x00FD,0x1184,0x0F7C,0x166C,0x23D2,0x0C9F,0x2380,
+    0x0B78,0x0F14,0x18F0,0x05AD,0x0252,0x138A,0x13FA,0x1A93,0x1F01,0x126A,
+    0x1D6A,0x11D9,0x182F,0x1492,0x1822,0x0D54,0x16E2,0x05D1,0x1155,0x0C4A,
+    0x1F58,0x00A3,0x17E0,0x0CD6,0x1D43,0x0250,0x16F3,0x0CFB,0x0C29,0x0B86,
+    0x11A4,0x1ED7,0x14FC,0x10D8,0x0F59,0x2338,0x1C5A,0x0F42,0x142D,0x12FD,
+    0x2373,0x11CE,0x0800,0x23E0,0x2025,0x0FFD,0x0A99,0x2264,0x1FF7,0x04A9,
+    0x1A67,0x1ED4,0x0BE2,0x21F3,0x1DF4,0x1927,0x04A4,0x1C84,0x0B09,0x11B9,
+    0x21A0,0x1D7B,0x1EF7,0x006F,0x18C6,0x1478,0x0985,0x1E23,0x0039,0x1EBC,
+    0x13D2,0x0391,0x039C,0x0118,0x1061,0x21C8,0x1A40,0x1EAA,0x175B,0x036C,
+    0x204F,0x19BA,0x1F91,0x193A,0x197B,0x0F24,0x176F,0x1592,0x0854,0x0804,
+    0x0FD4,0x0A2B,0x16FE,0x0D64,0x0587,0x1F00,0x1539,0x203C,0x1E54,0x01B4,
+    0x02E6,0x1B11,0x0A98,0x157C,0x1868,0x0786,0x15C8,0x083C,0x0F84,0x1209,
+    0x0B47,0x0F1C,0x0D77,0x188C,0x06C7,0x0521,0x203E,0x1921,0x0996,0x2020,
+    0x1E5D,0x12CE,0x0940,0x0309,0x1991,0x12A7,0x1E77,0x0830,0x1B94,0x1C73,
+    0x02C4,0x1D86,0x0F0F,0x192B,0x0BFC,0x1451,0x1969,0x09F1,0x010C,0x1865,
+    0x09C6,0x1AE8,0x17B7,0x21F8,0x14A1,0x21F6,0x07D7,0x0C36,0x1CB4,0x1883,
+    0x1655,0x1DDF,0x0863,0x00F0,0x0961,0x0687,0x1070,0x0FE5,0x072F,0x0BC2,
+    0x08C8,0x1AAA,0x0645,0x09CF,0x0FA8,0x2130,0x23CF,0x2246,0x1990,0x1744,
+    0x0D4B,0x0090,0x143F,0x166F,0x1DE5,0x0331,0x09CD,0x1447,0x1CEB,0x0D3B,
+    0x0CCD,0x2159,0x0F78,0x0251,0x068F,0x07BB,0x0877,0x1A2A,0x0700,0x23C2,
+    0x08A2,0x1C98,0x1427,0x0E79,0x15AC,0x0F8B,0x153A,0x0AEC,0x0DEC,0x03EE,
+    0x1AE2,0x1F6B,0x13F4,0x1EFA,0x172F,0x1C87,0x1B3F,0x192A,0x1C53,0x1BB1,
+    0x0297,0x0772,0x1385,0x173D,0x0707,0x17BD,0x007D,0x1A07,0x08C6,0x1D6F,
+    0x09D8,0x1850,0x1C8B,0x180D,0x1CB1,0x148A,0x0492,0x0847,0x0D78,0x0DEF,
+    0x0E7E,0x1D3A,0x0E91,0x1888,0x1C59,0x1AE7,0x1FC1,0x154C,0x058C,0x0078,
+    0x22BA,0x225B,0x0F5E,0x1A4C,0x0D3E,0x195D,0x06DF,0x02A7,0x14E5,0x0CFC,
+    0x16EE,0x0F7D,0x0321,0x178A,0x1097,0x0E0B,0x1479,0x079D,0x1C5B,0x1208,
+    0x0B1F,0x0D7C,0x1963,0x0835,0x1C99,0x2226,0x1417,0x045E,0x18E0,0x0051,
+    0x1243,0x181E,0x0659,0x172A,0x1373,0x1ABD,0x1F0C,0x1749,0x113A,0x06ED,
+    0x09A6,0x027F,0x015D,0x1084,0x022E,0x1A5B,0x1685,0x1D1B,0x0054,0x0FB3,
+    0x20CC,0x23A9,0x220B,0x045A,0x1B24,0x2145,0x148B,0x18EC,0x16BC,0x0B9B,
+    0x120C,0x18B0,0x02E3,0x1A1D,0x0BE7,0x133D,0x0DE1,0x21D4,0x0357,0x1715,
+    0x20A2,0x0A18,0x239D,0x22D6,0x0CD5,0x1942,0x16E9,0x0E54,0x1007,0x069D,
+    0x1CB8,0x12DC,0x0381,0x0C93,0x1EFF,0x04E4,0x1C25,0x1FE7,0x20C1,0x0412,
+    0x0215,0x1594,0x1BC5,0x217E,0x221C,0x173A,0x1F19,0x1183,0x0765,0x20F8,
+    0x05F2,0x130A,0x036D,0x012E,0x06EA,0x0B3C,0x1C42,0x1F43,0x0A95,0x1B8C,
+    0x1F36,0x0622,0x04DA,0x2070,0x089E,0x04D4,0x184E,0x1520,0x1CC8,0x127B,
+    0x1302,0x13D0,0x0626,0x0429,0x004A,0x18C0,0x2144,0x0A34,0x1AEA,0x1212,
+    0x12A2,0x06D2,0x0751,0x1D2B,0x104A,0x133A,0x1E80,0x12F6,0x1C9E,0x1460,
+    0x13BA,0x16D9,0x1648,0x1E3A,0x1B29,0x0592,0x11BA,0x1D0E,0x0153,0x0ADB,
+    0x15C3,0x1507,0x17FC,0x122C,0x14D7,0x21AD,0x1A53,0x14F2,0x16DC,0x20F1,
+    0x118E,0x1AAB,0x04EB,0x0606,0x0D05,0x170E,0x05D9,0x0A83,0x10F7,0x070B,
+    0x04F8,0x0B27,0x2224,0x0F97,0x075E,0x180E,0x2194,0x010E,0x0B57,0x1A80,
+    0x1610,0x1B19,0x1BAC,0x0B30,0x0376,0x1697,0x0668,0x00EC,0x1256,0x1F74,
+    0x110D,0x0807,0x03D1,0x1326,0x0577,0x067C,0x1E5C,0x1D6D,0x06F1,0x075C,
+    0x0394,0x0184,0x1E7E,0x12F1,0x0216,0x0990,0x208D,0x1332,0x1044,0x0EF8,
+    0x0F70,0x075D,0x042C,0x030E,0x17CB,0x0AA3,0x04B2,0x1A63,0x04FE,0x097E,
+    0x213D,0x11DF,0x166B,0x0A2E,0x0664,0x0C75,0x21A3,0x102D,0x1F32,0x1D42,
+    0x0A65,0x14BF,0x0B11,0x22B9,0x08AC,0x1394,0x11B7,0x1FAE,0x1CCD,0x1A05,
+    0x177D,0x0D81,0x1E85,0x0D88,0x0A5E,0x0330,0x0EC4,0x13D9,0x1583,0x1CA6,
+    0x2126,0x0F99,0x158F,0x00F9,0x0176,0x1528,0x1C2B,0x1D69,0x049F,0x0418,
+    0x18B4,0x1ACB,0x236F,0x04C5,0x0705,0x0031,0x20B9,0x15B2,0x1FD4,0x18FC,
+    0x1A6E,0x21B1,0x0DEA,0x0432,0x1F1B,0x0CB7,0x2011,0x07CC,0x21FD,0x1216,
+    0x1F51,0x21AB,0x0974,0x0833,0x06F8,0x1935,0x10B4,0x0164,0x1421,0x1A4D,
+    0x1824,0x07DB,0x1551,0x0E53,0x152D,0x23CE,0x0DFE,0x0D51,0x1A6A,0x1E3C,
+    0x20B4,0x1BAA,0x0C62,0x0973,0x01E4,0x0035,0x01D7,0x0496,0x1A73,0x1435,
+    0x2290,0x22F4,0x1E71,0x0F7B,0x066D,0x0874,0x0DB5,0x0F1A,0x0F2D,0x218F,
+    0x17AE,0x0170,0x1BEA,0x1908,0x204A,0x0728,0x0746,0x18B8,0x0242,0x0F17,
+    0x1F8A,0x0B10,0x0966,0x1DD5,0x0174,0x07AE,0x1485,0x146C,0x0975,0x1556,
+    0x1783,0x2021,0x21E7,0x06DB,0x227D,0x19E7,0x22DC,0x2297,0x1FD1,0x1A26,
+    0x07CD,0x233D,0x1B84,0x1E18,0x21CE,0x0EE4,0x2255,0x0862,0x1887,0x057A,
+    0x20C9,0x17F4,0x1BDD,0x2284,0x1817,0x0929,0x0079,0x18F3,0x0E14,0x1131,
+    0x16B8,0x144E,0x120E,0x16BF,0x058B,0x1C9B,0x05D4,0x0E7B,0x07D3,0x1D27,
+    0x1051,0x1E12,0x2157,0x0A89,0x03E0,0x0DC8,0x219B,0x0495,0x04C0,0x090E,
+    0x1914,0x1A13,0x05C4,0x1C0D,0x0564,0x178C,0x2069,0x0291,0x08B5,0x0138,
+    0x1224,0x14C6,0x14C1,0x1AC7,0x0689,0x1E72,0x1751,0x1E0C,0x2270,0x080D,
+    0x1C00,0x03AD,0x1EF8,0x15C9,0x0F28,0x0E40,0x0F9E,0x0344,0x1D58,0x11F5,
+    0x1EAC,0x17A7,0x188D,0x05BA,0x1472,0x154E,0x0017,0x05C7,0x1ACD,0x2370,
+    0x1140,0x2230,0x0F2E,0x1EB2,0x1CA5,0x1B5E,0x1633,0x09B5,0x08B1,0x1B3E,
+    0x0CFE,0x02ED,0x1CEC,0x020F,0x2103,0x13ED,0x0C99,0x07E3,0x00D9,0x1342,
+    0x2179,0x03AA,0x13F5,0x124C,0x1EAB,0x15BA,0x0F41,0x02F6,0x1652,0x057E,
+    0x0157,0x0BE6,0x09AB,0x148D,0x072A,0x1071,0x09B0,0x0500,0x1B65,0x0A6A,
+    0x13A0,0x0F65,0x21BE,0x01FF,0x19B3,0x1CBA,0x109F,0x1EF0,0x0517,0x0307,
+    0x18AC,0x0FD5,0x1FEF,0x0F16,0x197E,0x1291,0x078A,0x1657,0x13C1,0x0E7A,
+    0x1466,0x07BE,0x164E,0x0419,0x2158,0x0FC4,0x0E7D,0x18D9,0x0942,0x0AEF,
+    0x163E,0x2200,0x226D,0x037A,0x1B66,0x0CAF,0x07FB,0x0CEC,0x0D4A,0x0CB6,
+    0x000E,0x1ADE,0x1BD5,0x1892,0x15A1,0x1DD1,0x1DBC,0x01EE,0x12E0,0x0671,
+    0x0ABB,0x1E0E,0x189F,0x1D9D,0x0DF2,0x0008,0x13CB,0x11B8,0x0571,0x00BA,
+    0x0AC3,0x1568,0x070A,0x21B0,0x16EA,0x1000,0x10BF,0x0C8C,0x0AE5,0x186B,
+    0x1366,0x12DF,0x2156,0x0C82,0x05CD,0x0B25,0x08CA,0x1695,0x0FCE,0x055F,
+    0x0D37,0x1748,0x13DB,0x1E43,0x03E7,0x0D8E,0x095E,0x0AF1,0x0103,0x02F4,
+    0x02F8,0x01F6,0x07FD,0x095F,0x1376,0x1643,0x1350,0x1372,0x06E3,0x14D5,
+    0x0870,0x15D9,0x20CD,0x128D,0x1878,0x0FC1,0x0907,0x127C,0x0A2C,0x0041,
+    0x03F4,0x116C,0x02B1,0x1CEA,0x1A18,0x00FB,0x08DE,0x0660,0x06AA,0x23D1,
+    0x0092,0x230C,0x0D91,0x14A3,0x0478,0x0FF7,0x1AF1,0x001A,0x0E69,0x1F5C,
+    0x162C,0x19F8,0x141A,0x1FE6,0x100F,0x047F,0x1DAF,0x231E,0x236C,0x1725,
+    0x108E,0x0290,0x1006,0x0E74,0x1C0A,0x1E35,0x1B90,0x05A7,0x1C21,0x0F1F,
+    0x0514,0x1937,0x22A6,0x0B4A,0x1A3A,0x1217,0x0E50,0x078D,0x2198,0x1B3B,
+    0x1A44,0x0BAB,0x2268,0x16D5,0x03F3,0x06D0,0x0523,0x1D45,0x18DB,0x0BA7,
+    0x1DBA,0x0776,0x1CFA,0x1E13,0x0271,0x200A,0x0D9B,0x0C4B,0x0588,0x0593,
+    0x18E4,0x082A,0x0533,0x1988,0x0317,0x1848,0x0DAB,0x2177,0x1945,0x126B,
+    0x0842,0x07B9,0x1DE1,0x06F3,0x224E,0x0AF0,0x0026,0x0240,0x010F,0x18E7,
+    0x0E51,0x0947,0x1C35,0x1F28,0x1688,0x07A9,0x1759,0x1608,0x1437,0x0B39,
+    0x2009,0x0389,0x0858,0x15BE,0x08A9,0x22D4,0x0EAE,0x015F,0x0337,0x034D,
+    0x23D9,0x081D,0x1D74,0x0C26,0x1BD9,0x0651,0x1F7B,0x2008,0x16B5,0x23A2,
+    0x05E1,0x1325,0x1E20,0x225F,0x0DED,0x101A,0x1254,0x00A8,0x1F1C,0x1F26,
+    0x1C8C,0x0563,0x12D2,0x0821,0x2160,0x115D,0x11EE,0x0232,0x192E,0x1BDF,
+    0x05F3,0x0E57,0x11F3,0x044E,0x20B5,0x1BDE,0x0F25,0x0DBE,0x1361,0x1971,
+    0x17E7,0x0C46,0x16FC,0x1B2E,0x18CB,0x23C4,0x1912,0x214C,0x0BA4,0x2392,
+    0x1037,0x1666,0x0BBB,0x180B,0x041F,0x20FA,0x1577,0x18D7,0x0115,0x0904,
+    0x136E,0x1867,0x0F53,0x0E2B,0x1A02,0x1FB2,0x1A9A,0x1D6C,0x0EBA,0x0BD5,
+    0x09F8,0x083F,0x0227,0x0E89,0x1495,0x1033,0x0F07,0x0D4D,0x0B4D,0x0F6A,
+    0x07FE,0x1AFB,0x05B0,0x1205,0x06CE,0x02D6,0x09DF,0x1A0C,0x0C3E,0x22C9,
+    0x22E5,0x0FEB,0x0A0E,0x21E6,0x088A,0x1C64,0x10B8,0x0383,0x14F8,0x0ED4,
+    0x05B4,0x2188,0x226B,0x025C,0x020D,0x0D0C,0x0449,0x0C81,0x0965,0x1135,
+    0x0CC1,0x08FC,0x16E4,0x1ED1,0x1BBD,0x1BE3,0x06D9,0x00A2,0x04C3,0x0CBF,
+    0x1324,0x2235,0x116A,0x0789,0x0198,0x05C3,0x1181,0x106C,0x1C8F,0x0984,
+    0x1A71,0x05F9,0x1F61,0x1298,0x2310,0x0075,0x063B,0x0B71,0x10C8,0x1E6D,
+    0x08A3,0x045C,0x1157,0x1DCE,0x0A05,0x1AAC,0x03F5,0x0DD1,0x2137,0x1200,
+    0x0CC4,0x17DA,0x1DF7,0x06C5,0x1C07,0x1B59,0x1AD8,0x0C43,0x15A0,0x0EF0,
+    0x0243,0x1BDA,0x1338,0x0C2F,0x132E,0x1D63,0x0969,0x23F3,0x077E,0x0991,
+    0x1DBE,0x23C7,0x05A3,0x1253,0x1FB8,0x1BCE,0x053B,0x1B8F,0x00E3,0x20E2,
+    0x1B61,0x22CE,0x04E8,0x17E1,0x06A3,0x04D1,0x02D3,0x23B1,0x031A,0x2045,
+    0x1319,0x1E7F,0x20CA,0x21E9,0x0C50,0x1E8D,0x209B,0x2306,0x0A1D,0x044B,
+    0x08A1,0x0437,0x102C,0x11F0,0x159B,0x0913,0x0A08,0x1E36,0x128F,0x06FA,
+    0x0DF0,0x160B,0x1F2E,0x094C,0x0788,0x1309,0x1CD4,0x0599,0x179F,0x0F54,
+    0x1362,0x1763,0x1B6C,0x0302,0x0921,0x231D,0x13F1,0x09C3,0x1348,0x12E1,
+    0x00FA,0x1689,0x16BE,0x18AB,0x1604,0x19F1,0x21BA,0x0D6A,0x20FC,0x21D2,
+    0x21ED,0x0663,0x0421,0x0D92,0x061A,0x165F,0x1D92,0x152E,0x070C,0x12A8,
+    0x1C90,0x0951,0x0CE5,0x1D39,0x0B75,0x168B,0x0A61,0x23B4,0x1572,0x1E06,
+    0x1AF9,0x0F5A,0x00CC,0x2139,0x0114,0x18FA,0x1654,0x18A9,0x0B13,0x0AF8,
+    0x14E4,0x051C,0x098A,0x1C9C,0x0554,0x1BBE,0x0DE5,0x198E,0x1BBB,0x0BCD,
+    0x0511,0x0E22,0x1D95,0x0C11,0x14E2,0x0108,0x1A56,0x0401,0x11B0,0x00C6,
+    0x2165,0x0F64,0x17BF,0x0154,0x0B95,0x14A5,0x0CC8,0x1B8E,0x1D7A,0x024F,
+    0x1762,0x1F71,0x1501,0x1844,0x15C2,0x010D,0x1092,0x0060,0x00AF,0x154D,
+    0x0DA5,0x0DB8,0x196E,0x1EE5,0x035E,0x05D3,0x00FC,0x0BCB,0x0364,0x0CAB,
+    0x16A3,0x23A7,0x014B,0x1536,0x0550,0x0407,0x127A,0x0A9E,0x1D64,0x0FD8,
+    0x14D2,0x0701,0x17DC,0x0BC0,0x1BA7,0x2141,0x0CFF,0x1B31,0x0205,0x22A7,
+    0x0C5E,0x1A09,0x11DE,0x13CE,0x08F3,0x208F,0x0015,0x2037,0x0AAF,0x057D,
+    0x0087,0x0AFB,0x1A85,0x1A97,0x0FD7,0x12D9,0x1FED,0x1DE2,0x197F,0x22B1,
+    0x205A,0x0544,0x0AD0,0x01DF,0x1E64,0x0AEB,0x12A6,0x0F30,0x07F1,0x1BF0,
+    0x230A,0x0573,0x0F61,0x2386,0x1242,0x1C55,0x0DA4,0x0F43,0x22AE,0x0CC6,
+    0x1BB5,0x0CDC,0x16A0,0x02FE,0x053F,0x008C,0x18E8,0x02CE,0x0C17,0x1B71,
+    0x1494,0x15F0,0x0D5B,0x089C,0x0F21,0x0A87,0x10CB,0x1EEB,0x1A2D,0x1F38,
+    0x0508,0x1C13,0x09D6,0x1B83,0x03C7,0x177B,0x0BA0,0x0760,0x00A7,0x07B8,
+    0x0F3F,0x0070,0x163B,0x0718,0x1609,0x2313,0x1058,0x10A1,0x0DA2,0x1BD8,
+    0x19D3,0x203D,0x09AA,0x0F0C,0x0A4D,0x22AD,0x0E9B,0x07A8,0x14F1,0x1056,
+    0x1E74,0x0402,0x0D40,0x0D6C,0x021E,0x1756,0x0056,0x0EB1,0x0E1C,0x0206,
+    0x0C94,0x2326,0x1F31,0x23CD,0x1BBF,0x0BB6,0x0607,0x0E0E,0x13B9,0x1724,
+    0x03F1,0x1BCC,0x01F1,0x1624,0x129F,0x1A6D,0x22E0,0x1132,0x1AE5,0x1B69,
+    0x00F1,0x225E,0x1E28,0x05EA,0x0F8E,0x024B,0x108F,0x0A3E,0x135D,0x0C73,
+    0x18D3,0x1BDC,0x1E8B,0x0BAA,0x1D09,0x0305,0x22E2,0x1D7D,0x012B,0x2164,
+    0x156F,0x0069,0x1333,0x206D,0x04F2,0x1982,0x141D,0x023D,0x0144,0x1EA0,
+    0x2378,0x1486,0x0EC5,0x1677,0x0770,0x06B4,0x04F6,0x09BC,0x1704,0x1DEF,
+    0x1FAF,0x22D5,0x1A34,0x21C0,0x099D,0x1BD7,0x1C47,0x1A4B,0x195E,0x0569,
+    0x10E5,0x0BAE,0x01A4,0x220C,0x0BB9,0x1700};
+
+#define MX_MTBL		(sizeof(mekornd) / sizeof(unsigned short))
+
+typedef struct { int n; unsigned short int r; } MKT;
+
+static int comp_mt(const void *s, const void *d)
+{
+    MKT *mt1 = (MKT *)s;
+    MKT *mt2 = (MKT *)d;
+    return (int)(short)(mt1->r - mt2->r);
+}
+
+MKT *calcMEKO(int n)
+{
+    int i;
+    MKT *mt;
+
+    if(n <= 0 || n > MX_MTBL){
+	    ErrPopUp ("Error:  Over max array.", "\nOk");
+	    return(NULL);
+    }
+
+    mt = malloc(sizeof(MKT) * n);
+
+    if(!mt) {
+	    ErrPopUp ("Error:  No memory.", "\nOk");
+	    return(NULL);
+    }
+
+    for(i = 0; i < n; i++) {
+        mt[i].r = mekornd[i];
+        mt[i].n = i + 1;
+    }
+    qsort(mt, n, sizeof(MKT), comp_mt);
+    return(mt);
+}
diff -Naur xv-3.10a.old/xvmgcsfx.c xv-3.10a/xvmgcsfx.c
--- xv-3.10a.old/xvmgcsfx.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvmgcsfx.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,2263 @@
+/*
+ * $Id: xvmgcsfx.c,v 1.23 95/11/27 19:03:36 tin329 Exp Locker: tin329 $
+ * xvmgcsfx.c - Use the filters as input and output method.
+ *
+ * Features
+ * ========
+ * Use the filters as input and output method for load and save unsupported
+ * image format file. The filter command is recognized by definition of 
+ * magic number or suffix in "~/.xv_mgcsfx" .
+ *
+ * Bugs
+ * ====
+ * There are many bugs.
+ * Let's go hunting for insects with an insect net. (it's all joke.)
+ *
+ * Author
+ * ======
+ * Tetsuya INOUE  <tin329@chino.it.okayama-u.ac.jp>
+ */
+
+/*
+ * Known Bugs and Todo  /  $B$"$l$3$l5$$K$J$k$3$H(B
+ *
+ *  ~/.xv_mgcsfx $BFb(B
+ *    $B!&Dj5A$,IT40A4$@$H%(%i!<(B (':'$B$N?t(B)$B!#(B
+ *    $B!&%G%j%_%?$H$7$F(B ':' $B$r;H$&$N$G!"%9%?!<%H%"%C%W%U%!%$%kFb$G(B
+ *      ':' $B$rMQ$$$FDj5A$O$G$-$J$$!#(B'\:'$B$G$b%@%a!#(B
+ *    $B!&(B magic $B%?%$%W$G!"#8?J?t$O#37eJ,#0!A#7$rD4$Y!"#1#6?J?t$O(B
+ *       isxdigit $B$,??$rJV$94VCf=hM}$5$l$k!#$7$+$7!"#1#b#y#t#e$H(B
+ *       $B$7$F$7$+I>2A$5$l$J$$!#(B
+ *    $B!&%W%j%W%m%;%C%5$r;H$&$H$-$O!"%3%a%s%H$N=q$-J}$KCm0U$7$J$1$l$P$J(B
+ *        $B$i$J$$!#%W%j%W%m%;%C%5$K$h$C$F$O%3%a%s%H$,%(%i!<$K$J$k!#(B
+ *    $B!&%Q%$%W$X$NF~=PNO$N%U%)!<%^%C%H$N<oN`$,(B PNM $B$N$_(B
+ *        $BF~NO(B
+ *            $B%U%!%$%k%]%$%s%?$r(B seek $B$7$F$O$$$1$J$$(B
+ *            $B%U%!%$%k%5%$%:$rMQ$$$F$O$$$1$J$$(B
+ *        $B=PNO(B
+ *            $B%U%!%$%k%]%$%s%?$r(B seek $B$7$F$O$$$1$J$$(B
+ *            exec $B$G$-$J$/$F=*N;$7$?%W%m%;%9$K=q$-9~$_IT2D(B
+ *    $B!&%5%U%#%C%/%9$H%^%8%C%/%J%s%P!<$N;H$$J,$1$r$I$&$9$k$+!#(B
+ *        $B%^%8%C%/%J%s%P!<$,F1$8$G!"%5%U%#%C%/%9$,0[$J$k>l9g$rG'$a$k$+!)(B
+ *    $B!&(Bcompress(gzip)$B$N%U%!%$%k$O%F%s%]%i%j$G$O(B xvtmp??? $B$H$$$&L>A0$J(B
+ *      $B$N$G(B suffix $B$G$O<1JL$G$-$J$$!#(B
+ *
+ *  $BG'<1$9$k;~$K(B MACBINARY $B$K$OIi$1$k(B(in xv.c)$B!#(B
+ *
+ *  $BB?=E$K(B pipe $B$rDL$9$3$H$,$G$-$J$$!#(B(pipe $B$,(B seek $B$G$-$J$$$+$i(B)
+ *    $B!&(Bsocketpair $B$G!"(Brecv $B$K(B MSG_PEEK $B%U%i%0$r$D$+$C$F6uFI$_$9$k!#(B
+ *    $B!&$3$l$r$d$k$H%U%!%$%k$NG'<1$,$a$A$c$a$A$cCY$/$J$k!#(B
+ *
+ *  $B%j%=!<%9$G@_Dj(B
+ *    $B!&%j%=!<%9$G@_Dj$9$kJ}$,LLE]$/$5$$(B
+ *
+ *  $B%^%8%C%/%J%s%P!<$N@_Dj$K@55,I=8=(B
+ *
+ *  $B%;!<%VMQ%W%m%;%9$,<:GT$9$k>l9g$NBP:v$,:#0l$D(B
+ *
+ *  DEC OSF/1 V3.0 $B$G$O!"%Q%$%W$K%G!<%?$,$^$@$J$$;~$KFI$_9~$b$&$H$9$k$H!"(B
+ *  read $B$,IT40A4$K$J$k!#(B(in xvpbm.c)
+ *  $BF1MM$K=q$-9~$_;~$K$bLdBj$,@8$8$k$+$b$7$l$J$$!#(B
+ */
+
+#define  NEEDSDIR               /* for stat() */
+#include "xv.h"
+
+
+#ifdef HAVE_MGCSFX
+
+
+#ifdef __osf__
+#ifdef __alpha
+#define ARCHITECTURE64 1
+#endif /* __alpha */
+#endif /* __osf__ */
+
+#ifdef ARCHITECTURE64
+typedef short int16;
+typedef int   int32;
+typedef long  int64;
+#else
+typedef short int16;
+typedef long  int32;
+#endif /* ARCHITECTURE64 */
+
+#ifdef sgi
+#define vfork fork
+#endif
+
+#define USE_SIGCHLD
+#if 0
+#undef  USE_SIGCHLD
+#endif
+
+typedef struct _mgcsfxtab
+{
+  struct _mgcsfxtab *next;
+  char              *description;
+  int                mgcsfx_type;
+  int                offset;
+  union{
+    int16            int16_data;
+    int32            int32_data;
+    char            *string_data;
+  }                  dt;
+  int                string_len;
+  char              *suffix;
+  int                input_image_type;
+  char              *input_command;
+  int                output_image_type;
+  char              *output_command;
+} mgcsfxtab;
+
+
+#ifndef MGCSFXDIR
+#  define MGCSFXDIR       "/usr/local/lib"
+#endif
+#ifndef MGCSFX_SITE_RC
+#  define MGCSFX_SITE_RC  "xv_mgcsfx"
+#endif
+#ifndef MGCSFX_RC
+#  define MGCSFX_RC       ".xv_mgcsfx"
+#endif
+
+#ifdef USE_MGCSFX_PREPROCESSOR
+#ifndef MGCSFX_PREPROCESSOR
+#define MGCSFX_PREPROCESSOR "/usr/lib/cpp"
+#endif
+#endif
+
+
+/* Check type for Magic number and Suffix */
+enum {T_UNKNOWN,
+      T_MAGIC, T_SUFFIX,
+      T_BEINT16, T_BEINT32, T_BEINT64,
+      T_LEINT16, T_LEINT32, T_LEINT64};
+
+/* Image Type for input and output format */
+enum {IT_UNKNOWN,
+#ifdef HAVE_MGCSFX_AUTO
+      IT_AUTO,
+#endif /* HAVE_MGCSFX_AUTO */
+      IT_PNM, IT_PPM, IT_PGM, IT_PBM,
+      IT_PNM_RAW, IT_PPM_RAW, IT_PGM_RAW, IT_PBM_RAW,
+      IT_PNM_ASCII, IT_PPM_ASCII, IT_PGM_ASCII, IT_PBM_ASCII,
+      IT_GIF, IT_JPEG, IT_TIFF, IT_JFIF, /* IT_PS, IT_COMPRESS,*/
+      IT_XBM, IT_XPM, IT_BMP, IT_SUNRAS, IT_IRIS, IT_XWD,
+      /* IT_TARGA, IT_FITS, IT_PM, IT_UTAHRLE, IT_PCX, IT_PDSVICAR, IT_IFF, */
+      IT_MAG, IT_MAKI, IT_PI, IT_PIC, IT_PIC2 /* , IT_PCD */};
+
+
+/*--------------------------------------------------------------------------*/
+void  mgcsfx_handler        PARM((int));
+void  mgcsfx_handler_setup  PARM((void));
+
+#ifdef USE_MGCSFX_PREPROCESSOR
+static char      *get_tmp_fname          PARM((void));
+static char      *make_preprocessed_file PARM((char *));
+#endif /* USE_MGCSFX_PREPROCESSOR */
+
+int   is_mgcsfx             PARM((char *, unsigned char *, int));
+
+char *mgcsfx_auto_input_com PARM((char *));
+
+
+static mgcsfxtab *free_mgcsfx PARM((mgcsfxtab *));
+static char      *fgettoken   PARM((FILE*, int));
+static int        string_fin  PARM((char *));
+static int        type_mgcsfx PARM((char *));
+static int        type_image  PARM((char *));
+
+static void       read_mgcsfx PARM((mgcsfxtab **, char *));
+static void       init_mgcsfx PARM((void));
+static mgcsfxtab *find_mgcsfx PARM((char *, unsigned char *, int));
+
+int   LoadMGCSFX            PARM((char *, PICINFO *));
+
+#ifdef SVR4
+typedef void Sigfunc(int);
+static Sigfunc   *xv_signal   PARM((int , Sigfunc *));
+#endif
+
+/*--------------------------------------------------------------------------*/
+mgcsfxtab *mgcsfx_table = NULL;
+int       mgcsfx_setup_flag = 0;
+
+int       nitem_mgcsfx = 0;
+int       desc_width = 0;
+
+int       max_offset_mgcsfx = 0;
+int       max_length_mgcsfx = 0;
+int       need_buf_size = 0;
+
+static char input_command_ex[1024];
+static int  input_command_ex_flag = 0;
+
+#ifdef USE_SIGCHLD
+static int  w_p_fail=0;
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+/***************************************************/
+void mgcsfx_handler(sig)
+     int sig;
+{
+  int pid, pst;
+
+#if defined(SYSV) || defined(SVR4)
+  sighold(sig);
+#else
+  sigblock(sigmask(sig));
+#endif
+
+#ifdef USE_SIGCHLD
+  if(w_p_fail == 1){
+    /* 
+     * At this point, process write to broken pipe.
+     * Probably external command was can't exec.
+     */
+    w_p_fail = 2;
+    pid = wait(&pst);
+  }
+#endif
+
+  return;
+
+  /* Quit(1); */ /*exit(1);*/
+}
+
+void mgcsfx_handler_setup()
+{
+#ifdef SVR4
+  xv_signal(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
+  xv_signal(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
+#else
+# ifdef SYSV
+  sigset(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
+  sigset(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
+# else
+  signal(SIGPIPE, (void (*)PARM((int))) mgcsfx_handler);
+  signal(SIGCHLD, (void (*)PARM((int))) mgcsfx_handler);
+# endif
+#endif
+}
+
+/***************************************************/
+#ifdef USE_MGCSFX_PREPROCESSOR
+static char *get_tmp_fname()
+{
+  static char tmp[MAXPATHLEN+1];
+
+#ifndef VMS
+  sprintf(tmp, "%s/xvmgcsfxXXXXXX",tmpdir);
+#else
+  /* sprintf(tmp, "Sys$Scratch:xvmgcsfxXXXXXX"); */
+  strcpy(tmp, "[]xvmgcsfxXXXXXX");
+#endif /* VMS */
+
+  mktemp(tmp);
+
+  return tmp;
+}
+#endif /* USE_MGCSFX_PREPROCESSOR */
+
+#ifdef USE_MGCSFX_PREPROCESSOR
+static char *make_preprocessed_file(fname)
+     char *fname;
+{
+  char buf[512];
+  char *tmp_name;
+
+  tmp_name = get_tmp_fname();
+
+#ifndef VMS
+  sprintf(buf,"%s %s > %s", MGCSFX_PREPROCESSOR, fname, tmp_name);
+#else /* it IS VMS */
+  sprintf(buf,"%s %s > %s", MGCSFX_PREPROCESSOR, fname, tmp_name);/* realy OK? */
+#endif
+
+  SetISTR(ISTR_INFO, "Preprocessing '%s'...", BaseName(fname));
+#ifndef VMS
+  if (system(buf)) {
+#else
+  if (!system(buf)) {
+#endif
+    SetISTR(ISTR_INFO, "Unable to preprocess '%s'.", BaseName(fname));
+    Warning();
+    return NULL;
+  }
+
+  return tmp_name;
+}
+#endif /* USE_MGCSFX_PREPROCESSOR */
+
+/***************************************************/
+/* $BG'<1$G$-$k%U%!%$%k$+$I$&$+D4$Y$k(B */
+int is_mgcsfx(fname,buffer,size)
+     char          *fname;
+     unsigned char *buffer;
+     int            size;
+{
+  mgcsfxtab          *magic;
+  FILE               *fp;
+  unsigned char      *buf;
+  int                 s;
+
+  if(nomgcsfx){
+    return 0;
+  }else{
+    if(size < need_buf_size){
+      if((buf = (unsigned char *)calloc(need_buf_size, sizeof(char)))==NULL){
+	fprintf(stderr,"Can't allocate memory\n");
+	return 0;
+      }
+      if((fp = xv_fopen(fname, "r"))==NULL){
+	fprintf(stderr,"Can't open file %s\n", fname);
+	free(buf);
+	return 0;
+      }
+      s = fread(buf, 1, need_buf_size, fp);
+      if((magic = find_mgcsfx(fname, buf, s))!=NULL &&
+	magic->input_command != NULL){
+	free(buf);
+	fclose(fp);
+	return 1;
+      }else{
+	free(buf);
+	fclose(fp);
+	return 0;
+      }
+    }else{
+      if((magic = find_mgcsfx(fname, buffer, size))!=NULL &&
+	magic->input_command != NULL){
+	return 1;
+      }else{
+	return 0;
+      }
+    }
+  }
+}
+
+#ifdef HAVE_MGCSFX_AUTO
+char *mgcsfx_auto_input_com(fname)
+char *fname;
+{
+  static char command[1024];
+  mgcsfxtab       *magic;
+  char *ptr;
+
+  FILE *fp;
+  unsigned char *buf;
+  int                 s;
+
+  if((buf = (unsigned char *)calloc(need_buf_size, sizeof(char)))==NULL){
+    fprintf(stderr,"Can't allocate memory\n");
+    return NULL;
+  }
+  if((fp = xv_fopen(fname, "r"))==NULL){
+    fprintf(stderr,"Can't open file %s\n", fname);
+    free(buf);
+    return NULL;
+  }
+  s = fread(buf, 1, need_buf_size, fp);
+  if((magic = find_mgcsfx(fname, buf, s))!=NULL &&
+     magic->input_command != NULL && magic->input_image_type == IT_AUTO){
+    if (ptr = strstr(magic->input_command, "%s")){
+      sprintf(command, magic->input_command, fname);
+    }else{
+      sprintf(command, "%s < %s", magic->input_command, fname);
+    }
+    free(buf);
+    fclose(fp);
+    return command;
+  }else{
+    free(buf);
+    fclose(fp);
+    return NULL;
+  }
+}
+#endif /* HAVE_MGCSFX_AUTO */
+
+/***************************************************/
+static mgcsfxtab *free_mgcsfx(m)
+     mgcsfxtab *m;
+{
+  mgcsfxtab *next;
+  if(m == NULL) return NULL;
+  next = m->next;
+  if(m->description != NULL) free(m->description);
+  if(m->mgcsfx_type == T_MAGIC && m->dt.string_data != NULL)
+    free(m->dt.string_data);
+  if(m->suffix != NULL) free(m->suffix);
+  if(m->input_command != NULL) free(m->input_command);
+  if(m->output_command != NULL) free(m->output_command);
+  free(m);
+  return next;
+}
+
+
+
+/***************************************************/
+/* char c $B$^$?$O(B '\n' $B$G6h@Z$i$l$?J8;zNs$r<h$j=P$9(B
+ *  $B%U%!%$%k$N:G8e$^$GFI$s$@$i(B NULL $B$rJV$9(B
+ *  $B2~9T$J$i2~9T$rJV$9(B($B2~9T$G6h@Z$i$l$?>l9g$O(B '\n' $B$r%9%H%j!<%`$KLa$9(B)
+ */
+#define CBUF_SIZE 1024
+static char *fgettoken(fp, c)
+     FILE *fp;
+     int   c; /* Real mean is char */
+{
+  char *buf;
+  char *buf2;
+  int   i;
+  int   n=0;
+  int   max=0;
+  int   count = 1;
+
+  char *ss;
+  char *se;
+
+  if((buf = (char *)calloc(CBUF_SIZE, sizeof(char))) == NULL){
+    fprintf(stderr,"Can't allocate memory\n");
+    exit(1);
+  }
+  max = CBUF_SIZE;
+  count = 2;
+
+  do{
+    if((i = getc(fp))==EOF || i == '\n' || i == c) break;
+
+    buf[n] = (char)i;
+
+    if(i != c && n == max-1){
+      buf[max] = '\0';
+      if((buf2 = (char *)calloc(CBUF_SIZE * count, sizeof(char))) == NULL){
+	fprintf(stderr,"Can't allocate memory\n");
+	exit(1);
+      }
+      strcpy(buf2, buf);
+      free(buf);
+      buf = buf2;
+      buf2 = NULL;
+      max = CBUF_SIZE * count;
+      count++;
+    }
+
+    n++;
+  }while(i != c);
+
+  buf[n] = '\0';
+
+  /* $B:G=i$H:G8e$N6uGrJ8;z$r@Z$j5M$a$k(B */
+  ss = buf + strspn(buf, " \t\b\r\n"); /* find the first non-white space */
+  se = buf + strlen(buf);              /* find the end of the string */
+
+  /* strip from the end first */
+  while ((--se >= ss) && strchr(" \t\b\r\n", *se));
+  *(++se) = '\0';
+
+  if(i == EOF && strlen(ss)==0){        /* EOF $B$J$i(B NULL $B$rJV$9(B */
+    free(buf);
+    return NULL;
+  }else if(i == '\n' && strlen(ss)==0){ /* $B2~9T$N$_$N>l9g(B */
+    static char cr[2] = {'\n','\0'};
+    buf2 = strdup(cr);
+    free(buf);
+    return buf2;
+  }else{                                /* $BDL>o(B */
+    if(i == '\n' && strlen(ss)>0) ungetc(i,fp);
+    buf2 = strdup(ss);
+    free(buf);
+    return buf2;
+  }
+}
+
+
+
+/***************************************************/
+/* $BJ8;zNsCf$NFC<l5-9f(B(\)$B$r@5$7$$$b$N$K$9$k(B
+ */
+static int string_fin(string_data)
+     char *string_data;
+{
+  char *cptr;
+  char *ptr;
+  int   length;
+
+  /* Change all the \xx sequences into a single character */
+  cptr = string_data;
+
+  for (ptr = cptr; *ptr; ++ptr){
+    if (*ptr != '\\'){
+      *cptr = *ptr;
+    }else{
+      switch (*(++ptr)){
+#if defined(__STDC__)
+      case 'a': /* Audible alert (terminal bell) */
+	*cptr = '\007';
+	break;
+      case '?': /* Question mark */
+	*cptr = '\?';
+	break;
+#endif
+      case 'b': /* Backspace */
+	*cptr = '\b';
+	break;
+      case 'f': /* Form feed */
+	*cptr = '\f';
+	break;
+      case 'n': /* Line feed */
+	*cptr = '\n';
+	break;
+      case 'r': /* Carriage return */
+	*cptr = '\r';
+	break;
+      case 't': /* Horizontal tab */
+	*cptr = '\t';
+	break;
+      case 'v': /* Vertical tab */
+	*cptr = '\v';
+	break;
+      case '\\': /* Backslash */
+	*cptr = '\\';
+	break;
+      case '\'': /* Single quote */
+	*cptr = '\'';
+	break;
+      case '"': /* Double quote */
+	*cptr = '\"';
+	break;
+      case '0': /* Octal constant  \0 ... \377 */
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+	if ((ptr[1] >= '0') && (ptr[1] <= '7')){
+	  if ((ptr[2] >= '0') && (ptr[2] <= '7')){ /* \000 ...\377 */
+	    *cptr = ((*ptr - '0') * 64) +((ptr[1] - '0') * 8) +(ptr[1] - '0');
+	    ptr += 2;
+	  }else{ /* \00 ...\77 */
+	    *cptr = ((*ptr - '0') * 8) + (ptr[1] - '0');
+	    ++ptr;
+	  }
+	}else{ /* \0 ...\7 */
+	  *cptr = *ptr - '0';
+	}
+	break;
+      case 'x': /* Hexadecimal constant  \x0 .. \xff */
+	if (isxdigit (ptr[1])){
+	  *cptr = 0;
+	  while (isxdigit (*(++ptr)))
+	    *cptr = (*cptr * 16) +
+	      (*ptr > '9' ? tolower (*ptr) - ('a' - 10) : *ptr - '0');
+	  --ptr;
+	  break;
+	}
+      default:
+	/*  *(cptr++) = '\\';  No use for treat '\z' as 'z' */
+	*cptr = *ptr;
+	break;
+      }
+    }
+    ++cptr;
+  }
+  *cptr = '\0';
+  length = cptr - string_data;
+  return length;
+}
+
+/***************************************************/
+static int type_mgcsfx(str)
+     char *str;
+{
+  if(str == NULL){
+    return T_UNKNOWN;
+  }else if(!strcmp(str, "magic")   || !strcmp(str, "MAGIC")){
+    return T_MAGIC;
+  }else if(!strcmp(str, "string")  || !strcmp(str, "STRING")){
+    return T_MAGIC;
+  }else if(!strcmp(str, "suffix")  || !strcmp(str, "SUFFIX")){
+    return T_SUFFIX;
+  }else if(!strcmp(str, "beint16") || !strcmp(str, "BEINT16")){
+    return T_BEINT16;
+  }else if(!strcmp(str, "leint16") || !strcmp(str, "LEINT16")){
+    return T_LEINT16;
+  }else if(!strcmp(str, "beint32") || !strcmp(str, "BEINT32")){
+    return T_BEINT32;
+  }else if(!strcmp(str, "leint32") || !strcmp(str, "LEINT32")){
+    return T_LEINT32;
+  }else{
+    return T_UNKNOWN;
+  }
+}
+
+/***************************************************/
+static int type_image(str)
+     char *str;
+{
+  if(str == NULL){
+    return IT_UNKNOWN;
+#ifdef HAVE_MGCSFX_AUTO
+  }else if(!strcmp(str, "auto") || !strcmp(str, "AUTO")){
+    return IT_AUTO;
+#endif /* HAVE_MGCSFX_AUTO */
+  }else if(!strcmp(str, "pnm") || !strcmp(str, "PNM")){
+    return IT_PNM;
+  }else if(!strcmp(str, "ppm") || !strcmp(str, "PPM")){
+    return IT_PPM;
+  }else if(!strcmp(str, "pgm") || !strcmp(str, "PGM")){
+    return IT_PGM;
+  }else if(!strcmp(str, "pbm") || !strcmp(str, "PBM")){
+    return IT_PBM;
+  }else if(!strcmp(str, "pnm_raw") || !strcmp(str, "PNM_RAW")){
+    return IT_PNM_RAW;
+  }else if(!strcmp(str, "ppm_raw") || !strcmp(str, "PPM_RAW")){
+    return IT_PPM_RAW;
+  }else if(!strcmp(str, "pgm_raw") || !strcmp(str, "PGM_RAW")){
+    return IT_PGM_RAW;
+  }else if(!strcmp(str, "pbm_raw") || !strcmp(str, "PBM_RAW")){
+    return IT_PBM_RAW;
+  }else if(!strcmp(str, "pnm_ascii") || !strcmp(str, "PNM_ASCII")){
+    return IT_PNM_ASCII;
+  }else if(!strcmp(str, "ppm_ascii") || !strcmp(str, "PPM_ASCII")){
+    return IT_PPM_ASCII;
+  }else if(!strcmp(str, "pgm_ascii") || !strcmp(str, "PGM_ASCII")){
+    return IT_PGM_ASCII;
+  }else if(!strcmp(str, "pbm_ascii") || !strcmp(str, "PBM_ASCII")){
+    return IT_PBM_ASCII;
+
+  }else if(!strcmp(str, "gif")  || !strcmp(str, "GIF")){
+    return IT_GIF;
+  }else if(!strcmp(str, "jpeg") || !strcmp(str, "JPEG")){
+    return IT_JPEG;
+  }else if(!strcmp(str, "tiff") || !strcmp(str, "TIFF")){
+    return IT_TIFF;
+  }else if(!strcmp(str, "jfif") || !strcmp(str, "JFIF")){
+    return IT_JFIF;
+
+  }else if(!strcmp(str, "xbm") || !strcmp(str, "XBM")){
+    return IT_XBM;
+  }else if(!strcmp(str, "xpm") || !strcmp(str, "XPM")){
+    return IT_XPM;
+  }else if(!strcmp(str, "bmp") || !strcmp(str, "BMP")){
+    return IT_BMP;
+  }else if(!strcmp(str, "sunras") || !strcmp(str, "SUNRAS")){
+    return IT_SUNRAS;
+  }else if(!strcmp(str, "iris") || !strcmp(str, "IRIS")){
+    return IT_IRIS;
+  }else if(!strcmp(str, "xwd") || !strcmp(str, "XWD")){
+    return IT_XWD;
+
+  }else if(!strcmp(str, "mag") || !strcmp(str, "MAG")){
+    return IT_MAG;
+  }else if(!strcmp(str, "maki") || !strcmp(str, "MAKI")){
+    return IT_MAKI;
+  }else if(!strcmp(str, "pi") || !strcmp(str, "PI")){
+    return IT_PI;
+  }else if(!strcmp(str, "pic") || !strcmp(str, "PIC")){
+    return IT_PIC;
+  }else if(!strcmp(str, "pic2") || !strcmp(str, "PIC2")){
+    return IT_PIC2;
+
+  }else{
+    return IT_UNKNOWN;
+  }
+}
+
+/*--------------------------------------------------------------------------*/
+#define mgcsfx_read_error(FILENAME, LINENUM, AFTERFIELD) \
+fprintf (stderr,\
+"%s: line %d: missing fields of %s field\n",\
+FILENAME, LINENUM, AFTERFIELD);
+
+#define magic_type_error(FILENAME, LINENUM, MAGICNUMBER) \
+fprintf (stderr,\
+"%s: line %d: invalid <magic type> field '%s'\n",\
+FILENAME, LINENUM, MAGICNUMBER);
+/*--------------------------------------------------------------------------*/
+
+/***************************************************/
+static void read_mgcsfx(mgcsfx_table, fname)
+     mgcsfxtab **mgcsfx_table;
+     char       *fname;
+{
+  FILE *fp;
+  char *s;
+  int   line_number = 0;
+  int   str_len;
+  int   reach_end;
+  int   def_err;
+
+  char *description;
+  char *mgcsfx_type;
+  char *offset;
+  char *magic;
+  char *suffix;
+  char *i_img;
+  char *i_com;
+  char *o_img;
+  char *o_com;
+
+  mgcsfxtab  *ent;
+  mgcsfxtab **entry;
+
+
+  if((fp=fopen(fname, "r"))==NULL){
+    /* fprintf(stderr, "Can't open %s\n",fname); */
+    return;
+  }
+
+  while(1){
+retry:
+    line_number++;
+    def_err = 0;
+
+    s= NULL;
+    description = mgcsfx_type = offset = magic = suffix
+      = i_img = i_com = o_img = o_com = NULL;
+    reach_end = 0;
+
+    if((s = fgettoken(fp, ':'))==NULL) break; /* EOF $B$J$i=*$j(B */
+    if(*s == '#'){/* $B@hF,$,(B '#' $B$J$iFI$_$H$P$9(B */
+      while((s = fgettoken(fp, '\n'))!=NULL){
+	if(*s == '\n'){
+	  free(s);
+	  goto retry;
+	}
+	free(s);
+      }
+      if(s == NULL) break;
+    }else if(*s == '\n'){/* $B6u9T$OL5;k(B */
+      free(s);
+      goto retry;
+    }
+    if(strlen(s) > 0) description = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "data type");
+      goto next;
+    }
+    if(strlen(s) > 0) mgcsfx_type = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "byte offset");
+      goto next;
+    }
+    if(strlen(s) > 0) offset = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "magic number");
+      goto next;
+    }
+    if(strlen(s) > 0) magic = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "suffix");
+      goto next;
+    }
+    if(strlen(s) > 0) suffix = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "input image type");
+      goto next;
+    }
+    if(strlen(s) > 0) i_img = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "input command");
+      goto next;
+    }
+    if(strlen(s) > 0) i_com = s;
+    else free(s);
+
+    if((s = fgettoken(fp, ':'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+      if(s != NULL) free(s);
+      mgcsfx_read_error(fname, line_number, "output image type");
+      goto next;
+    }
+    if(strlen(s) > 0) o_img = s;
+    else free(s);
+
+    if((s = fgettoken(fp, '#'))==NULL || *s == '\n'){/* $B2?$b$J$$$J$i@_Dj%_%9(B */
+    /*
+      free(s);
+      mgcsfx_read_error(fname, line_number, "output command");
+      goto next;
+     */
+      if(s != NULL){
+	*s = '\0';
+	reach_end = 1;
+      }
+    }
+    if(s != NULL){
+      if(strlen(s) > 0) o_com = s;
+      else free(s);
+    }
+
+    if(reach_end == 0){
+      while((s = fgettoken(fp, '\n'))!=NULL){/* $B9TKv$N%4%_$r<N$F$k(B */
+	if(*s == '\n'){
+	  free(s);
+	  break; /* goto next; */
+	}
+	free(s);
+      }
+    }else{
+      reach_end = 0;
+    }
+
+
+
+    /* --------------------------------------------------------------------- */
+next:;
+
+    if(DEBUG){
+      fprintf(stderr,"Read:  file %s:  line %d.\n", fname, line_number);
+      fprintf(stderr,"Description : %s\n",
+	      description ? description : "-- error --");
+      fprintf(stderr,"Type        : %s\n",
+	      mgcsfx_type ? mgcsfx_type : "-- error --");
+      fprintf(stderr,"Offset      : %s\n", offset ? offset : "--+--");
+      fprintf(stderr,"Magic       : %s\n", magic ? magic : "--+--");
+      fprintf(stderr,"Suffix      : %s\n", suffix ? suffix : "--+--");
+      fprintf(stderr,"i Image     : %s\n", i_img ? i_img : "--+--");
+      fprintf(stderr,"i Command   : %s\n", i_com ? i_com : "--+--");
+      fprintf(stderr,"o Image     : %s\n", o_img ? o_img : "--+--");
+      fprintf(stderr,"o Command   : %s\n", o_com ? o_com : "--+--");
+      fprintf(stderr,"\n");
+    }
+
+    /* create mgcsfxtab */
+    if((ent = (mgcsfxtab *) malloc (sizeof (mgcsfxtab)))==NULL){
+      fprintf(stderr,"Can't allocate memory\n");
+      exit(1);
+    }
+    ent->next              = NULL;
+    ent->description       = NULL;
+    ent->mgcsfx_type       = T_UNKNOWN;
+    ent->offset            = 0;
+    ent->string_len        = 0;
+    ent->suffix            = NULL;
+    ent->input_image_type  = IT_UNKNOWN;
+    ent->input_command     = NULL;
+    ent->output_image_type = IT_UNKNOWN;
+    ent->output_command    = NULL;
+
+    if(description != NULL){
+      ent->description = description;
+      description = NULL;
+    }else{
+      fprintf (stderr,"%s: line %d: undefined <description> field.\n",
+	       fname, line_number);
+      def_err ++;
+      goto next2;
+    }
+
+    if(mgcsfx_type == NULL){
+      fprintf (stderr,"%s: line %d: undefined <mgcsfx type> field.\n",
+	       fname, line_number);
+      def_err ++;
+      goto next2;
+    }
+    ent->mgcsfx_type = type_mgcsfx(mgcsfx_type);
+    switch(ent->mgcsfx_type){
+    case T_SUFFIX:
+      if(suffix == NULL){
+	fprintf (stderr,
+              "%s: line %d: conflict definition : undefined <suffix> field.\n",
+		 fname, line_number);
+	def_err ++;
+	goto next2;
+      }
+      break;
+    case T_BEINT16:
+      if (sscanf(magic, "%hi", &(ent->dt.int16_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+    case T_LEINT16:
+      if (sscanf(magic, "%hi", &(ent->dt.int16_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+#ifdef ARCHITECTURE64
+    case T_BEINT32:
+      if (sscanf(magic, "%i", &(ent->dt.int32_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+    case T_LEINT32:
+      if (sscanf(magic, "%i", &(ent->dt.int32_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+#else
+    case T_BEINT32:
+      if (sscanf(magic, "%li", &(ent->dt.int32_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+    case T_LEINT32:
+      if (sscanf(magic, "%li", &(ent->dt.int32_data)) != 1){
+	magic_type_error(fname, line_number, magic);
+	def_err ++;
+	goto next2;
+      }
+      break;
+#endif /* ARCHITECTURE64 */
+    case T_MAGIC:
+      if(magic == NULL){
+	fprintf (stderr,"%s: line %d: undefined <magic> field.\n",
+		 fname, line_number);
+	def_err ++;
+	goto next2;
+      }
+      if((str_len = string_fin(magic))<=0){
+	fprintf (stderr,"%s: line %d: invalid <magic> field.\n",
+		 fname, line_number);
+	def_err ++;
+	goto next2;
+      }
+
+      ent->string_len = str_len;
+      if((ent->dt.string_data = (char *)malloc(str_len + 1))==NULL){
+	fprintf(stderr,"Can't allocate memory\n");
+	exit(1);
+      }
+      memcpy(ent->dt.string_data, magic, str_len + 1);
+      break;
+    case T_UNKNOWN:
+    default:
+      fprintf (stderr,"%s: line %d: invalid <mgcsfx type> field.\n",
+	       fname, line_number);
+      def_err ++;
+      goto next2;
+      break;
+    };
+
+
+    if(offset == NULL){
+      if(ent->mgcsfx_type == T_MAGIC ||
+	 ent->mgcsfx_type == T_BEINT16 ||
+	 ent->mgcsfx_type == T_LEINT16 ||
+	 ent->mgcsfx_type == T_BEINT32 ||
+	 ent->mgcsfx_type == T_LEINT32){
+	fprintf (stderr,
+	      "%s: line %d: conflict definition : undefined <offset> field.\n",
+		 fname, line_number);
+	def_err ++;
+	goto next2;
+      }
+    }else{
+      if(ent->mgcsfx_type != T_SUFFIX) sscanf(offset, "%i", &(ent->offset));
+    }
+
+    if(suffix != NULL){
+      ent->suffix = suffix;
+      suffix = NULL;
+    }
+
+    if((i_img == NULL && i_com == NULL) && (o_img == NULL || o_com == NULL)){
+      fprintf (stderr,"%s: line %d: invalid definition.\n",
+	       fname, line_number);
+      def_err ++;
+      goto next2;
+    }
+    if((o_img == NULL && o_com == NULL) && (i_img == NULL || i_com == NULL)){
+      fprintf (stderr,"%s: line %d: invalid definition.\n",
+	       fname, line_number);
+      def_err ++;
+      goto next2;
+    }
+
+    if(i_img != NULL && i_com != NULL){
+      ent->input_image_type  = type_image(i_img);
+      ent->input_command = i_com;
+      i_com = NULL;
+    }else{
+      ent->input_image_type  = IT_UNKNOWN;
+      ent->input_command = NULL;
+    }
+
+    if(o_img != NULL && o_com != NULL){
+      ent->output_image_type = type_image(o_img);
+      ent->output_command = o_com;
+      o_com = NULL;
+    }else{
+      ent->output_image_type = IT_UNKNOWN;
+      ent->output_command = NULL;
+    }
+    /* end of create mgcsfxtab */
+
+
+next2:;
+
+    if(def_err != 0 || DEBUG){
+      fprintf(stderr,"Description : %s \t -> %s\n",
+	      description ? description : "--+--",
+	      ent->description ? ent->description : "-- error --");
+      fprintf(stderr,"Type        : %s \t -> %d\n",
+	      mgcsfx_type ? mgcsfx_type : "--+--",
+	      ent->mgcsfx_type);
+      fprintf(stderr,"Offset      : %s \t -> %d\n",
+	      offset ? offset : "--+--",
+	      ent->offset);
+
+      fprintf(stderr,"Magic       : %s", magic ? magic : "--+--");
+      switch(ent->mgcsfx_type){
+      case T_BEINT16:
+      case T_LEINT16:
+	fprintf(stderr," \t -> %d\n",ent->dt.int16_data);
+	break;
+      case T_BEINT32:
+      case T_LEINT32:
+	fprintf(stderr," \t -> %d\n",ent->dt.int32_data);
+	break;
+      case T_MAGIC:
+	fprintf(stderr," \t -> %s\n",ent->dt.string_data);
+	break;
+      default:
+	fprintf(stderr,"\n");
+	break;
+      };
+
+      fprintf(stderr,"Suffix      : %s \t -> %s\n",
+	      suffix ? suffix : "--+--",
+	      ent->suffix ? ent->suffix : "--+--");
+      fprintf(stderr,"i Image     : %s \t -> %d\n",
+	      i_img ? i_img : "--+--",
+	      ent->input_image_type);
+      fprintf(stderr,"i Command   : %s \t -> %s\n",
+	      i_com ? i_com : "--+--",
+	      ent->input_command ? ent->input_command : "--+--");
+      fprintf(stderr,"o Image     : %s \t -> %d\n",
+	      o_img ? o_img : "--+--",
+	      ent->output_image_type);
+      fprintf(stderr,"o Command   : %s \t -> %s\n",
+	      o_com ? o_com : "--+--",
+	      ent->output_command ? ent->output_command : "--+--");
+      fprintf(stderr,"\n");
+    }
+
+    if(description != NULL) free(description);
+    if(mgcsfx_type != NULL) free(mgcsfx_type);
+    if(offset      != NULL) free(offset);
+    if(magic       != NULL) free(magic);
+    if(suffix      != NULL) free(suffix);
+    if(i_img       != NULL) free(i_img);
+    if(i_com       != NULL) free(i_com);
+    if(o_img       != NULL) free(o_img);
+    if(o_com       != NULL) free(o_com);
+
+
+    if(def_err != 0) goto next3;
+
+    /* Override any existing entry for this magic number/file type */
+    for(entry = mgcsfx_table; *entry; entry = &((*entry)->next)){
+      if((ent->mgcsfx_type == (*entry)->mgcsfx_type) &&
+	 (
+	   ((ent->offset == (*entry)->offset) &&
+	    (((ent->mgcsfx_type == T_BEINT16) &&
+	      (ent->dt.int16_data == (*entry)->dt.int16_data)) ||
+	     ((ent->mgcsfx_type == T_BEINT32) &&
+	      (ent->dt.int32_data == (*entry)->dt.int32_data)) ||
+	     ((ent->mgcsfx_type == T_LEINT16) &&
+	      (ent->dt.int16_data == (*entry)->dt.int16_data)) ||
+	     ((ent->mgcsfx_type == T_LEINT32) &&
+	      (ent->dt.int32_data == (*entry)->dt.int32_data)) ||
+
+	     ((ent->mgcsfx_type == T_MAGIC) &&
+	      !memcmp(ent->dt.string_data, (*entry)->dt.string_data,
+		      ent->string_len))
+	      )) ||
+	  ((ent->mgcsfx_type == T_SUFFIX) &&
+	   !strcmp(ent->suffix, (*entry)->suffix))
+	 )
+	){
+
+	free ((*entry)->description);
+	(*entry)->description = ent->description;
+	ent->description = NULL;
+
+	(*entry)->input_image_type = ent->input_image_type;
+	if ((*entry)->input_command) free ((*entry)->input_command);
+	(*entry)->input_command = ent->input_command;
+	ent->input_command = NULL;
+
+	(*entry)->output_image_type = ent->output_image_type;
+	if ((*entry)->output_command) free ((*entry)->output_command);
+	(*entry)->output_command = ent->output_command;
+	ent->output_command = NULL;
+
+	free_mgcsfx(ent);
+	break;
+      }
+    }
+    if (!*entry){
+      ent->next = NULL;
+      *entry = ent;
+    }
+
+    /* if(s == NULL) break; */
+next3:;
+    if(def_err != 0) free_mgcsfx(ent);
+  } /* end of while(1) */
+}
+
+
+/***************************************************/
+/* $B%^%8%C%/%J%s%P!<Dj5A%U%!%$%kL>$rF@$F!"FI$_9~$^$;$k(B */
+static void init_mgcsfx ()
+{
+  extern char *getenv ();
+
+  char      *home_dir;
+  char       fname[1024];
+  mgcsfxtab *entry;
+  int        len;
+  struct stat st;
+
+#ifdef USE_MGCSFX_PREPROCESSOR
+  char      *pp_fname;
+#endif /* USE_MGCSFX_PREPROCESSOR */
+
+  mgcsfx_table = NULL;
+
+  mgcsfx_handler_setup();
+
+  if(nomgcsfx){
+    mgcsfx_setup_flag = 1;
+    nitem_mgcsfx = 0;
+    desc_width = 0;
+  }else{
+    sprintf (fname, "%s/%s", MGCSFXDIR, MGCSFX_SITE_RC);
+    if(stat(fname, &st) == 0 && S_ISREG(st.st_mode)){
+      /* Read the site MagicSuffix table into a linked list */
+#ifdef USE_MGCSFX_PREPROCESSOR
+      if((pp_fname = make_preprocessed_file(fname)) != NULL){
+	read_mgcsfx (&mgcsfx_table, pp_fname);
+      }
+      unlink(pp_fname);
+#else
+      read_mgcsfx (&mgcsfx_table, fname);
+#endif /* USE_MGCSFX_PREPROCESSOR */
+    }
+
+    /* Read the personal MgcSfx table into the list overriding site entries */
+    if (home_dir = getenv ("HOME")){
+      sprintf (fname, "%s/%s", home_dir, MGCSFX_RC);
+      if(stat(fname, &st) == 0 && S_ISREG(st.st_mode)){
+#ifdef USE_MGCSFX_PREPROCESSOR
+	if((pp_fname = make_preprocessed_file(fname)) != NULL){
+	  read_mgcsfx (&mgcsfx_table, pp_fname);
+	}
+	unlink(pp_fname);
+#else
+	read_mgcsfx (&mgcsfx_table, fname);
+#endif /* USE_MGCSFX_PREPROCESSOR */
+      }
+    }
+
+    mgcsfx_setup_flag = 1;
+
+    nitem_mgcsfx = 0;
+    desc_width = 0;
+    for (entry = mgcsfx_table; entry; entry = entry->next){
+      nitem_mgcsfx ++;
+      len = strlen(entry->description);
+      if(len > desc_width) desc_width = len;
+      if(max_offset_mgcsfx < entry->offset) max_offset_mgcsfx = entry->offset;
+      if(entry->mgcsfx_type == T_MAGIC &&
+	 max_length_mgcsfx < entry->string_len)
+	max_length_mgcsfx = entry->string_len;
+    }
+    if(max_length_mgcsfx == 0) max_length_mgcsfx = sizeof(int32);
+    need_buf_size = max_offset_mgcsfx + max_length_mgcsfx + 1;/* 1 is safety */
+  }
+}
+
+/***************************************************/
+/* $B%^%8%C%/%J%s%P!<$rD4$Y$F!"Dj5A$7$F$$$k%F!<%V%k$r8!:w$9$k(B 
+   $B%^%8%C%/%J%s%P!<$N%F!<%V%k$rFI$_9~$s$G$$$J$$$J$iFI$_9~$`(B */
+static mgcsfxtab *find_mgcsfx (fname, buffer, buffer_size)
+     char           *fname;
+     unsigned char  *buffer;
+     int             buffer_size;
+{
+  mgcsfxtab *entry;
+  int16      buf16;
+  int32      buf32;
+  char      *suf;
+
+  if (mgcsfx_setup_flag == 0) init_mgcsfx ();
+
+  for (entry = mgcsfx_table; entry; entry = entry->next){
+    switch (entry->mgcsfx_type){
+    case T_BEINT16:
+      if ((buffer_size > 0) &&
+	  ((entry->offset + sizeof (int16)) <= buffer_size)){
+	buf16 = ((char)*(buffer + entry->offset) << 8) |
+	  ((char)*(buffer + entry->offset +1));
+	if(entry->dt.int16_data == buf16) return entry;
+      }
+      break;
+    case T_LEINT16:
+      if ((buffer_size > 0) &&
+	  ((entry->offset + sizeof (int16)) <= buffer_size)){
+	buf16 = ((char)*(buffer + entry->offset +1) << 8) |
+	  ((char)*(buffer + entry->offset));
+	if(entry->dt.int16_data == buf16) return entry;
+      }
+      break;
+    case T_BEINT32:
+      if ((buffer_size > 0) &&
+	  ((entry->offset + sizeof (int32)) <= buffer_size)){
+	buf32 = ((char)*(buffer + entry->offset) << 24) |
+	  ((char)*(buffer + entry->offset +1) << 16) |
+	  ((char)*(buffer + entry->offset +2) << 8) |
+	  ((char)*(buffer + entry->offset +3));
+	if(entry->dt.int32_data == buf32) return entry;
+      }
+      break;
+    case T_LEINT32:
+      if ((buffer_size > 0) &&
+	  ((entry->offset + sizeof (int32)) <= buffer_size)){
+	buf32 = ((char)*(buffer + entry->offset +3) << 24) |
+	  ((char)*(buffer + entry->offset +2) << 16) |
+	  ((char)*(buffer + entry->offset +1) << 8) |
+	  ((char)*(buffer + entry->offset));
+	if(entry->dt.int32_data == buf32) return entry;
+      }
+      break;
+    case T_MAGIC:
+      if ((buffer_size > 0) &&
+	  ((entry->offset + entry->string_len)
+	   <= buffer_size) &&
+	  !memcmp (entry->dt.string_data, buffer + entry->offset,
+		   entry->string_len ))
+	return entry;
+      break;
+    case T_SUFFIX:
+      if(fname != NULL && entry->suffix != NULL){
+	if(strlen(fname) - strlen(entry->suffix) > 0){
+	  suf = fname + (strlen(fname) - strlen(entry->suffix));
+	  if(!strcmp(suf, entry->suffix)) return entry;
+	}
+      }
+      break;
+    case T_UNKNOWN:
+    default:
+      return NULL;
+      break;
+    }
+  }
+  return NULL;
+}
+
+
+
+
+
+/***************************************************/
+/* $B%^%8%C%/%J%s%P!<$NDj5A$rD4$Y$F!"$=$l$K$"$o$;$?%3%^%s%I$r<B9T$9$k(B */
+/* if OK return 1, else if ERROR return 0 */
+int
+LoadMGCSFX(file_name, pinfo)
+     char    *file_name;
+     PICINFO *pinfo;
+{
+  unsigned char *buffer;
+  int            size;
+  mgcsfxtab     *magic;
+  mgcsfxtab     *magic_cur;
+  char          *ptr;
+  char           command[1024];
+  int            fd[2];
+  int            pid;
+  int            file;
+  char          *fname;
+  int            rv;
+  int            pst;
+
+  int            i_it;
+  char          *i_com;
+
+  WaitCursor();
+
+  fname = file_name;
+  if((file = open (fname, O_RDONLY))<0){
+    SetISTR(ISTR_WARNING, "Can't open %s",fname);
+    return 0;
+  }
+
+  if((buffer = (unsigned char *)calloc(need_buf_size, sizeof(char))) == NULL){
+    SetISTR(ISTR_WARNING, "Can't allocate memory");
+    return 0;
+  }
+
+  magic_cur = NULL;
+
+/*  do{ */
+    size = read (file, buffer, need_buf_size);
+
+    if (lseek (file, 0L, 0) < 0){ /* can't seek pipe !! */
+      fprintf (stderr, "Can't lseek %s\n", file_name);
+      close(file);
+      return 0;
+    }
+
+    magic = find_mgcsfx (fname, buffer, size);
+
+    if ((magic != NULL && magic->input_command) ||
+        (magic == NULL && mgcsfx && input_command_ex_flag)){
+
+      if(magic == NULL){
+	if (fname != NULL && (ptr = strstr(input_command_ex, "%s"))){
+	  sprintf (command, input_command_ex, fname);
+	}else{
+	  strcpy (command, input_command_ex);
+	  fname=NULL;
+	}
+      }else{
+	/* Use stdin or give file name */
+	if (fname != NULL && (ptr = strstr(magic->input_command, "%s"))){
+	  sprintf (command, magic->input_command, fname);
+	}else{
+	  strcpy (command, magic->input_command);
+	  fname=NULL;
+	}
+      }
+
+      /* Do the pipe/fork/exec here */
+      if (pipe (fd) < 0){
+	fprintf (stderr, "Can't pipe : %s\n", file_name);
+	close(file);
+	return 0;
+      }
+
+      if ((pid = vfork ()) < 0){
+	fprintf (stderr, "Can't vfork : %s\n", file_name);
+	close (fd[0]);
+	close (fd[1]);
+	close(file);
+	return 0;
+      }
+
+      if (!pid){
+	 close(0);
+	if (fname == NULL || (open ("/dev/null", O_RDONLY) < 0)){
+	   dup(file);
+	}
+	 close(file);
+	 close(1);
+	 dup(fd[1]);
+	 close(2);
+	 open("/dev/null", O_WRONLY);
+	 close(fd[0]);
+	 execl("/bin/sh", "/bin/sh", "-c", command, 0);
+	_exit(127);
+      }
+
+      close (fd[1]);
+      dup2(fd[0], file);
+      close (fd[0]);
+      fname = NULL;
+      magic_cur = magic;
+    }
+/*  } while(magic != NULL); */
+
+  free(buffer);
+
+  if(magic_cur == NULL && mgcsfx && input_command_ex_flag){
+    i_it  = IT_PNM;
+    i_com = input_command_ex;
+  }else{
+    i_it  = magic_cur->input_image_type;
+    i_com = magic_cur->input_command;
+  }
+
+  if((magic_cur != NULL && i_com) ||
+    (magic_cur == NULL && mgcsfx && input_command_ex_flag)){
+    switch(i_it){
+    case IT_PNM:
+    case IT_PPM:
+    case IT_PGM:
+    case IT_PBM:
+    case IT_PNM_RAW:
+    case IT_PPM_RAW:
+    case IT_PGM_RAW:
+    case IT_PBM_RAW:
+    case IT_PNM_ASCII:
+    case IT_PPM_ASCII:
+    case IT_PGM_ASCII:
+    case IT_PBM_ASCII:
+      rv = LoadPBM(file_name, pinfo, file);
+      break;
+    case IT_GIF:
+    case IT_JPEG:
+    case IT_TIFF:
+    case IT_JFIF:
+    case IT_XBM:
+    case IT_XPM:
+    case IT_BMP:
+    case IT_SUNRAS:
+    case IT_IRIS:
+    case IT_XWD:
+    case IT_MAG:
+    case IT_MAKI:
+    case IT_PI:
+    case IT_PIC:
+    case IT_PIC2:
+      SetISTR(ISTR_WARNING, "Yet supported input image type (from filter output)");
+      rv = 0;
+      break;
+    case IT_UNKNOWN:
+      SetISTR(ISTR_WARNING, "Unknown input image type (from filter output)");
+      rv = 0;
+      break;
+#ifdef HAVE_MGCSFX_AUTO
+    case IT_AUTO:
+#endif /* HAVE_MGCSFX_AUTO */
+    default:
+      SetISTR(ISTR_WARNING, "Error in input image type (from filter output)");
+      rv = 0;
+      break;
+    }
+  }else{
+    rv = 0;
+  }
+
+  while(wait(&pst) != pid);
+  if( *((char *)&pst) != 0 ) rv = 0;
+
+  input_command_ex_flag = 0;
+
+  return rv;
+
+  /* fclose(fp);  close in Load??? */
+  /* return 0; error */
+  /* return 1; ok */
+}
+
+
+
+
+
+/*--------------------------------------------------------------------------*/
+#ifndef MGCSFX_DEFAULT_INPUT_COMMAND
+#define MGCSFX_DEFAULT_INPUT_COMMAND  "tifftopnm"
+#endif
+#ifndef MGCSFX_DEFAULT_OUTPUT_COMMAND
+#define MGCSFX_DEFAULT_OUTPUT_COMMAND "pnmtotiff"
+#endif
+
+int MSWIDE  =  0;
+int MSHIGH  =  0;
+
+#define MS_NBUTTS 2
+#define MS_BOK    0
+#define MS_BCANC  1
+#define BUTTW    60  /* width of buttons (OK or Cancel) */
+#define BUTTH    24  /* height of buttons (OK or Cancel) */
+#define RBSIZE   15  /* width and height of RB button (select, ON or OFF)*/
+#define CWIDE    8   /* width of character */
+/* #define CHIGH        height of character      defined in xv.h */
+#define MARGIN    3  /* margin of button and label     SPACING */
+
+#define MSD_TITLE       "Save file with external command..."
+#define MSD_RBTITLE     "Type of Magic and Suffix"
+#define MSD_IC_TITLE    "input command"
+
+static BUTT  msbut[MS_NBUTTS];
+static RBUTT *typeRB;
+
+static char output_command_ex[1024];
+static int  output_command_ex_flag = 0;
+
+static int   colorType;
+
+static int   w_pid;
+static int   w_pstatus;
+
+#define MSNAMWIDE 252               /* width of 'file name' entry window */
+#define MAXFNLEN 256               /* max len of filename being entered */
+static char   DialogFileName[MAXFNLEN+100];   /* filename being entered */
+static int    curPos, stPos, enPos;     /* filename textedit stuff */
+
+
+static mgcsfxtab *get_mgcsfx PARM((int));
+static void changeSuffix PARM((int));
+
+static int WriteMGCSFX  PARM((FILE**,byte*,int,int,int,
+			    byte*,byte*,byte*,int,int,char*,
+			    int, int, char*));
+void  CreateMGCSFXW         PARM((void));
+void  MGCSFXDialog          PARM((int));
+int   MGCSFXCheckEvent      PARM((XEvent *));
+int   MGCSFXSaveParams      PARM((char *, int));
+
+static void drawMSD     PARM((int,int,int,int));
+static void clickMSD    PARM((int,int));
+static void doCmd       PARM((int));
+static int writeMGCSFX  PARM((void));
+
+static void changeSuffix   PARM((int));
+static void redrawNamMSD   PARM((void));
+static void showFNamMSD    PARM((void));
+static int keyinMSD        PARM((int));
+
+int getInputCom  PARM((void));
+int getOutputCom PARM((void));
+/*--------------------------------------------------------------------------*/
+
+/***************************************************/
+/* $B$I$l$rA*$s$@$+D4$Y$k!##0$O%3%^%s%I$rF~NO$9$k$b$N$H$9$k(B */
+static mgcsfxtab *get_mgcsfx(ms_type)
+     int ms_type;
+{
+  mgcsfxtab *magic;
+  int        i;
+
+  magic = NULL;
+  if(ms_type != 0){
+    i = 1;
+    for(magic = mgcsfx_table; (magic && i<ms_type); magic = magic->next){i++;}
+  }
+  return magic;
+}
+
+/***************************************************/
+/* $B30It%3%^%s%I$r<B9T$7$F!"$=$l$K=PNO$9$k(B */
+/* if OK return 0, else if ERROR return -1 */
+static
+int WriteMGCSFX(fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,file_name,
+		ms_type, file, comment)
+     FILE **fp;
+     byte  *pic;
+     int    ptype, w,h;
+     byte  *rmap, *gmap, *bmap;
+     int    numcols, colorstyle;
+     char  *file_name;
+     int    ms_type;
+     int    file; /* file descriptor */
+     char  *comment;
+{
+  mgcsfxtab *magic;
+
+  int        fd[2];
+  int        pid;
+  int        rv;
+
+  WaitCursor();
+
+#ifdef USE_SIGCHLD
+  w_p_fail = 1;
+#endif
+
+  magic = get_mgcsfx(ms_type);
+  if(ms_type != 0 && magic == NULL) return -1;
+
+  if ((ms_type == 0 && output_command_ex_flag) ||
+      (ms_type !=0 && magic != NULL && magic->output_command)){
+
+    /* Do the pipe/fork/exec here */
+    if (pipe (fd) < 0){
+      fprintf (stderr, "Can't pipe : %s\n", file_name);
+      return -1;
+    }
+
+    if ((pid = vfork ()) < 0){
+      fprintf (stderr, "Can't vfork : %s\n", file_name);
+      close (fd[0]);
+      close (fd[1]);
+      return -1;
+    }
+
+    if (!pid){
+      close(1);
+      dup(file);
+      close(file);
+      close(0);
+      dup(fd[0]);
+      close(2);
+      open("/dev/null", O_WRONLY);
+      close(fd[1]);
+      if(ms_type == 0){
+	execl("/bin/sh", "/bin/sh", "-c", output_command_ex, 0);
+      }else{
+	execl("/bin/sh", "/bin/sh", "-c", magic->output_command, 0);
+      }
+      _exit(127);
+    }
+
+    close (fd[0]);
+    dup2(fd[1], file);
+    close (fd[1]);
+
+  }else{
+    return -1;
+  }
+
+
+  *fp = fdopen(file, "w");
+
+  /* sleep(1); Best way is wait for checking SIGCHLD, but it's feel waist.*/
+
+#ifdef USE_SIGCHLD
+  if(w_p_fail != 2){
+#endif
+    if(ms_type == 0){
+      rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
+		    1, comment);
+    }else{
+      switch(magic -> output_image_type){
+      case IT_PNM:
+      case IT_PPM:
+      case IT_PGM:
+      case IT_PBM:
+      case IT_PNM_RAW:
+      case IT_PPM_RAW:
+      case IT_PGM_RAW:
+      case IT_PBM_RAW:
+	rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
+		      1, comment);
+	break;
+      case IT_PNM_ASCII:
+      case IT_PPM_ASCII:
+      case IT_PGM_ASCII:
+      case IT_PBM_ASCII:
+	rv = WritePBM(*fp,pic,ptype,w,h,rmap,gmap,bmap,numcols,colorstyle,
+		      0, comment);
+	break;
+      case IT_GIF:
+      case IT_JPEG:
+      case IT_TIFF:
+      case IT_JFIF:
+      case IT_XBM:
+      case IT_XPM:
+      case IT_BMP:
+      case IT_SUNRAS:
+      case IT_IRIS:
+      case IT_XWD:
+      case IT_MAG:
+      case IT_MAKI:
+      case IT_PI:
+      case IT_PIC:
+      case IT_PIC2:
+	SetISTR(ISTR_WARNING, "Yet supported output image type (to filter input)");
+	rv = -1;
+	break;
+      case IT_UNKNOWN:
+	SetISTR(ISTR_WARNING, "Unknown output image type (to filter input)");
+	rv = -1;
+	break;
+#ifdef HAVE_MGCSFX_AUTO
+      case IT_AUTO:
+#endif /* HAVE_MGCSFX_AUTO */
+      default:
+	SetISTR(ISTR_WARNING, "Error in output image type (to filter input)");
+	rv = -1;
+	break;
+      }
+    }
+#ifdef USE_SIGCHLD
+  }else{
+    rv = -1;
+  }
+#endif
+
+#ifdef USE_SIGCHLD
+  if(w_p_fail != 2){
+#endif
+    w_pid = pid;
+#ifdef USE_SIGCHLD
+    w_p_fail = 0;
+  }else{
+    rv = -1;
+  }
+#endif
+
+  output_command_ex_flag = 0;
+
+  return rv;
+
+  /* fclose(*fp);   close in CloseOutFile in writeMGCSFX */
+  /* return  0; ok */
+  /* return -1; error */
+}
+
+/***************************************************/
+void CreateMGCSFXW()
+{
+  int	     y;
+  int        type_num;
+  mgcsfxtab *entry;
+
+  if (mgcsfx_setup_flag == 0) init_mgcsfx ();
+
+  if(desc_width < strlen(MSD_IC_TITLE))  desc_width = strlen(MSD_IC_TITLE);
+  nitem_mgcsfx ++;
+
+  MSWIDE = desc_width * CWIDE + RBSIZE + 36; /* 36 is start of RB button */
+  MSHIGH = nitem_mgcsfx * (RBSIZE + MARGIN);
+
+  if(MSWIDE < strlen(MSD_TITLE) + 20) MSWIDE = strlen(MSD_TITLE) + 20;
+  if(MSWIDE < strlen(MSD_RBTITLE) + 16) MSWIDE = strlen(MSD_RBTITLE) + 16;
+  if(MSWIDE < MSNAMWIDE + 10) MSWIDE = MSNAMWIDE + 10;
+  if(MSWIDE <  BUTTW * 2 + 10) MSWIDE = BUTTW * 2 + 10;
+
+  MSHIGH += 55 + LINEHIGH + 10 + BUTTH + 10;
+
+  MSWIDE += 20; /* right side margin */
+  MSHIGH += 10; /* RB buttun down side margin */
+
+
+  mgcsfxW = CreateWindow("xv mgcsfx", "XVmgcsfx", NULL, 
+			 MSWIDE, MSHIGH, infofg, infobg, 0);
+  if (!mgcsfxW) FatalError("can't create mgcsfx window!");
+
+  XSelectInput(theDisp, mgcsfxW,
+	       ExposureMask | ButtonPressMask | KeyPressMask);
+
+  mgcsfxNameW = XCreateSimpleWindow(theDisp, mgcsfxW,
+				    10,  MSHIGH-LINEHIGH-10-BUTTH-10-1, 
+				    (u_int) MSNAMWIDE+6, (u_int) LINEHIGH+5, 
+				    1, infofg, infobg);
+  if (!mgcsfxNameW) FatalError("can't create mgcsfx name window");
+  XSelectInput(theDisp, mgcsfxNameW, ExposureMask);
+
+  /* Ok $B%\%?%s(B */
+  BTCreate(&msbut[MS_BOK], mgcsfxW,
+	   MSWIDE-BUTTW-10-BUTTW-10-1, MSHIGH-BUTTH-10-1,
+	   BUTTW, BUTTH, 
+	   "Ok", infofg, infobg, hicol, locol);
+  /* Cancel $B%\%?%s(B*/
+  BTCreate(&msbut[MS_BCANC], mgcsfxW,
+	   MSWIDE-BUTTW-10-1, MSHIGH-BUTTH-10-1,
+	   BUTTW, BUTTH,
+	   "Cancel", infofg, infobg, hicol, locol);
+
+  y = 55;
+  /* User should input command to exec external command */
+  typeRB = RBCreate(NULL, mgcsfxW, 36, y,          MSD_IC_TITLE,
+		    infofg, infobg,hicol,locol);
+  y += (RBSIZE + MARGIN); /* 18 */
+
+  type_num = 1;
+  for (entry = mgcsfx_table; entry; entry = entry->next){
+    RBCreate(typeRB, mgcsfxW, 36, y,            entry->description,
+	     infofg, infobg,hicol,locol);
+    y += (RBSIZE + MARGIN); /* 18 */
+    if(entry->output_command == NULL){
+      RBSetActive(typeRB, type_num, 0); /* if no command, off */
+    }
+    type_num++;
+  }
+
+  XMapSubwindows(theDisp, mgcsfxW);
+}
+
+
+/***************************************************/
+void MGCSFXDialog(vis)
+     int vis;
+{
+  if (vis) {
+    CenterMapWindow(mgcsfxW, msbut[MS_BOK].x + msbut[MS_BOK].w/2,
+		    msbut[MS_BOK].y + msbut[MS_BOK].h/2, MSWIDE, MSHIGH);
+  }
+  else     XUnmapWindow(theDisp, mgcsfxW);
+  mgcsfxUp = vis;
+}
+
+
+/***************************************************/
+int MGCSFXCheckEvent(xev)
+     XEvent *xev;
+{
+  /* check event to see if it's for one of our subwindows.  If it is,
+     deal accordingly, and return '1'.  Otherwise, return '0' */
+
+  int rv;
+  rv = 1;
+
+  if (!mgcsfxUp) return (0);
+
+  if (xev->type == Expose) {
+    int x,y,w,h;
+    XExposeEvent *e = (XExposeEvent *) xev;
+    x = e->x;  y = e->y;  w = e->width;  h = e->height;
+
+    if (e->window == mgcsfxW)       drawMSD(x, y, w, h);
+    else rv = 0;
+  }
+
+  else if (xev->type == ButtonPress) {
+    XButtonEvent *e = (XButtonEvent *) xev;
+    int x,y;
+    x = e->x;  y = e->y;
+
+    if (e->button == Button1) {
+      if      (e->window == mgcsfxW)     clickMSD(x,y);
+      else rv = 0;
+    }  /* button1 */
+    else rv = 0;
+  }  /* button press */
+
+  else if (xev->type == KeyPress) {
+    XKeyEvent *e = (XKeyEvent *) xev;
+    char buf[128];  KeySym ks;  XComposeStatus status;  
+    int stlen;
+
+    stlen = XLookupString(e,buf,128,&ks,&status);
+    buf[stlen] = '\0';
+
+    if (e->window == mgcsfxW) {
+      if (stlen) {
+	keyinMSD(buf[0]);
+      }
+    }
+    else rv = 0;
+  }
+  else rv = 0;
+
+  if (rv == 0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
+    XBell(theDisp, 50);
+    rv = 1;   /* eat it */
+  }
+
+  return (rv);
+}
+
+
+/***************************************************/
+int MGCSFXSaveParams(fname, col)
+     char *fname;
+     int col;
+{
+  colorType = col;
+  strcpy(DialogFileName, GetDirFName());
+  return (0);
+}
+
+/***************************************************/
+/* $B%@%$%"%m%0$rI=<($9$k$H$-$N=hM}(B */
+static void drawMSD(x,y,w,h)
+     int x,y,w,h;
+{
+  int        i;
+  XRectangle xr;
+
+  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
+  XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
+
+  XSetForeground(theDisp, theGC, infofg);
+  XSetBackground(theDisp, theGC, infobg);
+
+  for (i = 0; i < MS_NBUTTS; i++) BTRedraw(&msbut[i]);
+
+  ULineString(mgcsfxW, typeRB->x-16, typeRB->y-3-DESCENT,
+	      MSD_RBTITLE);
+  RBRedraw(typeRB, -1);
+
+  DrawString(mgcsfxW, 20, 29, MSD_TITLE);
+
+  XSetClipMask(theDisp, theGC, None);
+
+  showFNamMSD();
+}
+
+/***************************************************/
+/* $B%@%$%"%m%0$r%/%j%C%/$7$?$H$-$N=hM}(B */
+static void clickMSD(x,y)
+     int x,y;
+{
+  int   i;
+  BUTT *bp;
+
+  /* check BUTTs */
+
+  /* check the RBUTTS first, since they don't DO anything */
+  if ((i = RBClick(typeRB, x,y)) >= 0) { /* $BA*Br(B(type)$B%\%?%s$N=hM}(B */
+    (void) RBTrack(typeRB, i);  /* $BA*Br(B(type)$B%\%?%s$r2!$7$?$H$-(B */
+    changeSuffix(i);
+    return;
+  }
+
+  for (i = 0; i < MS_NBUTTS; i++) { /* Ok,Cancel $B%\%?%s$N=hM}(B */
+    bp = &msbut[i];
+    if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
+      break;
+  }
+  if (i < MS_NBUTTS)  /* found one */ /* Ok,Cancel $B%\%?%s$r2!$7$?$H$-(B */
+    if (BTTrack(bp)) doCmd(i);
+}
+
+/***************************************************/
+/* $B%\%?%s(B(Ok, Cancel) $B$N=hM}(B */
+static void doCmd(cmd)
+     int cmd;
+{
+  int rv;
+
+  switch (cmd) {
+  case MS_BOK: /* Ok button */ {
+    char *fullname;
+
+    rv = writeMGCSFX(); /* Save with filter(MGCSFX) */
+    MGCSFXDialog(0);
+
+    fullname = GetDirFullName();
+    if (!ISPIPE(fullname[0])) {
+      XVCreatedFile(fullname);
+      if(!rv) StickInCtrlList(0);
+    }
+  }
+    break;
+  case MS_BCANC: /* Cancel button */
+    DialogFileName[0] = '\0';
+    curPos = stPos = enPos = 0;
+    MGCSFXDialog(0);
+    break;
+  default:
+    break;
+  }
+}
+
+/*******************************************/
+static int writeMGCSFX()
+{
+  int   rv, type;
+  int   ptype, w, h, pfree, nc;
+  byte *inpix, *rmap, *gmap, *bmap;
+
+  FILE *fp = NULL;
+  int   file;
+  char *fullname;
+
+  rv = -1;
+  type = RBWhich(typeRB);
+
+  SetDirFName(DialogFileName); /* change filename in dir dialog */
+  fullname = GetDirFullName();
+
+  if(type == 0){
+    if(getOutputCom() == 0) return rv;
+  }
+
+  file = OpenOutFileDesc(fullname);
+  if(file < 0) return rv;
+
+  WaitCursor();
+  inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
+
+  rv = WriteMGCSFX(&fp, inpix, ptype, w, h,
+		   rmap, gmap, bmap, nc, colorType, fullname,
+		   type, file, picComments);
+
+  SetCursors(-1);
+
+  if (CloseOutFile(fp, fullname, rv) == 0) DirBox(0);
+
+  WaitCursor();
+#ifdef USE_SIGCHLD
+  if(w_p_fail == 0){
+#endif
+    while(wait(&w_pstatus) != w_pid);  /* if( *((char *)&w_pstatus) != 0 ) ; */
+#ifdef USE_SIGCHLD
+  }else{
+    w_p_fail = 0;
+  }
+#endif
+  w_pid = 0;
+  w_pstatus = 0;
+
+  if (pfree) free(inpix);
+  return rv;
+}
+
+
+/***************************************/
+static void changeSuffix(ms_type)
+     int ms_type;
+{
+  /* see if there's a common suffix at the end of the DialogFileName.  
+     if there is, remember what case it was (all caps or all lower), lop
+     it off, and replace it with a new appropriate suffix, in the
+     same case */
+
+  int allcaps;
+  char *suffix, *sp, *dp, lowsuf[512];
+  mgcsfxtab *magic;
+
+  /* find the last '.' in the DialogFileName */
+  suffix = (char *) rindex(DialogFileName, '.');
+  if (!suffix) return;
+  suffix++;  /* point to first letter of the suffix */
+
+  /* check for all-caposity */
+  for (sp = suffix, allcaps=1; *sp; sp++) 
+    if (islower(*sp)) allcaps = 0;
+
+  /* copy the suffix into an all-lower-case buffer */
+  for (sp=suffix, dp=lowsuf; *sp; sp++, dp++) {
+    *dp = (isupper(*sp)) ? tolower(*sp) : *sp;
+  }
+  *dp = '\0';
+
+
+  magic = get_mgcsfx(ms_type);
+  if(magic != NULL && magic->suffix != NULL){
+    strcpy(lowsuf,(magic->suffix)+1);
+
+    if (allcaps) {  /* upper-caseify lowsuf */
+      for (sp=lowsuf; *sp; sp++) 
+	*sp = (islower(*sp)) ? toupper(*sp) : *sp;
+    }
+    
+    /* one other case:  if the original suffix started with a single
+       capital letter, make the new suffix start with a single cap */
+    if (isupper(suffix[0])) lowsuf[0] = toupper(lowsuf[0]);
+
+    strcpy(suffix, lowsuf);   /* tack onto DialogFileName */
+    showFNamMSD();
+  }
+}
+
+/***************************************************/
+/* $B%@%$%"%m%0Fb$K%U%!%$%k%M!<%`$rI=<($9$k$H$-$N=hM}(B ($B2<@A$1(B)*/
+static void redrawNamMSD()
+{
+  int cpos;
+
+  /* draw substring DialogFileName[stPos:enPos] and cursor */
+
+  Draw3dRect(mgcsfxNameW, 0, 0, (u_int) MSNAMWIDE+5, (u_int) LINEHIGH+4, R3D_IN, 2, 
+	     hicol, locol, infobg);
+
+  XSetForeground(theDisp, theGC, infofg);
+
+  if (stPos>0) {  /* draw a "there's more over here" doowah */
+    XDrawLine(theDisp, mgcsfxNameW, theGC, 0,0,0,LINEHIGH+5);
+    XDrawLine(theDisp, mgcsfxNameW, theGC, 1,0,1,LINEHIGH+5);
+    XDrawLine(theDisp, mgcsfxNameW, theGC, 2,0,2,LINEHIGH+5);
+  }
+
+  if ((size_t) enPos < strlen(DialogFileName)) { 
+    /* draw a "there's more over here" doowah */
+    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+5,0,MSNAMWIDE+5,LINEHIGH+5);
+    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+4,0,MSNAMWIDE+4,LINEHIGH+5);
+    XDrawLine(theDisp, mgcsfxNameW, theGC, MSNAMWIDE+3,0,MSNAMWIDE+3,LINEHIGH+5);
+  }
+
+  XDrawString(theDisp, mgcsfxNameW, theGC,3,ASCENT+3,DialogFileName+stPos, enPos-stPos);
+
+  cpos = XTextWidth(mfinfo, &DialogFileName[stPos], curPos-stPos);
+  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2, 3+cpos, 2+CHIGH+1);
+  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2+CHIGH+1, 5+cpos, 2+CHIGH+3);
+  XDrawLine(theDisp, mgcsfxNameW, theGC, 3+cpos, 2+CHIGH+1, 1+cpos, 2+CHIGH+3);
+}
+
+/***************************************************/
+/* $B%@%$%"%m%0Fb$K%U%!%$%k%M!<%`$rI=<($9$k(B */
+static void showFNamMSD()
+{
+  int len;
+  
+  len = strlen(DialogFileName);
+  
+  if (curPos<stPos) stPos = curPos;
+  if (curPos>enPos) enPos = curPos;
+  
+  if (stPos>len) stPos = (len>0) ? len-1 : 0;
+  if (enPos>len) enPos = (len>0) ? len-1 : 0;
+  
+  /* while substring is shorter than window, inc enPos */
+  
+  while (XTextWidth(mfinfo, &DialogFileName[stPos], enPos-stPos) < MSNAMWIDE
+	 && enPos<len) { enPos++; }
+
+  /* while substring is longer than window, dec enpos, unless enpos==curpos,
+     in which case, inc stpos */
+
+  while (XTextWidth(mfinfo, &DialogFileName[stPos], enPos-stPos) > MSNAMWIDE) {
+    if (enPos != curPos) enPos--;
+    else stPos++;
+  }
+
+
+  if (ctrlColor) XClearArea(theDisp, mgcsfxNameW, 2,2, (u_int) MSNAMWIDE+5-3, 
+			    (u_int) LINEHIGH+4-3, False);
+  else XClearWindow(theDisp, mgcsfxNameW);
+
+  redrawNamMSD();
+  BTSetActive(&msbut[MS_BOK], strlen(DialogFileName)!=0);
+}
+
+/***************************************************/
+/* $B%-!<F~NO$7$?$H$-$N=hM}(B */
+static int keyinMSD(c)
+     int c;
+{
+  /* got keypress in dirW.  stick on end of DialogFileName */
+  int len;
+
+  len = strlen(DialogFileName);
+  
+  if (c>=' ' && c<'\177') {             /* printable characters */
+    /* note: only allow 'piped commands' in savemode... */
+
+    /* only allow spaces in 'piped commands', not filenames */
+    if (c==' ' && (!ISPIPE(DialogFileName[0]) || curPos==0)) return (-1);
+
+    /* only allow vertbars in 'piped commands', not filenames */
+    if (c=='|' && curPos!=0 && !ISPIPE(DialogFileName[0])) return(-1);
+
+    if (len >= MAXFNLEN-1) return(-1);  /* max length of string */
+    xvbcopy(&DialogFileName[curPos], &DialogFileName[curPos+1], (size_t) (len-curPos+1));
+    DialogFileName[curPos]=c;  curPos++;
+  }
+
+  else if (c=='\010' || c=='\177') {    /* BS or DEL */
+    if (curPos==0) return(-1);          /* at beginning of str */
+    xvbcopy(&DialogFileName[curPos], &DialogFileName[curPos-1], (size_t) (len-curPos+1));
+    curPos--;
+  }
+
+  else if (c=='\025') {                 /* ^U: clear entire line */
+    DialogFileName[0] = '\0';
+    curPos = 0;
+  }
+
+  else if (c=='\013') {                 /* ^K: clear to end of line */
+    DialogFileName[curPos] = '\0';
+  }
+
+  else if (c=='\001') {                 /* ^A: move to beginning */
+    curPos = 0;
+  }
+
+  else if (c=='\005') {                 /* ^E: move to end */
+    curPos = len;
+  }
+
+  else if (c=='\004') {                 /* ^D: delete character at curPos */
+    if (curPos==len) return(-1);
+    xvbcopy(&DialogFileName[curPos+1], &DialogFileName[curPos], (size_t) (len-curPos));
+  }
+
+  else if (c=='\002') {                 /* ^B: move backwards char */
+    if (curPos==0) return(-1);
+    curPos--;
+  }
+
+  else if (c=='\006') {                 /* ^F: move forwards char */
+    if (curPos==len) return(-1);
+    curPos++;
+  }
+
+  else if (c=='\012' || c=='\015') {    /* CR(\r) or LF(\n) */
+    FakeButtonPress(&msbut[MS_BOK]);
+  }
+
+  else if (c=='\033') {                  /* ESC = Cancel */
+    FakeButtonPress(&msbut[MS_BCANC]);
+  }
+
+  else if (c=='\011') {                  /* tab = filename expansion */
+    if (1 /* !autoComplete() */) XBell(theDisp, 0);
+    else {
+      curPos = strlen(DialogFileName);
+    }
+  }
+
+  else return(-1);                      /* unhandled character */
+
+  showFNamMSD();
+
+  return(0);
+}
+
+
+/*******************************************/
+int getInputCom()
+{
+  static char *labels[] = { "\nOk", "\033Cancel" };
+  int i;
+
+  strcpy(input_command_ex, MGCSFX_DEFAULT_INPUT_COMMAND);
+  i = GetStrPopUp("Input External Command (Input is PNM):", labels, 2,
+		  input_command_ex, 1024, "",0);
+  if (i == 0 && strlen(input_command_ex) != 0){
+    input_command_ex_flag = 1;
+    return 1;
+  }else{
+    input_command_ex_flag = 0;
+    return 0;
+  }
+}
+
+int getOutputCom()
+{
+  static char *labels[] = { "\nOk", "\033Cancel" };
+  int i;
+
+  strcpy(output_command_ex, MGCSFX_DEFAULT_OUTPUT_COMMAND);
+  i = GetStrPopUp("Input External Command (Output is PNM_RAW):", labels, 2,
+		  output_command_ex, 1024, "",0);
+  if (i == 0 && strlen(output_command_ex) != 0){
+    output_command_ex_flag = 1;
+    return 1;
+  }else{
+    output_command_ex_flag = 0;
+    return 0;
+  }
+}
+
+#ifdef SVR4
+Sigfunc *
+xv_signal(signo, func)
+     int signo;
+     Sigfunc *func;
+{
+  struct sigaction act, oact;
+
+  act.sa_handler = func;
+  sigemptyset(&act.sa_mask);
+  act.sa_flags = 0;
+  act.sa_flags |= SA_RESTART;
+
+  if (sigaction(signo, &act, &oact) < 0)
+    return SIG_ERR;
+
+  return oact.sa_handler;
+}
+#endif
+
+#endif /* HAVE_MGCSFX */
diff -Naur xv-3.10a.old/xvmisc.c xv-3.10a/xvmisc.c
--- xv-3.10a.old/xvmisc.c	Sat Jan 14 08:41:34 1995
+++ xv-3.10a/xvmisc.c	Tue Apr 24 09:37:06 2001
@@ -28,6 +28,8 @@
  *     int    xvbcmp (s1,  s2,  length)
  *     void   xvbzero(s, length)
  *     char  *xv_strstr(s1, s2)
+ *     FILE  *xv_fopen(str, str)
+ *     void   xv_mktemp(str)
  *     void   Timer(milliseconds)
  */
 
@@ -497,6 +499,11 @@
      as we have to keep the alloc'd colors around, but we don't want anything
      else to stay */
 
+#ifdef AUTO_EXPAND
+  chdir(initdir);
+  Vdsettle();
+#endif
+
   if (!theDisp) exit(i);   /* called before connection opened */
 
   if (useroot && i==0) {   /* save the root info */
@@ -520,6 +527,22 @@
     if (tiffW) XDestroyWindow(theDisp, tiffW);
 #endif
 
+#ifdef HAVE_PIC2
+    if (pic2W) XDestroyWindow(theDisp, pic2W);
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+    if (pcdW)  XDestroyWindow(theDisp, pcdW);
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+    if (mgcsfxW) XDestroyWindow(theDisp, mgcsfxW);
+#endif /* HAVE_MGCSFX */
+
+#ifdef HAVE_PNG
+    if (pngW)  XDestroyWindow(theDisp, pngW);
+#endif
+
     /* if NOT using stdcmap for images, free stdcmap */
     if (colorMapMode != CM_STDCMAP) { 
       int j;
@@ -716,6 +739,22 @@
 #ifdef HAVE_TIFF
   if (tiffW) XDefineCursor(theDisp, tiffW, otherc);
 #endif
+
+#ifdef HAVE_PNG
+  if (pngW)  XDefineCursor(theDisp, pngW, otherc);
+#endif
+
+#ifdef HAVE_PIC2
+  if (pic2W) XDefineCursor(theDisp, pic2W, otherc);
+#endif /* HAVE_PIC2 */
+
+#ifdef HAVE_PCD
+  if (pcdW)  XDefineCursor(theDisp, pcdW, otherc);
+#endif /* HAVE_PCD */
+
+#ifdef HAVE_MGCSFX
+  if (mgcsfxW) XDefineCursor(theDisp, mgcsfxW, otherc);
+#endif /* HAVE_MGCSFX */
 }
 
 
@@ -1000,6 +1039,9 @@
 	((rv=(char *) getenv("cwd"))==NULL)) rv = "./";
     strcpy(buf, rv);
   }
+#ifdef AUTO_EXPAND
+  Vdtodir(buf);
+#endif
 }
 
 
@@ -1066,6 +1108,16 @@
 }
 
 
+/***************************************************/
+void xv_mktemp(buf, fname)
+     char *buf, *fname;
+{
+#ifndef VMS
+  sprintf(buf, "%s/%s", tmpdir, fname);
+#else
+  sprintf(buf, "Sys$Disk:[]%s", fname);
+#endif
+}
 
 
 /*******/
diff -Naur xv-3.10a.old/xvml.c xv-3.10a/xvml.c
--- xv-3.10a.old/xvml.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvml.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,992 @@
+/*
+ * xvml.c  -  makes text item structure for multi-lingual textviewer.
+ *
+ * Entry Points:
+ *  struct ml_text *ml_draw_text()
+ *  struct context *ml_create_context()
+ *  int ml_set_charsets()
+ *  void get_monofont_size()
+ */
+
+#include "xv.h"
+#include <X11/Xresource.h>
+
+#ifdef TV_MULTILINGUAL	/* whole this file. */
+
+#include "xvml.h"
+#define HAVE_STRDUP 1
+#define USE_MULE_EXTENSION
+
+#ifndef __STDC__
+#define CHAR char
+#else
+#define CHAR int
+#endif
+
+#define CODE_SI  0x0e	/* LS0 */
+#define CODE_SO  0x0f	/* LS1 */
+#define CODE_SS2 ((unsigned char) 0x8e)
+#define CODE_SS3 ((unsigned char) 0x8f)
+
+int ml_tab_width = 64;	/* dots */
+
+struct charset {
+    int bpc;		/* bytes per char */
+    int noc;		/* number of chars */
+    char designator;
+    char *registry;
+    int bit7;
+    
+    int loaded;
+    char *fontname;
+    
+    XFontStruct *fs;
+} charset[] = {
+    { 1, 94, 'B', "iso8859-1",       0, 0, NULL, NULL},
+    { 1, 96, 'A', "iso8859-1",       1, 0, NULL, NULL},
+    { 1, 94, '0', "omron_udc_zh-0",  0, 0, NULL, NULL},
+    { 1, 94, '2', "mulearabic-0",    0, 0, NULL, NULL},
+    { 1, 94, '3', "mulearabic-1",    0, 0, NULL, NULL},
+    { 1, 94, '4', "mulearabic-2",    0, 0, NULL, NULL},
+    { 1, 94, 'J', "jisx0201.1976-0", 0, 0, NULL, NULL},
+    { 1, 96, '0', "muleipa-1",       1, 0, NULL, NULL},
+    { 1, 96, '1', "viscii1.1-1",     1, 0, NULL, NULL},
+    { 1, 96, '2', "viscii1.1-1",     1, 0, NULL, NULL},
+    { 1, 96, 'B', "iso8859-2",       1, 0, NULL, NULL},
+    { 1, 96, 'C', "iso8859-3",       1, 0, NULL, NULL},
+    { 1, 96, 'D', "iso8859-4",       1, 0, NULL, NULL},
+    { 1, 96, 'T', "tis620.1986-0",   1, 0, NULL, NULL},
+    { 1, 96, 'F', "iso8859-7",       1, 0, NULL, NULL},
+    { 1, 96, 'G', "iso8859-6",       1, 0, NULL, NULL},
+    { 1, 96, 'H', "iso8859-8",       1, 0, NULL, NULL},
+    { 1, 94, 'I', "jisx0201.1976-0", 1, 0, NULL, NULL},
+    { 1, 96, 'L', "iso8859-5",       1, 0, NULL, NULL},
+    { 1, 96, 'M', "iso8859-9",       1, 0, NULL, NULL},
+    { 2, 94, '2', "ethio-0",         0, 0, NULL, NULL},
+    { 2, 94, '@', "jisx0208.1978",   0, 0, NULL, NULL},
+    { 2, 94, 'A', "gb2312.1980-0",   0, 0, NULL, NULL},
+    { 2, 94, 'B', "jisx0208.1983-0", 0, 0, NULL, NULL},
+    { 2, 94, 'C', "ksc5601.1987-0",  0, 0, NULL, NULL},
+    { 2, 94, 'D', "jisx0212.1990-0", 0, 0, NULL, NULL},
+    { 2, 94, '0', "big5.eten-0",     0, 0, NULL, NULL},
+    { 2, 94, '1', "big5.hku-0",      0, 0, NULL, NULL},
+    /* End Mark */
+    { 0,  0,   0,        NULL,       0, 0, NULL, NULL},
+};
+#define NR_CHARSETS ((int) (sizeof charset / sizeof charset[0]))
+
+static struct charset *ascii = NULL;
+
+struct context {
+    struct charset *g[4];
+    struct charset **gl, **gr;
+    struct charset **ss;
+    int eol;		/* 0: \n,  1: \r\n,  2: \r,  3: any */
+    int valid[4];	/* g[i] is valid? */
+    int short_form;	/* allow shortened designator sequence? */
+    int lock_shift;	/* allow locking shift? */
+    
+    unsigned char *cbuf, *cbp;
+    struct ml_text text;
+    int line;
+    int delta;
+    int toolong;
+    
+    Display *dpy;
+    Screen *scr;
+    Window root_win;
+};
+#define DPY (context->dpy)
+#define SCR (context->scr)
+#define ROOT_WIN (context->root_win)
+
+static unsigned char *escape_sequence		PARM((unsigned char *));
+static unsigned char *designator_sequence	PARM((unsigned char *));
+static void locking_shift			PARM((unsigned CHAR));
+static void single_shift			PARM((unsigned CHAR));
+static void put_unknown_char			PARM((unsigned CHAR));
+static struct charset *search_charset		PARM((int, int, int));
+static void pack_string				PARM((struct charset *,
+						      unsigned char *, int));
+static void init_xrm				PARM((void));
+static void init_xrm_fonts			PARM((void));
+static void init_xrm_tab			PARM((void));
+#ifndef HAVE_STRDUP
+static char *strdup				PARM((char *));
+#endif
+
+static char *default_fonts[] = {		/* default for xrm_fonts */
+    "-sony-fixed-medium-r-normal--16-*-*-*-*-*-iso8859-1",
+    "-jis-fixed-medium-r-normal--16-*-*-*-*-*-jisx0208.1983-0",
+};
+static int xrm_nfonts;
+static char **xrm_fonts;
+
+static struct context *context;	/* current context */
+
+struct ml_text *ml_draw_text(ctx, string, len)
+    struct context *ctx;
+    char *string;
+    int len;
+{
+    unsigned char *str = (unsigned char *) string;
+    unsigned char *estr = str + len;
+    
+    context = ctx;
+    
+    if(ascii == NULL){
+	fputs("ml_draw_text: call ml_set_charsets, first.\n", stderr);
+	return NULL;
+    }
+    
+    if(!str)
+	return &context->text;
+    
+    WaitCursor();
+    
+    if (context->text.maxlines != 0) {
+	struct ml_text *tp = &context->text;
+	struct ml_line *lp;
+	int i;
+	for (i = tp->nlines, lp = tp->lines; i > 0; i--, lp++) {
+	    XTextItem16 *ip;
+	    int j;
+	    if (lp->maxitems != 0)
+		free((char *) lp->items);
+	}
+	free((char *) tp->lines);
+	tp->maxlines = tp->nlines = 0;
+    }
+    if (context->cbuf != NULL)
+	free((char *) context->cbuf);
+    context->cbp = (unsigned char *) malloc((size_t) len * 8);/* all \xxx */
+    context->cbuf = context->cbp;
+    context->line = 0;
+    context->delta = 0;
+    context->ss = NULL;
+    
+    while(str < estr){
+	if((*str & 0x80) == 0){				/* left half */
+	    struct charset *cs = context->ss ? *context->ss : *context->gl;
+	    unsigned char min_char, max_char;
+	    if (cs != NULL) {
+		if(cs->noc == 94){
+		    min_char = 0x21;
+		    max_char = 0x7e;
+		}else{
+		    min_char = 0x20;
+		    max_char = 0x7f;
+		}
+	    }
+	    
+	    if (cs == NULL)
+		put_unknown_char(*str++);
+	    else if(*str < min_char || *str > max_char){	/* C1 */
+		switch(*str){
+		case ' ':
+		    {
+			unsigned char *p = str + 1;
+			while (*p == ' ' && p < estr)
+			    p++;
+			pack_string(ascii, str, (int) (p - str));
+			str = p;
+		    }
+		    break;
+		    
+		case '\t':
+		    pack_string(ascii, str++, 0);
+		    break;
+		    
+		case '\n':
+		    switch (context->eol) {
+		    case 0:				/* unix type eol */
+			pack_string(ascii, str, 0);
+			WaitCursor();
+			str++;
+			break;
+		    case 1:				/* dos type eol */
+		    case 2:				/* mac type eol */
+			put_unknown_char('\n');
+			str++;
+			break;
+		    case 3:				/* any type eol */
+			pack_string(ascii, str++, 0);
+			while (*str == '\n' || *str == '\r')
+			    str++;
+			WaitCursor();
+			break;
+		    }
+		    break;
+		    
+		case '\r':
+		    switch (context->eol) {
+		    case 0:
+			put_unknown_char('\r');
+			str++;
+			break;
+		    case 1:
+			str++;
+			if (*str == '\n')
+			    pack_string(ascii, str++, 0);
+			else
+			    put_unknown_char('\r');
+			break;
+		    case 2:
+			pack_string(ascii, str, 0);
+			WaitCursor();
+			str++;
+			break;
+		    case 3:
+			pack_string(ascii, str++, 0);
+			while (*str == '\n' || *str == '\r')
+			    str++;
+			WaitCursor();
+			break;
+		    }
+		    break;
+		    
+		case '\033':
+		    {
+			unsigned char *p;
+			str++;
+			if((p = escape_sequence(str)) == str)
+			    put_unknown_char('\033');
+			else
+			    str = p;
+		    }
+		    break;
+		    
+		case CODE_SI:
+		case CODE_SO:
+		    if (!context->lock_shift)
+			put_unknown_char((unsigned int) *str++);
+		    else
+			locking_shift((unsigned int) *str++);
+		    break;
+		    
+		default:
+		    put_unknown_char((unsigned int) *str++);
+		}
+	    }else{					/* GL */
+		if (context->ss != NULL) {
+		    pack_string(cs, str, 1);
+		    str += cs->bpc;
+		    context->ss = NULL;
+		} else {
+		    int n;
+		    
+		    if (cs->bpc == 1) {
+			unsigned char *p = str;
+			for (n = 0; p < estr; n++) {
+			    if (*p < min_char || *p > max_char)
+				break;
+			    p++;
+			}
+			pack_string(cs, str, n);
+			str = p;
+		    } else {
+			unsigned char *p = str;
+			for (n = 0; p < estr - 1; n++) {
+			    if (*p < min_char || *p > max_char ||
+				    *(p + 1) < min_char || *(p + 1) > max_char)
+				break;
+			    p += 2;
+			}
+			if (n > 0)
+			    pack_string(cs, str, n);
+			else
+			    put_unknown_char(*p++);
+			str = p;
+		    }
+		}
+	    }
+	}else{						/* right half */
+	    struct charset *cs = context->ss ? *context->ss : *context->gr;
+	    unsigned char min_char, max_char;
+	    if (cs != NULL) {
+		if(cs->noc == 94){
+		    min_char = 0xa1;
+		    max_char = 0xfe;
+		}else{
+		    min_char = 0xa0;
+		    max_char = 0xff;
+		}
+	    }
+	    
+	    if (cs == NULL)
+		put_unknown_char(*str++);
+	    else if(*str < min_char || *str > max_char){	/* C2 */
+		unsigned char c = *str++;
+		switch(c){
+		case CODE_SS2:
+		case CODE_SS3:
+		    single_shift((unsigned CHAR) c);
+		    break;
+		default:
+		    put_unknown_char(c);
+		}
+	    }else{					/* GR */
+		if (context->ss != NULL) {
+		    pack_string(cs, str, 1);
+		    str += cs->bpc;
+		    context->ss = NULL;
+		} else {
+		    int n;
+		    
+		    if (cs->bpc == 1) {
+			unsigned char *p = str;
+			for (n = 0; p < estr; n++) {
+			    if (*p < min_char || *p > max_char)
+				break;
+			    p++;
+			}
+			pack_string(cs, str, n);
+			str = p;
+		    } else {
+			unsigned char *p = str;
+			for (n = 0; p < estr - 1; n++) {
+			    if (*p < min_char || *p > max_char ||
+				    *(p + 1) < min_char || *(p + 1) > max_char)
+				break;
+			    p += 2;
+			}
+			if (n > 0)
+			    pack_string(cs, str, n);
+			else
+			    put_unknown_char(*p++);
+			str = p;
+		    }
+		}
+	    }
+	}
+    }
+    
+    {
+	struct ml_text *tp = &context->text;
+	struct ml_line *lp;
+	int i;
+	
+	tp->width = 0;
+	tp->height = 0;
+	for (lp = tp->lines, i = tp->nlines; i > 0; lp++, i--) {
+	    if (lp->nitems == 0) {
+		lp->ascent  = ascii->fs->ascent;
+		lp->descent = ascii->fs->descent;
+	    }
+	    if (tp->width < lp->width)
+		tp->width = lp->width;
+	    tp->height += lp->ascent + lp->descent;
+	}
+    }
+    
+    SetCursors(-1);
+    return &context->text;
+}
+
+static unsigned char *escape_sequence(str)
+    unsigned char *str;
+{
+    unsigned char *p;
+    switch(*str){
+    case '$':
+    case '(': case ')': case '*': case '+':
+    case '-': case '.': case '/': case ',':
+	if((p = designator_sequence(str)) == NULL)
+	    return str;
+	return p;
+    case 'n': case 'o': case '~': case '}': case '|':
+	if (!context->lock_shift)
+	    return str;
+	locking_shift(*str);
+	return str + 1;
+    case 'N': case 'O':
+	single_shift(*str);
+	return str + 1;
+    }
+    return str;
+    
+}
+
+static unsigned char *designator_sequence(str)
+    unsigned char *str;
+{
+    unsigned char *p = str;
+    int noc, bpc, n_g, shortened;
+    unsigned char des;
+    struct charset *cs;
+    
+    if(*p == '$'){
+	bpc = 2;
+	p++;
+    }else
+	bpc = 1;
+    
+    switch(*p++){
+    case '(':	noc = 94; n_g = 0; des = *p++; shortened = 0; break;
+    case ')':	noc = 94; n_g = 1; des = *p++; shortened = 0; break;
+    case '*':	noc = 94; n_g = 2; des = *p++; shortened = 0; break;
+    case '+':	noc = 94; n_g = 3; des = *p++; shortened = 0; break;
+#ifdef USE_MULE_EXTENSION
+    case ',':	noc = 96; n_g = 0; des = *p++; shortened = 0; break;
+#endif
+    case '-':	noc = 96; n_g = 1; des = *p++; shortened = 0; break;
+    case '.':	noc = 96; n_g = 2; des = *p++; shortened = 0; break;
+    case '/':	noc = 96; n_g = 3; des = *p++; shortened = 0; break;
+    case '@':	noc = 94; n_g = 0; des = 'B';  shortened = 0; break;
+    case 'A':	noc = 94; n_g = 0; des = 'A';  shortened = 1; break;
+    case 'B':	noc = 94; n_g = 0; des = 'B';  shortened = 1; break;
+    default:	return NULL;
+    }
+    if (!context->short_form && shortened)
+	return NULL;
+    
+    if((cs = search_charset(bpc, noc, des)) == NULL){
+	if(DEBUG){
+	    fprintf(stderr, "designator_sequence: (%d,%d,%c) not found.\n",
+		    bpc, noc, des);
+	}
+	return NULL;
+    }
+    if (!context->valid[n_g])
+	return NULL;
+    context->g[n_g] = cs;
+    if(DEBUG){
+	fprintf(stderr,
+		"designator_sequence: G%d is `%s'.\n", n_g, cs->registry);
+    }
+    return p;
+}
+
+static void locking_shift(c)
+    unsigned CHAR c;
+{
+    switch((unsigned char) c){
+    case CODE_SI:	context->gl = &context->g[0]; break;
+    case CODE_SO:	context->gl = &context->g[1]; break;
+    case 'n':		context->gl = &context->g[2]; break;
+    case 'o':		context->gl = &context->g[3]; break;
+    case '~':		context->gr = &context->g[1]; break;
+    case '}':		context->gr = &context->g[2]; break;
+    case '|':		context->gr = &context->g[3]; break;
+    }
+    if(DEBUG){
+	fprintf(stderr, "locking_shift: (%d,%d).\n",
+		(int)(context->gl - context->g),
+		(int)(context->gr - context->g));
+    }
+}
+
+static void single_shift(c)
+    unsigned CHAR c;
+{
+    switch((unsigned char) c){
+    case CODE_SS2:	context->ss = &context->g[2]; break;
+    case CODE_SS3:	context->ss = &context->g[3]; break;
+    }
+}
+
+
+static void put_unknown_char(chr)
+    unsigned CHAR chr;
+{
+    unsigned char c = chr;
+    
+    if(c < 0x20){
+	unsigned char buf[2];
+	buf[0] = '^';
+	buf[1] = c + 0x40;
+	pack_string(ascii, buf, 2);
+    }else{
+	unsigned char buf[4];
+	buf[0] = '\\';
+	buf[1] =  ((c >> 6) & 07) + '0';
+	buf[2] =  ((c >> 3) & 07) + '0';
+	buf[3] =  ((c     ) & 07) + '0';
+	pack_string(ascii, buf, 4);
+    }
+}
+
+struct context *ml_create_context(s)
+    Screen *s;
+{
+    context = (struct context *) malloc(sizeof *context);
+    
+    context->g[0] = NULL;
+    context->g[1] = NULL;
+    context->g[2] = NULL;
+    context->g[3] = NULL;
+    context->gl = NULL;
+    context->gr = NULL;
+    context->ss = NULL;
+    
+    context->cbuf = NULL;
+    context->text.maxlines = context->text.nlines = 0;
+    context->line = 0;
+    context->delta = 0;
+    context->toolong = 0;
+    
+    DPY = DisplayOfScreen(s);
+    SCR = s;
+    ROOT_WIN = RootWindowOfScreen(s);
+    
+    return context;
+}
+
+
+int ml_set_charsets(ctx, sys)
+    struct context *ctx;
+    struct coding_system *sys;
+{
+    int retval = 0;
+    int i;
+    
+    context = ctx;
+    
+    if(ascii == NULL){
+	init_xrm();
+	if((ascii = search_charset(1, 94, 'B')) == NULL){
+	    fputs("ml_set_charsets: ascii charset not found.\n", stderr);
+	    Quit(1);
+	}
+	if (ascii->fs == NULL) {
+	    fputs("ml_set_charsets: iso8859-1 font not found.\n", stderr);
+	    Quit(1);
+	}
+    }
+    for(i = 0; i < 4; i++){
+	struct charset *spec;
+	switch(sys->design[i].bpc){
+	case -1:	/* make G[i] invalid */
+	    context->valid[i] = 0;
+	    break;
+	    
+	case 0:		/* don't change */
+	    break;
+	    
+	case 1: case 2:	/* change it */
+	    if((context->g[i] = search_charset(sys->design[i].bpc,
+					       sys->design[i].noc,
+					       sys->design[i].des)) == NULL){
+		fputs("ml_set_charsets: ", stderr);
+		fprintf(stderr, "(%d,%d,%c) is specified as G%d, ",
+			sys->design[i].bpc, sys->design[i].noc,
+			sys->design[i].des, i);
+		fputs("but not found. using `iso8859-1'.\n", stderr);
+		context->g[i] = ascii;
+		retval++;
+	    }
+	    context->valid[i] = 1;
+	    break;
+	    
+	default:	/* error */
+	    fprintf(stderr,"ml_set_charsets: bad arguments of G%d. ", i);
+	    fputs("using `iso8859-1'.\n", stderr);
+	    context->g[i] = ascii;
+	    retval++;
+	}
+    }
+    if((unsigned int) sys->gl < 4)
+	context->gl = &context->g[sys->gl];
+    else{
+	fprintf(stderr, "ml_set_charsets: bad number as GL. using G0.\n");
+	context->gl = &context->g[0];
+    }
+    if((unsigned int) sys->gr < 4)
+	context->gr = &context->g[sys->gr];
+    else{
+	fprintf(stderr, "ml_set_charsets: bad number as GR. using G0.\n");
+	context->gr = &context->g[0];
+    }
+    context->eol = sys->eol;
+    context->short_form = sys->short_form;
+    context->lock_shift = sys->lock_shift;
+    return retval;
+}
+
+static struct charset *search_charset(bpc, noc, des)
+    int bpc, noc;
+    int des;
+{
+    struct charset *cset;
+    for(cset = charset; cset->bpc != 0; cset++){
+	if(cset->bpc == bpc &&
+	   cset->noc == noc &&
+	   cset->designator == (char) des){
+	    if(!cset->loaded){
+#if 0
+		int i, l;
+		l = strlen(cset->registry);
+		for (i = 0; i < xrm_nfonts; i++) {
+		    int li = strlen(xrm_fonts[i]);
+		    if (li > l) {
+			if (xrm_fonts[i][li - l - 1] == '-' &&
+				strcmp(xrm_fonts[i] + li - l,
+				       cset->registry) == 0) {
+			    if ((cset->fs = XLoadQueryFont(DPY, xrm_fonts[i]))
+				    != NULL) {
+				if (DEBUG) {
+				    fprintf(stderr, "%s for %s\n",
+					    xrm_fonts[i], cset->registry);
+				}
+				cset->fontname = xrm_fonts[i];
+				break;
+			    } else
+				SetISTR(ISTR_WARNING,
+					"%s: font not found.", xrm_fonts[i]);
+			}
+		    }
+		}
+#else
+		int i, l;
+		l = strlen(cset->registry);
+		for (i = 0; i < xrm_nfonts && cset->fs == NULL; i++) {
+		    int j, nfnts = 0;
+		    char **fnts = XListFonts(DPY, xrm_fonts[i],
+					     65535, &nfnts);
+		    for (j = 0 ; j < nfnts; j++) {
+			int ll = strlen(fnts[j]);
+			if (*(fnts[j] + ll - l - 1) == '-' &&
+			    strcmp(fnts[j] + ll - l, cset->registry)== 0) {
+			    if ((cset->fs = XLoadQueryFont(DPY, fnts[j]))
+				!= NULL) {
+				if (DEBUG) {
+				    fprintf(stderr, "%s for %s\n",
+					    fnts[j], cset->registry);
+				}
+				cset->fontname = strdup(fnts[j]);
+				break;
+			    } else
+				SetISTR(ISTR_WARNING,
+					"%s: font not found", fnts[j]);
+			}
+		    }
+		    if (fnts != NULL)
+			XFreeFontNames(fnts);
+		}
+#endif
+		if(cset->fs == NULL){
+		    SetISTR(ISTR_WARNING,
+			    "font for %s not found.\nusing ascii font.",
+			    cset->registry);
+		    if (ascii != NULL)
+			cset->fs = ascii->fs;
+		}
+		
+		cset->loaded = 1;
+	    }
+	    return cset;
+	}
+    }
+    return NULL;
+}
+
+static void pack_string(cs, str, len)
+    struct charset *cs;
+    unsigned char *str;
+    int len;	/* number of chars(not bytes) */
+{
+    struct ml_text *mt = &context->text;
+    struct ml_line *lp;
+    XTextItem16 *ip;
+    
+    if (context->line == mt->maxlines) {
+	int oldmax = mt->maxlines;
+	if (mt->maxlines < 1)
+	    mt->maxlines = 1;
+	else
+	    mt->maxlines = 2 * mt->maxlines;
+	if (oldmax == 0)
+	    mt->lines = (struct ml_line *)
+				malloc(sizeof(struct ml_line) * mt->maxlines);
+	else {
+	    mt->lines = (struct ml_line *)
+				realloc(mt->lines,
+					sizeof(struct ml_line) * mt->maxlines);
+	}
+    }
+    lp = &mt->lines[context->line];
+    if (mt->nlines == context->line) {
+	mt->nlines++;
+	lp->maxitems = 0;
+	lp->nitems = 0;
+	lp->width = 0;
+	lp->ascent = lp->descent = 0;
+    }
+    
+    if (len == 0) {
+	switch (*str) {
+	case '\n':
+	    context->line++;
+	    context->delta = 0;
+	    context->toolong = 0;
+	    break;
+	case '\t':
+	    {
+		int nx, x = lp->width + context->delta;
+		nx = (x + ml_tab_width) / ml_tab_width * ml_tab_width;
+		context->delta += nx - x;
+	    }
+	    break;
+	}
+	return;
+    }
+    
+    if (context->toolong)
+	return;
+    if (lp->width > 30000) {
+	context->toolong = 1;
+	cs = ascii;
+	str = (unsigned char *) "...";
+	len = 3;
+    }
+    
+    if (lp->nitems == lp->maxitems) {
+	int oldmax = lp->maxitems;
+	if (lp->maxitems < 1)
+	    lp->maxitems = 1;
+	else
+	    lp->maxitems = 2 * lp->maxitems;
+	if (oldmax == 0)
+	    lp->items = (XTextItem16 *)
+				malloc(sizeof(XTextItem16) * lp->maxitems);
+	else
+	    lp->items = (XTextItem16 *)
+				realloc(lp->items,
+					sizeof(XTextItem16) * lp->maxitems);
+    }
+    ip = &lp->items[lp->nitems++];
+    ip->chars = (XChar2b *) context->cbp;
+    ip->nchars = len;
+    ip->delta = context->delta;
+    ip->font = cs->fs->fid;
+    context->cbp += 2 * len;
+    context->delta = 0;
+    
+    if (cs->bpc == 1) {
+	XChar2b *p;
+	unsigned char b7 = cs->bit7 ? 0x80 : 0;
+	int i;
+	for (i = len, p = ip->chars; i > 0; i--, p++) {
+	    p->byte1 = '\0';
+	    p->byte2 = (*str++ & 0x7f) | b7;
+	}
+    } else {
+	XChar2b *p;
+	unsigned char b7 = cs->bit7 ? 0x80 : 0;
+	int i;
+	for (i = len, p = ip->chars; i > 0; i--, p++) {
+	    p->byte1 = (*str++ & 0x7f) | b7;
+	    p->byte2 = (*str++ & 0x7f) | b7;
+	}
+    }
+    
+    lp->width += XTextWidth16(cs->fs, ip->chars, ip->nchars);
+    if (lp->ascent < cs->fs->ascent)
+	lp->ascent = cs->fs->ascent;
+    if (lp->descent < cs->fs->descent)
+	lp->descent = cs->fs->descent;
+}
+
+void get_monofont_size(wide, high)
+    int *wide, *high;
+{
+    if (ascii == NULL) {
+	fputs("ml_draw_text: call ml_set_charsets, first.\n", stderr);
+	return;
+    }
+    *wide = ascii->fs->max_bounds.width;
+    *high = ascii->fs->ascent + ascii->fs->descent;
+}
+
+static void init_xrm()
+{
+    init_xrm_fonts();
+    init_xrm_tab();
+}
+
+static void init_xrm_fonts()
+{
+    char *p, *fns = XGetDefault(theDisp, "xv", "fontSet");
+    int n;
+    if (fns == NULL) {
+	xrm_fonts = default_fonts;
+	xrm_nfonts = sizeof default_fonts / sizeof *default_fonts;
+	return;
+    }
+    while(*fns == ' ' || *fns == '\t')
+	fns++;
+    if (*fns == '\0') {
+	xrm_fonts = default_fonts;
+	xrm_nfonts = sizeof default_fonts / sizeof *default_fonts;
+	return;
+    }
+    fns = strdup(fns);
+    
+    n = 1;
+    for (p = fns; *p != '\0'; p++) {
+	if (*p == ',')
+	    n++;
+    }
+    xrm_nfonts = n;
+    xrm_fonts = (char **) malloc(sizeof (char *) * xrm_nfonts);
+    for (n = 0, p = fns; n < xrm_nfonts && *p != '\0'; ) {
+	while (*p == ' ' || *p == '\t')
+	    p++;
+	xrm_fonts[n++] = p;
+	while (1) {
+	    char *q;
+	    while (*p != ' ' && *p != '\t' && *p != ',' && *p != '\0')
+		p++;
+	    q = p;
+	    while (*q == ' ' || *q == '\t')
+		q++;
+	    if (*q == ',' || *q == '\0') {
+		*p = '\0';
+		p = q + 1;
+		break;
+	    } else
+		p = q;
+	}
+    }
+    for ( ; n < xrm_nfonts; n++)
+	xrm_fonts[n] = "";
+}
+
+static void init_xrm_tab()
+{
+    char *ts = XGetDefault(theDisp, "xv", "tabWidth");
+    unsigned short tab;
+    if (ts == NULL)
+	tab = 64;
+    else {
+	char *ep;
+	long t;
+	int bad = 0;
+	t = strtol(ts, &ep, 0);
+	tab = (unsigned short) t;
+	if (ep != NULL) {
+	    while (*ep == ' ' && *ep == '\t')
+		ep++;
+	    if (*ep != '\0')
+		bad = 1;
+	}
+	if (tab != (long) (unsigned long) t)
+	    bad = 1;
+	if (bad) {
+	    SetISTR(ISTR_WARNING, "bad tab width.");
+	    tab = 64;
+	}
+    }
+    ml_tab_width = tab;
+}
+
+
+#ifndef HAVE_STRDUP
+static char *strdup(str)
+    char *str;
+{
+    return strcpy(malloc(strlen(str) + 1), str);
+}
+#endif
+
+char *lookup_registry(d, b7)
+    struct design d;
+    int *b7;
+{
+    int i;
+    for (i = 0; i < NR_CHARSETS; i++) {
+	if (charset[i].bpc == d.bpc && charset[i].noc == d.noc &&
+	    charset[i].designator == d.des) {
+	    *b7 = charset[i].bit7;
+	    return charset[i].registry;
+	}
+    }
+    return NULL;
+}
+
+struct design lookup_design(registry, b7)
+    char *registry;
+    int b7;
+{
+    struct design d;
+    int i;
+    d.bpc = 0;
+    d.noc = 0;
+    d.des = '\0';
+    for (i = 0; i < NR_CHARSETS; i++) {
+	if (strcmp(charset[i].registry, registry) == 0 &&
+		charset[i].bit7 == b7) {
+	    d.bpc = charset[i].bpc;
+	    d.noc = charset[i].noc;
+	    d.des = charset[i].designator;
+	    break;
+	}
+    }
+    return d;
+}
+
+char *sjis_to_jis(orig, len, newlen)
+    char *orig;
+    int len, *newlen;
+{
+    unsigned char *new;
+    unsigned char *p, *q, *endp;
+    if (len == 0) {
+	*newlen = 0;
+	return (char *) malloc((size_t) 1);
+    }
+    new = (unsigned char *) malloc((size_t) len * 4);	/* enough big */
+    for (p = (unsigned char *) orig, endp = p + len, q = new; p < endp; ) {
+	if ((*p & 0x80) == 0)			/* 1 byte char */
+	    *q++ = *p++;
+	else if (*p >= 0x81 && *p <= 0x9f) {	/* kanji 1st byte */
+	    unsigned char c1 = *p++;
+	    unsigned char c2 = *p++;
+	    if (c2 < 0x40 || c2 > 0xfc) {		/* bad 2nd byte */
+		*q++ = CODE_SS2;
+		*q++ = c1;
+		*q++ = CODE_SS2;
+		*q++ = c2;
+	    } else {					/* right 2nd byte */
+		if (c2 <= 0x9e) {
+		    if (c2 > 0x7f)
+			c2--;
+		    c1 = (c1 - 0x81) * 2 + 1 + 0xa0;
+		    c2 = (c2 - 0x40)     + 1 + 0xa0;
+		} else {
+		    c1 = (c1 - 0x81) * 2 + 2 + 0xa0;
+		    c2 = (c2 - 0x9f)     + 1 + 0xa0;
+		}
+		*q++ = c1;
+		*q++ = c2;
+	    }
+	} else if (*p >= 0xe0 && *p <= 0xef) {	/* kanji 1st byte */
+	    unsigned char c1 = *p++;
+	    unsigned char c2 = *p++;
+	    if (c2 < 0x40 || c2 > 0xfc) {		/* bad 2nd byte */
+		*q++ = CODE_SS2;
+		*q++ = c1;
+		*q++ = CODE_SS2;
+		*q++ = c2;
+	    } else {					/* right 2nd byte */
+		if (c2 <= 0x9e) {
+		    c1 = (c1 - 0xe0) * 2 + 63 + 0xa0;
+		    c2 = (c2 - 0x40)     +  1 + 0xa0;
+		} else {
+		    c1 = (c1 - 0xe0) * 2 + 64 + 0xa0;
+		    c2 = (c2 - 0x9f)     +  1 + 0xa0;
+		}
+		*q++ = c1;
+		*q++ = c2;
+	    }
+	} else {				/* katakana or something */
+	    *q++ = CODE_SS2;
+	    *q++ = *p++;
+	}
+    }
+    *newlen = q - new;
+    
+    return (char *) realloc(new, (size_t) *newlen);
+}
+
+#endif /* TV_MULTILINGUAL */
diff -Naur xv-3.10a.old/xvml.h xv-3.10a/xvml.h
--- xv-3.10a.old/xvml.h	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvml.h	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,96 @@
+#ifndef MLVIEW_H
+#define MLVIEW_H
+
+/*
+ * What is this?
+ *
+ *  It is a package to show multi-lingual text.
+ * 
+ * How to use?
+ * 
+ *  1. Call ml_set_screen(Screen *scr);
+ *	Tell this package the screen you use.
+ *
+ *  2. Call ml_set_charsets(struct char_spec spec[4], int gl, int gr);
+ *	Tell this package the initial charsets.
+ *	Gn is set to the charset specified by spec[n], respectively.
+ *	GL and GR are set to G[gl] and G[gr], respectively.
+ *	If first call, iso8859-1 font is loaded.
+ *
+ *  3. Call ml_draw_text(char *string);
+ *	It Creates a bitmap, and returns it to you.
+ *	If something goes wrong, it returns None.
+ *	DON'T free the returned pixmaps!!
+ *
+ * BUGS:
+ *  - Amharic and Tigrigna characters are strange.
+ *  - Big5 is not supported.
+ *  - Reverse direction is not supported.
+ *  - Composing is not supported.
+ *  - Cantonese can't be shown.
+ *  - Texts which have many lines are buggy.
+ *
+ * NOTE:
+ *  - Shifted JIS and Shifted GB must be converted to iso2022 in advance.
+ *
+ * Example of parameters to ml_set_charsets:
+ *  - EUC-Japan
+ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
+ *		 {2, 94, 'B'},		G1 is JIS X0208
+ *		 {1, 94, 'J'},		G2 is (right-half of)JIS X0201
+ *		 {2, 94, 'D'} };	G3 is JIS X0212
+ *	gl = 0;				GL is G0
+ *	gr = 1;				GR is G1
+ *
+ *  - Compound Text
+ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
+ *		 {1, 96, 'A'},		G1 is Latin-1
+ *		 {1, 94, 'B'},		G2 is US-ASCII (maybe unused)
+ *		 {1, 94, 'B'} };	G3 is US-ASCII (maybe unused)
+ *	gl = 0;				GL is G0
+ *	gr = 1;				GR is G1
+ *
+ *  - Korean Mail
+ *	spec = { {1, 94, 'B'},		G0 is US-ASCII
+ *		 {2, 94, 'C'},		G1 is KSC5601
+ *		 {1, 94, 'B'},		G2 is US-ASCII (maybe unused)
+ *		 {1, 94, 'B'} };	G3 is US-ASCII (maybe unused)
+ *	gl = 0;				GL is G0
+ *	gl = 1;				GR is G1
+ */
+
+struct coding_system {
+    struct design {
+	int bpc;	/* byte per char if 1 or 2,
+			   don't touch if 0, or
+			   don't use if -1.*/
+	int noc;	/* number of chars (94 or 96) */
+	char des;	/* designator ('A', 'B', ...) */
+    } design[4];
+    int gl, gr;
+    int eol;
+    int short_form;
+    int lock_shift;
+};
+
+struct ml_text {
+    int maxlines, nlines;
+    struct ml_line {
+	int maxitems, nitems;
+	int width, ascent, descent;
+	XTextItem16 *items;
+    } *lines;
+    int width, height;
+};
+
+struct context;
+struct ml_text *ml_draw_text		PARM((struct context *, char *, int));
+struct context *ml_create_context	PARM((Screen *));
+int ml_set_charsets			PARM((struct context *,
+					      struct coding_system *));
+void get_monofont_size			PARM((int *, int *));
+char *sjis_to_jis			PARM((char *, int, int *));
+char *lookup_registry			PARM((struct design, int *));
+struct design lookup_design		PARM((char *, int));
+
+#endif
diff -Naur xv-3.10a.old/xvpbm.c xv-3.10a/xvpbm.c
--- xv-3.10a.old/xvpbm.c	Wed Jan  4 06:23:44 1995
+++ xv-3.10a/xvpbm.c	Tue Apr 24 09:37:05 2001
@@ -38,10 +38,83 @@
 
 static char *bname;
 
+
+#ifdef HAVE_MGCSFX
+/*
+ * When file read or file write is fail, probably it's caused by
+ * reading from pipe which has no data yet, or writing to pipe
+ * which is not ready yet.
+ * Then, we can use systemcall select to descriptor of pipe and wait.
+ * if you want, change 'undef' to 'define' in the following line.
+ * This feature is performance killer.
+ */
+#undef FIX_PIPE_ERROR
+
+#ifdef __osf__
+#ifdef __alpha
+#define FIX_PIPE_ERROR
+#endif /* __alpha */
+#endif /* __osf__ */
+
+#endif /* HAVE_MGCSFX */
+
+
+#ifdef FIX_PIPE_ERROR
+
+int pipefdr;
+
+struct timeval timeout;
+int    width;
+fd_set fds;
+
+static void ready_read()
+{
+  if(pipefdr < 0) return; /* if file descriptor is not pipe, OK */
+  WaitCursor();
+
+reselect:
+  /* setting of timeout */
+  timeout.tv_sec = 1;  /* 1 sec */
+  timeout.tv_usec = 0; /* 0 usec */
+
+  FD_ZERO(&fds);     /* clear bits */
+  FD_SET(pipefdr, &fds); /* set bit of fd in fds */
+
+  /* number of file descriptor to want check (0 $B!A(B width-1) */
+  width = pipefdr + 1;
+
+  /* select returns number of file descriptors */
+  if (select(width, &fds, NULL, NULL, &timeout) < 0){
+    if(DEBUG){
+      fprintf(stderr, "No file descriptors can't selected, waiting...\n");
+    }
+    goto reselect;
+  }
+
+  if (FD_ISSET(pipefdr, &fds)){
+    /* Now, descriptor of pipe is ready to read */
+    return;
+  }else{
+    if(DEBUG){
+      fprintf(stderr, "Can't read from pipe yet, waiting...\n");
+    }
+    goto reselect;
+  }
+
+}
+#endif /* FIX_PIPE_ERROR */
+
 /*******************************************/
+#ifdef HAVE_MGCSFX
+int LoadPBM(fname, pinfo, fd)
+     char    *fname;
+     PICINFO *pinfo;
+     int      fd;
+#else
 int LoadPBM(fname, pinfo)
      char    *fname;
      PICINFO *pinfo;
+#endif /* HAVE_MGCSFX */
 /*******************************************/
 {
   /* returns '1' on success */
@@ -50,6 +123,10 @@
   int    c, c1;
   int    maxv, rv;
 
+#ifdef FIX_PIPE_ERROR
+  pipefdr = fd;
+#endif /* FIX_PIPE_ERROR */
+
   garbage = maxv = rv = 0;
   bname = BaseName(fname);
 
@@ -57,6 +134,22 @@
   pinfo->comment = (char *) NULL;
 
 
+#ifdef HAVE_MGCSFX
+  if(fd < 0){
+    /* open the file */
+    fp = xv_fopen(fname,"r");
+    if (!fp) return (pbmError(bname, "can't open file"));
+
+    /* compute file length */
+    fseek(fp, 0L, 2);
+    filesize = ftell(fp);
+    fseek(fp, 0L, 0);
+  }else{
+    fp = fdopen(fd, "r");
+    if (!fp) return (pbmError(bname, "can't open file"));
+    filesize = 0; /* dummy */
+  }
+#else
   /* open the file */
   fp = xv_fopen(fname,"r");
   if (!fp) return (pbmError(bname, "can't open file"));
@@ -65,6 +158,7 @@
   fseek(fp, 0L, 2);
   filesize = ftell(fp);
   fseek(fp, 0L, 0);
+#endif /* HAVE_MGCSFX */
 
 
   /* read the first two bytes of the file to determine which format
@@ -236,7 +330,20 @@
       }
     }
     else {
+#ifdef FIX_PIPE_ERROR
+  reread:
+      numgot += fread(pic8 + numgot, (size_t) 1, (size_t) w*h - numgot, fp); /* read raw data */
+      if(errno == EINTR){
+        if(DEBUG){
+	  fprintf(stderr,
+	  "Can't read all data from pipe, call select and waiting...\n");
+	}
+	ready_read();
+	goto reread;
+      }
+#else
       numgot = fread(pic8, (size_t) 1, (size_t) w*h, fp);  /* read raw data */
+#endif /* FIX_PIPE_ERROR */
     }
   }
 
@@ -297,7 +404,20 @@
       }
     }
     else {
+#ifdef FIX_PIPE_ERROR
+  reread:
+      numgot += fread(pic24 + numgot, (size_t) 1, (size_t) w*h*3 - numgot, fp);  /* read data */
+      if(errno == EINTR){
+        if(DEBUG){
+	  fprintf(stderr,
+	  "Can't read all data from pipe, call select and waiting...\n");
+	}
+	ready_read();
+	goto reread;
+      }
+#else
       numgot = fread(pic24, (size_t) 1, (size_t) w*h*3, fp);  /* read data */
+#endif /* FIX_PIPE_ERROR */
     }
   }
   
diff -Naur xv-3.10a.old/xvpcd.c xv-3.10a/xvpcd.c
--- xv-3.10a.old/xvpcd.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvpcd.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,1029 @@
+/*
+ * xvpcd.c - load routine for 'PhotoCD' format pictures
+ *
+ * LoadPCD(fname, pinfo, size)  -  loads a PhotoCD file
+ *
+ * This routine will popup a choice of which of the 5 available resolutions
+ * the user wants to choose, then load it as a 24 bit image.
+ *
+ * Copyright 1993 David Clunie, Melbourne, Australia.
+ *
+ * The outline of this is shamelessly derived from xvpbm.c to read the
+ * file, and xvtiffwr.c to handle the popup window and X stuff (X never
+ * has been my forte !), and the PhotoCD format information (though not
+ * the code) was found in Hadmut Danisch's (danisch@ira.uka.de) hpcdtoppm
+ * program in which he has reverse engineered the format by studying
+ * hex dumps of PhotoCDs ! After all who can afford the Kodak developer's
+ * kit, which none of us have seen yet ? Am I even allowed to mention these
+ * words (Kodak, PhotoCD) ? I presume they are registered trade marks.
+ *
+ * PS. I have no idea how Halmut worked out the YCC <-> RGB conversion
+ * factors, but I have calculated them from his tables and the results
+ * look good enough to me.
+ *
+ * Added size parameter to allow the schnautzer to create thumnails
+ * without requesting the size every time.
+ */
+
+#define trace (void)
+#define HAVE_PCD_DIALOG
+
+#include "xv.h"
+#include <memory.h>
+
+#ifdef HAVE_PCD
+
+/* comments on error handling:
+   a truncated file is not considered a Major Error.  The file is loaded, the
+   rest of the pic is filled with 0's.
+
+   not being able to malloc is a Fatal Error.  The program is aborted. */
+
+
+static void magnify                   PARM((int,int,int,int,int,byte*));
+static int pcdError                   PARM((char*,char*));
+static int gethuffdata                PARM((byte*,byte*,byte*,int,int));
+
+#define wcurfactor 16		/* Call WaitCursor() every n rows */
+
+static char *bname;
+
+static int size;                /* Set by window routines */
+
+static int leaveitup;		/* Cleared by docmd() when OK or CANCEL pressed */
+static int goforit;             /* Set to 1 if OK or 0 if CANCEL */
+
+static FILE  *fp;
+
+
+/*******************************************/
+int LoadPCD(fname, pinfo,theSize)
+     char    *fname;
+     PICINFO *pinfo;
+	 int	theSize;
+/* The size should be -1 for the popup to ask otherwise fast is assumed */
+/*******************************************/
+{
+  /* returns '1' on success */
+
+  int    rv;
+  long   offset;
+  int    mag;
+
+  byte *pic24, *luma, *chroma1, *chroma2, *ptr, *lptr, *c1ptr, *c2ptr;
+  int   w, h;
+  int   row, col;
+
+  int   huffplanes;
+
+  bname = BaseName(fname);
+
+  pinfo->pic     = (byte *) NULL;
+  pinfo->comment = (char *) NULL;
+
+
+  /* open the file */
+  fp=fopen(fname,"r");
+  if (!fp) return (pcdError(bname, "can't open file"));
+
+/* base/16
+	- plain data starts at sector 1+2+1=4
+	  (numbered from 0, ie. the 5th sector)
+	- luma 192*128 = 24576 bytes (12 sectors)
+	  + chroma1 96*64 = 6144 bytes (3 sectors)
+	  + chroma2 96*64 = 6144 bytes (3 sectors)
+	  = total 18 sectors
+
+	- NB. "Plain" data is interleaved - 2 luma rows 192 wide,
+	  then 1 of each of the chroma rows 96 wide !
+
+   base/4
+	- plain data starts at sector 1+2+1+18+1=23
+	- luma 384*256 = 98304 bytes (48 sectors)
+	  + chroma1 192*128 = 24576 bytes (12 sectors)
+	  + chroma2 192*128 = 24576 bytes (12 sectors)
+	  = total 72 sectors
+
+	- NB. "Plain" data is interleaved - 2 luma rows 384 wide,
+	  then 1 of each of the chroma rows 192 wide !
+
+   base
+	- plain data starts at sector 1+2+1+18+1+72+1=96
+
+	- luma 768*512 = 393216 bytes (192 sectors)
+	  + chroma1 384*256 = 98304 bytes (48 sectors)
+	  + chroma2 384*256 = 98304 bytes (48 sectors)
+	  = total 288 sectors
+
+	- NB. "Plain" data is interleaved - 2 luma rows 768 wide,
+	  then 1 of each of the chroma rows 384 wide !
+
+   4base
+	- plain data for base is read
+	- luma data interpolated *2
+	- chroma data interpolated *4
+
+	- cd_offset is 1+2+1+18+1+72+1+288=384
+	- at cd_offset+4 (388) is huffman table
+	- at cd_offset+5 (389) is 4base luma plane
+
+	(the sector at cd_offset+3 seems to contain 256 words each of
+	which is an offset presumably to the sector containing certain
+	rows ? rows/4 given 1024 possible rows. The rest of this sector
+	is filled with zeroes)
+
+
+   16base
+	- plain data for base is read
+	- luma data interpolated *2
+	- chroma data interpolated *4
+
+	- cd_offset is 1+2+1+18+1+72+1+288=384
+	- at cd_offset+4 (388) is huffman table for 4 base
+	- at cd_offset+5 (389) is 4base luma plane
+	- luma plane interpolated *2
+
+	- cd_offset is set to current position (should be start of sector)
+	- at cd_offset+12 is huffman table for 16 base
+	- at cd_offset+14 is 16 base luma & 2 chroma planes which are read
+          (note that the luma plane comes first, with a sync pattern
+           announcing each row from 0 to 2047, then the two chroma planes
+           are interleaved by row, the row # being even from 0 to 2046, with
+           each row containing 1536 values, the chroma1 row coming first,
+           finally followed by a sync pattern with a row of 2048 announcing
+           the end (its plane seems to be set to 3, ie. chroma2)
+	- chroma planes interpolated *2
+
+	(the sector at cd_offset+10 & 11 seem to contain 1024 pairs of words
+        the first for luma and the second for chroma, each of
+	which is an offset presumably to the sector containing certain
+	rows ? rows/2 given 2048 possible rows)
+
+Not yet implemented:
+
+In order to do overskip for base and 4base, one has to reach the chroma
+data for 16 base:
+
+	- for 4base, after reading the 4base luma plane (and presumably
+	  skipping the chroma planes) one sets cd_offset to the start of
+	  the "current" sector
+
+	- for base, one has to skip the 4base data first:
+	- cd_offset is set to 384
+	- at (cd_offset+3 sectors)[510] is a 16 bit word high byte 1st
+	  containing an offset to the beginning of the 16base stuff
+	  though there is then a loop until >30 0xff's start a sector !
+
+	- being now positioned after the end of the 4base stuff,
+	- at (cd_offset+10 sectors)[2] is a 16 bit word high byte 1st
+	  containing an offset to the chroma planes.
+	- at cd_offset+12 is the set of huffman tables
+
+	- for base, the 16base chroma planes are then halved
+*/
+
+#ifdef HAVE_PCD_DIALOG
+    PCDSetParamOptions(bname);
+	if (theSize == -1)
+	{
+    	PCDDialog(1);                   /* Open PCD Dialog box */
+    	SetCursors(-1);                 /* Somebody has already set it to wait :( */
+    	leaveitup=1;
+    	goforit=0;
+    	/* block until the popup window gets closed */
+    	while (leaveitup) {
+      	int i;
+      	XEvent event;
+      	XNextEvent(theDisp, &event);
+      	HandleEvent(&event, &i);
+    	}
+    	/* At this point goforit and size will have been set */
+    	if (!goforit) {
+      		/* nothing allocated so nothing needs freeing */
+      		return 0;
+    	}
+    	WaitCursor();
+	}
+	else 
+	{
+		size = theSize;
+		goforit = 1;
+	}
+#else /* HAVE_PCD_DIALOG */
+  {
+    static char *sizeoptions[3] = { "0192*128", "1384*256","2768*512" };
+    size=PopUp("Which of the stored resolutions would you like ?",sizeoptions,3);
+  }
+#endif /* HAVE_PCD_DIALOG */
+
+  switch (size) {
+  case 0:
+    pinfo->w=192;
+    pinfo->h=128;
+    offset=4*0x800;
+    mag=1;
+    huffplanes=0;
+    sprintf(pinfo->fullInfo, "PhotoCD, base/16 resolution");
+    break;
+  case 1:
+    pinfo->w=384;
+    pinfo->h=256;
+    offset=23*0x800;
+    mag=1;
+    huffplanes=0;
+    sprintf(pinfo->fullInfo, "PhotoCD, base/4 resolution");
+    break;
+  case 2:
+  default:
+    pinfo->w=768;
+    pinfo->h=512;
+    offset=96*0x800;
+    mag=1;
+    huffplanes=0;
+    sprintf(pinfo->fullInfo, "PhotoCD, base resolution");
+    break;
+  case 3:
+    pinfo->w=1536;
+    pinfo->h=1024;
+    offset=96*0x800;
+    mag=2;
+    huffplanes=1;
+    sprintf(pinfo->fullInfo, "PhotoCD, 4base resolution");
+    break;
+  case 4:
+    pinfo->w=3072;
+    pinfo->h=2048;
+    offset=96*0x800;
+    mag=4;
+    huffplanes=2;
+    sprintf(pinfo->fullInfo, "PhotoCD, 16base resolution");
+    break;
+  }
+
+  /* allocate 24-bit image */
+  pinfo->pic = (byte *) calloc(pinfo->w*pinfo->h*3,1);
+  if (!pinfo->pic) FatalError("couldn't malloc '24 bit rgb plane'");
+
+  pinfo->type = PIC24;
+  sprintf(pinfo->shrtInfo, "%dx%d PhotoCD.", pinfo->w, pinfo->h);
+  pinfo->colType = F_FULLCOLOR;
+  pinfo->frmType = -1;
+
+  if (fseek(fp,offset,0) == -1)
+    return pcdError(bname,"Can't find start of data.");
+
+  w = pinfo->w;  h = pinfo->h;
+  pic24 = pinfo->pic;
+
+  luma=(byte *) calloc(w*h,1);
+  if (!luma) FatalError("couldn't malloc 'luma plane'");
+  chroma1=(byte *) calloc(w*h/4,1);
+  if (!chroma1) FatalError("couldn't malloc 'chroma1 plane'");
+  chroma2=(byte *) calloc(w*h/4,1);
+  if (!chroma2) FatalError("couldn't malloc 'chroma2 plane'");
+
+  /* Read 2 luma rows length w, then one of each chroma rows w/2 */
+  /* If a mag factor is active, the small image is read into the */
+  /* top right hand corner of the larger allocated image */
+
+  for (row=0,lptr=luma,c1ptr=chroma1,c2ptr=chroma2; row <h/mag;
+       row+=2,lptr+=w*2,c1ptr+=w/2,c2ptr+=w/2) {
+    if (fread(lptr, 1, w/mag, fp) != w/mag) {
+      pcdError(bname,"Luma plane too short.");
+      break;
+    }
+    if (fread(lptr+w, 1, w/mag, fp) != w/mag) {
+      pcdError(bname,"Luma plane too short.");
+      break;
+    }
+    if (fread(c1ptr, 1, w/2/mag, fp) != w/2/mag) {
+      pcdError(bname,"Chroma1 plane too short.");
+      break;
+    }
+    if (fread(c2ptr, 1, w/2/mag, fp) != w/2/mag) {
+      pcdError(bname,"Chroma2 plane too short.");
+      break;
+    }
+    if (row%wcurfactor == 0) WaitCursor();
+  }
+
+  if (huffplanes) {
+    if (fseek(fp,388*0x800,0) == -1) {
+      return pcdError(bname,"Can't find start of huffman tables.");
+    }
+    magnify(2,h/mag,w/mag,h,w,luma);
+    magnify(2,h/2/mag,w/2/mag,h/2,w/2,chroma1);
+    magnify(2,h/2/mag,w/2/mag,h/2,w/2,chroma2);
+
+    /* doesn't really touch the chroma planes which aren't present in 4base */
+    gethuffdata(luma,chroma1,chroma2,w,h/mag*2);
+    /* if only doing 4base should probably fetch 16bases chroma planes here */
+
+    if (huffplanes == 2) {
+      /* This depends on gethuffdata() having grabbed things in 0x800 sectors */
+      /* AND still being positioned in the "last" sector of the data */
+      /* (cf. Hadmut's code which is positioned at start of the next sector) */
+      long offset=ftell(fp)/0x800+13;
+      trace(stderr,"New offset=%ld\n",(long)offset);
+      if (fseek(fp,offset*0x800,0) == -1) {
+        return pcdError(bname,"Can't find start of huffman tables.");
+      }
+      magnify(2,h/2,w/2,h,w,luma);
+      magnify(2,h/4,w/4,h/2,w/2,chroma1);
+      magnify(2,h/4,w/4,h/2,w/2,chroma2);
+
+      gethuffdata(luma,chroma1,chroma2,w,h);
+    }
+  }
+
+  ptr=pic24; lptr=luma; c1ptr=chroma1; c2ptr=chroma2;
+  for (row=0; row < h; row++) {
+    byte *rowc1ptr, *rowc2ptr;
+    rowc1ptr=c1ptr;
+    rowc2ptr=c2ptr;
+    for (col=0; col < w; col++) {
+      int r,g,b;
+      int y =*lptr++;
+      int c1=*c1ptr;
+      int c2=*c2ptr;
+
+      r = (5564 * y + 2048 + 7461 * c2 - 1022138)/4096;
+      g = (5564 * y + 2048 + 274934 - 1762 * c1 + 520268 - 3798 * c2)/4096; 
+      b = (5564 * y + 2048 + 9085 * c1 - 1417185)/4096;
+
+      if (r > 255) r=255;
+      if (r < 0 ) r=0;
+      if (g > 255) g=255;
+      if (g < 0 ) g=0;
+      if (b > 255) b=255;
+      if (b < 0 ) b=0;
+
+      *ptr++=r;
+      *ptr++=g;
+      *ptr++=b;
+      if (col%2) { ++c1ptr; ++c2ptr; }
+    }
+    if (row%2 == 0) { c1ptr=rowc1ptr; c2ptr=rowc2ptr; }
+    if (row%wcurfactor == 0) WaitCursor();
+  }
+
+  free(luma); free(chroma1); free(chroma2);
+
+  rv = 1;
+
+  fclose(fp);
+
+  if (!rv) {
+    if (pinfo->pic) free(pinfo->comment);
+    if (pinfo->comment) free(pinfo->comment);
+    pinfo->pic     = (byte *) NULL;
+    pinfo->comment = (char *) NULL;
+  }
+
+  return rv;
+}  
+
+
+/*******************************************/
+
+/* derived from Hadmut Danisch's interpolate() */
+
+static void
+magnify(mag,h,w,mh,mw,p)
+int mag;	/* power of 2 by which to magnify in place */
+int h,w;	/* the "start" unmag'd dimensions of the data in the array */
+int mh,mw;	/* the real (maximum) dimensions of the array */
+unsigned char *p;	/* pointer to the data */
+{
+  int x,y,yi;
+  unsigned char *optr,*nptr,*uptr;  /* MUST be unsigned, else averaging fails */
+
+  while (mag > 1) {
+
+    /* create every 2nd new row from 0 */
+    /*  even pixels being equal to the old, odd ones averaged with successor */
+    /*  special case being the last column which is just set equal to the */
+    /*  second last) ... */
+
+    for(y=0;y<h;y++) {
+      yi=h-1-y;
+      optr=p+  yi*mw + (w-1);	          /* last pixel of an old row */
+      nptr=p+2*yi*mw + (2*w - 2);         /* last pixel of a new row */
+
+      nptr[0]=nptr[1]=optr[0];            /* special cases */
+
+      for(x=1;x<w;x++) {
+        optr--; nptr-=2;                  /* next lower pixel(s) */
+        nptr[0]=optr[0];                  /* even pixels duped */
+        nptr[1]=(((int)optr[0])+
+                 ((int)optr[1])+1)>>1;    /* odd averaged */
+      }
+    }
+
+    /* Fill in odd rows, as average of prior & succeeding rows, with */
+    /* even pixels average of one column, odd pixels average of two */
+
+    for(y=0;y<h-1;y++) {                  /* all but the last old row */
+      optr=p + 2*y*mw;                    /* start of the new "even" rows */
+      nptr=optr+mw;                       /* start of the next empty row */
+      uptr=nptr+mw;                       /* start of the next again (even) */
+
+      for(x=0;x<w-1;x++) {                /* for all cols except the last */
+        nptr[0]=(((int)optr[0])+
+                 ((int)uptr[0])+1)>>1;    /* even pixels */
+        nptr[1]=(((int)optr[0])+
+                 ((int)optr[2])+
+                 ((int)uptr[0])+
+                 ((int)uptr[2])+2)>>2;    /* odd pixels */
+        nptr+=2; optr+=2; uptr+=2;
+      }
+      *(nptr++)=(((int)*(optr++))+
+                 ((int)*(uptr++))+1)>>1;  /* 2nd last pixel */
+      *(nptr++)=(((int)*(optr++))+
+                 ((int)*(uptr++))+1)>>1;  /* last pixel */
+    }
+
+    xvbcopy((char *) (p + (2*h-2)*mw),    /* 2nd last row */
+            (char *) (p + (2*h-1)*mw),    /* the last row */
+            (size_t) (2*w));              /* length of a new row */
+
+    h*=2; w*=2;
+    mag>>=1;	/* Obviously mag must be a power of 2 ! */
+  }
+}
+
+
+/*******************************************/
+static int pcdError(fname, st)
+     char *fname, *st;
+{
+  SetISTR(ISTR_WARNING, "%s:  %s", fname, st);
+  return 0;
+}
+
+
+/**** Stuff for PCDDialog box ****/
+
+#define TWIDE 380
+#define THIGH 160
+#define T_NBUTTS 2
+#define T_BOK    0
+#define T_BCANC  1
+#define BUTTH    24
+
+static void drawTD                    PARM((int,int,int,int));
+static void clickTD                   PARM((int,int));
+static void doCmd                     PARM((int));
+static void PCDSetParams              PARM((void));
+
+
+/* local variables */
+static BUTT  tbut[T_NBUTTS];
+static RBUTT *resnRB;
+
+
+
+/***************************************************/
+void CreatePCDW()
+{
+  int	     y;
+
+  pcdW = CreateWindow("xv pcd", "XVpcd", NULL, 
+		       TWIDE, THIGH, infofg, infobg, 0);
+  if (!pcdW) FatalError("can't create pcd window!");
+
+  XSelectInput(theDisp, pcdW, ExposureMask | ButtonPressMask | KeyPressMask);
+
+  BTCreate(&tbut[T_BOK], pcdW, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+	   "Ok", infofg, infobg, hicol, locol);
+
+  BTCreate(&tbut[T_BCANC], pcdW, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+	   "Cancel", infofg, infobg, hicol, locol);
+
+  y = 55;
+  resnRB = RBCreate(NULL, pcdW, 36, y,   "192*128   Base/16",
+           infofg, infobg,hicol,locol);
+  RBCreate(resnRB, pcdW, 36, y+18,       "384*256   Base/4",
+           infofg, infobg,hicol,locol);
+  RBCreate(resnRB, pcdW, 36, y+36,       "768*512   Base",
+           infofg, infobg, hicol, locol);
+  RBCreate(resnRB, pcdW, TWIDE/2, y,     "1536*1024 4Base",
+           infofg, infobg, hicol, locol);
+  RBCreate(resnRB, pcdW, TWIDE/2, y+18,  "3072*2048 16Base",
+           infofg, infobg, hicol, locol);
+#ifdef CRAP
+  RBCreate(resnRB, pcdW, TWIDE/2, y+36,  "Other",
+           infofg, infobg, hicol, locol);
+#endif
+
+  XMapSubwindows(theDisp, pcdW);
+}
+  
+
+/***************************************************/
+void PCDDialog(vis)
+int vis;
+{
+  if (vis) {
+    CenterMapWindow(pcdW, tbut[T_BOK].x + tbut[T_BOK].w/2,
+		    tbut[T_BOK].y + tbut[T_BOK].h/2, TWIDE, THIGH);
+  }
+  else     XUnmapWindow(theDisp, pcdW);
+  pcdUp = vis;
+}
+
+
+/***************************************************/
+int PCDCheckEvent(xev)
+XEvent *xev;
+{
+  /* check event to see if it's for one of our subwindows.  If it is,
+     deal accordingly, and return '1'.  Otherwise, return '0' */
+
+  int rv;
+  rv = 1;
+
+  if (!pcdUp) return 0;
+
+  if (xev->type == Expose) {
+    int x,y,w,h;
+    XExposeEvent *e = (XExposeEvent *) xev;
+    x = e->x;  y = e->y;  w = e->width;  h = e->height;
+
+    if (e->window == pcdW)       drawTD(x, y, w, h);
+    else rv = 0;
+  }
+
+  else if (xev->type == ButtonPress) {
+    XButtonEvent *e = (XButtonEvent *) xev;
+    int x,y;
+    x = e->x;  y = e->y;
+
+    if (e->button == Button1) {
+      if      (e->window == pcdW)     clickTD(x,y);
+      else rv = 0;
+    }  /* button1 */
+    else rv = 0;
+  }  /* button press */
+
+
+  else if (xev->type == KeyPress) {
+    XKeyEvent *e = (XKeyEvent *) xev;
+    char buf[128];  KeySym ks;  XComposeStatus status;  
+    int stlen;
+	
+    stlen = XLookupString(e,buf,128,&ks,&status);
+    buf[stlen] = '\0';
+
+    if (e->window == pcdW) {
+      if (stlen) {
+	if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
+	  FakeButtonPress(&tbut[T_BOK]);
+	}
+	else if (buf[0] == '\033') {            /* ESC */
+	  FakeButtonPress(&tbut[T_BCANC]);
+	}
+      }
+    }
+    else rv = 0;
+  }
+  else rv = 0;
+
+  if (rv==0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
+    XBell(theDisp, 50);
+    rv = 1;   /* eat it */
+  }
+
+  return rv;
+}
+
+
+/***************************************************/
+void PCDSetParamOptions(fname)
+char *fname;
+{
+  int cur;
+  cur = RBWhich(resnRB);
+
+  RBSetActive(resnRB,0,1);
+  RBSetActive(resnRB,1,1);
+  RBSetActive(resnRB,2,1);
+  RBSetActive(resnRB,3,1);
+  RBSetActive(resnRB,4,1);
+  RBSetActive(resnRB,5,0);
+}
+
+
+/***************************************************/
+static void drawTD(x,y,w,h)
+int x,y,w,h;
+{
+  char *title  = "Load PhotoCD file...";
+  int  i;
+  XRectangle xr;
+
+  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
+  XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
+
+  XSetForeground(theDisp, theGC, infofg);
+  XSetBackground(theDisp, theGC, infobg);
+
+  for (i=0; i<T_NBUTTS; i++) BTRedraw(&tbut[i]);
+
+  ULineString(pcdW, resnRB->x-16, resnRB->y-10-DESCENT, "Resolution");
+  RBRedraw(resnRB, -1);
+
+  DrawString(pcdW, 20, 19, title);
+
+  XSetClipMask(theDisp, theGC, None);
+}
+
+
+/***************************************************/
+static void clickTD(x,y)
+int x,y;
+{
+  int i;
+  BUTT *bp;
+
+  /* check BUTTs */
+
+  /* check the RBUTTS first, since they don't DO anything */
+  if ( (i=RBClick(resnRB, x,y)) >= 0) { 
+    (void) RBTrack(resnRB, i);
+    return;
+  }
+
+
+  for (i=0; i<T_NBUTTS; i++) {
+    bp = &tbut[i];
+    if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
+  }
+
+  if (i<T_NBUTTS) {  /* found one */
+    if (BTTrack(bp)) doCmd(i);
+  }
+}
+
+
+
+/***************************************************/
+static void doCmd(cmd)
+int cmd;
+{
+  leaveitup=0;
+  goforit=0;
+  switch (cmd) {
+  case T_BOK:  	PCDSetParams();
+                goforit=1;
+  case T_BCANC:	PCDDialog(0);
+                break;
+
+  default:	break;
+  }
+}
+
+
+/*******************************************/
+static void PCDSetParams()
+{
+  switch (RBWhich(resnRB)) {
+  case 0: size = 0;      break;
+  case 1: size = 1;      break;
+  case 2: size = 2;      break;
+  case 3: size = 3;      break;
+  case 4: size = 4;      break;
+  case 5: size = 0;      break;
+  default: size = 0;     break;
+  }
+}
+
+typedef char schar;  /* signed char */
+
+typedef int ihufftab;  /* Must be signed */
+
+static ihufftab *hufftable[3];
+static int hufflength[3];
+
+/*
+
+Read the Huffman tables which consist of an unsigned byte # of entries
+(less 1) followed by up to 256 entries, each of which is a series of 4
+unsigned bytes - length, highseq, lowseq, and key.
+
+Store the huffman table into tree type structure:
+
+	int ihufftab[n of entries*2]
+
+Each entry consists of two words (the 1st for zero and the 2nd for one).
+
+If the word is negative, then subtract it from the current pointer to
+get the next entry (ie. it is the negative offset from the current
+position*2 in order to skip entries not words) with which to make a decision.
+
+If the word is not negative, then the low 8 bits contain the value (which
+is supposed to be a signed char) and the rest of the word is zero.
+
+*/
+
+static ihufftab *
+gethufftable(alength)
+int *alength;
+{
+  unsigned num,i,offset;
+
+  ihufftab *hufftab,*huffptr,*hufftop;
+
+  num=fgetc(fp)+1;
+
+  trace(stderr,"gethufftable: hufftab length %u\n",num);
+
+  if ((hufftab=(ihufftab *)malloc(2*num*sizeof(ihufftab))) == 0) {
+    fprintf(stderr,"Can't allocate hufftab length %u\n",num);
+    exit(1);
+  }
+  for (i=0,huffptr=hufftab; i<2*num; i++)
+    *huffptr++=0;  /* Fill value is zero */
+
+  hufftop=hufftab;
+
+  for (i=0,offset=1; i<num; i++,offset+=4){
+    unsigned length=fgetc(fp);
+    unsigned msbseq=fgetc(fp);
+    unsigned lsbseq=fgetc(fp);
+    unsigned codeword=msbseq<<8|lsbseq;
+    unsigned value =fgetc(fp);
+    {
+      unsigned j;
+      huffptr=hufftab;
+      for (j=0; j<16; j++) {
+        int bit=codeword & 0x8000;
+        codeword<<=1;
+
+        if (j == length) {
+          if (bit) *++huffptr=value;
+          else *huffptr=value;
+        }
+        else {
+          if (j < length) {
+            if (bit) {
+              ++huffptr;
+            }
+            if (*huffptr >= 0) {
+              hufftop+=2;
+              if (hufftop-hufftab >2*num) {
+                fprintf(stderr,"Table overflow\n");
+                exit(1);
+              }
+              *huffptr=-(hufftop-huffptr);
+            }
+            huffptr-=*huffptr;
+          }
+        }
+      }
+    }
+  }
+
+  *alength=num;
+  return hufftab;
+}
+
+/* WORDTYPE & char buffer must be unsigned else */
+/* fills with sign bit not 0 on right shifts */
+typedef unsigned int WORDTYPE;
+typedef int SWORDTYPE;
+#define WORDSIZE sizeof(WORDTYPE)
+#define NBYTESINBUF 0x800
+
+static unsigned char buffer[NBYTESINBUF];
+static int bitsleft=0;
+static int bytesleft=0;
+static unsigned char *bufptr;
+static WORDTYPE word;
+
+/* assume WORDTYPE is 32 bit word */
+#define issync()  ((word & 0xffffff00) == 0xfffffe00)
+#define skiptosync()  { while (!issync()) (void)getbit(); }
+
+static void
+dumpbuffer()
+{
+  int i,left;
+  unsigned char *ptr=buffer;
+
+  fprintf(stderr,"dumpbuffer: bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+  for (left=NBYTESINBUF; left>0; left-=16) {
+    fprintf(stderr,"%05d  ",left);
+    for (i=0; i<8; i++) {
+      fprintf(stderr,"%02x",*ptr++);
+      fprintf(stderr,"%02x ",*ptr++);
+    }
+    fprintf(stderr,"\n");
+  }
+}
+
+static void
+loadbuffer()
+{
+  trace(stderr,"loadbuffer: start at sector %ld\n",(long)ftell(fp)/0x800
+);
+  if ((bytesleft=fread(buffer,1,NBYTESINBUF,fp)) == 0) {
+    fprintf(stderr,"Truncation error\n");
+    exit(1);
+  }
+  bufptr=buffer;
+  trace(stderr,"loadbuffer: Loaded buffer with %d bytes\n",bytesleft);
+  /* dumpbuffer(); */
+}
+
+static void
+loadbyte()
+{
+  trace(stderr,"loadbyte: start bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+  if (bytesleft <= 0) loadbuffer();
+  --bytesleft;
+  word|=(WORDTYPE)(*bufptr++)<<(sizeof(WORDTYPE)*8-8-bitsleft);
+  bitsleft+=8;
+  trace(stderr,"loadbyte: done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+}
+
+static int
+getbit()
+{
+  int bit;
+
+  trace(stderr,"getbit:   start bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+
+  while (bitsleft <= 0) loadbyte();
+  --bitsleft;
+  bit=(SWORDTYPE)(word)<0;  /* assumes word is signed */
+  /* bit=word>>(sizeof(WORDTYPE)*8-1); */
+  word<<=1;
+
+  trace(stderr,"getbit:   done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+  trace(stderr,"getbit:   done  bit=%d\n",bit);
+
+  return bit;
+}
+
+static WORDTYPE
+getnn(nn)
+int nn;
+{
+  WORDTYPE value;
+
+  trace(stderr,"getnn:    start nn=%d\n",nn);
+  trace(stderr,"getnn:    start bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+
+  while (bitsleft <= nn) loadbyte();
+  bitsleft-=nn;
+  value=word>>(sizeof(WORDTYPE)*8-nn);
+  word<<=nn;
+
+  trace(stderr,"getnn:    done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+  trace(stderr,"getnn:    done  value=0x%08lx\n",(unsigned long)value);
+
+  return value;
+}
+
+static WORDTYPE
+isnn(nn)
+int nn;
+{
+  WORDTYPE value;
+
+  trace(stderr,"isnn:     start nn=%d\n",nn);
+  trace(stderr,"isnn:     start bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+
+  while (bitsleft <= nn) loadbyte();
+  value=word>>(sizeof(WORDTYPE)*8-nn);
+
+  trace(stderr,"isnn:     done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+  trace(stderr,"isnn:     done  value=0x%08lx\n",(unsigned long)value);
+
+  return value;
+}
+
+static void
+skipnn(nn)
+int nn;
+{
+  trace(stderr,"skipnn:   start nn=%d\n",nn);
+  trace(stderr,"skipnn:   start bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+
+  while (bitsleft <= nn) loadbyte();
+  bitsleft-=nn;
+  word<<=nn;
+
+  trace(stderr,"skipnn:   done  bytesleft=%d bitsleft= %d word=0x%08lx\n",
+    bytesleft,bitsleft,(unsigned long)word);
+}
+
+#define get1()    (getbit())
+#define get2()    (getnn(2))
+#define get8()    (getnn(8))
+#define get13()    (getnn(13))
+#define get16()    (getnn(16))
+#define get24()    (getnn(24))
+
+#define is8()    (isnn(8))
+#define is16()    (isnn(16))
+#define is24()    (isnn(24))
+
+#define skip1()    (skipnn(1))
+#define skip8()    (skipnn(8))
+#define skip16()  (skipnn(16))
+#define skip24()  (skipnn(24))
+
+static int
+gethuffdata(luma,chroma1,chroma2,realrowwidth,maxrownumber)
+byte *luma, *chroma1, *chroma2;
+int realrowwidth;
+int maxrownumber;
+{
+    int row,plane,charcount;
+    int i;
+
+    trace(stderr,"gethuffdata: start\n");
+
+    /* should really only look for luma plane for 4base, but the */
+    /* there are zeroes in the rest of the sector that give both */
+    /* chroma tables 0 length */
+
+    for (i=0; i<3; i++) hufftable[i]=gethufftable(&hufflength[i]);
+
+    while (is24() != 0xfffffe) {
+      (void)get24();
+      trace(stderr,"Skipping for sync\n");
+    }
+    for (;;) {
+      ihufftab *huffstart;
+      schar    *pixelptr;
+
+      if (is24() == 0xfffffe) {
+        skip24();
+        trace(stderr,"Charcount=%d\n",charcount);
+        charcount=0;
+        plane=get2();
+        row=get13();
+        skip1();
+        trace(stderr,"Plane %d Row %d\n",plane,row);
+        if (row>=maxrownumber) {
+          trace(stderr,"Stopping at row %d\n",row);
+          break;
+        }
+        switch (plane) {
+          case 0:    huffstart=hufftable[0];
+                     pixelptr=(schar *) (luma+row*realrowwidth);
+                     trace(stderr,"Setting luma plane\n");
+                     break;
+          case 2:    huffstart=hufftable[1];
+                     pixelptr=(schar *) (chroma1+row/2*realrowwidth/2);
+                     trace(stderr,"Setting chroma1 plane\n");
+                     break;
+          case 3:    huffstart=hufftable[2];
+                     pixelptr=(schar *) (chroma2+row/2*realrowwidth/2);
+                     trace(stderr,"Setting chroma2 plane\n");
+                     break;
+          default:   fprintf(stderr,"Bad plane %d\n",plane);
+                     exit(1);
+        }
+        WaitCursor();
+      }
+      else {
+        ihufftab *huffptr=huffstart;
+        for (;;) {
+          int bit;
+          bit=get1();    /* never fails :) */
+          huffptr+=bit;    /* select entry 0 or entry 1 */
+          if (*huffptr < 0) {  /* flag to choose next entry */
+            huffptr-=*huffptr;
+          }
+          else {      /* found the value for the code */
+            schar value = *huffptr;
+            (*(pixelptr+charcount))+=value;  /* in lower 8 bits */
+            /* probably don't need to mask with 0xff */
+            ++charcount;
+            trace(stderr,"[%d]=%d\n",charcount,(int)value);
+            break;
+          }
+        }
+      }
+    }
+    trace(stderr,"Out ... \n");
+
+    for (i=0; i<3; i++) if (hufftable[i]) free(hufftable[i]);
+
+    return 1;
+}
+#endif /* HAVE_PCD */
diff -Naur xv-3.10a.old/xvpi.c xv-3.10a/xvpi.c
--- xv-3.10a.old/xvpi.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvpi.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,1060 @@
+/*
+ * xvpi.c - load routine for `Pi' format pictures.
+ *
+ * The `Pi' format is made by Yanagisawa.
+ * It is common among many Japanese personal computer users.
+ * 
+ */
+
+#include "xv.h"
+#include <setjmp.h>
+
+#ifdef HAVE_PI
+
+typedef unsigned short data16;
+typedef unsigned int data32;
+
+struct pi_info {
+    jmp_buf jmp;
+    FILE *fp;
+    struct {
+	int rest;
+	byte cur;
+    }bs;
+    long fsize;
+    byte mode;
+    int width, height;
+    float aspect;
+    int cbits;
+    int numcols;
+    byte *cmap;
+    struct ct_t{
+	struct elt_t *top;
+	struct elt_t{
+	    struct elt_t *old, *recent;
+	    byte val;
+	} *elt;
+    }*ct;
+    int defcmap;
+    int writing_grey;
+};
+
+static void pi_open_file         PARM((struct pi_info*, char*));
+static void pi_read_header       PARM((struct pi_info*, char**));
+static void pi_check_id          PARM((struct pi_info*));
+static void pi_read_comment      PARM((struct pi_info*, char**));
+static void pi_read_palette      PARM((struct pi_info*));
+static void pi_expand            PARM((struct pi_info*, byte**));
+static byte pi_read_color        PARM((struct pi_info*, int));
+static int pi_read_position      PARM((struct pi_info*));
+static data32 pi_read_length     PARM((struct pi_info*));
+static int pi_copy_pixels        PARM((struct pi_info*,
+				     byte*, int, int, data32));
+
+static void pi_write_header      PARM((struct pi_info*,
+				       char*, byte*, byte*, byte*));
+static void pi_write_id          PARM((struct pi_info*));
+static void pi_write_comment     PARM((struct pi_info*, char*));
+static void pi_write_palette     PARM((struct pi_info*, byte*, byte*, byte*));
+static void pi_compress          PARM((struct pi_info*, byte*));
+static void pi_write_gabage      PARM((struct pi_info*));
+static void pi_write_color       PARM((struct pi_info*, int, int));
+static int pi_test_matching      PARM((struct pi_info*,
+				       byte*, int, int, data32*));
+static void pi_write_position    PARM((struct pi_info*, int));
+static void pi_write_length      PARM((struct pi_info*, data32));
+
+static void pi_table_create      PARM((struct pi_info*));
+static byte pi_table_get_value   PARM((struct pi_info*, int, int));
+static int pi_table_lookup_value PARM((struct pi_info*, int, int));
+static data32 pi_read_bits       PARM((struct pi_info*, int));
+static void pi_write_bits        PARM((struct pi_info*, data32, int));
+static void pi_init_pi_info      PARM((struct pi_info*));
+static void pi_cleanup_pi_info   PARM((struct pi_info*, int));
+static void pi_cleanup_pinfo     PARM((PICINFO*));
+static void pi_memory_error      PARM((char*, char*));
+static void pi_error             PARM((struct pi_info*, int));
+static void pi_file_error        PARM((struct pi_info*, int));
+static void pi_file_warning      PARM((struct pi_info*, int));
+static void pi_show_pi_info      PARM((struct pi_info*));
+static void *pi_malloc           PARM((size_t, char*));
+static void *pi_realloc          PARM((void*, size_t, char*));
+
+
+static char *pi_id = "Pi";
+static char *pi_msgs[] = {
+    NULL,
+#define PI_OPEN 1
+    "couldn't open.",
+#define PI_CORRUPT 2
+    "file corrupted.",
+#define PI_FORMAT 3
+    "not PI format.",
+#define PI_PLANES 4
+    "bad number of planes.",
+#define PI_WRITE 5
+    "write failed.",
+};
+
+
+/* The main routine of `Pi' loader. */
+int LoadPi(fname, pinfo)
+    char *fname;
+    PICINFO *pinfo;
+{
+    struct pi_info pi;
+    int e;
+    int i;
+    if(DEBUG) fputs("LoadPi:\n", stderr);
+    
+    pinfo->comment = NULL;
+    pi_init_pi_info(&pi);
+    if((e = setjmp(pi.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	pi_cleanup_pi_info(&pi, 0);
+	pi_cleanup_pinfo(pinfo);
+	if(DEBUG) fputs("\n", stderr);
+	return 0;
+    }
+    
+    pi_open_file(&pi, fname);
+    pi_read_header(&pi, &pinfo->comment);
+    pi_expand(&pi, &pinfo->pic);
+    
+    pinfo->normw = pinfo->w = pi.width;
+    pinfo->normh = pinfo->h = pi.height;
+    pinfo->type = PIC8;
+    if(pi.numcols > 256)	/* shouldn't happen. */
+	pi.numcols = 256;
+    for(i = 0; i < pi.numcols; i++){
+	pinfo->r[i] = pi.cmap[i * 3    ];
+	pinfo->g[i] = pi.cmap[i * 3 + 1];
+	pinfo->b[i] = pi.cmap[i * 3 + 2];
+    }
+    pinfo->frmType = F_PI;
+    pinfo->colType = F_FULLCOLOR;
+    sprintf(pinfo->fullInfo, "Pi, %d colors (%ld bytes)",
+	    pi.numcols, pi.fsize);
+    sprintf(pinfo->shrtInfo, "%dx%d Pi.", pi.width, pi.height);
+    normaspect = pi.aspect;
+    
+    pi_cleanup_pi_info(&pi, 0);
+    if(DEBUG) fputs("\n", stderr);
+    return 1;
+}
+
+static void pi_open_file(pi, fname)
+    struct pi_info *pi;
+    char *fname;
+{
+    if((pi->fp = fopen(fname, "rb")) == NULL)
+	pi_file_error(pi, PI_OPEN);
+    fseek(pi->fp, (size_t) 0, SEEK_END);
+    pi->fsize = ftell(pi->fp);
+    fseek(pi->fp, (size_t) 0, SEEK_SET);
+}
+
+static void pi_read_header(pi, comm)
+    struct pi_info *pi;
+    char **comm;
+{
+    byte buf[10];
+    int mda;
+    int i;
+    
+    pi_check_id(pi);
+    pi_read_comment(pi, comm);
+    
+    if(fread(buf, (size_t) 10, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_CORRUPT);
+    
+    pi->mode = buf[0];
+    pi->defcmap = pi->mode & 0x80;
+    if(buf[1] != 0 && buf[2] != 0)
+	pi->aspect = (float) buf[2] / (int) buf[1];
+    pi->cbits = buf[3];
+    pi->numcols = 1 << pi->cbits;
+    
+    if(pi->cbits != 4 && pi->cbits != 8)
+	pi_error(pi, PI_PLANES);
+    
+    mda = (int) buf[8] << 8 | (int) buf[9];
+    for(i = 0; i < mda; i++){
+	if(fgetc(pi->fp) == EOF)
+	    pi_file_error(pi, PI_CORRUPT);
+    }
+    
+    if(fread(buf, (size_t) 4, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_CORRUPT);
+    pi->width  = (int) buf[0] << 8 | (int) buf[1];
+    pi->height = (int) buf[2] << 8 | (int) buf[3];
+    
+    pi_read_palette(pi);
+    
+    if(DEBUG) pi_show_pi_info(pi);
+}
+
+static void pi_check_id(pi)
+    struct pi_info *pi;
+{
+    char buf[2];
+    
+    if(fread(buf, (size_t) 2, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_CORRUPT);
+    if(strncmp(buf, pi_id, (size_t) 2) != 0)
+	pi_error(pi, PI_FORMAT);
+}
+
+static void pi_read_comment(pi, comm)
+    struct pi_info *pi;
+    char **comm;
+{
+/*
+ * The comment format is like:
+ *   comment string `^Z' dummy string `\0'
+ */
+    int max = -1, i = 0;
+    int c;
+    
+    while(1){
+	if((c = fgetc(pi->fp)) == EOF)
+	    pi_file_error(pi, PI_CORRUPT);
+	if(c == '\032')		/* 0x1a, '^Z' */
+	    break;
+	if(max < i){
+	    max += 32;
+	    *comm = pi_realloc(*comm, (size_t) max + 1, "pi_read_comment(1)");
+	}
+	(*comm)[i++] = c;
+    }
+    if(max < i){
+	max++;
+	*comm = pi_realloc(*comm, (size_t) max + 1, "pi_read_comment(2)");
+    }
+    (*comm)[i] = '\0';
+    
+    while((c = fgetc(pi->fp)) != '\0'){		/* skip the dummy area */
+	if(c == EOF)
+	    pi_file_error(pi, PI_CORRUPT);
+    }
+}
+
+static void pi_read_palette(pi)
+    struct pi_info *pi;
+{
+    pi->cmap = pi_malloc((size_t) pi->numcols * 3, "pi_read_palette");
+    if(pi->mode & 0x80){
+	if(pi->numcols == 16){
+	    int i;
+	    byte on;
+	    
+	    on = 0x77;
+	    for(i = 0; i < 8; i++){
+		pi->cmap[i * 3    ] = i & 2 ? on : 0;
+		pi->cmap[i * 3 + 1] = i & 4 ? on : 0;
+		pi->cmap[i * 3 + 2] = i & 1 ? on : 0;
+	    }
+	    on = 0xff;
+	    for(; i < 16; i++){
+		pi->cmap[i * 3    ] = i & 2 ? on : 0;
+		pi->cmap[i * 3 + 1] = i & 4 ? on : 0;
+		pi->cmap[i * 3 + 2] = i & 1 ? on : 0;
+	    }
+	}else{	/* pi->numcols == 256 */
+	    int i;
+	    byte r, g, b;
+	    r = g = b = 0;
+	    for(i = 0; i < 256; i++){
+		pi->cmap[i * 3    ] = r;
+		pi->cmap[i * 3 + 1] = g;
+		pi->cmap[i * 3 + 2] = b;
+		if((b += 0x40) == 0){
+		    if((r += 0x20) == 0)
+			g += 0x20;
+		}
+	    }
+	}
+    }else{
+	if(fread(pi->cmap, (size_t) pi->numcols * 3, (size_t) 1, pi->fp) != 1)
+	    pi_file_error(pi, PI_CORRUPT);
+    }
+}
+
+/* The main routine to expand `Pi' file. */
+static void pi_expand(pi, pic)
+    struct pi_info *pi;
+    byte **pic;
+{
+    byte prev_col = 0;
+    int prev_pos = -1;
+    int cnt = 0, max_cnt = pi->width * pi->height;
+    
+    *pic = pi_malloc((size_t) max_cnt, "pi_expand");
+    
+    pi_table_create(pi);
+    
+    if(pi->width > 2){
+	(*pic)[0] = pi_read_color(pi, 0);
+	(*pic)[1] = pi_read_color(pi, (*pic)[0]);
+	
+	while(cnt < max_cnt){
+	    int pos = pi_read_position(pi);
+	    if(pos != prev_pos){
+		data32 len = pi_read_length(pi);
+		cnt = pi_copy_pixels(pi, *pic, cnt, pos, len);
+		prev_col = (*pic)[cnt - 1];
+		prev_pos = pos;
+	    }else{
+		do{
+		    prev_col = pi_read_color(pi, (int) prev_col);
+		    (*pic)[cnt++] = prev_col;
+		    prev_col = pi_read_color(pi, (int) prev_col);
+		    (*pic)[cnt++] = prev_col;
+		}while(pi_read_bits(pi, 1) == 1);
+		
+		prev_pos = -1;
+	    }
+	}
+    }else{
+	while(cnt < max_cnt){
+	    prev_col = pi_read_color(pi, (int) prev_col);
+	    (*pic)[cnt++] = prev_col;
+	}
+    }
+}
+
+static byte pi_read_color(pi, prev)
+    struct pi_info *pi;
+    int prev;
+{
+    byte n;
+    if(pi->cbits == 4){
+	if(pi_read_bits(pi, 1) == 1)
+	    n = pi_read_bits(pi, 1);			/* 1x */
+	else{
+	    if(pi_read_bits(pi, 1) == 0)
+		n = pi_read_bits(pi, 1) + 2;		/* 00x */
+	    else{
+		if(pi_read_bits(pi, 1) == 0)
+		    n = pi_read_bits(pi, 2) + 4;	/* 010xx */
+		else
+		    n = pi_read_bits(pi, 3) + 8;	/* 011xxx */
+	    }
+	}
+    }else{	/* cbits == 8 */
+	if(pi_read_bits(pi, 1) == 1)
+	    n = pi_read_bits(pi, 1);
+	else{
+	    int bits = 0;
+	    byte base = 2;
+	    while(bits < 6){
+		if(pi_read_bits(pi, 1) == 0)
+		    break;
+		bits++;
+		base <<= 1;
+	    }
+	    n = pi_read_bits(pi, bits + 1) + base;
+	}
+    }
+    
+    return pi_table_get_value(pi, prev, (int) n);
+}
+
+static int pi_read_position(pi)
+    struct pi_info *pi;
+{
+    byte r;
+    if((r = pi_read_bits(pi, 2)) != 3)
+	return (int) r;
+    else
+	return (int) pi_read_bits(pi, 1) + 3;
+}
+
+static data32 pi_read_length(pi)
+    struct pi_info *pi;
+{
+    data32 r = 1;
+    int bits = 0;
+    while(pi_read_bits(pi, 1) == 1){
+	r <<= 1;
+	bits++;
+    }
+    if(bits > 0)
+	return r + pi_read_bits(pi, bits);
+    return 1;
+}
+
+static int pi_copy_pixels(pi, pic, cnt, pos, len)
+    struct pi_info *pi;
+    byte *pic;
+    int cnt, pos;
+    data32 len;
+{
+    int s = 0, d = cnt;
+    int max = pi->width * pi->height;
+    switch(pos){
+    case 0:
+	if(cnt < 2){
+	    if(pic[0] == pic[1])
+		s = cnt - 2;
+	    else
+		s = cnt - 4;
+	}else{
+	    if(pic[cnt - 2] == pic[cnt - 1])
+		s = cnt - 2;
+	    else
+		s = cnt - 4;
+	}
+	break;
+    case 1:
+	s = cnt - pi->width;
+	break;
+    case 2:
+	s = cnt - pi->width * 2;
+	break;
+    case 3:
+	s = cnt - pi->width + 1;
+	break;
+    case 4:
+	s = cnt - pi->width - 1;
+    }
+    
+    len *= 2;
+    while(s < 0 && len != 0 && d < max){
+	pic[d++] = pic[-(s++) % 2];
+	len--;
+    }
+    while(len != 0 && d < max){
+	pic[d++] = pic[s++];
+	len--;
+    }
+    return d;
+}
+
+/* The main routine of `Pi' saver. */
+int WritePi(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
+	    comment)
+    FILE *fp;
+    byte *pic;
+    int ptype, w, h;
+    byte *rmap, *gmap, *bmap;
+    int numcols, colorstyle;
+    char *comment;
+{
+    byte rtemp[256], gtemp[256], btemp[256];
+    struct pi_info pi;
+    int e;
+    
+    if(DEBUG) fputs("WritePi\n", stderr);
+    pi_init_pi_info(&pi);
+    pi.fp = fp;
+    pi.width  = w;
+    pi.height = h;
+    pi.writing_grey = (colorstyle == F_GREYSCALE);
+    if(ptype == PIC24){
+	if(!(pic = Conv24to8(pic, w, h, 256, rtemp, gtemp, btemp)))
+	    pi_memory_error("Conv24to8", "WritePi");
+	rmap = rtemp;
+	gmap = gtemp;
+	bmap = btemp;
+	numcols = 256;
+    }
+    
+    if((e = setjmp(pi.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	pi_cleanup_pi_info(&pi, 1);
+	if(DEBUG) fputs("\n", stderr);
+	return -1;
+    }
+    
+    pi.numcols = numcols;
+    pi_write_header(&pi, comment,  rmap, gmap, bmap);
+    pi_compress(&pi, pic);
+    pi_write_gabage(&pi);
+    
+    pi_cleanup_pi_info(&pi, 1);
+    if(DEBUG) fputs("\n", stderr);
+    return 0;
+}
+
+static void pi_write_header(pi, comm, r, g, b)
+    struct pi_info *pi;
+    char *comm;
+    byte *r, *g, *b;
+{
+    byte buf[14];
+    
+    if(DEBUG) pi_show_pi_info(pi);
+    
+    pi_write_id(pi);
+    pi_write_comment(pi, comm);
+    
+    buf[0] = buf[1] = buf[2] = 0;
+    buf[3] = pi->cbits = pi->numcols > 16 ? 8 : 4;
+    buf[4] = 'X';
+    buf[5] = 'V';
+    buf[6] = ' ';
+    buf[7] = ' ';
+    buf[8] = buf[9] = 0;
+    buf[10] = pi->width >> 8;
+    buf[11] = pi->width;
+    buf[12] = pi->height >> 8;
+    buf[13] = pi->height;
+    if(fwrite(buf, (size_t) 14, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_WRITE);
+    
+    pi_write_palette(pi, r, g, b);
+}
+
+static void pi_write_id(pi)
+    struct pi_info *pi;
+{
+    if(fwrite(pi_id, (size_t) 2, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_WRITE);
+}
+
+static void pi_write_comment(pi, comm)
+    struct pi_info *pi;
+    char *comm;
+{
+    if(comm){
+	int i;
+	for(i = 0; comm[i]; i++){
+	    if(comm[i] == '\032')	/* 0x1a, '^Z' */
+		comm[i] = ' ';
+	}
+	if(i > 0){
+	    if(fwrite(comm, (size_t) i, (size_t) 1, pi->fp) != 1)
+		pi_file_error(pi, PI_WRITE);
+	}
+    }
+    
+    if(fwrite("\032\0", (size_t) 2, (size_t) 1, pi->fp) != 1)
+	pi_file_error(pi, PI_WRITE);
+}
+
+static void pi_write_palette(pi, r, g, b)
+    struct pi_info *pi;
+    byte *r, *g, *b;
+{
+    int i;
+    int pinum = 1 << pi->cbits;
+    char buf[3];
+    
+    for(i = 0; i < pi->numcols; i++){
+	buf[0] = *r++;
+	buf[1] = *g++;
+	buf[2] = *b++;
+	if(pi->writing_grey)
+	    buf[0] = buf[1] = buf[2] = MONO(buf[0], buf[1], buf[2]);
+	if(fwrite(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
+	    pi_file_error(pi, PI_WRITE);
+    }
+    for( ; i < pinum; i++){
+	if(fwrite(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
+	    pi_file_error(pi, PI_WRITE);
+    }
+    pi->numcols = pinum;
+}
+
+/* The main routine to compress `Pi' format. */
+static void pi_compress(pi, pic)
+    struct pi_info *pi;
+    byte *pic;
+{
+    byte prev_col = 0;
+    int prev_pos = -1;
+    int cnt = 0, max_cnt = pi->width * pi->height;
+    pi_table_create(pi);
+    
+    if(pi->width > 2){
+	int pos;
+	data32 len;
+	
+	pi_write_color(pi, 0,      pic[0]);
+	pi_write_color(pi, pic[0], pic[1]);
+	pos = pi_test_matching(pi, pic, prev_pos, cnt, &len);
+	while(cnt < max_cnt){
+	    if(pos >= 0){
+		pi_write_position(pi, pos);
+		pi_write_length(pi, len);
+		if((cnt += len * 2) >= max_cnt)
+		    break;
+		prev_col = pic[cnt - 1];
+		prev_pos = pos;
+		pos = pi_test_matching(pi, pic, prev_pos, cnt, &len);
+	    }else{
+		pi_write_position(pi, prev_pos);
+		prev_pos = -1;
+		while(pos < 0){
+		    pi_write_color(pi, (int) prev_col, pic[cnt]);
+		    prev_col = pic[cnt];
+		    if(++cnt >= max_cnt)
+			break;
+		    pi_write_color(pi, (int) prev_col, pic[cnt]);
+		    prev_col = pic[cnt];
+		    if(++cnt >= max_cnt)
+			break;
+		    pos = pi_test_matching(pi, pic, -1, cnt, &len);
+		    if(pos < 0)
+			pi_write_bits(pi, 1, 1);
+		    else
+			pi_write_bits(pi, 0, 1);
+		}
+	    }
+	}
+    }else{
+	while(cnt < max_cnt){
+	    pi_write_color(pi, (int) prev_col, pic[cnt]);
+	    prev_col = pic[cnt++];
+	}
+    }
+}
+
+static void pi_write_gabage(pi)
+    struct pi_info *pi;
+{
+    pi_write_bits(pi, 0, 32);
+}
+
+static void pi_write_color(pi, prev, col)
+    struct pi_info *pi;
+    int prev, col;
+{
+    int n = pi_table_lookup_value(pi, prev, col);
+    
+    if(pi->cbits == 4){
+	if(n < 2)
+	    pi_write_bits(pi, (data32) n | 2, 2);
+	else if(n < 4)
+	    pi_write_bits(pi, (data32) n - 2, 3);
+	else if(n < 8)
+	    pi_write_bits(pi, (data32) (n - 4) | 8, 5);
+	else
+	    pi_write_bits(pi, (data32) (n - 8) | 24, 6);
+    }else{	/* cbits == 8 */
+	if(n < 2){
+	    pi_write_bits(pi, (data32) n | 2, 2);
+	}else{
+	    int bits = 0;
+	    byte base = 2;
+	    while(bits < 6){
+		if(n < (int) base * 2)
+		    break;
+		bits++;
+		base <<= 1;
+	    }
+	    pi_write_bits(pi, 0, 1);
+	    if(bits > 0)
+		pi_write_bits(pi, 0xffffffff, bits);
+	    if(bits < 6)
+		pi_write_bits(pi, 0, 1);
+	    pi_write_bits(pi, (data32) n - base, bits + 1);
+	}
+    }
+}
+
+static int pi_test_matching(pi, pic, prev, cnt, len)
+    struct pi_info *pi;
+    byte *pic;
+    int prev, cnt;
+    data32 *len;
+{
+    data32 lens[5];
+    int pos, p;
+    int s, d = 0;
+    int max = pi->width * pi->height;
+    
+    for(pos = 0; pos < 5; pos++){
+	switch(pos){
+	case 0:
+	    if(cnt < 2){
+		if(pic[0] == pic[1])
+		    d = cnt - 2;
+		else
+		    d = cnt - 4;
+	    }else{
+		if(pic[cnt - 2] == pic[cnt - 1])
+		    d = cnt - 2;
+		else
+		    d = cnt - 4;
+	    }
+	    break;
+	case 1:
+	    d = cnt - pi->width;
+	    break;
+	case 2:
+	    d = cnt - pi->width * 2;
+	    break;
+	case 3:
+	    d = cnt - pi->width + 1;
+	    break;
+	case 4:
+	    d = cnt - pi->width - 1;
+	}
+	s = cnt;
+	lens[pos] = 0;
+	
+	if(prev == 0 && pos == 0)
+	    continue;
+	
+	while(d < max){
+	    if(pic[(d < 0) ? (-d) % 2 : d] != pic[s])
+		break;
+	    lens[pos]++;
+	    d++;
+	    s++;
+	}
+	
+    }
+    
+    for(pos = 0, p = 1; p < 5; p++){
+	if(lens[p] >= lens[pos])
+	    pos = p;
+    }
+    
+    if(lens[pos] / 2 == 0)
+	return -1;
+    *len = lens[pos] / 2;
+    return pos;
+}
+
+static void pi_write_position(pi, pos)
+    struct pi_info *pi;
+    int pos;
+{
+    switch(pos){
+    case 0:
+	pi_write_bits(pi, 0, 2);
+	break;
+    case 1:
+	pi_write_bits(pi, 1, 2);
+	break;
+    case 2:
+	pi_write_bits(pi, 2, 2);
+	break;
+    case 3:
+	pi_write_bits(pi, 6, 3);
+	break;
+    case 4:
+	pi_write_bits(pi, 7, 3);
+	break;
+    }
+}
+
+static void pi_write_length(pi, len)
+    struct pi_info *pi;
+    data32 len;
+{
+    int bits = 0;
+    data32 base = 1;
+    
+    while(len >= base * 2){
+	bits++;
+	base <<= 1;
+    }
+    if(bits > 0){
+	pi_write_bits(pi, 0xffffffff, bits);
+	pi_write_bits(pi, 0, 1);
+	pi_write_bits(pi, len - base, bits);
+    }else
+	pi_write_bits(pi, 0, 1);
+}
+
+/*
+ * These pi_table_* functions manipulate the color table.
+ * pi_table_create:
+ *	allocates and initializes a color table.
+ * pi_table_get_value:
+ *	get the specified value, and move it to the top of the list.
+ * pi_table_lookup_value:
+ *	look up the specified value, and move it to the top of the list.
+ */
+static void pi_table_create(pi)
+    struct pi_info *pi;
+{
+    struct ct_t *t;
+    int i;
+    byte mask = pi->numcols - 1;
+    pi->ct = pi_malloc(sizeof *pi->ct * pi->numcols, "pi_table_create(1)");
+    for(i = 0, t = pi->ct; i < pi->numcols; i++, t++){
+	int j;
+	byte v = i;
+	t->elt = pi_malloc(sizeof *t->elt * pi->numcols, "pi_table_create(2)");
+	t->top = &t->elt[pi->numcols - 1];
+	for(j = 0; j < pi->numcols; j++){
+	    v = (v + 1) & mask;
+	    if(j > 0)
+		t->elt[j].old    = &t->elt[j - 1];
+	    else
+		t->elt[0].old    = t->top;
+	    if(j < pi->numcols - 1)
+		t->elt[j].recent = &t->elt[j + 1];
+	    else
+		t->elt[j].recent = &t->elt[0];
+	    t->elt[j].val    = v;
+	}
+	t->elt[0].old = t->top;
+	t->top->recent = &t->elt[0];
+    }
+}
+
+static byte pi_table_get_value(pi, left, num)
+    struct pi_info *pi;
+    int left, num;
+{
+    struct ct_t *t = &pi->ct[left];
+    struct elt_t *e = t->top;
+    if(left >= pi->numcols || num >= pi->numcols)
+	abort();
+    if(num != 0){
+	do {
+	    e = e->old;
+	}while(--num != 0);
+	
+	e->old->recent = e->recent;
+	e->recent->old = e->old;
+	
+	e->recent = t->top->recent;
+	e->recent->old = e;
+	e->old = t->top;
+	t->top->recent = e;
+	
+	t->top = e;
+    }
+    return e->val;
+}
+
+static int pi_table_lookup_value(pi, left, v)
+    struct pi_info *pi;
+    int left, v;
+{
+    struct ct_t *t = &pi->ct[left];
+    struct elt_t *e = t->top;
+    int num = 0;
+    
+    if(left >= pi->numcols || v >= pi->numcols)
+	abort();
+    
+    while(e->val != v){
+	e = e->old;
+	num++;
+    }
+    
+    if(num != 0){
+	e->old->recent = e->recent;
+	e->recent->old = e->old;
+	
+	e->recent = t->top->recent;
+	e->recent->old = e;
+	e->old = t->top;
+	t->top->recent = e;
+	
+	t->top = e;
+    }
+    
+    return num;
+}
+
+/*
+ * These 2 functions read or write to a bit stream.
+ * pi_read_bits:
+ *	reads a specified-bit data from the bit stream.
+ * pi_write_bits:
+ *	writes a specified-bit data to the bit stream.
+ */
+static data32 pi_read_bits(pi, numbits)
+    struct pi_info *pi;
+    int numbits;
+{
+    data32 r = 0;
+    
+    while(numbits > 0){
+	while(pi->bs.rest > 0 && numbits > 0){
+	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
+	    pi->bs.cur <<= 1;
+	    pi->bs.rest--;
+	    numbits--;
+	}
+	if(numbits > 0){
+	    int c;
+	    if((c = fgetc(pi->fp)) == EOF)
+		pi_file_warning(pi, PI_CORRUPT);
+	    pi->bs.cur  = c;
+	    pi->bs.rest = 8;
+	}
+    }
+    
+    return r;
+}
+
+static void pi_write_bits(pi, dat, bits)
+    struct pi_info *pi;
+    data32 dat;
+    int bits;
+{
+    data32 dat_mask = 1 << (bits - 1);
+    while(bits > 0){
+	while(pi->bs.rest < 8 && bits > 0){
+	    pi->bs.cur <<= 1;
+	    if(dat & dat_mask)
+		pi->bs.cur |= 1;
+	    pi->bs.rest++;
+	    bits--;
+	    dat_mask >>= 1;
+	}
+	if(pi->bs.rest >= 8){
+	    if(fputc((int)pi->bs.cur, pi->fp) == EOF)
+		pi_file_error(pi, PI_WRITE);
+	    pi->bs.cur  = 0;
+	    pi->bs.rest = 0;
+	}
+    }
+}
+
+/*
+ * The routines to initialize or clean up.
+ * pi_inif_pi_info:
+ *	initializes a pi_info structure.
+ * pi_cleanup_pi_info:
+ *	cleanup pi_info structure. It frees allocated memories.
+ * pi_cleanup_pinfo:
+ *	cleanup PICINFO structure when an error occurs.
+ */
+static void pi_init_pi_info(pi)
+    struct pi_info *pi;
+{
+    pi->fp = NULL;
+    pi->bs.rest = 0;
+    pi->bs.cur = 0;
+    pi->fsize = 0;
+    pi->mode = 0;
+    pi->width = pi->mode = 0;
+    pi->aspect = 1.0;
+    pi->cbits = 0;
+    pi->numcols = 0;
+    pi->cmap = NULL;
+    pi->ct = NULL;
+    pi->defcmap = 0;
+    pi->writing_grey = 0;
+}
+
+static void pi_cleanup_pi_info(pi, writing)
+    struct pi_info *pi;
+    int writing;
+{
+    if(pi->fp && !writing){
+	fclose(pi->fp);
+	pi->fp = NULL;
+    }
+    if(pi->cmap){
+	free(pi->cmap);
+	pi->cmap = NULL;
+    }
+    if(pi->ct){
+	int i;
+	for(i = 0; i < pi->numcols; i++)
+	    free(pi->ct[i].elt);
+	free(pi->ct);
+	pi->ct = NULL;
+    }
+}
+
+static void pi_cleanup_pinfo(pinfo)
+    PICINFO *pinfo;
+{
+    if(pinfo->pic){
+	free(pinfo->pic);
+	pinfo->pic = NULL;
+    }
+    if(pinfo->comment){
+	free(pinfo->comment);
+	pinfo->comment = NULL;
+    }
+}
+
+/*
+ * Error handling routins.
+ * pi_memory_error:
+ *	shows a error message, and terminates.
+ * pi_error:
+ *	shows a non-file error message.
+ * pi_file_error:
+ *	shows a file error message.
+ */
+static void pi_memory_error(scm, fn)
+    char *scm, *fn;
+{
+    char buf[128];
+    sprintf(buf, "%s: couldn't allocate memory. (%s)", scm ,fn);
+    FatalError(buf);
+}
+
+static void pi_error(pi, mn)
+    struct pi_info *pi;
+    int mn;
+{
+    SetISTR(ISTR_WARNING, "%s", pi_msgs[mn]);
+    longjmp(pi->jmp, 1);
+}
+
+static void pi_file_error(pi, mn)
+    struct pi_info *pi;
+    int mn;
+{
+    if(feof(pi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", pi_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", pi_msgs[mn], ERRSTR(errno));
+    longjmp(pi->jmp, 1);
+}
+
+static void pi_file_warning(pi, mn)
+    struct pi_info *pi;
+    int mn;
+{
+    if(feof(pi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", pi_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", pi_msgs[mn], ERRSTR(errno));
+}
+
+static void pi_show_pi_info(pi)
+    struct pi_info *pi;
+{
+    fprintf(stderr, "  file size: %ld.\n", pi->fsize);
+    fprintf(stderr, "  mode: 0x%02x.\n", pi->mode);
+    fprintf(stderr, "  image size: %dx%d.\n", pi->width, pi->height);
+    fprintf(stderr, "  aspect: %f.\n", pi->aspect);
+    fprintf(stderr, "  number of color bits: %d.\n", pi->cbits);
+    fprintf(stderr, "  number of colors: %d.\n", pi->numcols);
+    fprintf(stderr, "  using default colormap: %s.\n",
+	    pi->defcmap ? "true" : "false");
+    fprintf(stderr, "  writing greyscale image: %s.\n",
+	    pi->writing_grey ? "true" : "false");
+}
+
+/*
+ * Memory related routines.  If failed, they calls pi_memory_error.
+ */
+static void *pi_malloc(n, fn)
+    size_t n;
+    char *fn;
+{
+    void *r = (void *) malloc(n);
+    if(r == NULL)
+	pi_memory_error("malloc", fn);
+    return r;
+}
+
+static void *pi_realloc(p, n, fn)
+    void *p;
+    size_t n;
+    char *fn;
+{
+    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
+    if(r == NULL)
+	pi_memory_error("realloc", fn);
+    return r;
+}
+#endif /* HAVE_PI */
diff -Naur xv-3.10a.old/xvpic.c xv-3.10a/xvpic.c
--- xv-3.10a.old/xvpic.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvpic.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,1285 @@
+/*
+ * xvpic.c - load routine for `PIC' format pictures.
+ *
+ * The `PIC' format is used by many Japanese personal computer users.
+ */
+
+#include "xv.h"
+#include <setjmp.h>
+
+#ifdef HAVE_PIC
+
+typedef unsigned short data16;
+typedef unsigned int data32;
+
+struct pic_info {
+    jmp_buf jmp;
+    FILE *fp;
+    struct {
+	int rest;
+	byte cur;
+    }bs;
+    long fsize;
+    int type, mode;
+    int width, height;
+    float aspect;
+    int cbits;
+    int cmapped;
+    byte *cmap;
+    int cached;
+    struct cache_t {
+	int newest;
+	struct cachenode_t {
+	    data32 dat;
+	    int newer, older;
+	} *node;
+    } cache;
+    int g_bits, r_bits, b_bits, i_bits;
+    int inv_gr;
+    int tiled256;
+    int numcols;
+    int writing_grey;
+    data32 *data;
+};
+
+static void pic_open_file              PARM((struct pic_info*,char*));
+static void pic_check_id               PARM((struct pic_info*));
+static void pic_read_comment           PARM((struct pic_info*, char**));
+static void pic_read_header            PARM((struct pic_info*));
+static void pic_expand_data            PARM((struct pic_info*));
+static int pic_expanding_read_len      PARM((struct pic_info*));
+static data32 pic_expanding_read_color PARM((struct pic_info*));
+static void pic_expanding_read_chain
+			PARM((struct pic_info*, int, int, data32));
+static void pic_make_xvpic
+			PARM((struct pic_info*, byte**, byte*, byte*, byte*));
+
+static void pic_write_id               PARM((struct pic_info*));
+static void pic_write_comment          PARM((struct pic_info*, char*));
+static void pic_write_header           PARM((struct pic_info*));
+static void pic_write_palette
+			PARM((struct pic_info*, byte*, byte*, byte*));
+static void pic_make_sparse_data       PARM((struct pic_info*, byte*));
+static void pic_write_data             PARM((struct pic_info*));
+static void pic_write_length           PARM((struct pic_info*, data32));
+static void pic_write_color            PARM((struct pic_info*, data32));
+static void pic_write_chain
+			PARM((struct pic_info*, int, int, data32));
+
+static data32 pic_read_rgb             PARM((struct pic_info*));
+static data32 pic_read_color_code      PARM((struct pic_info*));
+static void pic_write_rgb              PARM((struct pic_info*, data32));
+static void pic_write_color_code       PARM((struct pic_info*, data32));
+
+static void pic_cache_init             PARM((struct pic_info*));
+static data32 pic_cache_get_value      PARM((struct pic_info*, int));
+static void pic_cache_add_value        PARM((struct pic_info*, data32));
+static int pic_cache_lookup            PARM((struct pic_info*, data32));
+
+static data32 pic_read_bits            PARM((struct pic_info*, int));
+static void pic_write_bits             PARM((struct pic_info*, data32, int));
+static byte pic_pad_bit                PARM((int, data32));
+
+static void pic_init_info              PARM((struct pic_info*));
+static void pic_cleanup_pic_info       PARM((struct pic_info*, int));
+static void pic_cleanup_pinfo          PARM((PICINFO*));
+static void pic_memory_error           PARM((char*, char*));
+static void pic_error                  PARM((struct pic_info*, int));
+static void pic_file_error             PARM((struct pic_info*, int));
+static void pic_file_warning           PARM((struct pic_info*, int));
+static void pic_show_pic_info          PARM((struct pic_info*));
+static void *pic_malloc                PARM((size_t, char*));
+static void *pic_realloc               PARM((void*, size_t, char*));
+
+
+static char *pic_id = "PIC";
+
+/* Error Messages */
+static char *pic_msgs[] = {
+    NULL,
+#define PIC_OPEN 1
+    "can't open file.",
+#define PIC_CORRUPT 2
+    "file corrupted.",
+#define PIC_FORMAT 3
+    "not PIC format.",
+#define PIC_SUPPORT 4
+    "unsupported type.",
+#define PIC_COMMENT 5
+    "can't read comment.",
+#define PIC_TYPE 6
+    "bad machine type.",
+#define PIC_MODE 7
+    "bad machine-dependent mode.",
+#define PIC_NUM_COLORS 8
+    "bad number of colors.",
+#define PIC_SIZE 9
+    "bad size.",
+#define PIC_ASPECT 10
+    "bad aspect.",
+#define PIC_WRITE 11
+    "write failed.",
+};
+
+#define H4(b) (((b) >> 4) & 0x0f)
+#define L4(b) ( (b)       & 0x0f)
+
+
+/* The main routine to load a PIC file. */
+int LoadPIC(fname, pinfo)
+    char *fname;
+    PICINFO *pinfo;
+{
+    int e;
+    struct pic_info pic;
+    char buf[128];
+    
+    if(DEBUG) fputs("LoadPIC:\n", stderr);
+    
+    pic_init_info(&pic);
+    
+    pinfo->comment = NULL;
+    if((e = setjmp(pic.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	pic_cleanup_pic_info(&pic, 0);
+	pic_cleanup_pinfo(pinfo);
+	if(DEBUG) fputs("\n", stderr);
+	return 0;
+    }
+    
+    pic_open_file(&pic, fname);
+    pic_check_id(&pic);
+    pic_read_comment(&pic, &pinfo->comment);
+    pic_read_header(&pic);
+    pic_expand_data(&pic);
+    pic_make_xvpic(&pic, &pinfo->pic, pinfo->r, pinfo->g, pinfo->b);
+    
+    pinfo->w = pic.width;
+    if(pic.tiled256)
+	pinfo->h = pic.height * 2;
+    else
+	pinfo->h = pic.height;
+    pinfo->normw = pinfo->w;
+    pinfo->normh = pinfo->h;
+    pinfo->type = pic.cmapped ? PIC8 : PIC24;
+    pinfo->frmType = F_PIC;
+    pinfo->colType = F_FULLCOLOR;
+    strcpy(pinfo->fullInfo, "PIC");
+    switch(pic.type){
+    case 0x0:
+	strcat(pinfo->fullInfo, ", X68k");
+	break;
+    case 0x1:
+	strcat(pinfo->fullInfo, ", PC-88VA");
+	if(pic.mode & 1)
+	    strcat(pinfo->fullInfo, ", HR");
+	if(pic.mode & 2)
+	    strcat(pinfo->fullInfo, ", tiled 256");
+	break;
+    case 0x2:
+	strcat(pinfo->fullInfo, ", FM-TOWNS");
+	if(pic.mode == 0x5){
+	    strcat(pinfo->fullInfo, ", low-resolution");
+	}else{
+	    strcat(pinfo->fullInfo, ", high-resolution");
+	}
+	break;
+    case 0x3:
+	strcat(pinfo->fullInfo, ", Machintosh");
+	break;
+    case 0xf:
+	;
+    }
+    sprintf(buf, " (%ld bytes)", pic.fsize);
+    strcat(pinfo->fullInfo, buf);
+    sprintf(pinfo->shrtInfo, "%dx%d(aspect %4.2f) PIC.",
+	    pinfo->w, pinfo->h, pic.aspect);
+    if (!nopicadjust)
+	normaspect = pic.aspect;
+    
+    pic_cleanup_pic_info(&pic, 0);
+    if(DEBUG) fputs("\n", stderr);
+    return 1;
+}
+
+static void pic_open_file(pi, fname)
+    struct pic_info *pi;
+    char *fname;
+{
+    if((pi->fp = fopen(fname, "rb")) == NULL)
+	pic_file_error(pi, PIC_OPEN);
+    fseek(pi->fp, (size_t) 0, SEEK_END);
+    pi->fsize = ftell(pi->fp);
+    fseek(pi->fp, (size_t) 0, SEEK_SET);
+}
+
+static void pic_check_id(pi)
+    struct pic_info *pi;
+{
+    char buf[3];
+    if(fread(buf, (size_t) 3, (size_t) 1, pi->fp) != 1)
+	pic_file_error(pi, PIC_CORRUPT);
+    if(strncmp(buf, pic_id, (size_t) 3) != 0)
+	pic_error(pi, PIC_FORMAT);
+}
+
+static void pic_read_comment(pi, comm)
+    struct pic_info *pi;
+    char **comm;
+{
+    /* The comment field is like:
+     * comment-string ^Z dummy \0 \0
+     */
+    int max = -1, i = 0;
+    int c;
+    
+    while(1){
+	if((c = fgetc(pi->fp)) == EOF)
+	    pic_file_error(pi, PIC_CORRUPT);
+	if(c == '\032')			/* 0x1a, '^Z' */
+	    break;
+	if(max < i){
+	    max += 32;
+	    *comm = pic_realloc(*comm, (size_t) max + 1, "pic_read_comment#1");
+	}
+	(*comm)[i++] = c;
+    }
+    
+    if(max < i){
+	max++;
+	*comm = pic_realloc(*comm, (size_t) max + 1, "pic_read_comment#2");
+    }
+    (*comm)[i] = '\0';
+    
+    while((c = fgetc(pi->fp)) != '\0'){	/* skip the dummy area */
+	if(c == EOF)
+	    pic_file_error(pi, PIC_CORRUPT);
+    }
+    
+    if(fgetc(pi->fp) != '\0')		/* check the reserved byte */
+	pic_error(pi, PIC_SUPPORT);
+}
+
+static void pic_read_header(pi)
+    struct pic_info *pi;
+{
+    pi->mode   = pic_read_bits(pi, 4);
+    pi->type   = pic_read_bits(pi, 4);
+    pi->cbits  = pic_read_bits(pi, 16);
+    pi->width  = pic_read_bits(pi, 16);
+    pi->height = pic_read_bits(pi, 16);
+    
+    /* machine dependent setups. */
+    switch(pi->type){
+    case 0x0:				/* X68K */
+	if(pi->mode != 0)
+	    pic_error(pi, PIC_MODE);
+	switch(pi->cbits){
+	case 4:
+	    pi->aspect = 1.0;
+	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
+	    pi->i_bits = 1;
+	    pi->cmapped = 1;
+	    break;
+	    
+	case 8:
+	    pi->aspect = 4.0 / 3.0;
+	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
+	    pi->i_bits = 1;
+	    pi->cmapped = 1;
+	    break;
+	    
+	case 15:
+	    pi->aspect = 4.0 / 3.0;
+	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
+	    pi->cached = 1;
+	    break;
+	    
+	case 16:
+	    pi->aspect = 4.0 / 3.0;
+	    pi->g_bits = pi->r_bits = pi->b_bits = 5;
+	    pi->i_bits = 1;
+	    pi->cached = 1;
+	    break;
+	    
+	default:
+	    pic_error(pi, PIC_NUM_COLORS);
+	}
+	break;
+	
+    case 0x1:				/* PC-88VA */
+	if(pi->height > 1000)
+	    pic_error(pi, PIC_SIZE);
+	switch(pi->width * 1000 + pi->height){
+	case 640400:
+	case 640204:
+	case 640200:
+	case 320408:
+	case 320400:
+	case 320200:
+	    break;
+	default:
+	    pic_error(pi, PIC_SIZE);
+	}
+	pi->aspect = 400.0 / pi->height;
+	pi->aspect *= pi->width / 640.0;
+	if(pi->mode & 0x1)		/* HR mode */
+	    pi->aspect *= 2.0;
+	if(pi->mode & 0x2){		/* tiled 256 format */
+	    if(pi->cbits != 16)
+		pic_error(pi, PIC_NUM_COLORS);
+	    pi->tiled256 = 1;
+	}
+	switch(pi->cbits){
+	case 8:
+	    pi->g_bits = pi->r_bits = 3;
+	    pi->b_bits = 2;
+	    break;
+	    
+	case 12:
+	    pi->g_bits = pi->r_bits = pi->b_bits = 4;
+	    pi->cached = 1;
+	    break;
+	    
+	case 16:
+	    pi->g_bits = 6;
+	    pi->r_bits = pi->b_bits = 5;
+	    pi->cached = 1;
+	    break;
+	    
+	default:
+	    pic_error(pi, PIC_NUM_COLORS);
+	}
+	break;
+	
+    case 0x2:				/* FM-TOWNS */
+	if(pi->cbits != 15)
+	    pic_error(pi, PIC_NUM_COLORS);
+	switch(pi->mode){	
+	case 0x5:
+	case 0xc:
+	    break;
+	default:
+	    pic_error(pi, PIC_MODE);
+	}
+	pi->g_bits = pi->r_bits = pi->b_bits = 5;
+	pi->cached = 1;
+	break;
+	
+    case 0x3:				/* MAC */
+	if(pi->cbits != 15)
+	    pic_error(pi, PIC_NUM_COLORS);
+	pi->r_bits = pi->g_bits = pi->b_bits = 5;
+	pi->inv_gr = 1;
+	break;
+	
+    case 0xf:				/* misc */
+	{
+	    byte ah, al;
+	    
+	    switch(pi->mode){
+	    case 0x0:
+		break;
+	    case 0x1:
+		pi->aspect = 4.0 / 3.0;
+		break;
+	    case 0xf:
+		break;
+	    default:
+		pic_error(pi, PIC_MODE);
+	    }
+	    pic_read_bits(pi, 16);	/* x */
+	    pic_read_bits(pi, 16);	/* y */
+	    ah = pic_read_bits(pi, 8);
+	    al = pic_read_bits(pi, 8);
+	    if(ah > 0 && al > 0)
+		pi->aspect = (float) al / (int) ah;
+	    else if(pi->mode == 0xf)
+		pic_error(pi, PIC_ASPECT);
+	    switch(pi->cbits){
+	    case 4:
+	    case 8:
+		pi->g_bits = pi->r_bits = pi->b_bits = pic_read_bits(pi, 8);
+		pi->cmapped = 1;
+		break;
+		
+	    case 12:
+		pi->g_bits = pi->r_bits = pi->b_bits = 4;
+		pi->cached = 1;
+		break;
+		
+	    case 15:
+		pi->g_bits = pi->r_bits = pi->b_bits = 5;
+		pi->cached = 1;
+		break;
+		
+	    case 16:
+		pi->g_bits = pi->r_bits = pi->b_bits = 5;
+		pi->i_bits = 1;
+		pi->cached = 1;
+		break;
+		
+	    case 24:
+		pi->g_bits = pi->r_bits = pi->b_bits = 8;
+		pi->cached = 1;
+		break;
+		
+	    case 32:
+		pic_error(pi, PIC_SUPPORT);
+		break;
+		
+	    default:
+		pic_error(pi, PIC_NUM_COLORS);
+	    }
+	}
+	break;
+	
+    default:
+	pic_error(pi, PIC_TYPE);
+    }
+    
+    pi->numcols = 1 << pi->cbits;
+    
+    /* read palette data */
+    if(pi->cmapped){
+	int i;
+	pi->cmap = pic_malloc((size_t) 3 * pi->numcols, "pic_read_header#1");
+	for(i = 0; i < pi->numcols; i++){
+	    data32 c = pic_read_rgb(pi);
+	    pi->cmap[i * 3    ] = c >> 16 & 0xff;
+	    pi->cmap[i * 3 + 1] = c >>  8 & 0xff;
+	    pi->cmap[i * 3 + 2] = c       & 0xff;
+	}
+    }
+    
+    /* setup color code cache */
+    if(pi->cached)
+	pic_cache_init(pi);
+    
+    
+    pi->data = pic_malloc(sizeof(data32) * pi->width * pi->height,
+			  "pic_read_header#2");
+    {
+	int i;
+	for(i = 0; i < pi->width * pi->height; i++)
+	    pi->data[i] = 0xffffffff;
+    }
+    
+    if(DEBUG)
+	pic_show_pic_info(pi);
+}
+
+/* The main routine to expand a PIC file. */
+static void pic_expand_data(pi)
+    struct pic_info *pi;
+{
+    int cnt;
+    data32 c;
+    pi->data[0] = c = 0;
+    for(cnt = -1; cnt < pi->width * pi->height; ){
+	int len = pic_expanding_read_len(pi);
+	cnt += len;
+	if(cnt < pi->width * pi->height){
+	    int x = cnt % pi->width;
+	    int y = cnt / pi->width;
+	    data32 c = pic_expanding_read_color(pi);
+	    pic_expanding_read_chain(pi, x, y, c);
+	}
+    }
+}
+
+static int pic_expanding_read_len(pi)
+    struct pic_info *pi;
+{
+    int len;
+    byte bits;
+    for(len = 2, bits = 1; pic_read_bits(pi, 1) == 1; bits++)
+	len <<= 1;
+    return len - 1 + pic_read_bits(pi, bits);
+}
+
+static data32 pic_expanding_read_color(pi)
+    struct pic_info *pi;
+{
+    if(pi->cached){
+	byte b = pic_read_bits(pi, 1);
+	if(b){
+	    return pic_cache_get_value(pi, (int) pic_read_bits(pi, 7));
+	}else{
+	    data32 c = pic_read_color_code(pi);
+	    pic_cache_add_value(pi, c);
+	    return c;
+	}
+    }
+    return pic_read_color_code(pi);
+}
+
+static void pic_expanding_read_chain(pi, x, y, c)
+    struct pic_info *pi;
+    int x, y;
+    data32 c;
+{
+    pi->data[y * pi->width + x] = c;
+    if(pic_read_bits(pi, 1) == 1){
+	int fin = 0;
+	while(!fin){
+	    switch(pic_read_bits(pi, 2)){
+	    case 1:	/* left */
+		pi->data[(++y) * pi->width + (--x)] = c;
+		break;
+	    case 2:	/* middle */
+		pi->data[(++y) * pi->width +    x ] = c;
+		break;
+	    case 3:	/* right */
+		pi->data[(++y) * pi->width + (++x)] = c;
+		break;
+	    case 0:	/* far or nothing */
+		if(pic_read_bits(pi, 1) == 0)
+		    fin = 1;
+		else{
+		    if(pic_read_bits(pi, 1) == 0)
+			pi->data[(++y) * pi->width + (x -= 2)] = c;
+		    else
+			pi->data[(++y) * pi->width + (x += 2)] = c;
+		}
+	    }
+	}
+    }
+}
+
+/*
+ * Make a picture from the expanded data.
+ */
+static void pic_make_xvpic(pi, xp, rp, gp, bp)
+    struct pic_info *pi;
+    byte **xp, *rp, *gp, *bp;
+{
+    if(pi->cmapped){
+	if(pi->tiled256)
+	    *xp = pic_malloc((size_t) pi->width * pi->height * 2,
+			     "pic_make_xvpic#1");
+	else
+	    *xp = pic_malloc((size_t) pi->width * pi->height,
+			     "pic_make_xvpic#2");
+    }else
+	*xp = pic_malloc((size_t) pi->width * pi->height * 3,
+			 "pic_make_xvpic#3");
+    
+    if(pi->cmapped){
+	int i;
+	
+	for(i = 0; i < pi->numcols; i++){
+	    rp[i] = pi->cmap[i * 3    ];
+	    gp[i] = pi->cmap[i * 3 + 1];
+	    bp[i] = pi->cmap[i * 3 + 2];
+	}
+	
+	if(pi->tiled256){
+	    int pic_idx = 0, dat_idx;
+	    data16 col = 0;
+	    for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
+		if(pi->data[dat_idx] != 0xffffffff)
+		    col = pi->data[dat_idx];
+		(*xp)[pic_idx++] = col      & 0xff;
+		(*xp)[pic_idx++] = col >> 8 & 0xff;
+		dat_idx++;
+	    }
+	}else{
+	    int pic_idx = 0, dat_idx;
+	    byte col = 0;
+	    for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
+		if(pi->data[dat_idx] != 0xffffffff)
+		    col = pi->data[dat_idx];
+		(*xp)[pic_idx++] = col;
+	    }
+	}
+    }else{
+	int pic_idx = 0, dat_idx;
+	byte r, g, b;
+	for(dat_idx = 0; dat_idx < pi->width * pi->height; dat_idx++){
+	    if(pi->data[dat_idx] != 0xffffffff){
+		data32 col = pi->data[dat_idx];
+		r = col >> 16 & 0xff;
+		g = col >>  8 & 0xff;
+		b = col       & 0xff;
+	    }
+	    (*xp)[pic_idx++] = r;
+	    (*xp)[pic_idx++] = g;
+	    (*xp)[pic_idx++] = b;
+	}
+    }
+}
+
+
+/* The main routine to write PIC file. */
+int WritePIC(fp, pic0, ptype, w, h, rmap, gmap, bmap, numcols, colorstyle,
+	     comment)
+    FILE *fp;
+    byte *pic0;
+    int ptype, w, h;
+    byte *rmap, *gmap, *bmap;
+    int numcols, colorstyle;
+    char *comment;
+{
+    struct pic_info pic;
+    int e;
+    
+    if(DEBUG) fputs("WritePIC:\n", stderr);
+    
+    pic_init_info(&pic);
+    pic.fp = fp;
+    pic.width  = w;
+    pic.height = h;
+    pic.writing_grey = (colorstyle == F_GREYSCALE);
+    if(ptype != PIC24){		/* PIC8  */
+	pic.cmapped = 1;
+	pic.cached  = 0;
+	pic.cbits   = 8;
+	pic.g_bits  =
+	pic.r_bits  =
+	pic.b_bits  = 8;
+	pic.i_bits  = 0;
+	pic.numcols = numcols;
+    }else{			/* PIC24 */
+	pic.cmapped = 0;
+	pic.cached  = 1;
+	pic.cbits   = 24;
+	pic.g_bits  =
+	pic.r_bits  =
+	pic.b_bits  = 8;
+	pic.i_bits  = 0;
+	pic.numcols = 1 << 24;
+	pic_cache_init(&pic);
+    }
+    
+    if((e = setjmp(pic.jmp)) != 0){
+	/* When an error occurs while writing, comes here. */
+	pic_cleanup_pic_info(&pic, 1);
+	if(DEBUG) fputs("\n", stderr);
+	return -1;
+    }
+    
+    pic_write_id(&pic);
+    pic_write_comment(&pic, comment);
+    pic_write_header(&pic);
+    if(pic.cmapped)
+	pic_write_palette(&pic, rmap, gmap, bmap);
+    pic_make_sparse_data(&pic, pic0);
+    pic_write_data(&pic);
+    pic_write_bits(&pic, 0, 8);
+    
+    pic_cleanup_pic_info(&pic, 1);
+    if(DEBUG) fputs("\n", stderr);
+    return 0;
+}
+
+static void pic_write_id(pi)
+    struct pic_info *pi;
+{
+    if(fwrite("PIC", (size_t) 3, (size_t) 1, pi->fp) != 1)
+	pic_file_error(pi, PIC_WRITE);
+}
+
+static void pic_write_comment(pi, comm)
+    struct pic_info *pi;
+    char *comm;
+{
+    if(comm){
+	while(*comm){
+	    int c = *comm;
+	    if(c == '\032')
+		c = ' ';
+	    if(fputc(*comm, pi->fp) == EOF)
+		pic_file_error(pi, PIC_WRITE);
+	    comm++;
+	}
+    }
+    /* write ^Z, 0, and reserved. */
+    if(fwrite("\032\0\0", (size_t)3, (size_t) 1, pi->fp) != 1)
+	pic_file_error(pi, PIC_WRITE);
+}
+
+static void pic_write_header(pi)
+    struct pic_info *pi;
+{
+    if(DEBUG) pic_show_pic_info(pi);
+    pic_write_bits(pi, (data32) 0, 4);			/* mode:  1:1 */
+    pic_write_bits(pi, (data32) 0xf, 4);		/* type: misc */
+    pic_write_bits(pi, (data32) pi->cbits, 16);		/* bits */
+    pic_write_bits(pi, (data32) pi->width, 16);		/* width */
+    pic_write_bits(pi, (data32) pi->height, 16);	/* height */
+    pic_write_bits(pi, (data32) 0xffff, 16);		/* x: unused */
+    pic_write_bits(pi, (data32) 0xffff, 16);		/* y: unused */
+    pic_write_bits(pi, (data32) 0x0101, 16);		/* real aspect */
+}
+
+static void pic_write_palette(pi, r, g, b)
+    struct pic_info *pi;
+    byte *r, *g, *b;
+{
+    int i;
+    data32 rgb = 0;
+    pic_write_bits(pi, (data32) pi->g_bits, 8);
+    for(i = 0; i < pi->numcols; i++){
+	rgb = (data32) *r++ << 16 | (data32) *g++ << 8 | (data32) *b++;
+	pic_write_rgb(pi, rgb);
+    }
+    for( ; i < 256; i++)
+	pic_write_rgb(pi, rgb);
+}
+
+static void pic_make_sparse_data(pi, dat)
+    struct pic_info *pi;
+    byte *dat;
+{
+    int i;
+    data32 c;
+    
+    pi->data = pic_malloc(sizeof(data32) * pi->width * pi->height,
+			  "pic_make_sparse_data");
+    
+    if(pi->cmapped){
+	c = 0;
+	for(i = 0; i < pi->width * pi->height; i++){
+	    if(c != dat[i])
+		c = pi->data[i] = dat[i];
+	    else
+		pi->data[i] = 0xffffffff;
+	}
+    }else{
+	int j = 0;
+	c = 0;
+	for(i = 0; i < pi->width * pi->height; i++){
+	    data32 r, g, b, t;
+	    r = dat[j++];
+	    g = dat[j++];
+	    b = dat[j++];
+	    t = r << 16 | g << 8 | b;
+	    if(c != t)
+		c = pi->data[i] = t;
+	    else
+		pi->data[i] = 0xffffffff;
+	}
+    }
+}
+
+static void pic_write_data(pi)
+    struct pic_info *pi;
+{
+    int i;
+    int max = pi->width * pi->height;
+    data32 c = 0;
+    
+    i = -1;
+    while(i < max){
+	int j;
+	for(j = i + 1; j < max; j++){
+	    if(pi->data[j] != 0xffffffff)
+		break;
+	}
+	pic_write_length(pi, (data32) j - i);
+	i = j;
+	if(i < max){
+	    pic_write_color(pi, c = pi->data[i]);
+	    pic_write_chain(pi, i % pi->width, i / pi->width, c);
+	}
+    }
+}
+
+static void pic_write_length(pi, len)
+    struct pic_info *pi;
+    data32 len;
+{
+    int bits = 0;	/* leading 1's */
+    int max = 2;
+    
+    while(len > max){
+	max = (max + 1) * 2;
+	bits++;
+    }
+    pic_write_bits(pi, 0xffffffff, bits);
+    pic_write_bits(pi, 0, 1);
+    pic_write_bits(pi, len - max / 2, bits + 1);
+}
+
+static void pic_write_color(pi, c)
+    struct pic_info *pi;
+    data32 c;
+{
+    if(pi->cached){
+	int idx = pic_cache_lookup(pi, c);
+	if(idx < 0){	/* not found */
+	    pic_write_bits(pi, 0, 1);
+	    pic_write_color_code(pi, c);
+	    pic_cache_add_value(pi, c);
+	}else{		/* found */
+	    pic_write_bits(pi, (data32) 0xffffffff, 1);
+	    pic_write_bits(pi, (data32) idx, 7);
+	}
+    }else
+	pic_write_color_code(pi, c);
+}
+
+static void pic_write_chain(pi, x, y, c)
+    struct pic_info *pi;
+    int x, y;
+    data32 c;
+{
+    int ctr = (y + 1) * pi->width + x;
+    
+    if(y < pi->height - 1 &&
+       (                      pi->data[ctr    ] == c  ||
+	(x > 0             && pi->data[ctr - 1] == c) ||
+	(x < pi->width - 1 && pi->data[ctr + 1] == c) ||
+	(x > 1             && pi->data[ctr - 2] == c) ||
+	(x < pi->width - 2 && pi->data[ctr + 2] == c))){
+	pic_write_bits(pi, 1, 1);
+	while(++y < pi->height){
+	    if(pi->data[ctr] == c){				  /* center */
+		pic_write_bits(pi, 2, 2);
+		pi->data[ctr] = 0xffffffff;
+		ctr += pi->width;
+	    }else if(x > 0 && pi->data[ctr - 1] == c){		  /* left */
+		pic_write_bits(pi, 1, 2);
+		pi->data[ctr - 1] = 0xffffffff;
+		ctr += pi->width - 1;
+	    }else if(x < pi->width - 1 && pi->data[ctr + 1] == c){/* right */
+		pic_write_bits(pi, 3, 2);
+		pi->data[ctr + 1] = 0xffffffff;
+		ctr += pi->width + 1;
+	    }else if(x > 1 && pi->data[ctr - 2] == c){		  /* 2-left */
+		pic_write_bits(pi, 2, 4);
+		pi->data[ctr - 2] = 0xffffffff;
+		ctr += pi->width - 2;
+	    }else if(x < pi->width - 2 && pi->data[ctr + 2] == c){/* 2-right */
+		pic_write_bits(pi, 3, 4);
+		pi->data[ctr + 2] = 0xffffffff;
+		ctr += pi->width + 2;
+	    }else						  /* nothing */
+		break;
+	}
+	pic_write_bits(pi, 0, 3);
+    }else
+	pic_write_bits(pi, 0, 1);
+}
+
+
+/*
+ * These 4 functions reads or writes a color.
+ *
+ * pic_read_rgb:
+ *	reads an RGB. Each bit length is [rgb]_bits, but
+ *	it is expanded to 8bits when returned.
+ *
+ * pic_read_color_code:
+ *	reads a color code, whose length is cbits.
+ *	It is the index to the colormap or RGB itself.
+ *
+ * pic_write_rgb:
+ *	writes an RGB value.
+ *
+ * pic_write_color_code:
+ *	writes a color code.
+ */
+static data32 pic_read_rgb(pi)
+    struct pic_info *pi;
+{
+    int rb = pi->r_bits, gb = pi->g_bits, bb = pi->b_bits;
+    byte r, g, b;
+    if(pi->inv_gr){
+	r = pic_read_bits(pi, rb);
+	g = pic_read_bits(pi, gb);
+    }else{
+	g = pic_read_bits(pi, gb);
+	r = pic_read_bits(pi, rb);
+    }
+    b = pic_read_bits(pi, bb);
+    if(pi->i_bits){
+	byte i;
+	i = pic_read_bits(pi, pi->i_bits);
+	r = r << pi->i_bits | i;
+	g = g << pi->i_bits | i;
+	b = b << pi->i_bits | i;
+	rb += pi->i_bits;
+	gb += pi->i_bits;
+	bb += pi->i_bits;
+    }
+    r = pic_pad_bit(rb, r);
+    g = pic_pad_bit(gb, g);
+    b = pic_pad_bit(bb, b);
+    
+    return (data32) r << 16 | (data32) g << 8 | (data32) b;
+}
+
+static data32 pic_read_color_code(pi)
+    struct pic_info *pi;
+{
+    if(pi->cmapped)
+	return pic_read_bits(pi, pi->cbits);
+    return pic_read_rgb(pi);
+}
+
+static void pic_write_rgb(pi, rgb)
+    struct pic_info *pi;
+    data32 rgb;
+{
+    byte r = rgb >> 16;
+    byte g = rgb >> 8;
+    byte b = rgb;
+    if(pi->writing_grey)
+	r = g = b = MONO(r, g, b);
+    pic_write_bits(pi, g, pi->g_bits);
+    pic_write_bits(pi, r, pi->r_bits);
+    pic_write_bits(pi, b, pi->b_bits);
+}
+
+static void pic_write_color_code(pi, code)
+    struct pic_info *pi;
+    data32 code;
+{
+    if(pi->cmapped){
+	pic_write_bits(pi, code, pi->cbits);
+    }else{
+	pic_write_rgb(pi, code);
+    }
+}
+
+
+/*
+ * These pic_cache_* functions are an implementation of the color cache.
+ *
+ * pic_cache_init:
+ *	initializes the cache.
+ *	
+ * pic_cache_get_value:
+ *	gets a color indexed by the argument `idx'.
+ *	It updates the `most recently used' time.
+ *	
+ * pic_cache_add_value:
+ *	adds a color to the top of the cache list.
+ */
+static void pic_cache_init(pi)
+    struct pic_info *pi;
+{
+    int i;
+    pi->cache.node = pic_malloc(sizeof(struct cachenode_t) * 128,
+				"pic_cache_init");
+    for(i = 0; i < 128; i++){
+	pi->cache.node[i].newer = i + 1;
+	pi->cache.node[i].older = i - 1;
+	pi->cache.node[i].dat = 0;
+    }
+    pi->cache.node[  0].older = 127;
+    pi->cache.node[127].newer = 0;
+    pi->cache.newest = 0;
+}
+
+static data32 pic_cache_get_value(pi, idx)
+    struct pic_info *pi;
+    int idx;
+{
+    struct cachenode_t *p = pi->cache.node;
+    int n = pi->cache.newest;
+    if(n != idx){
+	p[p[idx].newer].older = p[idx].older;
+	p[p[idx].older].newer = p[idx].newer;
+	
+	p[p[n].newer].older = idx;
+	p[idx].newer = p[n].newer;
+	p[n].newer = idx;
+	p[idx].older = n;
+	
+	pi->cache.newest = idx;
+    }
+    return pi->cache.node[idx].dat;
+}
+
+static void pic_cache_add_value(pi, dat)
+    struct pic_info *pi;
+    data32 dat;
+{
+    pi->cache.newest = pi->cache.node[pi->cache.newest].newer;
+    pi->cache.node[pi->cache.newest].dat = dat;
+}
+
+static int pic_cache_lookup(pi, dat)
+    struct pic_info *pi;
+    data32 dat;
+{
+    int i;
+    for(i = 0; i < 128; i++){
+	if(pi->cache.node[i].dat == dat){
+	    pic_cache_get_value(pi, i);
+	    return i;
+	}
+    }
+    return -1;
+}
+
+
+/*
+ * These pic_{read,write}_bits functions access the bit stream.
+ * pic_read_bits:
+ *	reads the specified bits from the file.
+ *
+ * pic_write_bits:
+ *	writes the specified bits to the file.
+ */
+static data32 pic_read_bits(pi, bits)
+    struct pic_info *pi;
+    int bits;
+{
+    data32 r = 0;
+    
+    while(bits > 0){
+	while(pi->bs.rest > 0 && bits > 0){
+	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
+	    pi->bs.cur <<= 1;
+	    pi->bs.rest--;
+	    bits--;
+	}
+	if(bits > 0){
+	    int c;
+	    if((c = fgetc(pi->fp)) == EOF){
+		pic_file_warning(pi, PIC_CORRUPT);
+		c = 0;
+	    }
+	    pi->bs.cur  = c;
+	    pi->bs.rest = 8;
+	}
+    }
+    
+    return r;
+}
+
+static void pic_write_bits(pi, dat, bits)
+    struct pic_info *pi;
+    data32 dat;
+    int bits;
+{
+    data32 dat_mask = 1 << (bits - 1);
+    while(bits > 0){
+	while(pi->bs.rest < 8 && bits > 0){
+	    pi->bs.cur <<= 1;
+	    if(dat & dat_mask)
+		pi->bs.cur |= 1;
+	    pi->bs.rest++;
+	    bits--;
+	    dat_mask >>= 1;
+	}
+	if(pi->bs.rest >= 8){
+	    if(fputc((int)pi->bs.cur, pi->fp) == EOF)
+		pic_error(pi, PIC_WRITE);
+	    pi->bs.cur  = 0;
+	    pi->bs.rest = 0;
+	}
+    }
+}
+
+
+/*
+ * This function extends a some-bit data to the 8-bit data.
+ */
+static byte pic_pad_bit(bits, dat)
+    int bits;
+    data32 dat;
+{
+    switch(bits){
+    case 1:
+	if(dat & 1)
+	    dat = 0xff;
+	else
+	    dat = 0;
+	break;
+    case 2:
+	dat = dat << 6 | dat << 4 | dat << 2 | dat;
+	break;
+    case 3:
+	dat = dat << 5 | dat << 2 | dat >> 1;
+	break;
+    case 4:
+	dat = dat << 4 | dat;
+	break;
+    case 5:
+	dat = dat << 3 | dat >> 2;
+	break;
+    case 6:
+	dat = dat << 2 | dat >> 4;
+	break;
+    case 7:
+	dat = dat << 1 | dat >> 6;
+    }
+    
+    return dat;
+}
+
+/*
+ * These functions initialize or clean up structures.
+ * pic_init_info:
+ *	initializes a pic_info structure.
+ * pic_cleanup_pic_info:
+ *	cleans up a pic_info structure.
+ * pic_cleanup_pinfo:
+ *	cleans up a PICINFO structure.
+ */
+static void pic_init_info(pi)
+    struct pic_info *pi;
+{
+    pi->fp = NULL;
+    pi->bs.rest = 0;
+    pi->bs.cur = '\0';
+    pi->type = pi->mode = 0;
+    pi->width = pi->height = 0;
+    pi->aspect = 1.0;
+    pi->cbits = 0;
+    pi->cmapped = pi->cached = 0;
+    pi->cache.node = NULL;
+    pi->cmap = NULL;
+    pi->g_bits = pi->r_bits = pi->b_bits = pi->i_bits = 0;
+    pi->inv_gr = 0;
+    pi->tiled256 = 0;
+    pi->numcols = 0;
+    pi->writing_grey = 0;
+}
+
+static void pic_cleanup_pic_info(pi, writing)
+    struct pic_info *pi;
+    int writing;
+{
+    if(!writing && pi->fp)
+	fclose(pi->fp);
+    if(pi->cmap)
+	free(pi->cmap);
+    if(pi->cache.node)
+	free(pi->cache.node);
+    if(pi->data)
+	free(pi->data);
+    pi->fp = NULL;
+    pi->cmap = NULL;
+    pi->cache.node = NULL;
+    pi->data = NULL;
+}
+
+static void pic_cleanup_pinfo(pinfo)
+    PICINFO *pinfo;
+{
+    if(pinfo->pic){
+	free(pinfo->pic);
+	pinfo->pic = NULL;
+    }
+    if(pinfo->comment){
+	free(pinfo->comment);
+	pinfo->comment = NULL;
+    }
+}
+
+/*
+ * Error Handlers.
+ * pic_memory_error:
+ *	shows an error message, and terminates.
+ * pic_error:
+ *	shows an non-file error message, and jumps to the entry for errors.
+ * pic_file_error:
+ *	shows an file error message, and jumps to the entry for errors.
+ * pic_file_warning:
+ *	shows an file warning message.
+ */
+static void pic_memory_error(scm, fn)
+    char *scm, *fn;
+{
+    char buf[128];
+    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
+    FatalError(buf);
+}
+
+static void pic_error(pi, mn)
+    struct pic_info *pi;
+    int mn;
+{
+    SetISTR(ISTR_WARNING, "%s", pic_msgs[mn]);
+    longjmp(pi->jmp, 1);
+}
+
+static void pic_file_error(pi, mn)
+    struct pic_info *pi;
+    int mn;
+{
+    if(feof(pi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", pic_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", pic_msgs[mn], ERRSTR(errno));
+    longjmp(pi->jmp, 1);
+}
+
+static void pic_file_warning(pi, mn)
+    struct pic_info *pi;
+    int mn;
+{
+    if(feof(pi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", pic_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", pic_msgs[mn], ERRSTR(errno));
+}
+
+static void pic_show_pic_info(pi)
+    struct pic_info *pi;
+{
+    fprintf(stderr, "  file size: %ld.\n", pi->fsize);
+    
+    fputs("  machine: ", stderr);
+    switch(pi->type){
+    case 0x0:
+	fputs("X68k", stderr);
+	break;
+    case 0x1:
+	fputs("PC-88VA", stderr);
+	if(pi->mode & 1)
+	    fputs(",HR", stderr);
+	if(pi->mode & 2)
+	    fputs(",tiled256", stderr);
+	break;
+    case 0x2:
+	fprintf(stderr,
+		"FM-TOWNS,%s-resolution", pi->mode == 5 ? "low" : "high");
+	break;
+    case 0x3:
+	fputs("Machintosh", stderr);
+	break;
+    case 0xf:
+	fputs("misc", stderr);
+    }
+    fputs("\n", stderr);
+    
+    fprintf(stderr, "  image size: %dx%d\n", pi->width, pi->height);
+    fprintf(stderr, "  aspect: %f\n", pi->aspect);
+    fprintf(stderr, "  cache: %s\n", pi->cached ? "on" : "off");
+    fprintf(stderr, "  colormap: %s\n", pi->cmapped ? "on" : "off");
+    fprintf(stderr, "  number of color bits: %d\n", pi->cbits);
+    fprintf(stderr, "  number of RGB bits: R%d,G%d,B%d,I%d\n",
+	   pi->r_bits, pi->g_bits, pi->b_bits, pi->i_bits);
+    fprintf(stderr, "  inverted G&R: %s\n", pi->inv_gr ? "true" : "false");
+    fprintf(stderr, "  number of colors: %d\n", pi->numcols);
+}
+
+/* Memory related routines. */
+static void *pic_malloc(n, fn)
+    size_t n;
+    char *fn;
+{
+    void *r = (void *) malloc(n);
+    if(r == NULL)
+	pic_memory_error("malloc", fn);
+    return r;
+}
+
+static void *pic_realloc(p, n, fn)
+    void *p;
+    size_t n;
+    char *fn;
+{
+    void *r = (p == NULL) ? (void *) malloc(n) : (void *) realloc(p, n);
+    if(r == NULL)
+	pic_memory_error("realloc", fn);
+    return r;
+}
+#endif /* HAVE_PIC */
diff -Naur xv-3.10a.old/xvpic2.c xv-3.10a/xvpic2.c
--- xv-3.10a.old/xvpic2.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvpic2.c	Tue Apr 24 09:37:05 2001
@@ -0,0 +1,3598 @@
+/*
+ * $Id: xvpic2.c,v 2.9.1.14 1995/04/24 15:34:15 ikeyan Exp $
+ * xvpic2.c - load and save routines for `PIC2' format pictures.
+ *
+ *
+ * Outline
+ * =======
+ * xvpic2.c supports the PIC2 format image file. It is used some
+ * Japanese personal computer users.
+ *
+ * The PIC2 format is designed by A.Yanagisawa. It is very excellent
+ * format except for it's encode/decode speed ;-)
+ *
+ * The features of the PIC2 format:
+ * - Powerful header information (included author, filename, title,
+ *   saver, product number, created date and comment).
+ * - Reversible compression, and very high compression ratio (In a lot
+ *   of case, keep higher compression ratio than the JPEG compression.
+ *   Especially, because of it's compression method, PIC2 is good at
+ *   pictures like cell animation).
+ * - Can handle full coloer(24 bits) image.
+ * - Can include multi image blocks into one PIC2 file.
+ * - Have four different block format (P2SS, P2SF, P2BM and
+ *   P2BI). P2SS format uses arithmetric compression for storeing
+ *   data. P2SF uses normal run length compression. P2BM and P2BI is
+ *   raw image format. Select any one accoding to the situation.
+ *
+ * Explanation of the PIC2 compression:
+
+ * - In the first place, try to record pixel color, uses color caches
+ *   which keep some recent colors, and formed accding to color's
+ *   frequency.  PIC2 has some color cache spaces that are switched by
+ *   upper pixel value of current pixel.  If cache is hit, record
+ *   that.
+ * - Unfortunately, in the case of color cache didn't hit, record the
+ *   difference from the value estimated with the value of upper and
+ *   left pixel of current pixel
+ * - And extract image's color chain if exist, and record that (It
+ *   results in image's outline).
+ * - In all time of recording values, it is pressed with arithmetric
+ *   compression method which produce the ideal compression ratio in
+ *   theory(P2SS).
+ *
+ * Features
+ * ========
+ * - Support 3,6,9,12,15,18,21,24bit PIC2 format (Load/Save).
+ * - Support all image block formats of PIC2 (Load/Save).
+ * - Support multi block PIC2 file (Load/Save).
+ *
+ *
+ * Bugs
+ * ====
+ * - Unsupport 8bit PIC2 image file.
+ *
+ * If you find other bugs (surely exist :-)), send me bug-report.
+ *
+ *
+ * Author
+ * ======
+ * IKEMOTO Masahiro <ikeyan@airlab.cs.ritsumei.ac.jp>
+ */
+
+#define PIC2_IGNORE_UNUSED_FUNCTIONS
+#define NEEDSDIR
+
+#include "xv.h"
+#include <setjmp.h>
+
+#ifdef HAVE_PIC2
+
+typedef unsigned long pixel;
+
+#define pic2_cextoshort(addr) ( \
+    (((short) (((byte *) addr)[0])) <<  8) | \
+    ( (short) (((byte *) addr)[1])) \
+)
+#define pic2_cextolong(addr) ( \
+    (((long)  (((byte *) addr)[0])) << 24) | \
+    (((long)  (((byte *) addr)[1])) << 16) | \
+    (((long)  (((byte *) addr)[2])) <<  8) | \
+    ( (long)  (((byte *) addr)[3])) \
+)
+#define pic2_shorttocex(addr, n) { \
+    ((byte *) addr)[0] = (((unsigned short) (n) >>  8) & 0xff); \
+    ((byte *) addr)[1] = ( (unsigned short) (n)        & 0xff); \
+}
+#define pic2_longtocex(addr, n) { \
+    ((byte *) addr)[0] = (((unsigned long)  (n) >> 24) & 0xff); \
+    ((byte *) addr)[1] = (((unsigned long)  (n) >> 16) & 0xff); \
+    ((byte *) addr)[2] = (((unsigned long)  (n) >>  8) & 0xff); \
+    ((byte *) addr)[3] = ( (unsigned long)  (n)        & 0xff); \
+}
+#define pic2_shift_bits(b, n) (((n) > 0) ? ((b) << (n)) : ((b) >> -(n)))
+
+#define PIC2_READ_MODE		0
+#define PIC2_WRITE_MODE		1
+
+#define PIC2_ARITH_CACHE	32
+#define PIC2_ARITH_CONTEXT	128
+#define PIC2_FAST_CACHE		64
+
+#define PIC2_HEADER_SIZE	124
+#define PIC2_BLOCK_HEADER_SIZE	26
+
+struct pic2_header {
+    char magic[4];
+    char name[18];
+    char subtitle[8];
+    char crlf0[2];
+    char title[30];
+    char crlf1[2];
+    char saver[30];
+    char crlf2[2];
+    char eof[1];
+    char reserve0[1];
+    short flag;
+    short no;
+    long time;
+    long size;
+    short depth;
+    short x_aspect;
+    short y_aspect;
+    short x_max;
+    short y_max;
+    long reserve1;
+};
+
+struct pic2_block {
+    char id[4];
+    long size;
+    short flag;
+    short x_wid;
+    short y_wid;
+    short x_offset;
+    short y_offset;
+    long opaque;
+    long reserve;
+};
+
+struct pic2_info {
+    jmp_buf jmp;
+    FILE *fp;
+    struct {
+	int rest;
+	byte cur;
+	int bits;
+	char zero;
+    }bs;
+    long fsize;
+    struct pic2_header *header;
+    struct pic2_block *block;
+    int n_pal;
+    int pal_bits;
+    byte pal[256][3];
+    char *comment;
+    char mode;
+    long next_pos;
+    long block_pos;
+    short x_max;
+    short y_max;
+    int ynow;
+    byte *buf;
+    pixel *vram_prev;
+    pixel *vram_now;
+    pixel *vram_next;
+    short *flag_now;
+    short *flag_next;
+    short *flag2_now;
+    short *flag2_next;
+    short *flag2_next2;
+    pixel (*cache)[PIC2_ARITH_CACHE];
+    unsigned short *cache_pos;
+    unsigned short *mulu_tab;
+    long aa;
+    long cc;
+    long dd;
+    char cache_hit_c;
+    int (*next_line) PARM((struct pic2_info *, pixel **));
+    char writing_grey;
+    char pagebname[64];
+    int pnum;
+};
+
+static void pic2_open_file             PARM((struct pic2_info*,char*));
+static void pic2_read_header           PARM((struct pic2_info*));
+static void pic2_read_block_header1    PARM((struct pic2_info*));
+static void pic2_read_block_header2    PARM((struct pic2_info*));
+static short pic2_arith_decode_bit     PARM((struct pic2_info*,int));
+static short pic2_arith_decode_nn      PARM((struct pic2_info*,int));
+static void pic2_arith_expand_chain    PARM((struct pic2_info*,int,int,pixel));
+static short pic2_arith_get_number     PARM((struct pic2_info*,int,int));
+static pixel pic2_arith_read_color     PARM((struct pic2_info*,int));
+static int pic2_arith_expand_line      PARM((struct pic2_info*,pixel**));
+static int pic2_arith_loader_init      PARM((struct pic2_info*));
+static int pic2_fast_read_length       PARM((struct pic2_info*));
+static void pic2_fast_expand_chain     PARM((struct pic2_info*,int,pixel));
+static pixel pic2_fast_read_color      PARM((struct pic2_info*,pixel));
+static int pic2_fast_expand_line       PARM((struct pic2_info*,pixel**));
+static int pic2_fast_loader_init       PARM((struct pic2_info*));
+static int pic2_beta_expand_line       PARM((struct pic2_info*,pixel**));
+static int pic2_beta_loader_init       PARM((struct pic2_info*));
+static void pic2_make_xvpic            PARM((struct pic2_info*,byte**,
+					     byte*,byte*,byte*));
+static void pic2_make_pagefile         PARM((struct pic2_info*,char*,int));
+static void pic2_setup_pic2_info       PARM((struct pic2_info*,
+					     char*,char*,char*,char*,
+					     int,int,int,int,int,int,char *));
+static void pic2_append                PARM((struct pic2_info*));
+static void pic2_write_header1         PARM((struct pic2_info*));
+static void pic2_write_header2         PARM((struct pic2_info*));
+static void pic2_write_block_header    PARM((struct pic2_info*));
+static void pic2_arith_write_zero_bit  PARM((struct pic2_info*));
+static void pic2_arith_flush_bit_buf   PARM((struct pic2_info*));
+static void pic2_arith_carry_bit       PARM((struct pic2_info*));
+static void pic2_arith_encode_bit      PARM((struct pic2_info*,int,int));
+static void pic2_arith_encode_nbyte    PARM((struct pic2_info*,int,int,int));
+static void pic2_arith_encode_nn       PARM((struct pic2_info*,int,int));
+static void pic2_arith_press_chain     PARM((struct pic2_info*,int));
+static void pic2_arith_put_number      PARM((struct pic2_info*,int,int,int));
+static void pic2_arith_write_color     PARM((struct pic2_info*,int));
+static void pic2_arith_press_line2     PARM((struct pic2_info*));
+static int pic2_arith_press_line       PARM((struct pic2_info*,pixel**));
+static int pic2_arith_saver_init       PARM((struct pic2_info*,pixel**));
+static void pic2_fast_write_length     PARM((struct pic2_info*,int));
+static void pic2_fast_press_chain      PARM((struct pic2_info*,int));
+static void pic2_fast_press_chain2     PARM((struct pic2_info*,int));
+static void pic2_fast_flush_chain      PARM((struct pic2_info*));
+static void pic2_fast_write_color      PARM((struct pic2_info*,int));
+static void pic2_fast_press_line2      PARM((struct pic2_info*));
+static int pic2_fast_press_line        PARM((struct pic2_info*,pixel**));
+static int pic2_fast_saver_init        PARM((struct pic2_info*,pixel**));
+static int pic2_beta_press_line        PARM((struct pic2_info*,pixel**));
+static int pic2_beta_saver_init        PARM((struct pic2_info*,pixel**));
+static void pic2_write_data            PARM((struct pic2_info*,byte*,
+					     int,int,int,int,int,
+					     byte*,byte*,byte*,int,int));
+static int pic2_next_line              PARM((struct pic2_info*,pixel**));
+static int pic2_next_block             PARM((struct pic2_info*));
+static int pic2_find_block             PARM((struct pic2_info*));
+static int pic2_load_block             PARM((struct pic2_info*));
+static int pic2_save_block             PARM((struct pic2_info*,pixel**,
+					     int,int,int,int,char*,pixel));
+#ifndef PIC2_IGNORE_UNUSED_FUNCTIONS
+static void pic2_read_palette          PARM((struct pic2_info*,
+					     byte*,byte*,byte*));
+static void pic2_write_palette         PARM((struct pic2_info*,int,int,
+					     byte*,byte*,byte*));
+#endif /* !PIC2_IGNORE_UNUSED_FUNCTIONS */
+static byte pic2_convert_color_bits    PARM((int,int,int));
+static byte pic2_pad_color_bits        PARM((int,int,int));
+static byte pic2_reduce_color_bits     PARM((int,int,int));
+static pixel pic2_exchange_rg          PARM((pixel,int));
+static void pic2_handle_para           PARM((struct pic2_info*,int));
+static int pic2_alloc_buffer           PARM((struct pic2_info*));
+static void pic2_free_buffer           PARM((struct pic2_info*));
+static long pic2_seek_file             PARM((struct pic2_info*,long,int));
+static long pic2_tell_file             PARM((struct pic2_info*));
+static int pic2_read_file              PARM((struct pic2_info*,void*,size_t));
+static long pic2_read_long             PARM((struct pic2_info*));
+static short pic2_read_short           PARM((struct pic2_info*));
+static char pic2_read_char             PARM((struct pic2_info*));
+static int pic2_write_file             PARM((struct pic2_info*,void*,size_t));
+static int pic2_write_long             PARM((struct pic2_info*,long));
+static int pic2_write_short            PARM((struct pic2_info*,int));
+static int pic2_write_char             PARM((struct pic2_info*,int));
+static unsigned long pic2_read_bits    PARM((struct pic2_info*,int));
+static void pic2_write_bits            PARM((struct pic2_info*,
+					     unsigned long,int));
+static void pic2_flush_bits            PARM((struct pic2_info*));
+static void pic2_memory_error          PARM((char*,char*));
+static void pic2_error                 PARM((struct pic2_info*,int));
+static void pic2_file_error            PARM((struct pic2_info*,int));
+static void pic2_init_info             PARM((struct pic2_info*));
+static void pic2_cleanup_pic2_info     PARM((struct pic2_info*,int));
+static void pic2_cleanup_pinfo         PARM((PICINFO*));
+static void pic2_show_pic2_info        PARM((struct pic2_info*));
+static char *pic2_strncpy              PARM((char*,char*,size_t));
+static void *pic2_malloc               PARM((size_t,char*));
+static void *pic2_new                  PARM((size_t,char*));
+
+static int WritePIC2                   PARM((FILE*,byte*,int,int,int,
+					     byte*,byte*,byte*,int,int,char*,
+					     int,int,int,int,int,char*));
+
+static char *pic2_id = "P2DT";
+
+/* Error Messages */
+static char *pic2_msgs[] = {
+    NULL,
+#define PIC2_OPEN 1
+    "can't open file.",
+#define PIC2_CORRUPT 2
+    "file corrupted.",
+#define PIC2_FORMAT 3
+    "not PIC2 format.",
+#define PIC2_DEPTH 4
+    "not support the depth which cannot be divided with 3.",
+#define PIC2_TMPFILE 5
+    "unable to create temporary filename???",
+#define PIC2_PAGE 6
+    "couldn't load the page.",
+#define PIC2_APPEND 7
+    "cannot append.",
+#define PIC2_WRITE 8
+    "write failed.",
+};
+
+struct _form_tab {
+    char *id;
+    int (*loader_init) PARM((struct pic2_info *));
+    int (*saver_init) PARM((struct pic2_info *, pixel **));
+} form_tab[] = {
+	{ "P2SS", pic2_arith_loader_init, pic2_arith_saver_init},
+	{ "P2SF", pic2_fast_loader_init, pic2_fast_saver_init},
+	{ "P2BM", pic2_beta_loader_init, pic2_beta_saver_init},
+	{ "P2BI", pic2_beta_loader_init, pic2_beta_saver_init},
+};
+#define	n_form_tab (sizeof(form_tab) / sizeof(struct _form_tab))
+#define P2SS 0
+#define P2SF 1
+#define P2BM 2
+#define P2BI 3
+
+/* The main routine to load a PIC2 file. */
+int LoadPIC2(fname, pinfo, quick)
+char *fname;
+PICINFO *pinfo;
+int quick;
+{
+    int e, i, block;
+    struct pic2_info pic2;
+    
+    if (DEBUG)
+	fputs("LoadPIC2:\n", stderr);
+
+    pic2_init_info(&pic2);
+    
+    if ((e = setjmp(pic2.jmp)) != 0){
+	/* When an error occurs, comes here. */
+	pic2_free_buffer(&pic2);
+	pic2_cleanup_pic2_info(&pic2, 0);
+	pic2_cleanup_pinfo(pinfo);
+	if (pic2split)
+	    KillPageFiles(pic2.pagebname, pic2.pnum);
+	SetCursors(-1);
+	if (DEBUG)
+	    fputs("\n", stderr);
+	return (0);
+    }
+    pic2_open_file(&pic2, fname);
+    pic2_read_header(&pic2);
+
+    if ((i = pic2_find_block(&pic2)) == 0)
+	pic2_file_error(&pic2, PIC2_CORRUPT);
+
+    block = 1;
+    while(i == 2) {
+	SetISTR(ISTR_WARNING, "unknown or invalid block #%d.", block);
+	i = pic2_next_block(&pic2);
+	block++;
+    }
+
+    if (pic2split && !quick) {
+	char firstpage[512];
+	struct stat st;
+
+#ifndef VMS
+	sprintf(pic2.pagebname, "%s/xvpic2XXXXXX", tmpdir);
+#else
+	sprintf(pic2.pagebname, "Sys$Scratch:xvpic2XXXXXX");
+#endif /* VMS */
+	mktemp(pic2.pagebname);
+	if (pic2.pagebname[0] == '\0')
+	    pic2_error(&pic2, PIC2_TMPFILE);
+	strcat(pic2.pagebname, ".");
+
+	sprintf(firstpage, "%s%d", pic2.pagebname, 1);
+	if (stat(firstpage, &st)) {
+	    for (pic2.pnum = 1; i >= 1; pic2.pnum++) {
+		pic2_load_block(&pic2);
+		pic2_make_pagefile(&pic2, pic2.pagebname, pic2.pnum);
+		while(block++, (i = pic2_next_block(&pic2)) == 2)
+		    SetISTR(ISTR_WARNING,
+			    "unknown or invalid block #%d.", block);
+	    }
+            pinfo->numpages = --pic2.pnum;
+            if (!LoadPIC2(firstpage, pinfo, 1))
+		pic2_error(&pic2, PIC2_PAGE);
+	    if (pic2.pnum == 1)
+		unlink(firstpage);
+	    else
+		strcpy(pinfo->pagebname, pic2.pagebname);
+	} else
+            if (!LoadPIC2(fname, pinfo, 1))
+		pic2_error(&pic2, PIC2_PAGE);
+    } else {
+	char buf[128], format[64];
+	int j;
+
+	pinfo->w = pic2.x_max;
+	pinfo->h = pic2.y_max;
+	pinfo->normw = pinfo->w;
+	pinfo->normh = pinfo->h;
+	pinfo->type = PIC24;
+	for (j = 0; j < n_form_tab; j++) {
+	    if (xvbcmp(pic2.block->id, form_tab[j].id, (size_t) 4) == 0)
+		break;
+	}
+	pinfo->frmType = F_PIC2;
+	pinfo->colType = F_FULLCOLOR;
+	pinfo->comment = pic2.comment;
+
+	if (pic2split) {
+	    pic2_make_xvpic(&pic2, &pinfo->pic, pinfo->r, pinfo->g, pinfo->b);
+	    strcpy(format, form_tab[j].id);
+	} else {
+	    for (pic2.pnum = 1; i >= 1; pic2.pnum++) {
+		SetISTR(ISTR_INFO, "composing block #%d", block);
+		pic2_make_xvpic(&pic2, &pinfo->pic,
+				pinfo->r, pinfo->g, pinfo->b);
+		while(block++, (i = pic2_next_block(&pic2)) == 2)
+		    SetISTR(ISTR_WARNING,
+			    "unknown or invalid block #%d.", block);
+	    }
+	    if (--block > 1)
+		if (block != --pic2.pnum)
+		    sprintf(format, "MultiBlock[%d/%d]", block, pic2.pnum);
+		else
+		    sprintf(format, "MultiBlock[%d]", block);
+	    else
+		strcpy(format, form_tab[j].id);
+	}
+	sprintf(buf, "PIC2(%s). %d colors (%ld bytes)", format,
+		(int) 1 << pic2.header->depth, pic2.fsize);
+	strcat(pinfo->fullInfo, buf);
+	sprintf(pinfo->shrtInfo, "%dx%d(aspect %4.2f) PIC2(%s).",
+		pinfo->w, pinfo->h,
+		(float) pic2.header->x_aspect / (float) pic2.header->y_aspect,
+		format);
+	if (!nopicadjust)
+	    normaspect = (float) pic2.header->x_aspect
+			 / (float) pic2.header->y_aspect;
+    }
+    pic2_cleanup_pic2_info(&pic2, 0);
+    SetCursors(-1);
+    if (DEBUG)
+	fputs("\n", stderr);
+    return (1);
+}
+
+/*
+ * This function opens the file, and set its size.
+ */
+static void pic2_open_file(pi, fname)
+    struct pic2_info *pi;
+    char *fname;
+{
+    if ((pi->fp = fopen(fname, "rb")) == NULL)
+	pic2_file_error(pi, PIC2_OPEN);
+    fseek(pi->fp, (size_t) 0, SEEK_END);
+    pi->fsize = ftell(pi->fp);
+    fseek(pi->fp, (size_t) 0, SEEK_SET);
+}
+
+/*
+ * These functions read the PIC2 header informations.
+ * pic2_read_header:
+ *	reads the PIC2 header.
+ * pic2_read_block_header1:
+ *	reads the id number of block header and the size of block.
+ * pic2_read_block_header2:
+ *	reads the rest of block header.
+ */
+static void pic2_read_header(pi)
+struct pic2_info *pi;
+{
+    long s_comment;
+
+    pi->mode = PIC2_READ_MODE;
+
+    /* read header image */
+    pic2_read_file(pi, pi->header->magic, 4);
+    pic2_read_file(pi, pi->header->name, 18);
+    pic2_read_file(pi, pi->header->subtitle, 8);
+    pic2_read_file(pi, pi->header->crlf0, 2);
+    pic2_read_file(pi, pi->header->title, 30);
+    pic2_read_file(pi, pi->header->crlf1, 2);
+    pic2_read_file(pi, pi->header->saver, 30);
+    pic2_read_file(pi, pi->header->crlf2, 2);
+    pic2_read_file(pi, pi->header->eof, 1);
+    pic2_read_file(pi, pi->header->reserve0, 1);
+    pi->header->flag = pic2_read_short(pi);
+    pi->header->no = pic2_read_short(pi);
+    pi->header->time = pic2_read_long(pi);
+    pi->header->size = pic2_read_long(pi);
+    pi->header->depth = pic2_read_short(pi);
+    pi->header->x_aspect = pic2_read_short(pi);
+    pi->header->y_aspect = pic2_read_short(pi);
+    pi->header->x_max = pic2_read_short(pi);
+    pi->header->y_max = pic2_read_short(pi);
+    pi->header->reserve1 = pic2_read_long(pi);
+
+    /* check magic number */
+    if (strncmp(pi->header->magic, pic2_id, (size_t) 4) != 0)
+        pic2_error(pi, PIC2_FORMAT);
+
+    /* read palette data, if exists */
+    if (pi->header->flag & 1) {
+	pi->pal_bits = pic2_read_char(pi);
+	pi->n_pal = pic2_read_short(pi);
+	pic2_read_file(pi, pi->pal, (size_t) (pi->n_pal * 3));
+    }
+
+    /* read comments */
+    s_comment = pi->header->size - pic2_tell_file(pi);
+    pi->comment = pic2_new(s_comment + 1, "pic2_read_header");
+    pic2_read_file(pi, pi->comment, (size_t) s_comment);
+    pi->comment[s_comment] = '\0';
+
+    pi->x_max = pi->header->x_max;
+    pi->y_max = pi->header->y_max;
+
+    /* set initial block point */
+    pi->next_pos = pic2_tell_file(pi);
+}
+
+static void pic2_read_block_header1(pi)
+struct pic2_info *pi;
+{
+    pic2_read_file(pi, pi->block->id, 4);
+    pi->block->size = pic2_read_long(pi);
+}
+
+static void pic2_read_block_header2(pi)
+struct pic2_info *pi;
+{
+    pi->block->flag = pic2_read_short(pi);
+    pi->block->x_wid = pic2_read_short(pi);
+    pi->block->y_wid = pic2_read_short(pi);
+    pi->block->x_offset = pic2_read_short(pi);
+    pi->block->y_offset = pic2_read_short(pi);
+    pi->block->opaque = pic2_read_long(pi);
+    pi->block->reserve = pic2_read_long(pi);
+}
+
+/*
+ * These functions are arithmetric pic2 format extractor.
+ */
+static short pic2_arith_decode_bit(pi, c)
+struct pic2_info *pi;
+int c;
+{
+    unsigned short pp;
+
+    pp = pi->mulu_tab[(pi->aa & 0x7f00) / 2 + c];
+    if (pi->dd >= (int) pp) {
+	pi->dd -= pp;
+	pi->aa -= pp;
+
+	while ((short) pi->aa >= 0) {
+	    pi->dd *= 2;
+	    if (pic2_read_bits(pi, 1))
+		pi->dd++;
+	    pi->aa *= 2;
+	}
+	return (1);
+    } else {
+	pi->aa = pp;
+
+	while ((short) pi->aa >= 0) {
+	    pi->dd *= 2;
+	    if (pic2_read_bits(pi, 1))
+		pi->dd++;
+	    pi->aa *= 2;
+	}
+	return (0);
+    }
+}
+
+static short pic2_arith_decode_nn(pi, c)
+struct pic2_info *pi;
+int c;
+{
+    int n;
+
+    if (pic2_arith_decode_bit(pi, c)) {
+	/* n < 1 */
+	n = 0;
+    } else if (pic2_arith_decode_bit(pi, c + 1)) {
+	/* n < 1 + 2 */
+	n = 1;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+    } else if (pic2_arith_decode_bit(pi, c + 2)) {
+	/* n < 1 + 2 + 4 */
+	n = 1 + 2;
+	if (pic2_arith_decode_bit(pi,  c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi,  c + 9))
+	    n += 2;
+    } else if (pic2_arith_decode_bit(pi, c + 3)) {
+	/* n < 1 + 2 + 4 + 8 */
+	n = 1 + 2 + 4;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi, c + 9))
+	    n += 2;
+	if (pic2_arith_decode_bit(pi, c + 10))
+	    n += 4;
+    } else if (pic2_arith_decode_bit(pi, c + 4)) {
+	/* n < 1 + 2 + 4 + 8 + 16 */
+	n = 1 + 2 + 4 + 8;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi, c + 9))
+	    n += 2;
+	if (pic2_arith_decode_bit(pi, c + 10))
+	    n += 4;
+	if (pic2_arith_decode_bit(pi, c + 11))
+	    n += 8;
+    } else if (pic2_arith_decode_bit(pi,  c + 5)) {
+	/* n < 1 + 2 + 4 + 8 + 16 + 32 */
+	n = 1 + 2 + 4 + 8 + 16;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi, c + 9))
+	    n += 2;
+	if (pic2_arith_decode_bit(pi, c + 10))
+	    n += 4;
+	if (pic2_arith_decode_bit(pi, c + 11))
+	    n += 8;
+	if (pic2_arith_decode_bit(pi, c + 12))
+	    n += 16;
+
+    } else if (pic2_arith_decode_bit(pi, c + 6)) {
+	/* n < 1 + 2 + 4 + 8 + 16 + 32 + 64 */
+	n = 1 + 2 + 4 + 8 + 16 + 32;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi, c + 9))
+	    n += 2;
+	if (pic2_arith_decode_bit(pi, c + 10))
+	    n += 4;
+	if (pic2_arith_decode_bit(pi, c + 11))
+	    n += 8;
+	if (pic2_arith_decode_bit(pi, c + 12))
+	    n += 16;
+	if (pic2_arith_decode_bit(pi, c + 13))
+	    n += 32;
+
+    } else if (pic2_arith_decode_bit(pi, c + 7)) {
+	/* n < 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 */
+	n = 1 + 2 + 4 + 8 + 16 + 32 + 64;
+	if (pic2_arith_decode_bit(pi, c + 8))
+	    n += 1;
+	if (pic2_arith_decode_bit(pi, c + 9))
+	    n += 2;
+	if (pic2_arith_decode_bit(pi, c + 10))
+	    n += 4;
+	if (pic2_arith_decode_bit(pi, c + 11))
+	    n += 8;
+	if (pic2_arith_decode_bit(pi, c + 12))
+	    n += 16;
+	if (pic2_arith_decode_bit(pi, c + 13))
+	    n += 32;
+	if (pic2_arith_decode_bit(pi, c + 14))
+	    n += 64;
+
+    } else {
+	n = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128;
+    }
+    return (n);
+}
+
+static void pic2_arith_expand_chain(pi, x, y, cc)
+struct pic2_info *pi;
+int x, y;
+pixel cc;
+{
+    static const unsigned short c_tab[] = {
+	80 + 6 * 5,	/* -5 */
+	80 + 6 * 4,
+	80 + 6 * 3,
+	80 + 6 * 2,
+	80 + 6 * 1,
+	80 + 6 * 0,	/* 0  */
+	80 + 6 * 0,	/* 1  */
+    };
+    unsigned short b;
+
+    b = c_tab[pi->flag_now[x] + 5];
+    if (!pic2_arith_decode_bit(pi, b++)) {
+	if (pic2_arith_decode_bit(pi, b++))      {	/* down */
+	    pi->vram_next[x    ] = cc;
+	    pi->flag_next[x    ] = -1;
+	} else if (pic2_arith_decode_bit(pi, b++)) {	/* left */
+	    pi->vram_next[x - 1] = cc;
+	    pi->flag_next[x - 1] = -2;
+	} else if (pic2_arith_decode_bit(pi, b++)) {	/* right */
+	    pi->vram_next[x + 1] = cc;
+	    pi->flag_next[x + 1] = -3;
+	} else if (pic2_arith_decode_bit(pi, b++)) {	/* left2 */
+	    pi->vram_next[x - 2] = cc;
+	    pi->flag_next[x - 2] = -4;
+	} else {					/* right2 */
+	    pi->vram_next[x + 2] = cc;
+	    pi->flag_next[x + 2] = -5;
+	}
+    }
+}
+
+static short pic2_arith_get_number(pi, c, bef)
+struct pic2_info *pi;
+int c, bef;
+{
+    unsigned short n;
+    byte maxcol;
+
+    maxcol = 0xff >> (8 - pi->header->depth / 3);
+
+    n = pic2_arith_decode_nn(pi, c);
+    if (bef > ((int) maxcol >> 1)) {
+	if (n > ((int) maxcol - bef) * 2)
+	    n = maxcol - n;
+	else if (n & 1)
+	    n = n / 2 + bef + 1;
+	else
+	    n = bef - n / 2;
+    } else {
+	if ((int) n > (bef * 2))
+	    n = n;
+	else if (n & 1)
+	    n = n / 2 + bef + 1;
+	else
+	    n = bef - n / 2;
+    }
+    return (n);
+}
+
+static pixel pic2_arith_read_color(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    pixel c1, c2, cc;
+    unsigned short i, j, k, m;
+    short r, g, b, r0, g0, b0;
+    short colbits;
+    pixel rmask, gmask, bmask;
+    byte maxcol;
+
+    colbits = pi->header->depth / 3;
+    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
+    gmask = (0xff >> (8 - colbits)) <<  colbits;
+    bmask = (0xff >> (8 - colbits));
+    maxcol = (byte) bmask;
+
+    c1 = pi->vram_prev[x];
+    k = ((c1 >> ((colbits - 3) * 3)) & 0x1c0)
+      | ((c1 >> ((colbits - 3) * 2)) & 0x038)
+      | ((c1 >>  (colbits - 3)     ) & 0x007);
+    if (colbits == 5)
+	k = pic2_exchange_rg(k, 3);
+
+    if (pic2_arith_decode_bit(pi, pi->cache_hit_c)) {	/* ouch */
+	pi->cache_hit_c = 16;
+
+        c2 = pi->vram_now[x - 1];
+	r = ((c1 & rmask) + (c2 & rmask)) >> (colbits * 2 + 1);
+	g = ((c1 & gmask) + (c2 & gmask)) >> (colbits     + 1);
+	b = ((c1 & bmask) + (c2 & bmask)) >> (              1);
+
+	g0 = pic2_arith_get_number(pi, 32, g);
+        r = r + g0 - g;
+	if (r > (short) maxcol)
+	    r = maxcol;
+	else if (r < 0)
+	    r = 0;
+
+        b = b + g0 - g;
+	if (b > (short) maxcol)
+	    b = maxcol;
+	else if (b < 0)
+	    b = 0;
+
+	r0 = pic2_arith_get_number(pi, 48, r);
+	b0 = pic2_arith_get_number(pi, 64, b);
+
+	pi->cache_pos[k] = j = (pi->cache_pos[k] - 1) & (PIC2_ARITH_CACHE - 1);
+	pi->cache[k][j] = cc = (r0 << (colbits * 2)) | (g0 << colbits) | b0;
+    } else {
+	pi->cache_hit_c = 15;
+
+	j = pic2_arith_decode_nn(pi, 17);
+	m = pi->cache_pos[k];
+	i = (m + j / 2) & (PIC2_ARITH_CACHE - 1);
+	j = (m + j) & (PIC2_ARITH_CACHE - 1);
+
+	cc = pi->cache[k][j];
+	pi->cache[k][j] = pi->cache[k][i];
+	pi->cache[k][i] = pi->cache[k][m];
+	pi->cache[k][m] = cc;
+    }
+    return (cc);
+}
+
+static int pic2_arith_expand_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int ymax;
+    int x, xw;
+    pixel cc;
+
+    pic2_handle_para(pi, 0);
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid - 1;
+
+    if (pi->ynow > ymax)
+	return (-2);					/* end */
+
+    /* set right end of previous line before left end of current line. */
+    if (pi->ynow == 0) {
+	cc = 0;
+    } else
+	cc = pi->vram_prev[xw - 1];
+    pi->vram_now[-1] = cc;
+
+    /* clear flag for change point */
+    xvbzero((char *) pi->flag_next, xw * sizeof(pi->flag_next[0]));
+
+    /* clear flag for position probability space */
+    xvbzero((char *) pi->flag2_next2, xw * sizeof(pi->flag2_next2[0]));
+
+    for (x = 0; x < xw; x++) {
+	if (pi->flag_now[x] < 0) {
+	    cc = pi->vram_now[x];
+	    if (pi->ynow < ymax)
+		pic2_arith_expand_chain(pi, x, pi->ynow, cc);
+	} else if (pic2_arith_decode_bit(pi, pi->flag2_now[x])) {
+	    /* ajust probability space around of change point */
+	    pi->flag2_now  [x + 1]++;
+	    pi->flag2_now  [x + 2]++;
+	    pi->flag2_next [x - 1]++;
+	    pi->flag2_next [x    ]++;
+	    pi->flag2_next [x + 1]++;
+	    pi->flag2_next2[x - 1]++;
+	    pi->flag2_next2[x    ]++;
+	    pi->flag2_next2[x + 1]++;
+
+	    pi->vram_now[x] = cc = pic2_arith_read_color(pi, x);
+	    if (pi->ynow < ymax)
+		pic2_arith_expand_chain(pi, x, pi->ynow, cc);
+	} else
+	    pi->vram_now[x] = cc;
+    }
+    if (line != NULL)
+	*line = pi->vram_now;
+    pi->ynow++;
+
+    pic2_handle_para(pi, 1);
+
+    return (pi->ynow - 1);
+}
+
+static int pic2_arith_loader_init(pi)
+struct pic2_info *pi;
+{
+    unsigned short p2b[256];
+    int i, xw;
+
+    pi->ynow = 0;
+
+    /* check the color depth */
+    if (pi->header->depth % 3)
+	pic2_error(pi, PIC2_DEPTH);
+
+    /* set function for extract next line */
+    pi->next_line = pic2_arith_expand_line;
+
+    /* clear cache and flags */
+    xw = pi->block->x_wid;
+    xvbzero((char *) pi->cache, 8 * 8 * 8 * sizeof(pi->cache[0]));
+    xvbzero((char *) pi->cache_pos, 8 * 8 * 8 * sizeof(pi->cache_pos[0]));
+
+    xvbzero((char *) pi->flag_now, xw * sizeof(pi->flag_now[0]));
+    xvbzero((char *) pi->flag2_now, 8 + xw * sizeof(pi->flag2_now[0]));
+    xvbzero((char *) pi->flag2_next, 8 + xw * sizeof(pi->flag2_next[0]));
+
+    /* go to picture data field */
+    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+
+    /* clear bit field marker */
+    pi->bs.rest = 0;
+    pi->bs.cur = 0;
+
+    /* read probability table */
+    for (i = 0; i < PIC2_ARITH_CONTEXT; i++)
+	p2b[i] = pic2_read_short(pi);
+
+    /* make multiplication table */
+    for (i = 0; i < 16384; i++) {
+	pi->mulu_tab[i] = (long) (i / 128 + 128) * (int) p2b[i & 127] / 256;
+	if (pi->mulu_tab[i] == 0) pi->mulu_tab[i] = 1;
+    }
+    /* initialize some valuables */
+    pi->aa = 0xffff;
+    pi->dd = 0;
+    for (i = 0; i < 16; i++) {
+	pi->dd *= 2;
+	if (pic2_read_bits(pi, 1))
+	    pi->dd |= 1;
+    }
+    pi->cache_hit_c = 16;
+
+    return (0);
+}
+
+/*
+ * These functions are fast pic2 compression extractor.
+ */
+static int pic2_fast_read_length(pi)
+struct pic2_info *pi;
+{
+    int a;
+	
+    a = 0;
+    while (pic2_read_bits(pi, 1)) {
+	a++;
+    }
+    if (a == 0)
+	return (0);
+    return (pic2_read_bits(pi, a) + (1 << a) - 1);
+}
+
+static void pic2_fast_expand_chain(pi, x, cc)
+struct pic2_info *pi;
+int x;
+pixel cc;
+{
+    if (pic2_read_bits(pi, 1) != 0) {
+	if (pic2_read_bits(pi, 1) != 0) {		/* down */
+	    pi->vram_next[x] = cc;
+	    pi->flag_next[x] = -1;
+	} else if (pic2_read_bits(pi, 1) != 0) {
+	    if (pic2_read_bits(pi, 1) == 0) {		/* left2down */
+		pi->vram_next[x - 2] = cc;
+		pi->flag_next[x - 2] = -1;
+	    } else {					/* left1down */
+		pi->vram_next[x - 1] = cc;
+		pi->flag_next[x - 1] = -1;
+	    }
+	} else {
+	    if (pic2_read_bits(pi, 1) == 0) {		/* right2down */
+		pi->vram_next[x + 2] = cc;
+		pi->flag_next[x + 2] = -1;
+	    } else {					/* left1down */
+		pi->vram_next[x + 1] = cc;
+		pi->flag_next[x + 1] = -1;
+	    }
+	}
+    }
+}
+
+static pixel pic2_fast_read_color(pi, bc)
+struct pic2_info *pi;
+pixel bc;
+{
+    pixel cc;
+    unsigned short j, k, m;
+    short depth, colbits;
+    pixel (*cache)[PIC2_FAST_CACHE];
+
+    depth = pi->header->depth;
+    colbits = depth / 3;
+    cache = (pixel (*)[PIC2_FAST_CACHE]) pi->cache;
+
+    bc = pic2_exchange_rg(bc, colbits);
+    k = pic2_shift_bits(bc, 8 - depth);
+    if (pic2_read_bits(pi, 1) == 0) {
+	pi->cache_pos[k] = m = (pi->cache_pos[k] - 1) & (PIC2_FAST_CACHE - 1);
+	cc = pic2_read_bits(pi, depth);
+	cc = pic2_exchange_rg(cc, colbits);
+	cache[k][m] = cc;
+    } else {
+	j = pic2_read_bits(pi, 6);		/* 6= log2(PIC2_FAST_CACHE) */
+	m = pi->cache_pos[k];
+	cc = cache[k][(m + j) & (PIC2_FAST_CACHE - 1)];
+    }
+    return (cc);
+}
+
+static int pic2_fast_expand_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int ymax;
+    int x, xw;
+    pixel cc;
+
+    pic2_handle_para(pi, 0);
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid - 1;
+
+    if (pi->ynow > ymax)
+	return (-2);
+
+    if (pi->ynow == 0) {
+	pi->dd = 0;
+	pi->aa = pic2_fast_read_length(pi);
+	if (pi->aa == 1023)
+	    pi->dd = 1023;
+	else if (pi->aa > 1023)
+	    pi->aa--;
+	cc = 0;
+    } else
+	cc = pi->vram_prev[xw - 1];
+
+    xvbzero((char *) pi->flag_next, xw * sizeof(pi->flag_next[0]));
+
+    for (x = 0; x < xw; x++) {
+	if (pi->dd > 0) {
+	    if (pi->flag_now[x] < 0) {			/* on chain ? */
+		cc = pi->vram_now[x];
+		pic2_fast_expand_chain(pi, x, cc);
+		if (--pi->dd == 0) {
+		    pi->aa = pic2_fast_read_length(pi);
+		    if (pi->aa == 1023)
+			pi->dd = 1023;
+		    else if (pi->aa > 1023)
+			pi->aa--;
+		}
+	    } else
+		pi->vram_now[x] = cc;
+	} else {
+	    if (pi->flag_now[x] < 0) {			/* on chain ? */
+		cc = pi->vram_now[x];
+		pic2_fast_expand_chain(pi, x, cc);
+	    } else if (--pi->aa < 0) {
+		cc = pi->vram_now[x] = pic2_fast_read_color(pi, cc);
+		pic2_fast_expand_chain(pi, x, cc);
+		pi->aa = pic2_fast_read_length(pi);
+		if (pi->aa == 1023)
+		    pi->dd = 1023;
+		else if (pi->aa > 1023)
+		    pi->aa--;
+	    } else
+		pi->vram_now[x] = cc;
+	}
+    }
+    if (line != NULL)
+	*line = pi->vram_now;
+    pi->ynow++;
+
+    pic2_handle_para(pi, 1);
+
+    return (pi->ynow - 1);
+}
+
+static int pic2_fast_loader_init(pi)
+struct pic2_info *pi;
+{
+    int xw;
+
+    pi->ynow = 0;
+
+    /* check the color depth */
+    if (pi->header->depth % 3)
+	pic2_error(pi, PIC2_DEPTH);
+
+    /* set function for extract next line */
+    pi->next_line = pic2_fast_expand_line;
+
+    /* clear cache and flags */
+    xw = pi->block->x_wid;
+    xvbzero((char *) pi->cache, sizeof(pi->cache[0]) * 256);
+    xvbzero((char *) pi->cache_pos, sizeof(pi->cache_pos[0]) * 8 * 8 * 8);
+    xvbzero((char *) pi->flag_now, (xw + 8) * sizeof(pi->flag_now[0]));
+    xvbzero((char *) pi->flag_next, (xw + 8) * sizeof(pi->flag_next[0]));
+
+    /* go to picture data field */
+    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+
+    /* clear bit field marker */
+    pi->bs.rest = 0;
+    pi->bs.cur = 0;
+
+    return (0);
+}
+
+/*
+ * These functions are beta pic2 format extractor.
+ */
+static int pic2_beta_expand_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int i, xw, ymax;
+    byte a, b, c, *p;
+    pixel *pc;
+    short depth, pixbyte, colbits;
+
+    depth = pi->header->depth;
+    pixbyte = depth / 8 + ((depth % 8) > 0);
+    colbits = depth / 3;
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid - 1;
+
+    if (pi->ynow > ymax)
+	return (-2);					/* end */
+
+    pc = pi->vram_now;
+    p = (byte *) pi->vram_prev;
+    if (pixbyte == 3) {
+	pic2_read_file(pi, pi->vram_prev, (size_t) (xw * pixbyte));
+	for (i = 0; i < xw; i++, pc++) {
+	    a = *p++;
+	    b = *p++;
+	    c = *p++;
+	    *pc = ((pixel) a << 16) | ((pixel) b << 8) | (pixel) c;
+	}
+    } else if (pixbyte == 2) {
+	pic2_read_file(pi, pi->vram_prev, (size_t) (xw * 2));
+	if (strncmp(pi->block->id, "P2BM", 4) == 0) {
+	    for (i = 0; i < xw; i++, pc++) {
+		a = *p++;
+		b = *p++;
+		*pc = ((pixel) a << 8) | (pixel) b;
+		if (colbits == 5) {
+		    *pc >>= 1;
+		    *pc = pic2_exchange_rg(*pc, colbits);
+		}
+	    }
+	} else {
+	    for (i = 0; i < xw; i++, pc++) {
+		a = *p++;
+		b = *p++;
+		*pc = ((pixel) b << 8) | (pixel) a;
+		if (colbits == 5) {
+		    *pc >>= 1;
+		    *pc = pic2_exchange_rg(*pc, colbits);
+		}
+	    }
+	}
+    } else {
+	pic2_read_file(pi, pi->vram_prev, (size_t) xw);
+	for (i = 0; i < xw; i++)
+	    *pc++ = *p++;
+    }
+    if (line != NULL)
+	*line = pi->vram_now;
+
+    pc = pi->vram_prev;
+    pi->vram_prev = pi->vram_now;
+    pi->vram_now = pi->vram_next;
+    pi->vram_next = pc;
+
+    pi->ynow++;
+    return (pi->ynow - 1);
+}
+
+static int pic2_beta_loader_init(pi)
+struct pic2_info *pi;
+{
+    pi->ynow = 0;
+    pi->next_line = pic2_beta_expand_line;
+    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+    return (0);
+}
+
+/*
+ * Make a picture from the expanded data.
+ */
+static void pic2_make_xvpic(pi, xp, rp, gp, bp)
+struct pic2_info *pi;
+byte **xp, *rp, *gp, *bp;
+{
+    int line, i;
+    pixel *linep, opaque;
+    short colbits;
+    byte colmask;
+
+    if (*xp == NULL)
+	*xp = pic2_new((size_t) pi->x_max * pi->y_max * 3, "pic2_make_xvpic");
+
+    if (pi->block->flag & 1)
+	opaque = pi->block->opaque;
+    else
+	opaque = 0xffffffff;
+
+    colbits = pi->header->depth / 3;
+    colmask = 0xff >> (8 - colbits);
+
+    line = pic2_load_block(pi);
+    for (;;) {
+	int pic_idx;
+
+	line = pic2_next_line(pi, &linep);
+	if (line < 0)
+	    break;
+	pic_idx = ((line + pi->block->y_offset) * pi->x_max
+		   + pi->block->x_offset) * 3;
+
+	for (i = 0; i < pi->block->x_wid; i++, linep++) {
+	    byte r, g, b;
+
+	    if (*linep != opaque) {
+		r = ((*linep >> (colbits * 2)) & colmask);
+		r = pic2_convert_color_bits(r, colbits, 8);
+		g = ((*linep >>  colbits     ) & colmask);
+		g = pic2_convert_color_bits(g, colbits, 8);
+		b = ( *linep                   & colmask);
+		b = pic2_convert_color_bits(b, colbits, 8);
+		(*xp)[pic_idx++] = r;
+		(*xp)[pic_idx++] = g;
+		(*xp)[pic_idx++] = b;
+	    } else
+	        pic_idx += 3;
+
+	    WaitCursor();
+	}
+    }
+}
+
+/*
+ * This function splits multi block PIC2 file to several pages.
+ */
+static void pic2_make_pagefile(pi, pagebname, pnum)
+struct pic2_info *pi;
+char *pagebname;
+int pnum;
+{
+    struct pic2_info pic2;
+    FILE *fp;
+    char pagefile[64], *buf;
+    size_t imagesize;
+
+    sprintf(pagefile, "%s%d", pagebname, pnum);
+    if ((fp = fopen(pagefile, "wb")) == NULL)
+	pic2_error(pi, PIC2_WRITE);
+
+    xvbcopy((char *) pi, (char *) &pic2, sizeof(struct pic2_info));
+    pic2.fp = fp;
+
+    pic2_write_header1(&pic2);
+
+    pic2_write_block_header(&pic2);
+
+    imagesize = pi->block->size - PIC2_BLOCK_HEADER_SIZE;
+    buf = (char *) pic2_malloc(imagesize, "pic2_make_pagefile");
+
+    pic2_seek_file(pi, pi->block_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+    if (fread(buf, (size_t) 1, imagesize, pi->fp) < imagesize) {
+	free(buf);
+	pic2_file_error(pi, PIC2_CORRUPT);
+    }
+    if (fwrite(buf, (size_t) 1, imagesize, fp) < imagesize) {
+	free(buf);
+	pic2_error(pi, PIC2_WRITE);
+    }
+    free(buf);
+
+    pic2.next_pos = pic2_tell_file(&pic2);
+    pic2_write_header2(&pic2);
+
+    fclose(fp);
+}
+
+/* The main routine to save a PIC2 file. */
+static int WritePIC2(fp, pic0, ptype, w, h, rmap, gmap, bmap, numcols,
+		     colorstyle, fname, type, depth, x_offset, y_offset,
+		     append, comment)
+FILE *fp;
+byte *pic0;
+int ptype, w, h;
+byte *rmap, *gmap, *bmap;
+int numcols, colorstyle;
+char *fname;
+int type, depth;
+int x_offset, y_offset;
+int append;
+char *comment;
+{
+    struct pic2_info pic2;
+    char creator[256], title[256], saver[256];
+    int e;
+    
+    if (DEBUG)
+	fputs("WritePIC2:\n", stderr);
+
+    pic2_init_info(&pic2);
+    pic2.fp = fp;
+    pic2.writing_grey = (colorstyle == F_GREYSCALE);
+
+    if ((e = setjmp(pic2.jmp)) != 0){
+	/* When an error occurs while writing, comes here. */
+	pic2_free_buffer(&pic2);
+	pic2_cleanup_pic2_info(&pic2, 1);
+	SetCursors(-1);
+	if (DEBUG)
+	    fputs("\n", stderr);
+	return (-1);
+    }
+    sprintf(creator, "XV Version %s", VERSTR);
+    pic2_strncpy(title, comment, 30);
+    sprintf(saver, "XV %s/UNIX/Bradley", VERSTR);
+
+    if (!append) {
+	pic2_setup_pic2_info(&pic2, creator, fname, title, saver,
+			     0, depth, 1, 1, w, h, comment);
+	pic2_write_header1(&pic2);
+    } else {
+	pic2_read_header(&pic2);
+	pic2_append(&pic2);
+	free(pic2.comment);
+	pic2_setup_pic2_info(&pic2, creator, fname, title, saver,
+			     0, depth, 1, 1, w, h, comment);
+    }
+
+    pic2_write_data(&pic2, pic0, ptype, x_offset, y_offset, w, h,
+		    rmap, gmap, bmap, type, depth);
+    pic2_write_header2(&pic2);
+
+    pic2_cleanup_pic2_info(&pic2, 1);
+    SetCursors(-1);
+    if (DEBUG)
+	fputs("\n", stderr);
+    return (0);
+}
+
+/*
+ * This function initializes pic2_info.
+ */
+static void pic2_setup_pic2_info(pi, name, fname, title, saver, no, depth,
+			      x_aspect, y_aspect, x_max, y_max, comment)
+struct pic2_info *pi;
+char *name, *fname, *title, *saver;
+int no, depth;
+int x_aspect, y_aspect;
+int x_max, y_max;
+char *comment;
+{
+    char basename[256], *suffix;
+
+    pi->mode = PIC2_WRITE_MODE;
+
+    /* set magic number */
+    strncpy(pi->header->magic, pic2_id, 4);
+
+    /* set creator's name */
+    pic2_strncpy(pi->header->name, (char *) name, 18);
+
+    /* set title and subtitle */
+    pic2_strncpy(pi->header->title, (char *) title, 30);
+    strcpy(basename, BaseName(fname));
+    suffix = (char *) rindex(basename, '.');
+    if (suffix) {
+	suffix++;
+	if (!strcmp(suffix, "p2") || !strcmp(suffix, "P2"))
+	    *(suffix - 1) = '\0';
+    }
+    pic2_strncpy(pi->header->subtitle, basename, 8);
+    
+    /* set saver */
+    pic2_strncpy(pi->header->saver, saver, 30);
+
+    /* set picture number */
+    pi->header->no = no;
+
+    /* import comment */
+    pi->comment = comment;
+
+    /* set some picture's info */
+    pi->header->depth = depth;
+    pi->header->x_aspect = x_aspect;
+    pi->header->y_aspect = y_aspect;
+    pi->header->x_max = x_max;
+    pi->header->y_max = y_max;
+
+    /* set some gaps */
+    pi->header->crlf0[0] = pi->header->crlf1[0] = pi->header->crlf2[0] = 0x0d;
+    pi->header->crlf0[1] = pi->header->crlf1[1] = pi->header->crlf2[1] = 0x0a;
+
+    pi->header->eof[0] = 0x1a;
+    pi->header->reserve0[0] = 0;
+    pi->header->reserve1 = 0;
+
+    /* set palettes */
+    if (pi->n_pal > 0)
+	pi->header->flag = 1;
+    else
+	pi->header->flag = 0;
+}
+
+/*
+ * This function appends to existing pic2 file.
+ */
+static void pic2_append(pi)
+struct pic2_info *pi;
+{
+    int block;
+
+    block = pic2_find_block(pi);
+    while (block > 0)
+	block = pic2_next_block(pi);
+
+    if (block != 0)
+	pic2_error(pi, PIC2_APPEND);
+}
+
+/*
+ * These functions write the PIC2 header.
+ * pic2_write_header1:
+ *	write palette data and comment.
+ * pic2_write_header2:
+ *	write the terminate block and rest header.
+ * pic2_write_block_header:
+ *	write the block header.
+ */
+static void pic2_write_header1(pi)
+struct pic2_info *pi;
+{
+    char *comment;
+
+    /* seek to block start position */
+    pic2_seek_file(pi, PIC2_HEADER_SIZE, SEEK_SET);
+
+    /* write palette */
+    if (pi->n_pal > 0) {
+	pic2_write_char(pi, pi->pal_bits);
+	pic2_write_short(pi, pi->n_pal);
+	pic2_write_file(pi, pi->pal, (size_t) (pi->n_pal * 3));
+    }
+    /* save comment */
+    comment = pi->comment;
+    if (pi->comment != NULL) {
+	for (comment = pi->comment; *comment; comment++) {
+	    if (*comment == '\n') {
+		pic2_write_char(pi, '\r');
+		pic2_write_char(pi, '\n');
+	    } else if (*comment != '\r')
+		pic2_write_char(pi, *comment);
+	}
+	pic2_write_char(pi, 0);
+    }
+    /* set the next block position */
+    pi->next_pos = pic2_tell_file(pi);
+    pi->header->size = pi->next_pos;
+}
+
+static void pic2_write_header2(pi)
+struct pic2_info *pi;
+{
+    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
+
+    /* write terminate block */
+    pic2_write_long(pi, 0);
+    pic2_write_long(pi, 0);
+
+    /* set some header information */
+    if (pi->header->x_max < pi->x_max)
+	pi->header->x_max = pi->x_max;
+    if (pi->header->y_max < pi->x_max)
+	pi->header->y_max = pi->y_max;
+
+    pi->header->time = time(NULL);
+    pic2_seek_file(pi, 0, SEEK_SET);
+
+    /* write header image */
+    pic2_write_file(pi, pi->header->magic, 4);
+    pic2_write_file(pi, pi->header->name, 18);
+    pic2_write_file(pi, pi->header->subtitle, 8);
+    pic2_write_file(pi, pi->header->crlf0, 2);
+    pic2_write_file(pi, pi->header->title, 30);
+    pic2_write_file(pi, pi->header->crlf1, 2);
+    pic2_write_file(pi, pi->header->saver, 30);
+    pic2_write_file(pi, pi->header->crlf2, 2);
+    pic2_write_file(pi, pi->header->eof, 1);
+    pic2_write_file(pi, pi->header->reserve0, 1);
+    pic2_write_short(pi, pi->header->flag);
+    pic2_write_short(pi, pi->header->no);
+    pic2_write_long(pi, pi->header->time);
+    pic2_write_long(pi, pi->header->size);
+    pic2_write_short(pi, pi->header->depth);
+    pic2_write_short(pi, pi->header->x_aspect);
+    pic2_write_short(pi, pi->header->y_aspect);
+    pic2_write_short(pi, pi->header->x_max);
+    pic2_write_short(pi, pi->header->y_max);
+    pic2_write_long(pi, pi->header->reserve1);
+}
+
+static void pic2_write_block_header(pi)
+struct pic2_info *pi;
+{
+    pic2_write_file(pi, pi->block->id, 4);
+    pic2_write_long(pi, pi->block->size);
+    pic2_write_short(pi, pi->block->flag);
+    pic2_write_short(pi, pi->block->x_wid);
+    pic2_write_short(pi, pi->block->y_wid);
+    pic2_write_short(pi, pi->block->x_offset);
+    pic2_write_short(pi, pi->block->y_offset);
+    pic2_write_long(pi, pi->block->opaque);
+    pic2_write_long(pi, pi->block->reserve);
+}
+
+/*
+ * These functions are arithmetric format compressor.
+ */
+#define	pic2_arith_write_one_bit(pi)	(pi->bs.bits++)
+
+static void pic2_arith_write_zero_bit(pi)
+struct pic2_info *pi;
+{
+    if (pi->bs.zero)
+	pic2_write_bits(pi, 0, 1);
+
+    while (pi->bs.bits--)
+	pic2_write_bits(pi, 1, 1);
+
+    pi->bs.bits = 0;
+    pi->bs.zero = 1;
+}
+
+static void pic2_arith_flush_bit_buf(pi)
+struct pic2_info *pi;
+{
+    int	i;
+
+    for (i = 0; i < 16; i++) {
+	if (pi->cc & 0x8000)
+	    pic2_arith_write_one_bit(pi);
+	else
+	    pic2_arith_write_zero_bit(pi);
+	pi->cc <<= 1;
+    }
+    pic2_arith_write_zero_bit(pi);
+    pic2_flush_bits(pi);
+}
+
+static void pic2_arith_carry_bit(pi)
+struct pic2_info *pi;
+{
+    pic2_write_bits(pi, 1, 1);
+
+    if (pi->bs.bits == 0) {
+	pi->bs.zero = 0;
+    } else {
+	while (--pi->bs.bits)
+	    pic2_write_bits(pi, 0, 1);
+	pi->bs.zero = 1;
+    }
+}
+
+static void pic2_arith_encode_bit(pi, n, c)
+struct pic2_info *pi;
+int n, c;
+{
+    int	pp;
+    long *c_sum, *c_0_sum;
+
+    c_sum = (long *) pi->mulu_tab;
+    c_0_sum = c_sum + PIC2_ARITH_CONTEXT + 1;
+
+    if (pi->dd  == 0) {
+	c_sum[c]++;
+	if (n == 0)
+	    c_0_sum[c]++;
+	return;
+    }
+    pp = pi->mulu_tab[(pi->aa & 0x7f00) / 2 + c];
+    if (n != 0) {
+	pi->cc = pi->cc + pp;
+	if (pi->cc > 0xffff) {
+	    pic2_arith_carry_bit(pi);
+	    pi->cc = pi->cc & 0xffff;
+	}
+	pi->aa = pi->aa - pp;
+	while (pi->aa < 0x8000) {
+	    if (pi->cc & 0x8000)
+		pic2_arith_write_one_bit(pi);
+	    else
+		pic2_arith_write_zero_bit(pi);
+	    pi->cc = (pi->cc * 2) & 0xffff;
+	    pi->aa = pi->aa * 2;
+	}
+    } else {
+	pi->aa = pp;
+
+	while (pi->aa < 0x8000) {
+	    if (pi->cc & 0x8000)
+		pic2_arith_write_one_bit(pi);
+	    else
+		pic2_arith_write_zero_bit(pi);
+	    pi->cc = (pi->cc * 2) & 0xffff;
+	    pi->aa = pi->aa * 2;
+	}
+    }
+}
+
+static void pic2_arith_encode_nbyte(pi, n, c, max)
+struct pic2_info *pi;
+int n, c, max;
+{
+    short i;
+
+    for (i = 0; i < n; i++) {
+	pic2_arith_encode_bit(pi, 0, c + i);
+    }
+    if (n < max) 
+	pic2_arith_encode_bit(pi, 1, c + n);
+}
+
+static void pic2_arith_encode_nn(pi, n, c)
+struct pic2_info *pi;
+int n, c;
+{
+    if (n < 1) {
+	pic2_arith_encode_bit(pi, 1, c);
+    } else if (n < 1 + 2) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 1, c + 1);
+	n -= 1;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+    } else if (n < 1 + 2 + 4) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 1, c + 2);
+	n -= 1 + 2;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+    } else if (n < 1 + 2 + 4 + 8) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 1, c + 3);
+	n -= 1 + 2 + 4;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+	pic2_arith_encode_bit(pi, n & 4, c + 10);
+    } else if (n < 1 + 2 + 4 + 8 + 16) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 0, c + 3);
+	pic2_arith_encode_bit(pi, 1, c + 4);
+	n -= 1 + 2 + 4 + 8;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+	pic2_arith_encode_bit(pi, n & 4, c + 10);
+	pic2_arith_encode_bit(pi, n & 8, c + 11);
+    } else if (n < 1 + 2 + 4 + 8 + 16 + 32) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 0, c + 3);
+	pic2_arith_encode_bit(pi, 0, c + 4);
+	pic2_arith_encode_bit(pi, 1, c + 5);
+	n -= 1 + 2 + 4 + 8 + 16;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+	pic2_arith_encode_bit(pi, n & 4, c + 10);
+	pic2_arith_encode_bit(pi, n & 8, c + 11);
+	pic2_arith_encode_bit(pi, n & 16, c + 12);
+    } else if (n < 1 + 2 + 4 + 8 + 16 + 32 + 64) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 0, c + 3);
+	pic2_arith_encode_bit(pi, 0, c + 4);
+	pic2_arith_encode_bit(pi, 0, c + 5);
+	pic2_arith_encode_bit(pi, 1, c + 6);
+	n -= 1 + 2 + 4 + 8 + 16 + 32;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+	pic2_arith_encode_bit(pi, n & 4, c + 10);
+	pic2_arith_encode_bit(pi, n & 8, c + 11);
+	pic2_arith_encode_bit(pi, n & 16, c + 12);
+	pic2_arith_encode_bit(pi, n & 32, c + 13);
+    } else if (n < 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128) {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 0, c + 3);
+	pic2_arith_encode_bit(pi, 0, c + 4);
+	pic2_arith_encode_bit(pi, 0, c + 5);
+	pic2_arith_encode_bit(pi, 0, c + 6);
+	pic2_arith_encode_bit(pi, 1, c + 7);
+	n -= 1 + 2 + 4 + 8 + 16 + 32 + 64;
+	pic2_arith_encode_bit(pi, n & 1, c + 8);
+	pic2_arith_encode_bit(pi, n & 2, c + 9);
+	pic2_arith_encode_bit(pi, n & 4, c + 10);
+	pic2_arith_encode_bit(pi, n & 8, c + 11);
+	pic2_arith_encode_bit(pi, n & 16, c + 12);
+	pic2_arith_encode_bit(pi, n & 32, c + 13);
+	pic2_arith_encode_bit(pi, n & 64, c + 14);
+    } else {
+	pic2_arith_encode_bit(pi, 0, c);
+	pic2_arith_encode_bit(pi, 0, c + 1);
+	pic2_arith_encode_bit(pi, 0, c + 2);
+	pic2_arith_encode_bit(pi, 0, c + 3);
+	pic2_arith_encode_bit(pi, 0, c + 4);
+	pic2_arith_encode_bit(pi, 0, c + 5);
+	pic2_arith_encode_bit(pi, 0, c + 6);
+	pic2_arith_encode_bit(pi, 0, c + 7);
+    }
+}
+
+static void pic2_arith_press_chain(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    int b, d;
+    pixel c;
+
+    b = -(pi->flag_now[x]);
+    c = pi->vram_now[x];
+    d = 0;
+
+    if (b < 0)
+	b = 0;
+
+    if (pi->flag_next[x] == 1 && pi->vram_next[x] == c) {
+	d = 1;
+	pi->flag_next[x] = -1;
+    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == c) {
+	d = 2;
+	pi->flag_next[x - 1] = -2;
+    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == c) {
+	d = 3;
+	pi->flag_next[x + 1] = -3;
+    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == c) {
+	d = 4;
+	pi->flag_next[x - 2] = -4;
+    } else if (pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == c) {
+	if ((pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == c)
+	    || (pi->flag_now[x + 1] != 0 && pi->vram_now[x + 1] == c)
+	    || (pi->flag_now[x + 3] != 0 && pi->vram_now[x + 3] == c)) {
+	    pic2_arith_encode_nbyte(pi, 0, 80 + 6 * b, 5);
+	    return;
+	}
+	d = 5;
+	pi->flag_next[x + 2] = -5;
+    }
+    pic2_arith_encode_nbyte(pi, d, 80 + 6 * b, 5);
+}
+
+static void pic2_arith_put_number(pi, xn, xa, xb)
+struct pic2_info *pi;
+int xn, xa, xb;
+{
+    short n;
+    byte maxcol;
+
+    maxcol = 0xff >> (8 - pi->header->depth / 3);
+
+    if (xa > ((int) maxcol >> 1)) {
+	if (xb > xa)
+	    n = (xb - xa) * 2 - 1;
+	else if (xa - ((int) maxcol - xa)  > xb)
+	    n = maxcol - xb;
+	else
+	    n = (xa - xb) * 2;
+    } else {
+	if (xb <= xa)
+	    n = (xa - xb) * 2;
+	else if (2 * xa < xb)
+	    n = xb;
+ 	else
+	    n = (xb - xa) * 2 - 1;
+    }
+    pic2_arith_encode_nn(pi, n, xn);
+}
+
+static void pic2_arith_write_color(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    pixel c1, c2, cc;
+    short g0, r0, b0, r, g, b;
+    int i, j;
+    unsigned short k;
+    pixel *p, *pp;
+    short colbits;
+    pixel rmask, gmask, bmask;
+    byte maxcol;
+
+    colbits = pi->header->depth / 3;
+    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
+    gmask = (0xff >> (8 - colbits)) <<  colbits;
+    bmask = (0xff >> (8 - colbits));
+    maxcol = (byte) bmask;
+
+    cc = pi->vram_now[x];
+    c1 = pi->vram_prev[x];
+    k = ((c1 >> ((colbits - 3) * 3)) & 0x1c0)
+      | ((c1 >> ((colbits - 3) * 2)) & 0x038)
+      | ((c1 >>  (colbits - 3)     ) & 0x007);
+    if (colbits == 5)
+	k = pic2_exchange_rg(k, 3);
+
+    p = pi->cache[k];
+    for (i = 0; i < (PIC2_ARITH_CACHE - 1); i++) {
+	if (cc == *p++)
+	    break;
+    }
+    if (i == (PIC2_ARITH_CACHE - 1)) {
+	pp = p - 1;
+	for (j = i; j > 0; j--) {
+	    *--p = *--pp;
+	}
+	pi->cache[k][0] = cc;
+	pic2_arith_encode_bit(pi, 1, pi->cache_hit_c);
+	pi->cache_hit_c = 16;
+
+	c2 = pi->vram_now[x - 1];
+	r = ((c1 & rmask) + (c2 & rmask)) >> (colbits * 2 + 1);
+	g = ((c1 & gmask) + (c2 & gmask)) >> (colbits     + 1);
+	b = ((c1 & bmask) + (c2 & bmask)) >> (              1);
+
+	r0 = (cc >> (colbits * 2)) & maxcol;
+	g0 = (cc >>  colbits     ) & maxcol;
+	b0 =  cc                   & maxcol;
+
+	r = r + g0 - g;
+	if (r < 0)
+	    r = 0;
+	else if (r > (short) maxcol)
+	    r = maxcol;
+
+	b = b + g0 - g;
+	if (b < 0)
+	    b = 0;
+	else if (b > (short) maxcol)
+	    b = maxcol;
+
+	pic2_arith_put_number(pi, 32, g, g0);
+	pic2_arith_put_number(pi, 48, r, r0);
+	pic2_arith_put_number(pi, 64, b, b0);
+    } else {
+	*--p = pi->cache[k][i / 2];
+	pi->cache[k][i / 2] = pi->cache[k][0];
+	pi->cache[k][0] = cc;
+
+	pic2_arith_encode_bit(pi, 0, pi->cache_hit_c);
+	pi->cache_hit_c = 15;
+	pic2_arith_encode_nn(pi, i, 17);
+    }
+}
+
+static void pic2_arith_press_line2(pi)
+struct pic2_info *pi;
+{
+    int x, xw, ymax;
+    pixel cc;
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid -1;
+    cc = pi->vram_now[xw - 1];			/* last color */
+    pi->vram_next[-1] = cc;
+
+    /* mark change point */
+    for (x = 0; x < xw; x++)
+	if (cc != pi->vram_next[x]) {
+	    pi->flag_next[x] = 1;
+	    cc = pi->vram_next[x];
+	} else
+	    pi->flag_next[x] = 0;
+
+    for (x = 0; x < xw; x++) {
+	if (pi->flag_now[x] == 1) {			/* change point */
+	    pi->flag2_now  [x + 1]++;
+	    pi->flag2_now  [x + 2]++;
+	    pi->flag2_next [x - 1]++;
+	    pi->flag2_next [x    ]++;
+	    pi->flag2_next [x + 1]++;
+	    pi->flag2_next2[x - 1]++;
+	    pi->flag2_next2[x    ]++;
+	    pi->flag2_next2[x + 1]++;
+
+	    /* write change point */
+	    pic2_arith_encode_bit(pi, 1, pi->flag2_now[x]);
+
+	    /* write color */
+	    pic2_arith_write_color(pi, x);
+
+	    /* if not last line, write chain */
+	    if (pi->ynow - 1 < ymax)
+		pic2_arith_press_chain(pi, x);
+	} else if (pi->flag_now[x] == 0)		/* not on chain */
+	    /* write change point */
+	    pic2_arith_encode_bit(pi, 0, pi->flag2_now[x]);
+	else				/* on chain */
+	     /* if not on last line, write next chain */
+	     if (pi->ynow - 1 < ymax)
+		 pic2_arith_press_chain(pi, x);
+    }
+}
+
+static int pic2_arith_press_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int i, xw, ymax;
+    long *c_sum, *c_0_sum;
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid -1;
+    c_sum = (long *) pi->mulu_tab;
+    c_0_sum = c_sum + PIC2_ARITH_CONTEXT +1;
+
+    pic2_handle_para(pi, 0);
+
+    xvbzero((char *) pi->flag2_next2 - 4,
+	    (8 + xw) * sizeof(pi->flag2_next2[0]));
+
+    if (pi->ynow == 0) {			/* first line */
+	int x;
+	pixel cc = 0;
+
+	if (pi->dd != 0) {			/* compress pass */
+	    unsigned short c_tab[PIC2_ARITH_CONTEXT];
+
+	    for (i = 0; i < PIC2_ARITH_CONTEXT; i++) {
+		unsigned long a, b;
+		a = c_0_sum[i];
+		b = c_sum[i];
+		while (a > 32767) {
+		    a /= 2;
+		    b /= 2;
+		}
+		if (a == b)
+		    c_tab[i] = 0xffff;		/* b==0 here, too */
+		else
+		    c_tab[i] = (65536 * a) / b; /* a < b, so less 65536 */
+	    }
+	    for (i = 0; i < 16384; i++) {
+		pi->mulu_tab[i] = (long) (i / 128 + 128) * (int) c_tab[i & 127] / 256;
+		if (pi->mulu_tab[i] == 0)
+		    pi->mulu_tab[i] = 1;	/* 0 is wrong */
+	    }
+	    for (i = 0; i < PIC2_ARITH_CONTEXT; i++)
+		pic2_write_short(pi, c_tab[i]);
+
+	    xvbzero((char *) pi->vram_now, xw * sizeof(pi->vram_now[0]));
+	} else {				/* statistical pass */
+	    xvbzero((char *) c_0_sum, PIC2_ARITH_CONTEXT * sizeof(c_0_sum[0]));
+	    xvbzero((char *) c_sum, PIC2_ARITH_CONTEXT * sizeof(c_sum[0]));
+	}
+    
+	/* initialize flags */
+	xvbzero((char *) pi->cache, 8 * 8 * 8 * sizeof(pi->cache[0]));
+	xvbzero((char *) pi->cache_pos, 8 * 8 * 8 * sizeof(pi->cache_pos[0]));
+
+	xvbzero((char *) pi->flag2_next - 4,
+		(8 + xw) * sizeof(pi->flag2_next[0]));
+	xvbzero((char *) pi->flag2_next2 - 4,
+		(8 + xw) * sizeof(pi->flag2_next2[0]));
+
+	pi->vram_next[-1] = cc;
+	for (x = 0; x < xw; x++)
+	    if (cc != pi->vram_next[x]) {
+		pi->flag_next[x] = 1;
+		cc = pi->vram_next[x];
+	    } else
+		pi->flag_next[x] = 0;
+
+	pi->aa = 0xffff;
+	cc = 0;
+	pi->cache_hit_c = 16;
+    } else					/* after second line */
+	pic2_arith_press_line2(pi);
+
+    if (pi->ynow ==  ymax) {
+	pi->ynow++;
+	pic2_handle_para(pi, 1);
+	pic2_handle_para(pi, 0);
+	pic2_arith_press_line2(pi);
+    }
+    /* line buffer for next data */
+    if (line != NULL)
+	*line = pi->vram_prev;
+
+    pi->ynow++;
+
+    if (pi->ynow - 1 < ymax) {
+	pic2_handle_para(pi, 1);
+	return (pi->ynow);
+    } else {					/* end */
+	if (pi->dd == 0) {			/* statistical pass */
+	    pi->dd = 1;
+	    pi->ynow = 0;
+	    pic2_handle_para(pi, 1);
+	    return (0);
+	} else {
+	    pic2_handle_para(pi, 1);
+	    pic2_arith_flush_bit_buf(pi);
+	    return (-2);			/* end */
+	}
+    }
+}
+
+static int pic2_arith_saver_init(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    pi->ynow = 0;
+
+    /* check the color depth */
+    if (pi->header->depth % 3)
+	pic2_error(pi, PIC2_DEPTH);
+
+    /* set next line function */
+    pi->next_line = pic2_arith_press_line;
+
+    if (line != NULL)
+	*line = pi->vram_next + 4;
+
+    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+
+    /* clear bit field marker */
+    pi->bs.rest = 0;
+    pi->bs.cur = 0;
+    pi->bs.zero = 0;
+    pi->bs.bits = 0;
+
+    return (0);
+}
+
+/*
+ * These functions are fast pic2 format compressor.
+ */
+static void pic2_fast_write_length(pi, n)
+struct pic2_info *pi;
+int n;
+{
+    int	a, b;
+    static const unsigned short len_data[8][2] = {
+	{1, 0},
+	{1, 0},
+	{3, 4},
+	{3, 5},
+	{5, 24},
+	{5, 25},
+	{5, 26},
+	{5, 27},
+    };
+
+    n++;
+    if (n < 8)
+	pic2_write_bits(pi, len_data[n][1], len_data[n][0]);
+    else {
+	a = 0;
+	b = 2;
+	while (n > b - 1) {
+	    a = a + 1;
+	    b = b * 2;
+	}
+	pic2_write_bits(pi, 0xfffffffe, a + 1);
+	if (a > 0)
+	    pic2_write_bits(pi, n - b / 2, a);
+    }
+}
+
+static void pic2_fast_press_chain(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    int ymax;
+    pixel cc;
+
+    ymax = pi->block->y_wid -1;
+    cc = pi->vram_now[x];
+
+    if (pi->ynow - 1 == ymax) {
+	pic2_write_bits(pi, 0, 1);
+	return;
+    }
+    if (pi->flag_next[x] == 1 && pi->vram_next[x] == cc) {
+	pi->flag_next[x] = -1;
+	pic2_write_bits(pi, 3, 2);
+    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == cc) {
+	pi->flag_next[x - 1] = -1;
+	pic2_write_bits(pi, 11, 4);
+    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == cc) {
+	pi->flag_next[x + 1] = -1;
+	pic2_write_bits(pi, 9, 4);
+    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == cc) {
+	pi->flag_next[x - 2] = -1;
+	pic2_write_bits(pi, 10, 4);
+    } else if ((pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == cc)
+		&& !(pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == cc)) {
+	pi->flag_next[x + 2] = -1;
+	pic2_write_bits(pi, 8, 4);
+    } else
+	pic2_write_bits(pi, 0, 1);
+}
+
+static void pic2_fast_press_chain2(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    int ymax;
+    pixel cc;
+    char *chain_buff;
+
+    ymax = pi->block->y_wid -1;
+    chain_buff = (char *) pi->mulu_tab;
+    cc = pi->vram_now[x];
+
+    if (pi->ynow - 1 == ymax) {
+	chain_buff[pi->cc++] = 0;
+	return;
+    }
+    if (pi->flag_next[x] == 1 && pi->vram_next[x] == cc) {
+	pi->flag_next[x] = -1;
+	chain_buff[pi->cc++] = 1;
+    } else if (pi->flag_next[x - 1] == 1 && pi->vram_next[x - 1] == cc) {
+	pi->flag_next[x - 1] = -1;
+	chain_buff[pi->cc++] = 2;
+    } else if (pi->flag_next[x + 1] == 1 && pi->vram_next[x + 1] == cc) {
+	pi->flag_next[x + 1] = -1;
+	chain_buff[pi->cc++] = 3;
+    } else if (pi->flag_next[x - 2] == 1 && pi->vram_next[x - 2] == cc) {
+	pi->flag_next[x - 2] = -1;
+	chain_buff[pi->cc++] = 4;
+    } else if ((pi->flag_next[x + 2] == 1 && pi->vram_next[x + 2] == cc)
+	       && !(pi->flag_now[x + 2] != 0 && pi->vram_now[x + 2] == cc)) {
+	pi->flag_next[x + 2] = -1;
+	chain_buff[pi->cc++] = 5;
+    } else
+	chain_buff[pi->cc++] = 0;
+}
+
+static void pic2_fast_flush_chain(pi)
+struct pic2_info *pi;
+{
+    int i;
+    char *chain_buf;
+
+    chain_buf = (char *) pi->mulu_tab;
+    for (i = 0; i < pi->cc; i++){
+	switch (chain_buf[i]) {
+	case 0:
+	    pic2_write_bits(pi, 0, 1);
+	    break;
+	case 1:
+	    pic2_write_bits(pi, 3, 2);
+	    break;
+	case 2:
+	    pic2_write_bits(pi, 11, 4);
+	    break;
+	case 3:
+	    pic2_write_bits(pi, 9, 4);
+	    break;
+	case 4:
+	    pic2_write_bits(pi, 10, 4);
+	    break;
+	case 5:
+	    pic2_write_bits(pi, 8, 4);
+	    break;
+	}
+    }
+    pi->cc = 0;
+}
+
+static void pic2_fast_write_color(pi, x)
+struct pic2_info *pi;
+int x;
+{
+    pixel cc, bc;
+    unsigned short j, k, m;
+    short depth, colbits;
+    pixel (*cache)[PIC2_FAST_CACHE];
+
+    depth = pi->header->depth;
+    colbits = depth / 3;
+    cache = (pixel (*)[PIC2_FAST_CACHE]) pi->cache;
+
+    bc = pi->vram_now[x - 1];
+    bc = pic2_exchange_rg(bc, colbits);
+    k = pic2_shift_bits(bc, 8 - depth);
+    cc = pi->vram_now[x];
+    m = pi->cache_pos[k];
+
+    for (j = 0; j < PIC2_FAST_CACHE; j++)
+	if (cache[k][(m + j) & (PIC2_FAST_CACHE - 1)] == cc)
+	    break;
+
+    if (j == PIC2_FAST_CACHE) {
+	m = (m - 1) & (PIC2_FAST_CACHE - 1);
+	pi->cache_pos[k] = m;
+	cache[k][m] = cc;
+
+	cc = pic2_exchange_rg(cc, colbits);
+	pic2_write_bits(pi, 0, 1);
+	pic2_write_bits(pi, cc, depth);
+    } else {
+	pic2_write_bits(pi, 1, 1);
+	pic2_write_bits(pi, j, 6);
+    }
+}
+
+static void pic2_fast_press_line2(pi)
+struct pic2_info *pi;
+{
+    int x, xw;
+    pixel cc;
+
+    xw = pi->block->x_wid;
+    cc = pi->vram_now[xw - 1];			/* last color */
+    pi->vram_next[-1] = cc;
+
+    /* mark change point */
+    for (x = 0; x < xw; x++)
+	if (cc != pi->vram_next[x]) {
+	    pi->flag_next[x] = 1;
+	    cc = pi->vram_next[x];
+	} else
+	    pi->flag_next[x] = 0;
+
+    for (x = 0; x < xw; x++)
+	if (pi->flag_now[x] == 1) {			/* change point */
+	    if (pi->aa >= 1023)
+		pi->aa++;
+	    pic2_fast_write_length(pi, pi->aa);
+	    pic2_fast_flush_chain(pi);
+	    pi->aa = 0;
+	    pic2_fast_write_color(pi, x);
+	    pic2_fast_press_chain(pi, x);
+	} else if (pi->flag_now[x] == 0) {
+	    pi->aa++;
+	} else {
+	    pic2_fast_press_chain2(pi, x);
+	    if (pi->cc == 1023) {
+		pic2_fast_write_length(pi, 1023);
+		pic2_fast_flush_chain(pi);
+		pi->aa = 0;
+	    }
+	}
+}
+
+static int pic2_fast_press_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int xw, ymax;
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid -1;
+
+    pic2_handle_para(pi, 0);
+
+    if (pi->ynow == 0) {			/* first line */
+	int x;
+	pixel cc = 0;
+
+	/* initialize flags */
+	xvbzero((char *) pi->cache, 256 * sizeof(pi->cache[0]));
+	xvbzero((char *) pi->cache_pos,
+		PIC2_FAST_CACHE * sizeof(pi->cache_pos[0]));
+
+	/* mark change point */
+	pi->vram_next[-1] = cc;
+	for (x = 0; x < xw; x++)
+	    if (cc != pi->vram_next[x]) {
+		pi->flag_next[x] = 1;
+		cc = pi->vram_next[x];
+	    } else
+		pi->flag_next[x] = 0;
+
+	pi->cc = 0;
+	pi->aa = 0;
+    } else					/* after second line */
+	pic2_fast_press_line2(pi);
+
+    if (pi->ynow ==  ymax) {
+	pi->ynow++;
+	pic2_handle_para(pi, 1);
+	pic2_handle_para(pi, 0);
+	pic2_fast_press_line2(pi);
+    }
+    /* line buffer for next data */
+    if (line != NULL)
+	*line = pi->vram_prev;
+
+    pi->ynow++;
+
+    if (pi->ynow - 1 < ymax) {
+	pic2_handle_para(pi, 1);
+	return (pi->ynow);
+    } else {					/* end */
+	pic2_handle_para(pi, 1);
+	if (pi->aa >= 1023)
+	    pi->aa++;
+	pic2_fast_write_length(pi, pi->aa);
+	pic2_fast_flush_chain(pi);
+	return (-2);				/* end */
+    }
+}
+
+static int pic2_fast_saver_init(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    pi->ynow = 0;
+
+    /* check the color depth */
+    if (pi->header->depth % 3)
+	pic2_error(pi, PIC2_DEPTH);
+
+    /* set next line function */
+    pi->next_line = pic2_fast_press_line;
+    if (line != NULL)
+	*line = pi->vram_next + 4;
+
+    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+
+    /* clear bit field marker */
+    pi->bs.rest = 0;
+    pi->bs.cur = 0;
+
+    return (0);
+}
+
+/*
+ * These functions are beta pic2 format compressor.
+ */
+static int pic2_beta_press_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int i, xw, ymax;
+    byte *p;
+    pixel *pc;
+    short depth, pixbyte, colbits;
+
+    depth = pi->header->depth;
+    pixbyte = depth / 8 + ((depth % 8) > 0);
+    colbits = depth / 3;
+
+    xw = pi->block->x_wid;
+    ymax = pi->block->y_wid - 1;
+
+    pc = pi->vram_now;
+    p = (byte *) pi->vram_prev;
+    if (pixbyte == 3) {
+	for (i = 0; i < xw; i++, pc++) {
+	    *p++ = *pc >> 16;
+	    *p++ = *pc >>  8;
+	    *p++ = *pc;
+	}
+	pic2_write_file(pi, pi->vram_prev, (size_t) (xw * 3));
+    } else if (pixbyte == 2) {
+	if (strncmp(pi->block->id, "P2BM", 4) == 0)
+	    for (i = 0; i < xw; i++, pc++) {
+		if (colbits == 5) {
+		    *pc = pic2_exchange_rg(*pc, colbits);
+		    *pc <<= 1;
+		}
+		*p++ = *pc >> 8;
+		*p++ = *pc;
+	    }
+	else
+	    for (i = 0; i < xw; i++, pc++) {
+		if (colbits == 5) {
+		    *pc = pic2_exchange_rg(*pc, colbits);
+		    *pc <<= 1;
+		}
+		*p++ = *pc;
+		*p++ = *pc >> 8;
+	    }
+	pic2_write_file(pi, pi->vram_prev, (size_t) (xw * 2));
+    } else {
+	for (i = 0; i < xw; i++, pc++)
+	    *p++ = *pc;
+	pic2_write_file(pi, pi->vram_prev, (size_t) xw);
+    }
+    if (line != NULL)
+	*line = pi->vram_now;
+
+    pi->ynow++;
+    if (pi->ynow > ymax)
+	return (-2);
+    return (pi->ynow);
+}
+
+static int pic2_beta_saver_init(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    pi->ynow = 0;
+
+    *line = pi->vram_now;
+    pi->next_line = pic2_beta_press_line;
+    pic2_seek_file(pi, pi->next_pos + PIC2_BLOCK_HEADER_SIZE, SEEK_SET);
+    return (0);
+}
+
+/*
+ * This function saves compressed data.
+ */
+static void pic2_write_data(pi, data, ptype, x_offset, y_offset, w, h,
+			    rmap, gmap, bmap, type, depth)
+struct pic2_info *pi;
+byte *data;
+int ptype;
+int x_offset, y_offset;
+int w, h;
+byte *rmap, *gmap, *bmap;
+int type, depth;
+{
+    int i, line;
+    pixel *linep;
+    short colbits;
+
+    colbits = pi->header->depth / 3;
+
+    line = pic2_save_block(pi, &linep, x_offset, y_offset, w, h,
+			   form_tab[type].id, 0xffffffff);
+    while (line >= 0) {
+	byte r, g, b;
+	int pic_idx;
+
+	pic_idx = line * w * ((ptype == PIC24) ? 3 : 1);
+
+	for (i = 0; i < w; i++) {
+	    if (ptype != PIC24) {
+		r = rmap[data[pic_idx]];
+		g = gmap[data[pic_idx]];
+		b = bmap[data[pic_idx]];
+		pic_idx++;
+	    } else {
+		r = data[pic_idx++];
+		g = data[pic_idx++];
+		b = data[pic_idx++];
+	    }
+	    if (pi->writing_grey)
+		r = g = b = MONO(r, g, b);
+
+	    r = pic2_convert_color_bits(r, 8, colbits);
+	    g = pic2_convert_color_bits(g, 8, colbits);
+	    b = pic2_convert_color_bits(b, 8, colbits);
+	    
+	    linep[i] = ((pixel) r << (colbits * 2))
+		     | ((pixel) g <<  colbits     )
+		     | ((pixel) b                 );
+	}
+	line = pic2_next_line(pi, &linep);
+	WaitCursor();
+    }
+}
+
+/*
+ * This function compress/extract one line buffer.
+ */
+static int pic2_next_line(pi, line)
+struct pic2_info *pi;
+pixel **line;
+{
+    int res;
+
+    res = pi->next_line(pi, line);
+    if (res == -2) {
+	if (pi->mode == PIC2_WRITE_MODE) {
+	    long new_pos;
+
+	    new_pos = pic2_tell_file(pi);
+	    pi->block->size = new_pos - pi->next_pos;
+	    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
+	    pic2_write_block_header(pi);
+	    pi->next_pos = new_pos;
+	    if (DEBUG)
+		pic2_show_pic2_info(pi);
+	}
+	pic2_free_buffer(pi);
+    }
+    return (res);
+}
+
+/*
+ * These functions find the pic2 image block.
+ * pic2_next_block:
+ *	moves the file pointer to the next image block.
+ * pic2_find_block:
+ *	find the first image block and move the file pointer to there.
+ */
+static int pic2_next_block(pi)
+struct pic2_info *pi;
+{
+    int i;
+
+    if (pi->mode != PIC2_READ_MODE)
+	return (-1);
+
+    /* go to block for read */
+    pic2_seek_file(pi, pi->next_pos, SEEK_SET);
+
+    /* read the head of block header */
+    pic2_read_block_header1(pi);
+
+    /* end block ? */
+    if (pi->block->id[0] == 0)
+	return (0);
+
+    /* set current block */
+    pi->block_pos = pi->next_pos;
+
+    /* set next block */
+    pi->next_pos += pi->block->size;
+
+   /* check block id */
+    for (i = 0; i < n_form_tab; i++) {
+	if (xvbcmp(pi->block->id, form_tab[i].id, (size_t) 4) == 0)
+	    break;
+    }
+    if (i == n_form_tab)
+	return (2);
+
+    /* read the rest of block header */
+    pic2_read_block_header2(pi);
+
+    if (pi->block->x_offset + pi->block->x_wid > pi->x_max)
+	pi->x_max = pi->block->x_offset + pi->block->x_wid;
+
+    if (pi->block->y_offset + pi->block->y_wid > pi->y_max)
+	pi->y_max = pi->block->y_offset + pi->block->y_wid;
+
+    if (DEBUG)
+	pic2_show_pic2_info(pi);
+    return (1);
+}
+
+static int pic2_find_block(pi)
+struct pic2_info *pi;
+{
+    if (pi->mode != PIC2_READ_MODE)
+	return (-1);
+
+    pi->next_pos = pi->header->size;
+    return (pic2_next_block(pi));
+}
+
+/*
+ * These functions load/save the pic2 image block.
+ * pic2_load_block:
+ *	initializes loader informations by current block information.
+ * pic2_save_block:
+ *	initializes saver informations.
+ */
+static int pic2_load_block(pi)
+struct pic2_info *pi;
+{
+    int i;
+
+    for (i = 0; i < n_form_tab; i++) {
+	if (xvbcmp(pi->block->id, form_tab[i].id, (size_t) 4) == 0)
+	    break;
+    }
+    if (i == n_form_tab)
+	return (2);
+
+    pic2_alloc_buffer(pi);
+    return (form_tab[i].loader_init(pi));
+}
+
+static int pic2_save_block(pi, line, x, y, xw, yw, id, opaque)
+struct pic2_info *pi;
+pixel **line;
+int x, y, xw, yw;
+char *id;
+pixel opaque;
+{
+    int i;
+
+    for (i = 0; i < n_form_tab; i++) {
+	if (xvbcmp(id, form_tab[i].id, (size_t) 4) == 0)
+	    break;
+    }
+    if (i == n_form_tab)
+	return (2);
+
+    strncpy(pi->block->id, id, 4);
+    pi->block->x_wid = xw;
+    pi->block->y_wid = yw;
+    pi->block->x_offset = x;
+    pi->block->y_offset = y;
+    pi->block->reserve = 0;
+
+    if (x < 0)
+	x = 0;
+    if (y < 0)
+	y = 0;
+    if (x + xw > pi->x_max)
+	pi->x_max = x + xw;
+    if (y + yw > pi->y_max)
+	pi->y_max = y + yw;
+
+    if (opaque != 0xffffffff) {
+	pi->block->flag = 1;
+	pi->block->opaque = opaque;
+    } else {
+	pi->block->flag = 0;
+	pi->block->opaque = 0;
+    }
+    pic2_alloc_buffer(pi);
+
+    return (form_tab[i].saver_init(pi, line));
+}
+
+/*
+ * These functions set/get palettes.
+ * pic2_read_palette:
+ *	copy the palettes from pic2_info to PICINFO.
+ * pic2_write_palette:
+ *	copy the palettes from PICINFO to pic2_info.
+ */
+#ifndef PIC2_IGNORE_UNUSED_FUNCTIONS
+static void pic2_read_palette(pi, r, g, b)
+struct pic2_info *pi;
+byte *r, *g, *b;
+{
+    int i;
+
+    if (pi->n_pal > 256)
+	pi->n_pal = 256;
+
+    if (pi->pal_bits > 8)
+	pi->pal_bits = 8;
+
+    for (i = 0; i < pi->n_pal; i++) {
+	*r++ =pic2_convert_color_bits(pi->pal[i][0] >> (8 - pi->pal_bits),
+				      pi->pal_bits, 8);
+	*g++ =pic2_convert_color_bits(pi->pal[i][1] >> (8 - pi->pal_bits),
+				      pi->pal_bits, 8);
+	*b++ =pic2_convert_color_bits(pi->pal[i][2] >> (8 - pi->pal_bits),
+				      pi->pal_bits, 8);
+    }
+}
+
+static void pic2_write_palette(pi, n_pal, pal_bits, r, g, b)
+struct pic2_info *pi;
+int n_pal, pal_bits;
+byte *r, *g, *b;
+{
+    int i;
+
+    if (n_pal > 256)
+	pi->n_pal = 256;
+    else
+	pi->n_pal = n_pal;
+
+    if (pal_bits > 8)
+	pi->pal_bits = 8;
+    else
+	pi->pal_bits = pal_bits;
+
+    for (i = 0; i < n_pal; i++) {
+	pi->pal[i][0] = pic2_convert_color_bits(*r++, 8, pal_bits)
+	    << (8 - pal_bits);
+	pi->pal[i][1] = pic2_convert_color_bits(*g++, 8, pal_bits)
+	    << (8 - pal_bits);
+	pi->pal[i][2] = pic2_convert_color_bits(*b++, 8, pal_bits)
+	    << (8 - pal_bits);
+    }
+}
+#endif /* PIC2_IGNORE_UNUSED_FUNCTIONS */
+
+/*
+ * These function handle color bit.
+ * pic2_convert_color_bits:
+ *	converts color bits.
+ * pic2_pad_color_bits:
+ *	pads color bits.
+ * pic2_reduce_color_bits:
+ *	reduces color bits.
+ * pic2_exchange_rg:
+ *      exchanges red and green value.
+ */
+static byte pic2_convert_color_bits(c, from, to)
+int c, from, to;
+{
+    if (from == to)
+	return ((byte) c);
+    else if (from < to)
+	return (pic2_pad_color_bits(c, from, to));
+    else
+	return (pic2_reduce_color_bits(c, from, to));
+}
+
+static byte pic2_pad_color_bits(c, from, to)
+int c, from, to;
+{
+    byte p = 0;
+
+    do {
+	to -= from;
+	p |= pic2_shift_bits(c, to);
+    } while (to >= 0);
+    return (p);
+}
+
+static byte pic2_reduce_color_bits(c, from, to)
+int c, from, to;
+{
+    return ((byte) (c >> (from - to)));
+}
+
+static pixel pic2_exchange_rg(p, colbits)
+pixel p;
+int colbits;
+{
+    pixel rmask, gmask, bmask;
+
+    rmask = (0xff >> (8 - colbits)) << (colbits * 2);
+    gmask = (0xff >> (8 - colbits)) <<  colbits;
+    bmask = (0xff >> (8 - colbits));
+
+    p = ((p << colbits) & rmask)
+      | ((p >> colbits) & gmask)
+      | ( p             & bmask);
+    return (p);
+}
+
+/*
+ * This function handles work memory buffer.
+ */
+static void pic2_handle_para(pi, mode)
+struct pic2_info *pi;
+int mode;
+{
+    static pixel *vram_prev, *vram_now, *vram_next;
+    static short *flag_now, *flag_next;
+    static short *flag2_now, *flag2_next, *flag2_next2;
+
+    switch (mode) {
+    case 0:
+	vram_prev = pi->vram_prev;
+	vram_now = pi->vram_now;
+	vram_next = pi->vram_next;
+	flag_now = pi->flag_now;
+	flag_next = pi->flag_next;
+	flag2_now = pi->flag2_now;
+	flag2_next = pi->flag2_next;
+	flag2_next2 = pi->flag2_next2;
+	pi->vram_prev += 4;
+	pi->vram_now += 4;
+	pi->vram_next += 4;
+	pi->flag_now += 4;
+	pi->flag_next += 4;
+	pi->flag2_now += 4;
+	pi->flag2_next += 4;
+	pi->flag2_next2 += 4;
+	break;
+    case 1:
+	pi->vram_prev = vram_now;
+	pi->vram_now = vram_next;
+	pi->vram_next = vram_prev;
+	pi->flag_now = flag_next;
+	pi->flag_next = flag_now;
+	pi->flag2_now = flag2_next;
+	pi->flag2_next = flag2_next2;
+	pi->flag2_next2 = flag2_now;
+	break;
+    }
+}
+
+/*
+ * These functions alloc/free work memory.
+ * pic2_alloc_buffer:
+ *	alloc work memory buffer.
+ * pic2_free_buffer:
+ *	free work memory buffer.
+ */
+static int pic2_alloc_buffer(pi)
+struct pic2_info *pi;
+{
+    int wid;
+    byte *p;
+
+    if (pi->buf != NULL)
+	return (-1);
+
+    wid = pi->block->x_wid;
+
+    p = pi->buf = (byte *) pic2_new((wid + 8) * sizeof(pixel) * 3
+				    + sizeof(pi->cache[0]) * 8 * 8 * 8
+				    + sizeof(pi->cache_pos[0]) * 8 * 8 * 8
+				    + sizeof(pi->mulu_tab[0]) * 16384
+				    + sizeof(pi->flag_now[0]) * ((wid+8) * 5),
+				    "pic2_alloc_buffer");
+
+    pi->vram_prev = (pixel *) p;
+    p += (wid + 8) * sizeof(pixel);
+    pi->vram_now = (pixel *) p;
+    p += (wid + 8) * sizeof(pixel);
+    pi->vram_next = (pixel *) p;
+    p += (wid + 8) * sizeof(pixel);
+    pi->cache = (pixel (*)[PIC2_ARITH_CACHE]) p;
+    p += sizeof(pi->cache[0]) * 8 * 8 * 8;
+    pi->cache_pos = (unsigned short *) p;
+    p += sizeof(pi->cache_pos[0]) * 8 * 8 * 8;
+    pi->mulu_tab = (unsigned short *) p;
+    p += sizeof(pi->mulu_tab[0]) * 16384;
+    pi->flag_now = (short *) p;
+    p += sizeof(pi->flag_now[0]) * (wid + 8);
+    pi->flag_next = (short *) p;
+    p += sizeof(pi->flag_next[0]) * (wid + 8);
+    pi->flag2_now = (short *) p;
+    p += sizeof(pi->flag2_now[0]) * (wid + 8);
+    pi->flag2_next = (short *) p;
+    p += sizeof(pi->flag2_next[0]) * (wid + 8);
+    pi->flag2_next2 = (short *) p;
+    p += sizeof(pi->flag2_next2[0]) * (wid + 8);
+    return (0);
+}
+
+static void pic2_free_buffer(pi)
+struct pic2_info *pi;
+{
+    free(pi->buf);
+    pi->buf = NULL;
+}
+
+/*
+ * These functions handle the file pointer.
+ * pic2_seek_file:
+ *	moves the file pointer.
+ * pic2_tell_file:
+ *	tells a location of the file pointer.
+ */
+static long pic2_seek_file(pi, offset, whence)
+struct pic2_info *pi;
+long offset;
+int whence;
+{
+    long n;
+
+    n = fseek(pi->fp, offset, whence);
+    if (n < 0)
+	pic2_file_error(pi, PIC2_CORRUPT);
+
+    return (n);
+}
+
+static long pic2_tell_file(pi)
+struct pic2_info *pi;
+{
+    return (ftell(pi->fp));
+}
+
+/*
+ * These functions handle file.
+ * pic2_read_file:
+ *	reads data from the file.
+ * pic2_read_long:
+ *	reads long word data from the file and converts to internal expression.
+ * pic2_read_short:
+ *	reads word data from the file and converts to internal expression.
+ * pic2_read_char:
+ *	reads byte data from the file.
+ * pic2_write_file:
+ *	writes data to the file.
+ * pic2_write_long:
+ *	converts long word data to common expression and writes to the file.
+ * pic2_write_short:
+ *	converts word data to common expression and writes to the file.
+ * pic2_write_char:
+ *	writes byte data to the file.
+ */
+static int pic2_read_file(pi, buf, size)
+struct pic2_info *pi;
+void *buf;
+size_t size;
+{
+    if (fread(buf, (size_t) 1, size, pi->fp) < size)
+	pic2_file_error(pi, PIC2_CORRUPT);
+    return (0);
+}
+
+static long pic2_read_long(pi)
+struct pic2_info *pi;
+{
+    byte buf[4];
+
+    if (fread(buf, (size_t) 4, (size_t) 1, pi->fp) < 1)
+	pic2_file_error(pi, PIC2_CORRUPT);
+    return (pic2_cextolong(buf));
+}
+
+static short pic2_read_short(pi)
+struct pic2_info *pi;
+{
+    byte buf[2];
+
+    if (fread(buf, (size_t) 2, (size_t) 1, pi->fp) < 1)
+	pic2_file_error(pi, PIC2_CORRUPT);
+    return (pic2_cextoshort(buf));
+}
+
+static char pic2_read_char(pi)
+struct pic2_info *pi;
+{
+    int c;
+
+    if ((c = fgetc(pi->fp)) == EOF)
+	pic2_file_error(pi, PIC2_CORRUPT);
+    return ((char) c);
+}
+
+static int pic2_write_file(pi, buf, size)
+struct pic2_info *pi;
+void *buf;
+size_t size;
+{
+    if (fwrite(buf, (size_t) 1, size, pi->fp) < size)
+	pic2_error(pi, PIC2_WRITE);
+    return (0);
+}
+
+static int pic2_write_long(pi, n)
+struct pic2_info *pi;
+long n;
+{
+    byte buf[4];
+
+    pic2_longtocex(buf, n);
+    if (fwrite(buf, (size_t) 4, (size_t) 1, pi->fp) < 1)
+	pic2_error(pi, PIC2_WRITE);
+    return (0);
+}
+
+static int pic2_write_short(pi, n)
+struct pic2_info *pi;
+int n;
+{
+    byte buf[2];
+
+    pic2_shorttocex(buf, n);
+    if (fwrite(buf, (size_t) 2, (size_t) 1, pi->fp) < 1)
+	pic2_error(pi, PIC2_WRITE);
+    return (0);
+}
+
+static int pic2_write_char(pi, c)
+struct pic2_info *pi;
+int c;
+{
+    if (fputc(c, pi->fp) == EOF)
+	pic2_error(pi, PIC2_WRITE);
+    return (0);
+}
+
+/*
+ * These  functions access the bit stream.
+ * pic2_read_bits:
+ *	reads the specified bits from the file.
+ * pic2_write_bits:
+ *	writes the specified bits to the file.
+ * pic2_flush_bits:
+ *	flushes bit buffer to the file.
+ */
+static unsigned long pic2_read_bits(pi, bits)
+struct pic2_info *pi;
+int bits;
+{
+    unsigned long r = 0;
+
+    while (bits > 0) {
+	while (pi->bs.rest > 0 && bits > 0) {
+	    r = (r << 1) | (pi->bs.cur & 0x80 ? 1 : 0);
+	    pi->bs.cur <<= 1;
+	    pi->bs.rest--;
+	    bits--;
+	}
+	if (bits > 0) {
+	    int c;
+	    if ((c = fgetc(pi->fp)) == EOF)
+		pic2_file_error(pi, PIC2_CORRUPT);
+	    pi->bs.cur  = (byte) c;
+	    pi->bs.rest = 8;
+	}
+    }
+    return r;
+}
+
+static void pic2_write_bits(pi, dat, bits)
+struct pic2_info *pi;
+unsigned long dat;
+int bits;
+{
+    unsigned long dat_mask = 1 << (bits - 1);
+
+    while (bits > 0) {
+	while (pi->bs.rest < 8 && bits > 0) {
+	    pi->bs.cur <<= 1;
+	    if (dat & dat_mask)
+		pi->bs.cur |= 1;
+	    pi->bs.rest++;
+	    bits--;
+	    dat_mask >>= 1;
+	}
+	if (pi->bs.rest >= 8) {
+	    if ((fputc((int) pi->bs.cur, pi->fp)) == EOF)
+		pic2_error(pi, PIC2_WRITE);
+	    pi->bs.cur  = 0;
+	    pi->bs.rest = 0;
+	}
+    }
+}
+
+static void pic2_flush_bits(pi)
+struct pic2_info *pi;
+{
+    if (pi->bs.rest < 8) {
+	pi->bs.cur <<= 8 - pi->bs.rest;
+	if (fputc((int) pi->bs.cur, pi->fp) == EOF)
+		pic2_error(pi, PIC2_WRITE);
+	pi->bs.cur  = 0;
+	pi->bs.rest = 0;
+    }
+}
+
+/*
+ * These functions initialize or clean up structures.
+ * pic2_init_info:
+ *	initializes a pic2_info structure.
+ * pic2_cleanup_pic2_info:
+ *	cleans up a pic_info structure.
+ * pic2_cleanup_pinfo:
+ *	cleans up a PICINFO structure.
+ */
+static void pic2_init_info(pi)
+struct pic2_info *pi;
+{
+    xvbzero((char *) pi, sizeof(struct pic2_info));
+    pi->header = pic2_new(sizeof(struct pic2_header), "pic2_init_info#1");
+    pi->block = pic2_new(sizeof(struct pic2_block), "pic2_init_info#2");
+}
+
+static void pic2_cleanup_pic2_info(pi, writing)
+struct pic2_info *pi;
+int writing;
+{
+    if (!writing && pi->fp)
+	fclose(pi->fp);
+    if (pi->header)
+	free(pi->header);
+    if (pi->block)
+	free(pi->block);
+    pi->fp = NULL;
+    pi->header = NULL;
+    pi->block = NULL;
+    pi->comment = NULL;
+}
+
+static void pic2_cleanup_pinfo(pinfo)
+PICINFO *pinfo;
+{
+    if (pinfo->pic){
+	free(pinfo->pic);
+	pinfo->pic = NULL;
+    }
+    if (pinfo->comment){
+	free(pinfo->comment);
+	pinfo->comment = NULL;
+    }
+}
+
+/*
+ * Error Handlers.
+ * pic2_memory_error:
+ *	shows an error message, and terminates.
+ * pic2_error:
+ *	shows an non-file error message, and jumps to the entry for errors.
+ * pic2_file_error:
+ *	shows an file error message, and jumps to the entry for errors.
+ */
+static void pic2_memory_error(scm, fn)
+char *scm, *fn;
+{
+    char buf[128];
+    sprintf(buf, "%s: can't allocate memory. (%s)", scm, fn);
+    FatalError(buf);
+}
+
+static void pic2_error(pi, mn)
+struct pic2_info *pi;
+int mn;
+{
+    SetISTR(ISTR_WARNING, "%s", pic2_msgs[mn]);
+    longjmp(pi->jmp, 1);
+}
+
+static void pic2_file_error(pi, mn)
+    struct pic2_info *pi;
+    int mn;
+{
+    if (feof(pi->fp))
+	SetISTR(ISTR_WARNING, "%s (end of file)", pic2_msgs[mn]);
+    else
+	SetISTR(ISTR_WARNING, "%s (%s)", pic2_msgs[mn], ERRSTR(errno));
+    longjmp(pi->jmp, 1);
+}
+
+static void pic2_show_pic2_info(pi)
+    struct pic2_info *pi;
+{
+    fprintf(stderr, "file size: %ld.\n", pi->fsize);
+    fprintf(stderr, "full image size: %dx%d\n", pi->x_max, pi->y_max);
+    fprintf(stderr, "number of palettes: %d\n", pi->n_pal);
+    fprintf(stderr, "depth of palettes: %d\n", pi->pal_bits);
+    fprintf(stderr, "current block position: %d\n", pi->block_pos);
+    fprintf(stderr, "next block position: %d\n\n", pi->next_pos);
+
+    fprintf(stderr, "header flag: %x\n", pi->header->flag);
+    fprintf(stderr, "header size: %d\n", pi->header->size);
+    fprintf(stderr, "x_aspect: %d, y_aspect: %d\n",
+	    pi->header->x_aspect, pi->header->y_aspect);
+    fprintf(stderr, "number of color bits: %d\n\n", pi->header->depth);
+
+    fprintf(stderr, "image block id: %s\n", pi->block->id);
+    fprintf(stderr, "image block size: %d\n", pi->block->size);
+    fprintf(stderr, "block flag: %x\n", pi->block->flag);
+
+    fprintf(stderr, "block image size: %dx%d\n",
+	    pi->block->x_wid, pi->block->y_wid);
+    fprintf(stderr, "x_offset: %d\n", pi->block->x_offset);
+    fprintf(stderr, "y_offset: %d\n", pi->block->y_offset);
+    fprintf(stderr, "opaque color: %x\n\n", pi->block->opaque);
+}
+
+/*
+ * This function is simular to strncpy.
+ * But this fills whitespaces after the null charactor.
+ */
+static char *pic2_strncpy(dest, src, n)
+char *dest, *src;
+size_t n;
+{
+    char *r;
+
+    r = dest;
+    while (n--)
+	if ((src != NULL) && (*src != '\r') && (*src != '\n') && *src)
+	    *dest++ = *src++;
+	else
+	    *dest++ = ' ';
+    return (r);
+}
+
+/*
+ * These function create memory block.
+ */
+static void *pic2_malloc(size, fn)
+size_t size;
+char *fn;
+{
+    void *p;
+
+    p = (void *) malloc(size);
+    if (p == NULL)
+	pic2_memory_error("malloc", fn);
+    return (p);
+}
+
+static void *pic2_new(size, fn)
+size_t size;
+char *fn;
+{
+    void *p;
+
+    p = (void *) pic2_malloc(size, fn);
+    xvbzero((char *) p, size);
+    return (p);
+}
+
+
+
+
+/**** Stuff for PIC2Dialog box ****/
+
+#define TWIDE    320
+#define THIGH	 178
+#define T_NBUTTS 2
+#define T_BOK    0
+#define T_BCANC  1
+#define BUTTH    24
+
+static void drawTD    PARM((int,int,int,int));
+static void clickTD   PARM((int,int));
+static void doCmd     PARM((int));
+static void writePIC2 PARM((void));
+
+/* local variables */
+static FILE  *fp;
+static char  *filename;
+static int   colorType;
+static int   append;
+static int   x_offset;
+static int   y_offset;
+static BUTT  tbut[T_NBUTTS];
+static RBUTT *typeRB;
+static RBUTT *depthRB;
+
+
+
+/***************************************************/
+void CreatePIC2W()
+{
+    int	     y;
+
+    pic2W = CreateWindow("xv pic2", "XVpic2", NULL, 
+			TWIDE, THIGH, infofg, infobg, 0);
+    if (!pic2W)
+	FatalError("can't create pic2 window!");
+
+    XSelectInput(theDisp, pic2W,
+		 ExposureMask | ButtonPressMask | KeyPressMask);
+
+    BTCreate(&tbut[T_BOK], pic2W, TWIDE-140-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+	     "Ok", infofg, infobg, hicol, locol);
+
+    BTCreate(&tbut[T_BCANC], pic2W, TWIDE-70-1, THIGH-10-BUTTH-1, 60, BUTTH, 
+	     "Cancel", infofg, infobg, hicol, locol);
+
+    y = 55;
+    typeRB = RBCreate(NULL, pic2W, 36, y,          "P2SS",
+		      infofg, infobg,hicol,locol);
+    RBCreate(typeRB, pic2W, 36, y+18,              "P2SF",
+	     infofg, infobg,hicol,locol);
+    RBCreate(typeRB, pic2W, 36, y+36,              "P2BM",
+	     infofg, infobg, hicol, locol);
+    RBCreate(typeRB, pic2W, 36, y+54,              "P2BI",
+	     infofg, infobg, hicol, locol);
+
+    depthRB = RBCreate(NULL, pic2W, TWIDE/2-16, y, "  3bit",
+		       infofg, infobg,hicol,locol);
+    RBCreate(depthRB, pic2W, TWIDE/2-16, y+18,     "  6bit",
+	     infofg, infobg,hicol,locol);
+    RBCreate(depthRB, pic2W, TWIDE/2-16, y+36,     "  9bit",
+	     infofg, infobg, hicol, locol);
+    RBCreate(depthRB, pic2W, TWIDE/2-16, y+54,     "12bit",
+	     infofg, infobg, hicol, locol);
+    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y,      "15bit",
+	     infofg, infobg, hicol, locol);
+    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+18,   "18bit",
+	     infofg, infobg, hicol, locol);
+    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+36,   "21bit",
+	     infofg, infobg, hicol, locol);
+    RBCreate(depthRB, pic2W, TWIDE/4*3-16, y+54,   "24bit",
+	     infofg, infobg, hicol, locol);
+
+    XMapSubwindows(theDisp, pic2W);
+}
+
+
+/***************************************************/
+void PIC2Dialog(vis)
+int vis;
+{
+    if (vis) {
+	CenterMapWindow(pic2W, tbut[T_BOK].x + tbut[T_BOK].w/2,
+			tbut[T_BOK].y + tbut[T_BOK].h/2, TWIDE, THIGH);
+    }
+    else     XUnmapWindow(theDisp, pic2W);
+    pic2Up = vis;
+}
+
+
+/***************************************************/
+int PIC2CheckEvent(xev)
+XEvent *xev;
+{
+    /* check event to see if it's for one of our subwindows.  If it is,
+       deal accordingly, and return '1'.  Otherwise, return '0' */
+
+    int rv;
+    rv = 1;
+
+    if (!pic2Up)
+	return (0);
+
+    if (xev->type == Expose) {
+	int x,y,w,h;
+	XExposeEvent *e = (XExposeEvent *) xev;
+	x = e->x;  y = e->y;  w = e->width;  h = e->height;
+
+	if (e->window == pic2W)       drawTD(x, y, w, h);
+	else rv = 0;
+    }
+
+    else if (xev->type == ButtonPress) {
+	XButtonEvent *e = (XButtonEvent *) xev;
+	int x,y;
+	x = e->x;  y = e->y;
+
+	if (e->button == Button1) {
+	    if      (e->window == pic2W)     clickTD(x,y);
+	    else rv = 0;
+	}  /* button1 */
+	else rv = 0;
+    }  /* button press */
+
+
+    else if (xev->type == KeyPress) {
+	XKeyEvent *e = (XKeyEvent *) xev;
+	char buf[128];  KeySym ks;  XComposeStatus status;  
+	int stlen;
+	
+	stlen = XLookupString(e,buf,128,&ks,&status);
+	buf[stlen] = '\0';
+
+	if (e->window == pic2W) {
+	    if (stlen) {
+		if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
+		    FakeButtonPress(&tbut[T_BOK]);
+		}
+		else if (buf[0] == '\033') {            /* ESC */
+		    FakeButtonPress(&tbut[T_BCANC]);
+		}
+	    }
+	}
+	else rv = 0;
+    }
+    else rv = 0;
+
+    if (rv == 0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
+	XBell(theDisp, 50);
+	rv = 1;   /* eat it */
+    }
+
+    return (rv);
+}
+
+
+/***************************************************/
+int PIC2SaveParams(fname, col)
+char *fname;
+int col;
+{
+    filename = fname;
+    colorType = col;
+
+    /* see if we can open the output file before proceeding */
+    fp = pic2_OpenOutFile(filename, &append);
+    if (!fp)
+	return (-1);
+
+    RBSetActive(typeRB,0,1);
+    RBSetActive(typeRB,1,1);
+    RBSetActive(typeRB,2,1);
+    RBSetActive(typeRB,3,1);
+    RBSelect(typeRB,0);
+
+
+    if (append) {
+	struct pic2_info pic2;
+
+	pic2_init_info(&pic2);
+	pic2.fp = fp;
+	pic2_read_header(&pic2);
+
+	RBSetActive(depthRB,0,0);
+	RBSetActive(depthRB,1,0);
+	RBSetActive(depthRB,2,0);
+	RBSetActive(depthRB,3,0);
+	RBSetActive(depthRB,4,0);
+	RBSetActive(depthRB,5,0);
+	RBSetActive(depthRB,6,0);
+	RBSetActive(depthRB,7,0);
+
+	switch (pic2.header->depth) {
+	case  3:
+	    RBSetActive(depthRB,0,1);
+	    RBSelect(depthRB,0);
+	    RBSetActive(typeRB,3,0);
+	    break;
+	case  6:
+	    RBSetActive(depthRB,1,1);
+	    RBSelect(depthRB,1);
+	    RBSetActive(typeRB,3,0);
+	    break;
+	case  9:
+	    RBSetActive(depthRB,2,1);
+	    RBSelect(depthRB,2);
+	    break;
+	case 12:
+	    RBSetActive(depthRB,3,1);
+	    RBSelect(depthRB,3);
+	    break;
+	case 15:
+	    RBSetActive(depthRB,4,1);
+	    RBSelect(depthRB,4);
+	    break;
+	case 18:
+	    RBSetActive(depthRB,5,1);
+	    RBSelect(depthRB,5);
+	    RBSetActive(typeRB,3,0);
+	    break;
+	case 21:
+	    RBSetActive(depthRB,6,1);
+	    RBSelect(depthRB,6);
+	    RBSetActive(typeRB,3,0);
+	    break;
+	case 24:
+	    RBSetActive(depthRB,7,1);
+	    RBSelect(depthRB,7);
+	    RBSetActive(typeRB,3,0);
+	    break;
+	default: {
+	    char str[512];
+	    sprintf(str, "unsupported PIC2 file '%s'.", filename);
+	    ErrPopUp(str, "\nBummer");
+	    CloseOutFile(fp, filename, 0);
+	    fp = OpenOutFile(fname);
+	    if (!fp)
+		return (-1);
+	    break;
+	}
+	}
+	pic2_seek_file(&pic2, 0, SEEK_SET);
+	pic2_cleanup_pic2_info(&pic2, 1);
+    } else {
+	RBSetActive(depthRB,0,1);
+	RBSetActive(depthRB,1,1);
+	RBSetActive(depthRB,2,1);
+	RBSetActive(depthRB,3,1);
+	RBSetActive(depthRB,4,1);
+	RBSetActive(depthRB,5,1);
+	RBSetActive(depthRB,6,1);
+	RBSetActive(depthRB,7,1);
+	RBSelect(depthRB,7);
+	RBSetActive(typeRB,3,0);
+    }
+    return (0);
+}
+
+
+/***************************************************/
+static void drawTD(x,y,w,h)
+int x,y,w,h;
+{
+    char *title  = "Save PIC2 file...";
+    int  i;
+    XRectangle xr;
+
+    xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
+    XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
+
+    XSetForeground(theDisp, theGC, infofg);
+    XSetBackground(theDisp, theGC, infobg);
+
+    for (i = 0; i < T_NBUTTS; i++)
+	BTRedraw(&tbut[i]);
+
+    ULineString(pic2W, typeRB->x-16, typeRB->y-3-DESCENT,   "FormatType");
+    ULineString(pic2W, depthRB->x-16, depthRB->y-3-DESCENT, "ColorDepth");
+    RBRedraw(typeRB, -1);
+    RBRedraw(depthRB, -1);
+
+    DrawString(pic2W, 20, 29, title);
+
+    XSetClipMask(theDisp, theGC, None);
+}
+
+static void clickTD(x,y)
+int x,y;
+{
+    int i;
+    BUTT *bp;
+
+    /* check BUTTs */
+
+    /* check the RBUTTS first, since they don't DO anything */
+    if ((i = RBClick(typeRB, x,y)) >= 0) { 
+	(void) RBTrack(typeRB, i);
+	return;
+    } else if ((i = RBClick(depthRB, x,y)) >= 0) { 
+	(void) RBTrack(depthRB, i);
+	if ((2 <= i) && (i <= 4))
+	    RBSetActive(typeRB,3,1);
+	else {
+	    RBSetActive(typeRB,3,0);
+	    if (RBWhich(typeRB) == 3)
+		RBSelect(typeRB,0);
+	return;
+	}
+    }
+    for (i = 0; i < T_NBUTTS; i++) {
+	bp = &tbut[i];
+	if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
+	    break;
+    }
+    if (i < T_NBUTTS)  /* found one */
+	if (BTTrack(bp))
+	    doCmd(i);
+}
+
+
+
+/***************************************************/
+static void doCmd(cmd)
+int cmd;
+{
+    switch (cmd) {
+    case T_BOK: {
+	char *fullname;
+	char buf[64], *x_offsetp, *y_offsetp;
+	static char *labels[] = { "\nOk", "\033Cancel" };
+        XEvent event;
+	int i;
+
+	strcpy(buf, "0,0");
+	i = GetStrPopUp("Enter offset (x,y):", labels, 2, buf, 64,
+			"01234567890,", 1);
+
+	if (i)
+	    return;
+	if (strlen(buf)==0)
+	    return;
+
+	x_offsetp = buf;
+	y_offsetp = index(buf, ',');
+	if (!y_offsetp)
+	    return;
+	*(y_offsetp++) = '\0';
+	if ((*x_offsetp == '\0') || (*y_offsetp == '\0'))
+	    return;
+	x_offset = atoi(x_offsetp);
+	y_offset = atoi(y_offsetp);
+
+        XNextEvent(theDisp, &event);
+	HandleEvent(&event, &i);
+
+	writePIC2();
+	PIC2Dialog(0);
+
+	fullname = GetDirFullName();
+	if (!ISPIPE(fullname[0])) {
+	    XVCreatedFile(fullname);
+	    StickInCtrlList(0);
+	}
+    }
+	break;
+    case T_BCANC:
+	pic2_KillNullFile(fp);
+	PIC2Dialog(0);
+	break;
+    default:
+	break;
+    }
+}
+
+
+/*******************************************/
+static void writePIC2()
+{
+    int   w, h, nc, rv, type, depth, ptype, pfree;
+    byte *inpix, *rmap, *gmap, *bmap;
+
+
+    WaitCursor();
+    inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
+
+    if (colorType == F_REDUCED)
+	colorType = F_FULLCOLOR;
+
+    switch (RBWhich(typeRB)) {
+    case 0: type = P2SS;  break;
+    case 1: type = P2SF;  break;
+    case 2: type = P2BM;  break;
+    case 3: type = P2BI;  break;
+    default: type = P2SS; break;
+    }
+    switch (RBWhich(depthRB)) {
+    case 0: depth =  3;  break;
+    case 1: depth =  6;  break;
+    case 2: depth =  9;  break;
+    case 3: depth = 12;  break;
+    case 4: depth = 15;  break;
+    case 5: depth = 18;  break;
+    case 6: depth = 21;  break;
+    case 7: depth = 24;  break;
+    default: depth = 24; break;
+    }
+    rv = WritePIC2(fp, inpix, ptype, w, h,
+		   rmap, gmap, bmap, nc, colorType, filename,
+		   type, depth, x_offset, y_offset, append, picComments);
+
+    if (CloseOutFile(fp, filename, rv) == 0)
+	DirBox(0);
+
+    if (pfree)
+	free(inpix);
+}
+#endif /* HAVE_PIC2 */
diff -Naur xv-3.10a.old/xvpng.c xv-3.10a/xvpng.c
--- xv-3.10a.old/xvpng.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvpng.c	Tue Apr 24 09:37:06 2001
@@ -0,0 +1,991 @@
+/*
+ * xvpng.c - load and write routines for 'PNG' format pictures
+ *
+ * callable functions
+ *
+ *    CreatePNGW()
+ *    PNGDialog(vis)
+ *    PNGCheckEvent(xev)
+ *    PNGSaveParams(fname, col)
+ *    LoadPNG(fname, pinfo)
+ */
+
+/*#include "copyright.h"*/
+/* (c) 1995 by Alexander Lehmann <lehmann@mathematik.th-darmstadt.de>
+ *   this file is a suplement to xv and is supplied under the same copying
+ *   conditions (except the shareware part)
+ * Modified by Andreas Dilger <adilger@enel.ucalgary.ca> to fix
+ *   error handling for bad PNGs, add dialogs for interlacing and
+ *   compression selection, and upgrade to libpng-0.89
+ * The copyright will be passed on to JB at some future point if he
+ * so desires.
+ */
+
+#include "xv.h"
+
+#ifdef HAVE_PNG
+
+#include "png.h"
+
+/*** Stuff for PNG Dialog box ***/
+#define PWIDE 318
+#define PHIGH 215
+
+#define DISPLAY_GAMMA 2.20  /* Default display gamma */
+/* Default zlib compression level
+#define COMPRESSION   Z_BEST_COMPRESSION
+*/
+#define COMPRESSION   6
+
+#define DWIDE     86
+#define DHIGH    104
+#define PFX PWIDE-93
+#define PFY       44
+#define PFH       20
+
+#define P_BOK    0
+#define P_BCANC  1
+#define P_NBUTTS 2
+
+#define BUTTH    24
+
+#define LF       10   /* a.k.a. '\n' on ASCII machines */
+#define CR       13   /* a.k.a. '\r' on ASCII machines */
+
+/*** local functions ***/
+static    void drawPD         PARM((int, int, int, int));
+static    void clickPD        PARM((int, int));
+static    void doCmd          PARM((int));
+static    void writePNG       PARM((void));
+static    int  WritePNG       PARM((FILE *, byte *, int, int, int,
+                                    byte *, byte *, byte *, int));
+
+static    void png_xv_error   PARM((png_structp png_ptr,
+                                    png_const_charp message));
+static    void png_xv_warning PARM((png_structp png_ptr,
+                                    png_const_charp message));
+
+/*** local variables ***/
+static char *filename;
+static char *fbasename;
+static int   colorType;
+static int   read_anything;
+static double Display_Gamma = DISPLAY_GAMMA;
+
+static DIAL  cDial, gDial;
+static BUTT  pbut[P_NBUTTS];
+static CBUTT interCB;
+static CBUTT FdefCB, FnoneCB, FsubCB, FupCB, FavgCB, FPaethCB;
+
+/**************************************************************************/
+/* PNG SAVE DIALOG ROUTINES ***********************************************/
+/**************************************************************************/
+
+
+/*******************************************/
+void CreatePNGW()
+{
+  pngW = CreateWindow("xv png", "XVPNG", NULL,
+                      PWIDE, PHIGH, infofg, infobg, 0);
+  if (!pngW) FatalError("can't create PNG window!");
+
+  XSelectInput(theDisp, pngW, ExposureMask | ButtonPressMask | KeyPressMask);
+
+  DCreate(&cDial, pngW,  12, 25, DWIDE, DHIGH, (double)Z_NO_COMPRESSION,
+          (double)Z_BEST_COMPRESSION, COMPRESSION, 1.0, 3.0,
+          infofg, infobg, hicol, locol, "Compression", NULL);
+
+  DCreate(&gDial, pngW, DWIDE+27, 25, DWIDE, DHIGH, 1.0, 3.5,DISPLAY_GAMMA,0.01,0.2,
+          infofg, infobg, hicol, locol, "Disp. Gamma", NULL);
+
+  CBCreate(&interCB, pngW,  DWIDE+30, DHIGH+3*LINEHIGH+2, "interlace",
+           infofg, infobg, hicol, locol);
+
+  CBCreate(&FdefCB,   pngW, PFX, PFY, "Default",
+           infofg, infobg, hicol, locol);
+  FdefCB.val = 1;
+
+  CBCreate(&FnoneCB,  pngW, PFX, FdefCB.y + PFH + 4, "none",
+           infofg, infobg, hicol, locol);
+  CBCreate(&FsubCB,   pngW, PFX, FnoneCB.y + PFH, "sub",
+           infofg, infobg, hicol, locol);
+  CBCreate(&FupCB,    pngW, PFX, FsubCB.y  + PFH, "up",
+           infofg, infobg, hicol, locol);
+  CBCreate(&FavgCB,   pngW, PFX, FupCB.y   + PFH, "average",
+           infofg, infobg, hicol, locol);
+  CBCreate(&FPaethCB, pngW, PFX, FavgCB.y  + PFH, "Paeth",
+           infofg, infobg, hicol, locol);
+
+  FnoneCB.val = FsubCB.val = FupCB.val = FavgCB.val = FPaethCB.val = 1;
+  CBSetActive(&FnoneCB, !FdefCB.val);
+  CBSetActive(&FsubCB, !FdefCB.val);
+  CBSetActive(&FupCB, !FdefCB.val);
+  CBSetActive(&FavgCB, !FdefCB.val);
+  CBSetActive(&FPaethCB, !FdefCB.val);
+
+  BTCreate(&pbut[P_BOK], pngW, PWIDE-180-1, PHIGH-10-BUTTH-1, 80, BUTTH,
+          "Ok", infofg, infobg, hicol, locol);
+  BTCreate(&pbut[P_BCANC], pngW, PWIDE-90-1, PHIGH-10-BUTTH-1, 80, BUTTH,
+          "Cancel", infofg, infobg, hicol, locol);
+
+  XMapSubwindows(theDisp, pngW);          
+}
+
+
+/*******************************************/
+void PNGDialog(vis)
+     int vis;
+{
+  if (vis) {
+    CenterMapWindow(pngW, pbut[P_BOK].x + (int) pbut[P_BOK].w/2,
+                          pbut[P_BOK].y + (int) pbut[P_BOK].h/2,
+                    PWIDE, PHIGH);
+  }
+  else XUnmapWindow(theDisp, pngW);
+  pngUp = vis;
+}
+
+
+/*******************************************/
+int PNGCheckEvent(xev)
+     XEvent *xev;
+{
+  /* check event to see if it's for one of our subwindows.  If it is,
+     deal accordingly, and return '1'.  Otherwise, return '0' */
+
+  int rv;
+  rv = 1;
+
+  if (!pngUp) return 0;
+
+  if (xev->type == Expose) {
+    int x,y,w,h;
+    XExposeEvent *e = (XExposeEvent *) xev;
+    x = e->x; y = e->y; w = e->width; h = e->height;
+
+    /* throw away excess expose events for 'dumb' windows */
+    if (e->count > 0 && (e->window == cDial.win)) {}
+
+    else if (e->window == pngW)        drawPD(x, y, w, h);
+    else if (e->window == cDial.win)   DRedraw(&cDial);
+    else if (e->window == gDial.win)   DRedraw(&gDial);
+    else rv = 0;
+  }
+
+  else if (xev->type == ButtonPress) {
+    XButtonEvent *e = (XButtonEvent *) xev;
+    int x,y;
+    x = e->x;  y = e->y;
+    
+    if (e->button == Button1) {
+      if      (e->window == pngW)       clickPD(x,y);
+      else if (e->window == cDial.win)  DTrack(&cDial,x,y);
+      else if (e->window == gDial.win)  DTrack(&gDial,x,y);
+      else rv = 0;
+    }  /* button1 */
+    else rv = 0;
+  }  /* button press */
+
+  else if (xev->type == KeyPress) {
+    XKeyEvent *e = (XKeyEvent *) xev;
+    char buf[128];  KeySym ks;
+    int stlen;
+    
+    stlen = XLookupString(e,buf,128,&ks,(XComposeStatus *) NULL);
+    buf[stlen] = '\0';
+    
+    RemapKeyCheck(ks, buf, &stlen);
+    
+    if (e->window == pngW) {
+      if (stlen) {
+        if (buf[0] == '\r' || buf[0] == '\n') { /* enter */
+          FakeButtonPress(&pbut[P_BOK]);
+        }
+        else if (buf[0] == '\033') {            /* ESC */
+          FakeButtonPress(&pbut[P_BCANC]);
+        }
+      }
+    }
+    else rv = 0;
+  }
+  else rv = 0;
+
+  if (rv==0 && (xev->type == ButtonPress || xev->type == KeyPress)) {
+    XBell(theDisp, 50);
+    rv = 1;   /* eat it */
+  }
+
+  return rv;
+}
+
+
+/*******************************************/
+void PNGSaveParams(fname, col)
+     char *fname;
+     int col;
+{
+  filename = fname;
+  colorType = col;
+}
+
+
+/*******************************************/
+static void drawPD(x, y, w, h)
+     int x, y, w, h;
+{
+  char *title   = "Save PNG file...";
+
+  char ctitle1[20];
+  char *ctitle2 = "Useful range";
+  char *ctitle3 = "is 2 - 7.";
+  char *ctitle4 = "Uncompressed = 0";
+
+  char *ftitle  = "Row Filters:";
+
+  char gtitle[20];
+
+  int i;
+  XRectangle xr;
+  
+  xr.x = x;  xr.y = y;  xr.width = w;  xr.height = h;
+  XSetClipRectangles(theDisp, theGC, 0,0, &xr, 1, Unsorted);
+
+  XSetForeground(theDisp, theGC, infofg);
+  XSetBackground(theDisp, theGC, infobg);
+
+  for (i=0; i<P_NBUTTS; i++) BTRedraw(&pbut[i]);
+
+  DrawString(pngW,       15,  6+ASCENT,                          title);
+
+  sprintf(ctitle1, "Default = %d", COMPRESSION);
+  DrawString(pngW,       18,  6+DHIGH+cDial.y+ASCENT,            ctitle1);
+  DrawString(pngW,       17,  6+DHIGH+cDial.y+ASCENT+LINEHIGH,   ctitle2);
+  DrawString(pngW,       17,  6+DHIGH+cDial.y+ASCENT+2*LINEHIGH, ctitle3);
+  DrawString(pngW,       17,  6+DHIGH+cDial.y+ASCENT+3*LINEHIGH, ctitle4);
+
+  sprintf(gtitle, "Default = %g", DISPLAY_GAMMA);
+  DrawString(pngW, DWIDE+30,  6+DHIGH+gDial.y+ASCENT,            gtitle);
+
+  ULineString(pngW, FdefCB.x, FdefCB.y-3-DESCENT, ftitle);
+  XDrawRectangle(theDisp, pngW, theGC, FdefCB.x-11, FdefCB.y-LINEHIGH-3,
+                                       93, 8*LINEHIGH+15);
+  CBRedraw(&FdefCB);
+  XDrawLine(theDisp, pngW, theGC, FdefCB.x-11, FdefCB.y+LINEHIGH+4,
+                                  FdefCB.x+82, FdefCB.y+LINEHIGH+4);
+
+  CBRedraw(&FnoneCB);
+  CBRedraw(&FupCB);
+  CBRedraw(&FsubCB);
+  CBRedraw(&FavgCB);
+  CBRedraw(&FPaethCB);
+
+  CBRedraw(&interCB);
+
+  XSetClipMask(theDisp, theGC, None);
+}
+
+
+/*******************************************/
+static void clickPD(x,y)
+     int x,y;
+{
+  int i;
+  BUTT *bp;
+
+  /* check BUTTs */
+  
+  for (i=0; i<P_NBUTTS; i++) {
+    bp = &pbut[i];
+    if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h)) break;
+  }
+  
+  if (i<P_NBUTTS) {  /* found one */
+    if (BTTrack(bp)) doCmd(i);
+  }
+
+  /* check CBUTTs */
+
+  else if (CBClick(&FdefCB,x,y)) {
+    int oldval = FdefCB.val;
+
+    CBTrack(&FdefCB);
+
+    if (oldval != FdefCB.val)
+    {
+      CBSetActive(&FnoneCB, !FdefCB.val);
+      CBSetActive(&FsubCB, !FdefCB.val);
+      CBSetActive(&FupCB, !FdefCB.val);
+      CBSetActive(&FavgCB, !FdefCB.val);
+      CBSetActive(&FPaethCB, !FdefCB.val);
+
+      CBRedraw(&FnoneCB);
+      CBRedraw(&FupCB);
+      CBRedraw(&FsubCB);
+      CBRedraw(&FavgCB);
+      CBRedraw(&FPaethCB);
+    }
+  }
+  else if (CBClick(&FnoneCB,x,y))  CBTrack(&FnoneCB);
+  else if (CBClick(&FsubCB,x,y))   CBTrack(&FsubCB);
+  else if (CBClick(&FupCB,x,y))    CBTrack(&FupCB);
+  else if (CBClick(&FavgCB,x,y))   CBTrack(&FavgCB);
+  else if (CBClick(&FPaethCB,x,y)) CBTrack(&FPaethCB);
+  else if (CBClick(&interCB,x,y))  CBTrack(&interCB);
+}
+
+
+/*******************************************/
+static void doCmd(cmd)
+     int cmd;
+{
+  switch (cmd) {
+  case P_BOK: {
+    char *fullname;
+
+    writePNG();
+    PNGDialog(0);
+    
+    fullname = GetDirFullName();
+    if (!ISPIPE(fullname[0])) {
+      XVCreatedFile(fullname);
+      StickInCtrlList(0);
+    }
+  }
+    break;
+
+  case P_BCANC:  PNGDialog(0);  break;
+
+  default:        break;
+  }
+}
+
+
+/*******************************************/
+static void writePNG()
+{
+  FILE       *fp;
+  int         w, h, nc, rv, ptype, pfree;
+  byte       *inpix, *rmap, *gmap, *bmap;
+
+  fp = OpenOutFile(filename);
+  if (!fp) return;
+
+  fbasename = BaseName(filename);
+
+  WaitCursor();
+  inpix = GenSavePic(&ptype, &w, &h, &pfree, &nc, &rmap, &gmap, &bmap);
+
+  rv = WritePNG(fp, inpix, ptype, w, h, rmap, gmap, bmap, nc);
+
+  SetCursors(-1);
+
+  if (CloseOutFile(fp, filename, rv) == 0) DirBox(0);
+
+  if (pfree) free(inpix);
+}
+
+
+/*******************************************/
+int WritePNG(fp, pic, ptype, w, h, rmap, gmap, bmap, numcols)
+     FILE *fp;
+     byte *pic;
+     int   ptype, w, h;
+     byte *rmap, *gmap, *bmap;
+     int   numcols;
+{
+  png_struct *png_ptr;
+  png_info   *info_ptr;
+  png_color   palette[256];
+  png_textp   text;
+  byte        remap[256];
+  int         i, filter, linesize = 0, pass;
+  byte       *p, *png_line;
+  char        software[256];
+  char       *savecmnt = NULL;
+
+  if ((png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,
+       png_xv_error, png_xv_warning)) == NULL) {
+    FatalError("malloc failure in WritePNG");
+  }
+
+  if ((info_ptr = png_create_info_struct(png_ptr)) == NULL)
+  {
+    png_destroy_write_struct(&png_ptr, &info_ptr);
+    FatalError("malloc failure in WritePNG");
+  }
+
+  if (setjmp(png_ptr->jmpbuf)) {
+    png_destroy_write_struct(&png_ptr, &info_ptr);
+    return -1;
+  }
+
+  png_init_io(png_ptr, fp);
+
+  png_set_compression_level(png_ptr, (int)cDial.val);
+
+  /* Don't bother filtering if we aren't compressing the image */
+  if (FdefCB.val)
+  {
+    if ((int)cDial.val == 0)
+      png_set_filter(png_ptr, 0, PNG_FILTER_NONE);
+  }
+  else
+  {
+    filter  = FnoneCB.val  ? PNG_FILTER_NONE  : 0;
+    filter |= FsubCB.val   ? PNG_FILTER_SUB   : 0;
+    filter |= FupCB.val    ? PNG_FILTER_UP    : 0;
+    filter |= FavgCB.val   ? PNG_FILTER_AVG   : 0;
+    filter |= FPaethCB.val ? PNG_FILTER_PAETH : 0;
+
+    png_set_filter(png_ptr, 0, filter);
+  }
+
+  info_ptr->width = w;
+  info_ptr->height = h;
+
+  info_ptr->interlace_type = interCB.val ? 1 : 0;
+
+  if (colorType == F_FULLCOLOR || colorType == F_REDUCED) {
+    if(ptype == PIC24) {
+      linesize = 3*w;
+      info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+      info_ptr->bit_depth = 8;
+    } else {
+      linesize = w;
+      info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+      if(numcols <= 2)
+        info_ptr->bit_depth = 1;
+      else
+      if(numcols <= 4)
+        info_ptr->bit_depth = 2;
+      else
+      if(numcols <= 16)
+        info_ptr->bit_depth = 4;
+      else
+        info_ptr->bit_depth = 8;
+
+      for(i = 0; i < numcols; i++) {
+        palette[i].red   = rmap[i];
+        palette[i].green = gmap[i];
+        palette[i].blue  = bmap[i];
+      }
+      info_ptr->num_palette = numcols;
+      info_ptr->palette = palette;
+      info_ptr->valid |= PNG_INFO_PLTE;
+    }
+  }
+
+  else if(colorType == F_GREYSCALE || colorType == F_BWDITHER) {
+    info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+    if(colorType == F_BWDITHER) {
+      /* shouldn't happen */
+      if (ptype == PIC24) FatalError("PIC24 and B/W Stipple in WritePNG()");
+
+      info_ptr->bit_depth = 1;
+      if(MONO(rmap[0], gmap[0], bmap[0]) > MONO(rmap[1], gmap[1], bmap[1])) {
+        remap[0] = 1;
+        remap[1] = 0;
+      }
+      else {
+        remap[0] = 0;
+        remap[1] = 1;
+      }
+      linesize = w;
+    }
+    else {
+      if(ptype == PIC24) {
+        linesize = w*3;
+        info_ptr->bit_depth = 8;
+      }
+      else {
+        int low_presc;
+
+        linesize = w;
+
+        for(i = 0; i < numcols; i++)
+          remap[i] = MONO(rmap[i], gmap[i], bmap[i]);
+
+        for(; i < 256; i++)
+          remap[i]=0;
+
+        info_ptr->bit_depth = 8;
+
+        /* Note that this fails most of the time because of gamma */
+        /* try to adjust to 4 bit prescision grayscale */
+
+        low_presc=1;
+
+        for(i = 0; i < numcols; i++) {
+          if((remap[i] & 0x0f) * 0x11 != remap[i]) {
+            low_presc = 0;
+            break;
+          }
+        }
+
+        if(low_presc) {
+          for(i = 0; i < numcols; i++) {
+            remap[i] &= 0xf;
+          }
+          info_ptr->bit_depth = 4;
+
+          /* try to adjust to 2 bit prescision grayscale */
+
+          for(i = 0; i < numcols; i++) {
+            if((remap[i] & 0x03) * 0x05 != remap[i]) {
+              low_presc = 0;
+              break;
+            }
+          }
+        }
+
+        if(low_presc) {
+          for(i = 0; i < numcols; i++) {
+            remap[i] &= 3;
+          }
+          info_ptr->bit_depth = 2;
+
+          /* try to adjust to 1 bit prescision grayscale */
+
+          for(i = 0; i < numcols; i++) {
+            if((remap[i] & 0x01) * 0x03 != remap[i]) {
+              low_presc = 0;
+              break;
+            }
+          }
+        }
+
+        if(low_presc) {
+          for(i = 0; i < numcols; i++) {
+            remap[i] &= 1;
+          }
+          info_ptr->bit_depth = 1;
+        }
+      }
+    }
+  }
+
+  else
+    png_error(png_ptr, "Unknown colorstyle in WritePNG");
+
+  if ((text = (png_textp)malloc(sizeof(png_text)))) {
+    sprintf(software, "XV %s", REVDATE);
+
+    text->compression = -1;
+    text->key = "Software";
+    text->text = software;
+    text->text_length = strlen(text->text);
+
+    info_ptr->max_text = 1;
+    info_ptr->num_text = 1;
+    info_ptr->text = text;
+  }
+
+  Display_Gamma = gDial.val;  /* Save the current gamma for loading */
+
+  info_ptr->gamma = 1.0/gDial.val;
+  info_ptr->valid |= PNG_INFO_gAMA;
+
+  png_write_info(png_ptr, info_ptr);
+
+  if(info_ptr->bit_depth < 8)
+    png_set_packing(png_ptr);
+
+  pass=png_set_interlace_handling(png_ptr);
+
+  if((png_line = malloc(linesize)) == NULL)
+    png_error(png_ptr, "cannot allocate temp image line");
+
+  for(i = 0; i < pass; i++) {
+    int j;
+    p = pic;
+    for(j = 0; j < h; j++) {
+      if(info_ptr->color_type == PNG_COLOR_TYPE_GRAY) {
+        int k;
+        for(k = 0; k < w; k++)
+          png_line[k] = ptype==PIC24 ? MONO(p[k*3], p[k*3+1], p[k*3+2]) :
+                                       remap[p[k]];
+        png_write_row(png_ptr, png_line);
+      } else  /* RGB or palette */
+        png_write_row(png_ptr, p);
+      if((j & 0x1f) == 0) WaitCursor();
+      p += linesize;
+    }
+  }
+
+  free(png_line);
+
+  if (text)
+  {
+    if (picComments && strlen(picComments) &&
+        (savecmnt = (char *)malloc((strlen(picComments) + 1)*sizeof(char)))) {
+      png_textp tp;
+      char *comment, *key;
+
+      strcpy(savecmnt, picComments);
+      key = savecmnt;
+      tp = text;
+      info_ptr->num_text = 0;
+
+      comment = strchr(key, ':');
+
+      do  {
+        /* Allocate a larger structure for comments if necessary */
+        if (info_ptr->num_text >= info_ptr->max_text)
+        {
+          if ((tp =
+              realloc(text, (info_ptr->num_text + 2)*sizeof(png_text))) == NULL)
+          {
+            break;
+          }
+          else
+          {
+            text = tp;
+            tp = &text[info_ptr->num_text];
+            info_ptr->max_text += 2;
+          }
+        }
+
+        /* See if it looks like a PNG keyword from LoadPNG */
+        /* GRR: should test for strictly < 80, right? (key = 1-79 chars only) */
+        if(comment && comment[1] == ':' && comment - key <= 80) {
+          *(comment++) = '\0';
+          *(comment++) = '\0';
+
+          /* If the comment is the 'Software' chunk XV writes, we remove it,
+             since we have already stored one */
+          if (strcmp(key, "Software") == 0 && strncmp(comment, "XV", 2) == 0) {
+            key = strchr(comment, '\n');
+            if(key)
+              key++; /* skip \n */
+            comment = strchr(key, ':');
+          }
+          /* We have another keyword and/or comment to write out */
+          else {
+            tp->key = key;
+            tp->text = comment;
+
+            /* We have to find the end of this comment, and the next keyword
+               if there is one */
+            for (; NULL != (key = comment = strchr(comment, ':')); comment++)
+              if (key[1] == ':')
+                break;
+
+            /* It looks like another keyword, go backward to the beginning */
+            if (key) {
+              while(key > tp->text && *key != '\n')
+                key--;
+
+              if (key > tp->text && comment - key <= 80) {
+                *key = '\0';
+                key++;
+              }
+            }
+
+            tp->text_length = strlen(tp->text);
+
+            /* We don't have another keyword, so remove the last newline */
+            if (!key && tp->text[tp->text_length - 1] == '\n')
+            {
+              tp->text[tp->text_length] = '\0';
+              tp->text_length--;
+            }
+
+            tp->compression = tp->text_length > 640 ? 0 : -1;
+            info_ptr->num_text++;
+            tp++;
+          }
+        }
+        /* Just a generic comment:  make sure line-endings are valid for PNG */
+        else {
+          char *p=key, *q=key;     /* only deleting chars, not adding any */
+
+          while (*p) {
+            if (*p == CR) {        /* lone CR or CR/LF:  EOL either way */
+              *q++ = LF;           /* LF is the only allowed PNG line-ending */
+              if (p[1] == LF)      /* get rid of any original LF */
+                ++p;
+            } else if (*p == LF)   /* lone LF */
+              *q++ = LF;
+            else
+              *q++ = *p;
+            ++p;
+          }
+          *q = '\0';               /* unnecessary...but what the heck */
+          tp->key = "Comment";
+          tp->text = key;
+          tp->text_length = q - key;
+          tp->compression = tp->text_length > 750 ? 0 : -1;
+          info_ptr->num_text++;
+          key = NULL;
+        }
+      } while (key && *key);
+    }
+    else
+    {
+      info_ptr->num_text = 0;
+    }
+  }
+  info_ptr->text = text;
+
+  png_convert_from_time_t(&(info_ptr->mod_time), time(NULL));
+  info_ptr->valid |= PNG_INFO_tIME;
+
+  png_write_end(png_ptr, info_ptr);
+  fflush(fp);   /* just in case we core-dump before finishing... */
+
+  if (text)
+  {
+    free(text);
+    /* must do this or png_destroy_write_struct() 0.97+ will free text again: */
+    info_ptr->text = (png_textp)NULL;
+    if (savecmnt)
+    {
+      free(savecmnt);
+      savecmnt = (char *)NULL;
+    }
+  }
+
+  png_destroy_write_struct(&png_ptr, &info_ptr);
+
+  return 0;
+}
+
+
+/*******************************************/
+int LoadPNG(fname, pinfo)
+     char    *fname;
+     PICINFO *pinfo;
+/*******************************************/
+{
+  /* returns '1' on success */
+
+  FILE  *fp;
+  png_struct *png_ptr;
+  png_info *info_ptr;
+  png_color_16 my_background;
+  int i,j;
+  int linesize;
+  int filesize;
+  int pass;
+  size_t commentsize;
+
+  fbasename = BaseName(fname);
+
+  pinfo->pic     = (byte *) NULL;
+  pinfo->comment = (char *) NULL;
+
+  read_anything=0;
+
+  /* open the file */
+  fp = xv_fopen(fname,"r");
+  if (!fp)
+  {
+    SetISTR(ISTR_WARNING,"%s:  can't open file", fname);
+    return 0;
+  }
+
+  /* find the size of the file */
+  fseek(fp, 0L, 2);
+  filesize = ftell(fp);
+  fseek(fp, 0L, 0);
+  
+  png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL,
+                                   png_xv_error, png_xv_warning);
+  if(!png_ptr) {
+    fclose(fp);
+    FatalError("malloc failure in LoadPNG");
+  }
+
+  info_ptr = png_create_info_struct(png_ptr);
+
+  if(!info_ptr) {
+    fclose(fp);
+    png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
+    FatalError("malloc failure in LoadPNG");
+  }
+
+  if(setjmp(png_ptr->jmpbuf)) {
+    fclose(fp);
+    png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+    if(!read_anything) {
+      if(pinfo->pic) {
+        free(pinfo->pic);
+        pinfo->pic = NULL;
+      }
+      if(pinfo->comment) {
+        free(pinfo->comment);
+        pinfo->comment = NULL;
+      }
+    }
+    return read_anything;
+  }
+
+  png_init_io(png_ptr, fp);
+  png_read_info(png_ptr, info_ptr);
+
+  pinfo->w = pinfo->normw = info_ptr->width;
+  pinfo->h = pinfo->normh = info_ptr->height;
+
+  pinfo->frmType = F_PNG;
+
+  sprintf(pinfo->fullInfo, "PNG, %d bit ",
+          info_ptr->bit_depth * info_ptr->channels);
+
+  switch(info_ptr->color_type) {
+    case PNG_COLOR_TYPE_PALETTE:
+      strcat(pinfo->fullInfo, "palette color");
+      break;
+
+    case PNG_COLOR_TYPE_GRAY:
+      strcat(pinfo->fullInfo, "grayscale");
+      break;
+
+    case PNG_COLOR_TYPE_GRAY_ALPHA:
+      strcat(pinfo->fullInfo, "grayscale+alpha");
+      break;
+
+    case PNG_COLOR_TYPE_RGB:
+      strcat(pinfo->fullInfo, "truecolor");
+      break;
+
+    case PNG_COLOR_TYPE_RGB_ALPHA:
+      strcat(pinfo->fullInfo, "truecolor+alpha");
+      break;
+  }
+
+  sprintf(pinfo->fullInfo + strlen(pinfo->fullInfo),
+	  ", %sinterlaced. (%d bytes)",
+	  info_ptr->interlace_type ? "" : "non-", filesize);
+
+  sprintf(pinfo->shrtInfo, "%dx%d PNG", info_ptr->width, info_ptr->height);
+
+  if (info_ptr->bit_depth < 8)
+      png_set_packing(png_ptr);
+
+  if (info_ptr->valid & PNG_INFO_gAMA)
+    png_set_gamma(png_ptr, Display_Gamma, info_ptr->gamma);
+  else
+    png_set_gamma(png_ptr, Display_Gamma, 0.45);
+
+  if (info_ptr->valid & PNG_INFO_bKGD)
+    png_set_background(png_ptr, &info_ptr->background,
+                       PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
+  else {
+    my_background.red = my_background.green = my_background.blue =
+      my_background.gray = 0;
+    png_set_background(png_ptr, &my_background, PNG_BACKGROUND_GAMMA_SCREEN,
+                       0, Display_Gamma);
+  }
+
+  if (info_ptr->bit_depth == 16)
+    png_set_strip_16(png_ptr);
+
+  if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
+      info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+  {
+    if (info_ptr->bit_depth == 1)
+      pinfo->colType = F_BWDITHER;
+    else
+      pinfo->colType = F_GREYSCALE;
+    png_set_expand(png_ptr);
+  }
+
+  pass=png_set_interlace_handling(png_ptr);
+
+  png_read_update_info(png_ptr, info_ptr);
+
+  if(info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
+     info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {
+    linesize = pinfo->w * 3;
+    pinfo->colType = F_FULLCOLOR;
+    pinfo->type = PIC24;
+  } else {
+    linesize = pinfo->w;
+    pinfo->type = PIC8;
+    if(info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
+       info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {
+      for(i = 0; i < 256; i++)
+        pinfo->r[i] = pinfo->g[i] = pinfo->b[i] = i;
+    } else {
+      pinfo->colType = F_FULLCOLOR;
+      for(i = 0; i < info_ptr->num_palette; i++) {
+        pinfo->r[i] = info_ptr->palette[i].red;
+        pinfo->g[i] = info_ptr->palette[i].green;
+        pinfo->b[i] = info_ptr->palette[i].blue;
+      }
+    }
+  }
+  pinfo->pic = calloc((size_t)(linesize*pinfo->h), (size_t)1);
+
+  if(!pinfo->pic) {
+    png_error(png_ptr, "can't allocate space for PNG image");
+  }
+
+  png_start_read_image(png_ptr);
+
+  for(i = 0; i < pass; i++) {
+    byte *p = pinfo->pic;
+    for(j = 0; j < pinfo->h; j++) {
+      png_read_row(png_ptr, p, NULL);
+      read_anything = 1;
+      if((j & 0x1f) == 0) WaitCursor();
+      p += linesize;
+    }
+  }
+
+  png_read_end(png_ptr, info_ptr);
+
+  if(info_ptr->num_text > 0) {
+    commentsize = 1;
+
+    for(i = 0; i < info_ptr->num_text; i++)
+      commentsize += strlen(info_ptr->text[i].key) + 1 +
+                     info_ptr->text[i].text_length + 2;
+
+    if((pinfo->comment = malloc(commentsize)) == NULL) {
+      png_warning(png_ptr,"can't allocate comment string");
+    }
+    else {
+      pinfo->comment[0] = '\0';
+      for(i = 0; i < info_ptr->num_text; i++) {
+        strcat(pinfo->comment, info_ptr->text[i].key);
+        strcat(pinfo->comment, "::");
+        strcat(pinfo->comment, info_ptr->text[i].text);
+        strcat(pinfo->comment, "\n");
+      }
+    }
+  }
+
+  png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+
+  fclose(fp);
+
+  return 1;
+}
+
+
+/*******************************************/
+static void
+png_xv_error(png_ptr, message)
+     png_structp png_ptr;
+     png_const_charp message;
+{
+  SetISTR(ISTR_WARNING,"%s:  libpng error: %s", fbasename, message);
+
+  longjmp(png_ptr->jmpbuf, 1);
+}
+
+
+/*******************************************/
+static void
+png_xv_warning(png_ptr, message)
+     png_structp png_ptr;
+     png_const_charp message;
+{
+  if (!png_ptr)
+    return;
+
+  SetISTR(ISTR_WARNING,"%s:  libpng warning: %s", fbasename, message);
+}
+
+#endif
diff -Naur xv-3.10a.old/xvpopup.c xv-3.10a/xvpopup.c
--- xv-3.10a.old/xvpopup.c	Fri Jan 20 03:09:31 1995
+++ xv-3.10a/xvpopup.c	Tue Apr 24 09:37:06 2001
@@ -200,14 +200,14 @@
     
     if (!padHaveDooDads) {
       DCreate(&padWDial, popW, 16,      puhigh-16-100-1,75,100,
-	      1, 2048, pWIDE, 10,
+	      1.0, 2048.0, (double)pWIDE, 1.0, 10.0,
 	      infofg, infobg, hicol, locol, "Width", NULL);
       DCreate(&padHDial, popW, 16+1+75, puhigh-16-100-1,75,100,
-	      1, 2048, pHIGH, 10,
+	      1.0, 2048.0, (double)pHIGH, 1.0, 10.0,
 	      infofg, infobg, hicol, locol, "Height", NULL);
 
       DCreate(&padODial, popW, 16+1+75+75+9, puhigh-16-100-1,75,100,
-	      0, 100, 100, 10,
+	      0.0, 100.0, 100.0, 1.0, 10.0,
 	      infofg, infobg, hicol, locol, "Opaque", NULL);
 
       MBCreate(&padMthdMB, popW, 100-2+44, 10, 140, 19, NULL,
@@ -258,9 +258,9 @@
   else if (poptyp == ISPAD) {
     BTSetActive(&bts[0], (int) strlen(gsBuf));
     i = pWIDE * 3;  RANGE(i,2048,9999);  
-    DSetRange(&padWDial, 1, i, padWDial.val, 10);
+    DSetRange(&padWDial, 1.0, (double)i, padWDial.val, 1.0, 10.0);
     i = pHIGH * 3;  RANGE(i,2048,9999);  
-    DSetRange(&padHDial, 1, i, padHDial.val, 10);
+    DSetRange(&padHDial, 1.0, (double)i, padHDial.val, 1.0, 10.0);
 
     DSetActive(&padWDial, (padMode!=PAD_LOAD));  /* DSetRange activates dial */
     DSetActive(&padHDial, (padMode!=PAD_LOAD));
@@ -465,9 +465,9 @@
   changedGSBuf();      /* careful!  popW doesn't exist yet! */
 
   if (padHaveDooDads) { 
-    oldW = padWDial.val;  
-    oldH = padHDial.val;
-    oldO = padODial.val;
+    oldW = (int)padWDial.val;  
+    oldH = (int)padHDial.val;
+    oldO = (int)padODial.val;
   }
   else { oldW = pWIDE;  oldH = pHIGH;  oldO = 100; }
 
@@ -486,9 +486,9 @@
   }
 
   if (rv == 1) {   /* cancelled:  restore normal values */
-    DSetVal(&padWDial, oldW);
-    DSetVal(&padHDial, oldH);
-    DSetVal(&padODial, oldO);
+    DSetVal(&padWDial, (double)oldW);
+    DSetVal(&padHDial, (double)oldH);
+    DSetVal(&padODial, (double)oldO);
   }
 
   XUnmapWindow(theDisp, padWDial.win);
@@ -498,9 +498,9 @@
   /* load up return values */
   *pMode   = padMode;  
   *pStr    = padBuf;  
-  *pWide   = padWDial.val;
-  *pHigh   = padHDial.val;
-  *pOpaque = padODial.val;
+  *pWide   = (int)padWDial.val;
+  *pHigh   = (int)padHDial.val;
+  *pOpaque = (int)padODial.val;
   *pOmode  = padOMode;
 
   return rv;
@@ -560,6 +560,7 @@
 	nams[*lenp] = (char *) malloc((size_t) 32);
 	if (!nams[*lenp]) { free(vals[*lenp]); continue; }
 	strncpy(nams[*lenp], vals[*lenp], (size_t) 31);
+	nams[*lenp][31] = '\0';
       }
       
       if (strlen(nams[*lenp]) > (size_t) 20) {   /* fix long names */
@@ -972,8 +973,8 @@
   else if (popUp == ISPAD) {
     if (PTINRECT(x, y, padDButt.x, padDButt.y, padDButt.w, padDButt.h)) {
       if (BTTrack(&padDButt)) {
-	DSetVal(&padWDial, pWIDE);
-	DSetVal(&padHDial, pHIGH);
+	DSetVal(&padWDial, (double)pWIDE);
+	DSetVal(&padHDial, (double)pHIGH);
       }
     }
 
diff -Naur xv-3.10a.old/xvps.c xv-3.10a/xvps.c
--- xv-3.10a.old/xvps.c	Fri Dec 23 07:34:42 1994
+++ xv-3.10a/xvps.c	Tue Apr 24 09:37:06 2001
@@ -75,6 +75,7 @@
 				 byte *, byte *, byte *, int));
 static int  writeBWStip    PARM((FILE *, byte *, char *, int, int, int));
 
+static void buildCmdStr    PARM((char *, char *, char *, int, int));
 
 
 /* local variables */
@@ -139,9 +140,9 @@
   CBCreate(&encapsCB, psW, 240, 7, "preview", infofg, infobg, hicol, locol);
   CBCreate(&pscompCB, psW, 331, 7, "compress", infofg, infobg, hicol, locol);
 
-  DCreate(&xsDial, psW, 240, 30, 80, 100, 10, 800, 100, 5, 
+  DCreate(&xsDial, psW, 240, 30, 80, 100, 10.0, 800.0, 100.0, 0.5, 5.0, 
 	  infofg, infobg, hicol, locol, "Width", "%");
-  DCreate(&ysDial, psW, 331, 30, 80, 100, 10, 800, 100, 5, 
+  DCreate(&ysDial, psW, 331, 30, 80, 100, 10.0, 800.0, 100.0, 0.5, 5.0, 
 	  infofg, infobg, hicol, locol, "Height", "%");
   xsDial.drawobj = changedScale;
   ysDial.drawobj = changedScale;
@@ -236,10 +237,10 @@
 
   if (rd_int("psres")) {             /* xv.psres:  default paper resolution */
     if (def_int >= 10 && def_int <= 720) {
-      int i = (int) ((PIX2INCH * 100) / def_int);
+      double v = (PIX2INCH * 100) / def_int;
 
-      DSetVal(&xsDial, i);
-      DSetVal(&ysDial, i);
+      DSetVal(&xsDial, v);
+      DSetVal(&ysDial, v);
     }
   }
 
@@ -836,7 +837,7 @@
   if (scx < scy) { sz_iny = h * scx; }
             else { sz_inx = w * scy; }
 
-  DSetVal(&xsDial, (int) ((100 * (sz_inx * PIX2INCH) / w) + .5));
+  DSetVal(&xsDial, 100 * (sz_inx * PIX2INCH) / w);
   DSetVal(&ysDial, xsDial.val);
 
   sz_inx = (double) w / PIX2INCH * (xsDial.val / 100.0);  
@@ -1536,13 +1537,15 @@
      the first one is loaded (but not deleted) */
 
 
-  char tmp[512], tmp1[512], tmpname[64];
-  int  gsresult, nump, i, filetype;
+  char tmp[512], gscmd[512], cmdstr[512], tmpname[64];
+  int  gsresult, nump, i, filetype, doalert, epsf;
   char *rld;
 
   pinfo->pic     = (byte *) NULL;
   pinfo->comment = (char *) NULL;
 
+  doalert = (!quick && !ctrlUp && !infoUp);  /* open alert if no info wins */
+  epsf    = 0;
 
 #ifdef GS_PATH
 
@@ -1561,13 +1564,13 @@
   strcat(tmpname,".");
 
 
-  /* build command string */
+  /* build 'gscmd' string */
 
 #ifndef VMS  /* VMS needs quotes around mixed case command lines */
-  sprintf(tmp, "%s -sDEVICE=%s -r%d -q -dNOPAUSE -sOutputFile=%s%%d ",
+  sprintf(gscmd, "%s -sDEVICE=%s -r%d -q -dNOPAUSE -sOutputFile=%s%%d ",
 	  GS_PATH, gsDev, gsRes, tmpname);
 #else
-  sprintf(tmp, 
+  sprintf(gscmd, 
 	  "%s \"-sDEVICE=%s\" -r%d -q \"-dNOPAUSE\" \"-sOutputFile=%s%%d\" ",
 	  GS_PATH, gsDev, gsRes, tmpname);
 #endif
@@ -1575,74 +1578,60 @@
 
 #ifdef GS_LIB
 #  ifndef VMS
-     sprintf(tmp1, "-I%s ", GS_LIB);
+     sprintf(tmp, "-I%s ", GS_LIB);
 #  else
-     sprintf(tmp1, "\"-I%s\"", GS_LIB);
+     sprintf(tmp, "\"-I%s\" ", GS_LIB);
 #  endif
-   strcat(tmp, tmp1);
+   strcat(gscmd, tmp);
 #endif
 
-  if (gsGeomStr) {
-    sprintf(tmp1, "-g%s ", gsGeomStr);
-    strcat(tmp, tmp1);
-  }
-
-  /* if 'quick' is set, stop processing after first page by tacking
-     some PostScript commands that break the 'showpage' operator onto
-     the front of the stream passed to the ghostscript interpreter */
-
+ 
+  /* prevent some potential naughtiness... */
 #ifndef VMS
-  if (quick) {
-    sprintf(tmp1, "echo '%s' | cat - %s | %s -",
-	    "/showpage { showpage quit } bind def",   /* mk showpage exit */
-	    fname,  tmp);
-    strcpy(tmp, tmp1);
-  }
-  else {
-    strcat(tmp, " -- ");
-    strcat(tmp, fname);
-  }
-#else /* VMS */
-  /* VMS doesn't have pipes or an 'echo' command and GS doesn't like
-     Unix-style file names as input files in the VMS version */
-  strcat(tmp, " -- ");
-  rld = strrchr(fname, '/');     /* Pointer to last '/' */
-  if (rld) rld++;                /* Pointer to filename */
-      else rld = fname;          /* No path - use original string */
-  strcat(tmp, rld);
+   strcat(tmp, "-dSAFER ");
+#else
+   strcat(tmp, "\"-dSAFER\" ");
 #endif
+ 
 
+  if (gsGeomStr) {
+    sprintf(tmp, "-g%s ", gsGeomStr);
+    strcat(gscmd, tmp);
+  }
 
 
+  do {
+    buildCmdStr(cmdstr, gscmd, fname, quick, epsf);
 
-  WaitCursor();
-
-  if (DEBUG) fprintf(stderr,"LoadPS:  executing command '%s'\n", tmp);
-  SetISTR(ISTR_INFO, "Running '%s'...", GS_PATH);
-
-  sprintf(tmp1, "Running %s", tmp);
-  if (!quick && !ctrlUp && !infoUp) OpenAlert(tmp1);
+    if (DEBUG) fprintf(stderr,"LoadPS:  executing command '%s'\n", cmdstr);
+    SetISTR(ISTR_INFO, "Running '%s'...", GS_PATH);
+    sprintf(tmp, "Running %s", cmdstr);
+    if (doalert && epsf==0) OpenAlert(tmp);  /* open alert first time only */
 
-#ifndef VMS
-  gsresult = system(tmp);
-#else
-  gsresult = !system(tmp);
+    WaitCursor();
+    gsresult = system(cmdstr);
+    WaitCursor();
+#ifdef VMS
+    gsresult = !gsresult;   /* VMS returns non-zero if OK */
 #endif
+    
+    /* count # of files produced... */
+    for (i=1; i<1000; i++) {
+      struct stat st;
+      sprintf(tmp, "%s%d", tmpname, i);
+      if (stat(tmp, &st)!=0) break;
+    }
+    nump = i-1;
+    WaitCursor();
+    
+    /* EPSF hack:  if gsresult==0 (OK) and 0 pages produced, 
+       try tacking a 'showpage' onto the end of the file, do it again... */
+    
+    if (!gsresult && !nump && !epsf) epsf++;
+  } while (!gsresult && !nump && epsf<2);
+      
+  if (doalert) CloseAlert();
 
-  WaitCursor();
-
-  if (!quick && !ctrlUp && !infoUp) CloseAlert();
-
-  /* figure out how many page files were created, by stating files. 
-     breaks out on first failure, assuming there won't be any more after
-     that, and it would complicate matters too much anyhow... */
-
-  for (i=1; i<1000; i++) {
-    struct stat st;
-    sprintf(tmp, "%s%d", tmpname, i);
-    if (stat(tmp, &st)!=0) break;
-  }
-  nump = i-1;
 
   WaitCursor();
 
@@ -1712,3 +1701,38 @@
 		 we don't have 'gs' package */
 }
 
+
+
+/******************************************************************/
+void buildCmdStr(str, gscmd, fname, quick, espf)
+     char *str, *gscmd, *fname;
+     int   quick, espf;
+{
+  /* note 'epsf' only set on files that don't have a showpage cmd */
+  
+#ifdef GS_PATH
+#ifndef VMS
+  
+  if      (espf)  sprintf(str, "echo '\n showpage ' | cat '%s' - | %s -", 
+			  fname, gscmd);
+  
+  else if (quick) sprintf(str, "echo '%s' | cat - '%s' | %s -",
+			  "/showpage { showpage quit } bind def",
+			  fname,  gscmd);
+  
+  else            sprintf(str, "%s -- %s", gscmd, fname);
+  
+#else /* VMS */
+  /* VMS doesn't have pipes or an 'echo' command and GS doesn't like
+     Unix-style file names as input files in the VMS version */
+  strcat(tmp, " -- ");
+  rld = strrchr(fname, '/');     /* Pointer to last '/' */
+  if (rld) rld++;                /* Pointer to filename */
+  else rld = fname;          /* No path - use original string */
+  strcat(tmp, rld);
+#endif  /* VMS */
+#endif  /* GS_PATH */
+}
+
+
+  
diff -Naur xv-3.10a.old/xvroot.c xv-3.10a/xvroot.c
--- xv-3.10a.old/xvroot.c	Fri Dec 23 07:34:42 1994
+++ xv-3.10a/xvroot.c	Tue Apr 24 09:37:06 2001
@@ -44,6 +44,7 @@
   case RM_MIRROR:
   case RM_IMIRROR: rpixw = 2*eWIDE;  rpixh = 2*eHIGH;  break;
   case RM_CSOLID:
+  case RM_UPLEFT:
   case RM_CWARP:
   case RM_CBRICK:  rpixw = dispWIDE; rpixh = dispHIGH; break;
 
@@ -101,7 +102,7 @@
 
 
   else if (rmode == RM_CENTER || rmode == RM_CENTILE || rmode == RM_CSOLID ||
-	   rmode == RM_CWARP || rmode == RM_CBRICK) {
+	   rmode == RM_CWARP || rmode == RM_CBRICK || rmode == RM_UPLEFT) {
     /* do some stuff to set up the border around the picture */
 
     if (rmode != RM_CENTILE) {
@@ -138,6 +139,12 @@
 
     else if (rmode == RM_CSOLID) { }
 
+    else if (rmode == RM_UPLEFT) {
+
+      XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 0,0,
+		(u_int) eWIDE, (u_int) eHIGH);
+    }
+
     else if (rmode == RM_CWARP) {          /* warp effect */
       XSetForeground(theDisp, theGC, rootfg);
       for (i=0; i<=dispWIDE; i+=8) 
@@ -157,7 +164,7 @@
 
 
     /* draw the image centered on top of the background */
-    if (rmode != RM_CENTILE) 
+    if ((rmode != RM_CENTILE) && (rmode != RM_UPLEFT))
       XPutImage(theDisp, tmpPix, theGC, theImage, 0,0, 
 		((int) dispWIDE-eWIDE)/2, ((int) dispHIGH-eHIGH)/2, 
 		(u_int) eWIDE, (u_int) eHIGH);
diff -Naur xv-3.10a.old/xvtext.c xv-3.10a/xvtext.c
--- xv-3.10a.old/xvtext.c	Sat Jan 14 08:46:28 1995
+++ xv-3.10a/xvtext.c	Tue Apr 24 09:37:06 2001
@@ -19,9 +19,13 @@
 #include "copyright.h"
 
 #include "xv.h"
+#ifdef TV_MULTILINGUAL
+#include "xvml.h"
+#endif
 
-
-#define BUTTW 80
+#define BUTTW1 80
+#define BUTTW2 60
+#define BUTTW3 110
 #define BUTTH 24
 
 #define TOPMARGIN 30       /* from top of window to top of text window */
@@ -36,11 +40,28 @@
 #define TV_ASCII    0
 #define TV_HEX      1
 #define TV_CLOSE    2
-#define TV_NBUTTS   3
 
+#define TV_E_NBUTTS 3
+
+#ifdef TV_L10N
+#  define TV_RESCAN   3
+#  define TV_USASCII  4
+#  define TV_JIS      5
+#  define TV_EUCJ     6
+#  define TV_MSCODE   7
+
+#  define TV_J_NBUTTS 8
+#endif
 
 #define TITLELEN 128
 
+#ifdef TV_MULTILINGUAL
+struct coding_spec {
+    struct coding_system coding_system;
+    char *(*converter)PARM((char *, int, int *));
+};
+#endif
+
 /* data needed per text window */
 typedef struct {  Window win, textW;
 		  int    vis, wasvis;
@@ -57,16 +78,89 @@
 		  int    chwide, chhigh;   /* size of textW, in chars */
 		  int    hexmode;          /* true if disp Hex, else Ascii */
 		  SCRL   vscrl, hscrl;
-		  BUTT   but[TV_NBUTTS], nopBut;
+#ifdef TV_L10N
+		  int    code;         /* current charactor code */
+		  BUTT   but[TV_J_NBUTTS], nopBut;
+#else
+		  BUTT   but[TV_E_NBUTTS], nopBut;
+#endif
+#ifdef TV_MULTILINGUAL
+/*		  int    codeset; */
+                  struct coding_spec ccs;	/* current coding_spec */
+		  BUTT   csbut;
+		  char *cv_text;
+		  int cv_len;
+		  struct context *ctx;
+		  struct ml_text *txt;
+		  struct csinfo_t *cs;
+#endif
 		} TVINFO;
 
 
 static TVINFO   tinfo[MAXTVWIN];
 static int      hasBeenSized = 0;
 static int      haveWindows  = 0;
+static int      nbutts;		/* # of buttons */
 static int      mfwide, mfhigh, mfascent;   /* size of chars in mono font */
 static int     *event_retP, *event_doneP;   /* used in tvChkEvent() */
-
+#ifdef TV_MULTILINGUAL
+# define TV_PLAIN          0
+# define TV_ISO_8859_1     1
+# define TV_ISO_2022_JP    2
+# define TV_EUC_JAPAN      3
+# define TV_ISO_2022_INT_1 4
+# define TV_ISO_2022_KR    5
+# define TV_EUC_KOREA      6
+# define TV_ISO_2022_SS2_8 7
+# define TV_ISO_2022_SS2_7 8
+# define TV_SHIFT_JIS      9
+# define TV_NCSS          10
+static char *codeSetNames[TV_NCSS] = {
+    "plain",
+    "iso-8859-1",
+    "iso-2022-jp",
+    "euc-japan",
+    "iso-2022-int-1",
+    "iso-2022-kr",
+    "euc-korea",
+    "iso-2022-ss2-8",
+    "iso-2022-ss2-7",
+    "Shift JIS",
+};
+static struct coding_spec coding_spec[TV_NCSS] = {
+    /* --- G0 ---   --- G1 ---   --- G2 ---   --- G3 ---  GL GR EOL SF LS */
+    /* plain */
+    {{{{ 1,94,'B'}, { 1,94,'B'}, { 1,94,'B'}, { 1,94,'B'}}, 0, 0,  0, 1, 1},
+     NULL},
+    /* iso-8859-1 */
+    {{{{ 1,94,'B'}, { 1,96,'A'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
+     NULL},
+    /* iso-2022-jp */
+    {{{{ 1,94,'B'}, {-1,94,'B'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 0,  0, 1, 0},
+     NULL},
+    /* euc-japan */
+    {{{{ 1,94,'B'}, { 2,94,'B'}, { 1,94,'J'}, { 2,94,'D'}}, 0, 1,  0, 1, 0},
+     NULL},
+    /* iso-2022-int-1 */
+    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 1, 1},
+     NULL},
+    /* iso-2022-kr */
+    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 1},
+     NULL},
+    /* euc-korea */
+    {{{{ 1,94,'B'}, { 2,94,'C'}, {-1,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
+     NULL},
+    /* iso-2022-ss2-8 */
+    {{{{ 1,94,'B'}, {-1,94,'C'}, { 0,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 0, 0},
+     NULL},
+    /* iso-2022-ss2-7 */
+    {{{{ 1,94,'B'}, {-1,94,'C'}, { 0,94,'B'}, {-1,94,'B'}}, 0, 1,  0, 1, 0},
+     NULL},
+    /* shift jis */
+    {{{{ 1,94,'B'}, { 2,94,'B'}, { 1,94,'J'}, { 2,94,'D'}}, 0, 1,  1, 1, 0},
+     sjis_to_jis},
+};
+#endif
 
 static void closeText       PARM((TVINFO *));
 static int  tvChkEvent      PARM((TVINFO *, XEvent *));
@@ -82,7 +176,15 @@
 static void textKey         PARM((TVINFO *, int));
 static void doHexAsciiCmd   PARM((TVINFO *, int));
 static void computeText     PARM((TVINFO *));
-
+#ifdef TV_L10N
+static int  selectCodeset         PARM((TVINFO *));
+#endif
+#ifdef TV_MULTILINGUAL
+static void setCodingSpec   PARM((TVINFO *, struct coding_spec *));
+static void createCsWins    PARM((char *));
+static void openCsWin       PARM((TVINFO *));
+static void closeCsWin      PARM((TVINFO *));
+#endif
 
 /* HEXMODE output looks like this:
 0x00000000: 00 11 22 33 44 55 66 77 - 88 99 aa bb cc dd ee ff  0123456789abcdef
@@ -99,11 +201,51 @@
   XSetWindowAttributes  xswa;
   TVINFO               *tv;
   int                   gx,gy,gw,gh,gset,gx1,gy1;
-  
+#ifdef TV_MULTILINGUAL
+  int			default_codeset;
+#endif
+
+#ifdef TV_L10N  
+  if (!xlocale) {
+#endif
+      mfwide = monofinfo->max_bounds.width;
+      mfhigh = monofinfo->ascent + monofinfo->descent;
+      mfascent = monofinfo->ascent;
 
-  mfwide = monofinfo->max_bounds.width;
-  mfhigh = monofinfo->ascent + monofinfo->descent;
-  mfascent = monofinfo->ascent;
+      nbutts = TV_E_NBUTTS;	/* # of buttons */
+#ifdef TV_L10N
+  }
+  else {
+      mfwide = monofsetinfo->max_logical_extent.width / 2;	/* shit! */
+      mfhigh = monofsetinfo->max_logical_extent.height + 1;
+      mfascent = mfhigh;
+
+      nbutts = TV_J_NBUTTS;	/* # of buttons */
+  }
+#endif
+
+#ifdef TV_MULTILINGUAL
+  {
+    char *dc = XGetDefault(theDisp, "xv", "codeSet");
+    if (dc == NULL) 
+      default_codeset = TV_DEFAULT_CODESET;
+    else {
+      for (i = 0; i < TV_NCSS; i++) {
+	if (strcmp(dc, codeSetNames[i]) == 0)
+	  break;
+      }
+      if (i >= TV_NCSS) {
+        if (strcmp(dc, "iso-2022") == 0)
+	  default_codeset = TV_PLAIN;
+	else {
+	  SetISTR(ISTR_WARNING, "%s: unknown codeset.", dc);
+	  default_codeset = TV_PLAIN;
+	}
+      } else
+	default_codeset = i;
+    }
+  }
+#endif
 
   /* compute default size of textview windows.  should be big enough to
      hold an 80x24 text window */
@@ -119,6 +261,14 @@
   for (i=0; i<MAXTVWIN; i++) {
     tv = &tinfo[i];
 
+#ifdef TV_MULTILINGUAL
+    tv->ctx = ml_create_context(ScreenOfDisplay(theDisp, theScreen));
+    tv->txt = NULL;
+    tv->cv_text = NULL;
+    tv->cv_len = 0;
+    ml_set_charsets(tv->ctx, &coding_spec[TV_PLAIN].coding_system);
+#endif
+
     tv->win = CreateWindow((i<CMTWIN) ? "xv text viewer" : "xv image comments",
 			   "XVtextview", 
 			   (i<CMTWIN) ? geom : cmtgeom, 
@@ -163,24 +313,56 @@
     XSelectInput(theDisp, tv->textW, ExposureMask | ButtonPressMask);
 
     
-    BTCreate(&(tv->but[TV_ASCII]), tv->win, 0,0,BUTTW,BUTTH,
+    BTCreate(&(tv->but[TV_ASCII]), tv->win, 0,0,BUTTW1,BUTTH,
 	     "Ascii",infofg,infobg,hicol,locol);
-    BTCreate(&(tv->but[TV_HEX]), tv->win, 0,0,BUTTW,BUTTH,
+    BTCreate(&(tv->but[TV_HEX]), tv->win, 0,0,BUTTW1,BUTTH,
 	     "Hex",infofg,infobg,hicol,locol);
-    BTCreate(&(tv->but[TV_CLOSE]), tv->win, 0,0,BUTTW,BUTTH,
+    BTCreate(&(tv->but[TV_CLOSE]), tv->win, 0,0,BUTTW1,BUTTH,
 	     "Close",infofg,infobg,hicol,locol);
 
+#ifdef TV_L10N
+    if (xlocale) {
+	BTCreate(&(tv->but[TV_RESCAN]), tv->win, 0,0,BUTTW2,BUTTH,
+		 "RESCAN",infofg,infobg,hicol,locol);
+	BTCreate(&(tv->but[TV_USASCII]), tv->win, 0,0,BUTTW2,BUTTH,
+		 "ASCII",infofg,infobg,hicol,locol);
+	BTCreate(&(tv->but[TV_JIS]), tv->win, 0,0,BUTTW2,BUTTH,
+		 "JIS",infofg,infobg,hicol,locol);
+	BTCreate(&(tv->but[TV_EUCJ]), tv->win, 0,0,BUTTW2,BUTTH,
+		 "EUC-j",infofg,infobg,hicol,locol);
+	BTCreate(&(tv->but[TV_MSCODE]), tv->win, 0,0,BUTTW2,BUTTH,
+		 "MS Kanji",infofg,infobg,hicol,locol);
+    }
+#endif
+
     BTCreate(&(tv->nopBut), tv->win, 0,0, (u_int) tv->vscrl.tsize+1,
 	     (u_int) tv->vscrl.tsize+1, "", infofg, infobg, hicol, locol);
     tv->nopBut.active = 0;
 
     XMapSubwindows(theDisp, tv->win);
 
+#ifdef TV_MULTILINGUAL
+    BTCreate(&tv->csbut, tv->win, 0, 0, BUTTW1, BUTTH, "Code Sets",
+	     infofg, infobg, hicol, locol);
+#endif
+
     tv->text = (char *) NULL;
     tv->textlen = 0;
     tv->title[0] = '\0';
+#ifdef TV_L10N
+      tv->code = (xlocale ? LOCALE_DEFAULT : 0);
+#endif
+#ifdef TV_MULTILINGUAL
+    tv->ccs = coding_spec[default_codeset];
+#endif
   }
-
+#ifdef TV_MULTILINGUAL
+  get_monofont_size(&mfwide, &mfhigh);
+  /* recalculate sizes. */
+  defwide = 80 * mfwide + 2*LRMARGINS + 8 + 20;   /* -ish */
+  defhigh = 24 * mfhigh + TOPMARGIN + BOTMARGIN + 8 + 20;   /* ish */
+  cmthigh = 6  * mfhigh + TOPMARGIN + BOTMARGIN + 8 + 20;   /* ish */
+#endif
 
   for (i=0; i<MAXTVWIN; i++) {
     resizeText(&tinfo[i], defwide, (i<CMTWIN) ? defhigh : cmthigh);
@@ -190,7 +372,10 @@
   }
 
   hasBeenSized = 1;  /* we can now start looking at textview events */
-
+  
+#ifdef TV_MULTILINGUAL
+  createCsWins("+100+100");
+#endif
 }
 
 
@@ -200,26 +385,35 @@
 {
   /* given a filename, attempts to read in the file and open a textview win */
 
-  int   i;
+  int   i, filetype;
   long  textlen;
   char *text, buf[512], title[128], rfname[MAXPATHLEN+1];
   char *basefname[128];  /* just current fname, no path */
   FILE *fp;
+  char filename[MAXPATHLEN+1];
+
+  strcpy(filename, fname);
+
+#ifdef AUTO_EXPAND
+  Mkvdir(filename);
+  Dirtovd(filename);
+#endif
 
   basefname[0] = '\0';
-  strcpy(rfname, fname);
+  strcpy(rfname, filename);
 
   /* see if this file is compressed.  if it is, uncompress it, and view
      the uncompressed version */
 
-  if (ReadFileType(fname) == RFT_COMPRESS) {
+  filetype = ReadFileType(filename);
+  if ((filetype == RFT_COMPRESS) || (filetype == RFT_BZIP2)) {
 #ifndef VMS
-    if (!UncompressFile(fname, rfname)) return;    /* failed to uncompress */
+    if (!UncompressFile(filename, rfname, filetype)) return;    /* failed to uncompress */
 #else
     /* chop off trailing '.Z' from friendly displayed basefname, if any */
-    strcpy (basefname, fname);
+    strcpy (basefname, filename);
     *rindex (basefname, '.') = '\0';
-    if (!UncompressFile(basefname, rfname)) return;/* failed to uncompress */
+    if (!UncompressFile(basefname, rfname, filetype)) return;/* failed to uncompress */
 #endif
   }
       
@@ -244,7 +438,7 @@
     return;
   }
 
-  text = (char *) malloc((size_t) textlen);
+  text = (char *) malloc((size_t) textlen + 1);
   if (!text) {
     sprintf(buf, "Couldn't malloc %ld bytes to read file '%s'", 
 	    textlen, rfname);
@@ -258,6 +452,9 @@
 	    rfname);
     ErrPopUp(buf, "\nHmm...");
   }
+#ifdef TV_MULTILINGUAL
+  text[textlen] = '\0';
+#endif
 
   fclose(fp);
 
@@ -293,6 +490,7 @@
   tv->textlen     = len;
   tv->freeonclose = freeonclose;
   strncpy(tv->title, title, (size_t) TITLELEN-1);
+  tv->title[TITLELEN-1] = '\0';
 
   computeText(tv);      /* compute # lines and linestarts array */
 
@@ -507,6 +705,10 @@
   tv->text  = (char *) NULL;  
   tv->lines = (char **) NULL;
   tv->numlines = tv->textlen = tv->hexmode = 0;
+
+#ifdef TV_MULTILINGUAL
+  closeCsWin(tv);
+#endif
 }
 
 
@@ -636,7 +838,9 @@
   int        i, maxw, maxh, hmax, hpage, vmax, vpage;
   XSizeHints hints;
 
+#ifndef TV_MULTILINGUAL
   if (tv->wide == w && tv->high == h) return;  /* no change in size */
+#endif
 
   if (XGetNormalHints(theDisp, tv->win, &hints)) {
     hints.width  = w;
@@ -660,10 +864,23 @@
   XMoveResizeWindow(theDisp, tv->textW, LRMARGINS, TOPMARGIN, 
 		    (u_int) tv->twWide, (u_int) tv->twHigh);
 
-  for (i=0; i<TV_NBUTTS; i++) {
-    tv->but[i].x = tv->wide - (TV_NBUTTS-i) * (BUTTW+5);
+  for (i=0; i<TV_E_NBUTTS; i++) {
+    tv->but[i].x = tv->wide - (TV_E_NBUTTS-i) * (BUTTW1+5);
     tv->but[i].y = tv->high - BUTTH - 5;
   }
+#ifdef TV_MULTILINGUAL
+  tv->csbut.x = 5;
+  tv->csbut.y = tv->high - BUTTH - 5;
+#endif
+
+#ifdef TV_L10N
+  if (xlocale) {
+    for (; i<TV_J_NBUTTS; i++) {
+      tv->but[i].x = 5 + (i-TV_E_NBUTTS) * (BUTTW2+5);
+      tv->but[i].y = tv->high - BUTTH - 5;
+    }
+  }
+#endif
 
   computeScrlVals(tv);
 
@@ -714,6 +931,29 @@
   case TV_CLOSE:   if (tv == &tinfo[CMTWIN]) CloseCommentText();
                    else closeText(tv);
                    break;
+
+#ifdef TV_L10N
+  case TV_RESCAN:
+    tv->code = selectCodeset(tv);
+    drawTextW(0, &tv->vscrl);
+    break;
+  case TV_USASCII:
+    tv->code = LOCALE_USASCII;
+    drawTextW(0, &tv->vscrl);
+    break;
+  case TV_JIS:
+    tv->code = LOCALE_JIS;
+    drawTextW(0, &tv->vscrl);
+    break;
+  case TV_EUCJ:
+    tv->code = LOCALE_EUCJ;
+    drawTextW(0, &tv->vscrl);
+    break;
+  case TV_MSCODE:
+    tv->code = LOCALE_MSCODE;
+    drawTextW(0, &tv->vscrl);
+    break;
+#endif	/* TV_L10N */
   }
 }
 
@@ -748,8 +988,10 @@
   drawNumLines(tv);
 
   /* draw the buttons */
-  for (i=0; i<TV_NBUTTS; i++) BTRedraw(&(tv->but[i]));
-
+  for (i=0; i<nbutts; i++) BTRedraw(&(tv->but[i]));
+#ifdef TV_MULTILINGUAL
+  BTRedraw(&tv->csbut);
+#endif
   BTRedraw(&tv->nopBut);
 }
 
@@ -820,6 +1062,10 @@
      SCRL *sptr;
 {
   int     i, j, lnum, hpos, cpos, extrach, lwide;
+#ifdef TV_L10N
+  int     desig_stat;	/* for ISO 2022-JP */
+	      /* 0: ASCII,  1: JIS X 0208,  2: GL is JIS X 0201 kana */
+#endif
   TVINFO *tv;
   char    linestr[512];
   u_char  *sp, *ep, *lp;
@@ -846,6 +1092,31 @@
 
   /* draw text */
   if (!tv->hexmode) {     /* ASCII mode */
+#ifdef TV_MULTILINGUAL
+    XClearArea(theDisp, tv->textW, 0, 0,
+	       (u_int) tv->twWide, (u_int) tv->twHigh, False);
+    if(tv->txt == NULL)
+      return;
+    else {
+	int i;
+	int y;
+	struct ml_text *tp = tv->txt;
+	struct ml_line *lp;
+	
+	XSetFunction(theDisp, theGC, GXcopy);
+	XSetClipMask(theDisp, theGC, None);
+	y = 3;
+	for (lp = &tp->lines[tv->vscrl.val], i = tp->nlines - tv->vscrl.val;
+		i > 0; lp++, i--) {
+	    XDrawText16(theDisp, tv->textW, theGC,
+			-mfwide * hpos + 3, y + lp->ascent,
+			lp->items, lp->nitems);
+	    y += lp->ascent + lp->descent;
+	    if (y > tv->twHigh)
+		break;
+	}
+    }
+#else
     for (i=0; i<tv->chhigh; i++) {    /* draw each line */
       lnum = i + tv->vscrl.val;
       if (lnum < tv->numlines-1) {
@@ -868,7 +1139,13 @@
 	      cpos--;  sp++;
 	    }
 	    else if (*sp < 32) extrach = 1;
+
+#ifdef TV_L10N
+	    else if (!tv->code && *sp > 127) extrach = 3;
+#else
 	    else if (*sp > 127) extrach = 3;
+#endif
+
 	    else sp++;
 	  }
 	  else {
@@ -884,6 +1161,10 @@
 
 	/* build up the linestr buffer, which is the current line, padded
 	   with blanks to a width of exactly tv->chwide chars */
+#ifdef TV_L10N
+	desig_stat = 0;		/* for ISO 2022-JP */
+	      /* 0: ASCII,  1: JIS X 0208,  2: GL is JIS X 0201 kana */
+#endif
 	for (cpos=0, lp=(byte *) linestr; cpos<lwide; cpos++, lp++) {
 	  if (sp>=ep) *lp = ' ';
 	  else {
@@ -897,13 +1178,117 @@
 	      cpos--;  lp--;  sp++;
 	    }
 
+#ifdef TV_L10N
+	    else if (*sp < 32 && !(tv->code == LOCALE_JIS && *sp == 0x1b)) {
+#else
 	    else if (*sp < 32) {
+#endif
 	      if (!extrach) extrach = 2;
 	      if      (extrach == 2) *lp = '^';
 	      else if (extrach == 1) *lp = *sp + 64;
 	    }
-      
+
+#ifdef TV_L10N
+	    /* convert to EUC-Japan */
+	    else if (tv->code == LOCALE_JIS) {
+	      if (*sp == 0x1b) {	/* ESC */
+		if (*(sp+1) == '$') {
+		  if (*(sp+2) == 'B' || *(sp+2) == 'A' || *(sp+2) == '@') {
+		    /* ESC $ B,  ESC $ A,  ESC $ @ */
+		    desig_stat = 1;
+		    sp += 3;  cpos--;  lp--;
+		  }
+		  else if (*(sp+2) == '(' && *(sp+3) == 'B') {
+		    /* ESC $ ( B */
+		    desig_stat = 1;
+		    sp += 4;  cpos--;  lp--;
+		  }
+		}
+		else if (*(sp+1) == '(') {
+		  if (*(sp+2) == 'B' || *(sp+2) == 'J' || *(sp+2) == 'H') {
+		    /* ESC ( B,  ESC ( J,  ESC ( H */
+		    desig_stat = 0;
+		    sp += 3;  cpos--;  lp--;
+		  }
+		  else if (*(sp+2) == 'I') {
+		    /* ESC ( I */
+		    desig_stat = 2;
+		    sp += 3;  cpos--;  lp--;
+		  }
+		}
+		else if (*(sp+1) == ')' && *(sp+2) == 'I') {
+		  /* ESC ) I */
+		  desig_stat = 2;
+		  sp += 3;  cpos--;  lp--;
+		}
+		else {	/* error */
+		  *lp = ' ';  sp++;
+		}
+	      }
+
+	      else {
+		switch (desig_stat) {
+		case 0:		/* ASCII */
+		  *lp = *sp++;
+		  break;
+		case 1:		/* JIS X 0208 */
+		  *lp++ = *sp++ | 0x80;
+		  *lp   = *sp++ | 0x80;
+		  cpos++;
+		  break;
+		case 2:		/* JIS X 0201 kana */
+#if defined(__osf__) && !defined(X_LOCALE)
+		  *lp   = '=';  sp++;
+#else
+		  *lp++ = 0x8e;	/* ^N | 0x80 */
+		  *lp   = *sp++ | 0x80;
+#endif
+		  break;
+		default:	/* error */
+		  *lp = *sp++;
+		  break;
+		}
+	      }
+	    }
+
+	    else if (tv->code == LOCALE_MSCODE) {
+	      if ((*sp >= 0x81 && *sp <= 0x9f)
+			 || (*sp >= 0xe0 && *sp <= 0xef)) {
+		static u_char c1, c2;
+
+/*fprintf(stderr, "(%x,%x)->", *sp, *(sp+1));*/
+		c1 = ((*sp - ((*sp>=0xe0) ? 0xb0 : 0x70)) << 1)
+			- ((*(sp+1)<=0x9e) ? 1 : 0);
+		c2 = *(sp+1);
+		if      (c2 >= 0x9f)  c2 -= 0x7e;	/* 0x9F - 0xFC */
+		else if (c2 >= 0x80)  c2 -= 0x20;	/* 0x80 - 0x9E */
+		else		      c2 -= 0x1f;	/* 0x40 - 0x7E */
+
+		*lp++ = c1 | 0x80;
+		*lp   = c2 | 0x80;
+		sp += 2;
+/*fprintf(stderr, "(%x %x) ", c1 | 0x80, c2 | 0x80);*/
+		cpos++;
+	      }
+
+	      else if (*sp >= 0xa1 && *sp <= 0xdf) {	/* JIS X 0201 kana */
+#if defined(__osf__) && !defined(X_LOCALE)
+		*lp   = '=';  sp++;
+#else
+		*lp++ = 0x8e;	/* ^N | 0x80 */
+		*lp   = *sp++;
+#endif
+	      }
+
+	      else *lp = *sp++;
+	    }
+#endif	/* TV_L10N */
+
+#ifdef TV_L10N
+	    else if (!tv->code && *sp > 127) {
+#else
 	    else if (*sp > 127) {
+#endif
 	      if (!extrach) extrach = 4;
 	      if      (extrach == 4) *lp = '\\';
 	      else if (extrach == 3) *lp = ((u_char)(*sp & 0700) >> 6) + '0';
@@ -919,6 +1304,9 @@
 	    }
 	  }
 	}
+#ifdef TV_L10N
+	*lp = '\0';	/* terminate linestr */
+#endif
       }
 
       else {  /* below bottom of file.  Just build a blank str */
@@ -926,9 +1314,16 @@
       }
 
       /* draw the line */
-      XDrawImageString(theDisp, tv->textW, theGC, 
-		       3, i*mfhigh + 3 + mfascent, linestr, lwide);
+#ifdef TV_L10N
+      if (xlocale)
+	XmbDrawImageString(theDisp, tv->textW, monofset, theGC,
+		3, i*mfhigh + 1 + mfascent, linestr, strlen(linestr));
+      else
+#endif
+	XDrawImageString(theDisp, tv->textW, theGC, 
+			 3, i*mfhigh + 3 + mfascent, linestr, lwide);
     }  /* for i ... */
+#endif /* TV_MULTILINGUAL */
   }  /* if hexmode */
 
 
@@ -960,7 +1355,11 @@
 
 	for (j=0; j<16; j++) {
 	  if (sp+j < ep) {
+#ifdef TV_L10N
+	    if (sp[j] >= 32 && (sp[j] <= 127 || tv->code)) *lp++ = sp[j];
+#else
 	    if (sp[j] >= 32 && sp[j] <= 127) *lp++ = sp[j];
+#endif
 	    else *lp++ = '.';
 	  }
 	  else *lp++ = ' ';
@@ -1008,14 +1407,21 @@
   int   i;
   BUTT *bp;
 
-  for (i=0, bp=tv->but; i<TV_NBUTTS; i++, bp++) {
+  for (i=0, bp=tv->but; i<nbutts; i++, bp++) {
     if (PTINRECT(x,y,bp->x,bp->y,bp->w,bp->h)) break;
   }
 
-  if (i<TV_NBUTTS) {
+  if (i<nbutts) {
     if (BTTrack(bp)) doCmd(tv, i);
     return;
   }
+
+#ifdef TV_MULTILINGUAL
+  if (PTINRECT(x, y, tv->csbut.x, tv->csbut.y, tv->csbut.w, tv->csbut.h)) {
+    if (BTTrack(&tv->csbut))
+      openCsWin(tv);
+  }
+#endif
 }
 
 
@@ -1045,13 +1451,38 @@
 
   /* keyboard equivalents */
   switch (buf[0]) {
-  case '\001': doCmd(tv, TV_ASCII);   break;      /* ^A = Ascii */
-  case '\010': doCmd(tv, TV_HEX);     break;      /* ^H = Hex   */
-
-  case '\033': doCmd(tv, TV_CLOSE);   break;      /* ESC = Close window */
+  case '\001':  case 'a':  case 'A':
+    doCmd(tv, TV_ASCII);   break;      /* ^A = Ascii */
+  case '\010':  case 'h':  case 'H':
+    doCmd(tv, TV_HEX);     break;      /* ^H = Hex   */
+
+  case '\021':  case 'q':  case 'Q':
+  case '\003':  case 'c':  case 'C':
+  case '\033':
+    doCmd(tv, TV_CLOSE);   break;      /* ESC = Close window */
 
   default:     break;
   }
+
+#ifdef TV_L10N
+  if (xlocale) {
+    switch (buf[0]) {
+    case '\022':  case 'r':  case 'R':
+      doCmd(tv, TV_RESCAN);   break;
+    case '\012':  case 'j':  case 'J':
+      doCmd(tv, TV_JIS);      break;
+    case '\005':  case 'e':  case 'E':
+    case '\025':  case 'u':  case 'U':
+      doCmd(tv, TV_EUCJ);     break;
+    case '\015':  case 'm':  case 'M':
+    case '\023':  case 's':  case 'S':
+      doCmd(tv, TV_MSCODE);  break;
+
+    default:  break;
+    }
+  }
+#endif	/* TV_L10N */
+
 }
 
 
@@ -1114,7 +1545,20 @@
     if (i<tv->numlines-1) SCSetVal(&tv->vscrl, i);
   }
 
+#ifdef TV_L10N
+  /* redraw text */
+  if (xlocale) {
+    XClearArea(theDisp, tv->textW, 0, 0,
+	       (u_int) tv->twWide, (u_int) tv->twHigh, False);
+
+    drawTextW(0, &tv->vscrl);
+  }
+#endif
+#ifdef TV_MULTILINGUAL
+  XClearArea(theDisp, tv->textW, 0, 0,
+	     (u_int) tv->twWide, (u_int) tv->twHigh, False);
   drawTextW(0, &tv->vscrl);
+#endif
 }
 
 
@@ -1127,9 +1571,22 @@
   int   i,j,wide,maxwide,space;
   byte *sp;
 
+#ifdef TV_L10N
+  /* select code-set */
+  if (xlocale)
+    tv->code = selectCodeset(tv);
+#endif	/* TV_L10N */
+
   if (!tv->text) { 
     tv->numlines = tv->hexlines = 0;  
     tv->lines = (char **) NULL; 
+#ifdef TV_MULTILINGUAL
+    if (tv->cv_text != NULL) {
+	free(tv->cv_text);
+	tv->cv_text = NULL;
+    }
+    tv->txt = NULL;
+#endif
     return;
   }
 
@@ -1177,17 +1634,134 @@
 	wide += space;
       }
       else if (*sp <  32) wide += 2;
+#ifdef TV_L10N
+      else if (*sp > 127 && !tv->code) wide += 4;
+#else
       else if (*sp > 127) wide += 4;
+#endif
       else wide++;
     }
     if (wide > maxwide) maxwide = wide;
   }
   tv->maxwide = maxwide;
 
+#ifdef TV_MULTILINGUAL
+  ml_set_charsets(tv->ctx, &tv->ccs.coding_system);
+  if (tv->cv_text != NULL) {
+      free(tv->cv_text);
+      tv->cv_text = NULL;
+  }
+  if (tv->ccs.converter == NULL) {
+      tv->txt = ml_draw_text(tv->ctx, tv->text, tv->textlen);
+  } else {
+      tv->cv_text = (*tv->ccs.converter)(tv->text, tv->textlen, &tv->cv_len);
+      tv->txt = ml_draw_text(tv->ctx, tv->cv_text, tv->cv_len);
+  }
+  tv->maxwide = tv->txt->width / mfwide;
+  tv->numlines = tv->txt->height / mfhigh + 1;
+#endif
+
   tv->hexlines = (tv->textlen + 15) / 16;
 }
 
 
+/***************************************************/
+#ifdef TV_L10N
+static int selectCodeset(tv)
+     TVINFO *tv;
+{
+  u_char *sp;
+  int i, len;
+  int code;
+
+  len = tv->textlen;
+
+  /* select code-set */
+  if (xlocale) {
+    code = LOCALE_USASCII;	/* == 0 */
+
+    sp = (u_char *) tv->text;  i = 0;
+    while (i < len - 1) {
+      if (*sp == 0x1b &&
+	  (*(sp+1) == '$' || *(sp+1) == '(' || *(sp+1) == ')')) {
+	code = LOCALE_JIS;
+	break;
+      }
+
+      else if (*sp >= 0xa1 && *sp <= 0xdf) {
+	if (*(sp+1) >= 0xf0 && *(sp+1) <= 0xfe) {
+	  code = LOCALE_EUCJ;
+	  break;
+	}
+#  if (LOCALE_DEFAULT == LOCALE_EUCJ)
+	else {
+	  sp++;  i++;
+	}
+#  endif
+      }
+
+      else if ((*sp >= 0x81 && *sp <= 0x9f) || (*sp >= 0xe0 && *sp <= 0xef)) {
+	if ((*(sp+1) >= 0x40 && *(sp+1) <= 0x7e) || *(sp+1) == 0x80) {
+	  code = LOCALE_MSCODE;
+	  break;
+	}
+	else if (*(sp+1) == 0xfd || *(sp+1) == 0xfe) {
+	  code = LOCALE_EUCJ;
+	  break;
+	}
+	else {
+	  sp++;  i++;
+	}
+      }
+
+      else if (*sp >= 0xf0 && *sp <= 0xfe) {
+	code = LOCALE_EUCJ;
+	break;
+      }
+
+      sp++;  i++;
+    }
+    if (!code)  code = LOCALE_DEFAULT;
+#  if 0	/* obsolete method */
+    setlocale(LC_ALL, localeList[code]);
+#  endif
+/*fprintf(stderr, "\n%s\n\n", localeList[code]);*/
+  }
+
+  return code;
+}
+#endif	/* TV_L10N */
+
+#ifdef TV_MULTILINGUAL
+static void setCodingSpec(tv, cs)
+    TVINFO *tv;
+    struct coding_spec *cs;
+{
+  if (xvbcmp((char *) &tv->ccs, (char *) cs, sizeof *cs) == 0)
+    return;
+  
+  tv->ccs = *cs;
+#if 0
+  ml_set_charsets(tv->ctx, &tv->ccs.coding_system);
+  if (tv->cv_text != NULL) {
+      free(tv->cv_text);
+      tv->cv_text = NULL;
+  }
+  if (tv->ccs.converter == NULL) {
+      tv->txt = ml_draw_text(tv->ctx, tv->text, tv->textlen);
+  } else {
+      tv->cv_text = (*tv->ccs.converter)(tv->text, tv->textlen, &tv->cv_len);
+      tv->txt = ml_draw_text(tv->ctx, tv->cv_text, tv->cv_len);
+  }
+#else
+  computeText(tv);
+  computeScrlVals(tv);
+#endif
+  /* drawTextW(0, &tv->vscrl); */
+}
+#endif
+
+
 /**********************************************************************/
 /* BUILT-IN TEXT FILES ************************************************/
 /**********************************************************************/
@@ -1560,7 +2134,517 @@
   OpenTextView(keyhelp, (int) strlen(keyhelp), "XV Help", 0);
 }
 
+#ifdef TV_MULTILINGUAL
+
+#define TV_ML_ACCEPT TV_NCSS
+#define TV_ML_CLOSE  (TV_ML_ACCEPT + 1)
+#define TV_ML_NBUTTS (TV_ML_CLOSE + 1)
+
+#define TV_ML_RETCODE	0
+#	define TV_ML_RET_LF	0
+#	define TV_ML_RET_CRLF	1
+#	define TV_ML_RET_CR	2
+#	define TV_ML_RET_ANY	3
+#define TV_ML_GL	1
+#define TV_ML_GR	2
+#define TV_ML_CVTR	3
+#define TV_ML_NRBUTTS	4
+
+#define TV_ML_SHORT	0
+#define TV_ML_LOCK	1
+#define TV_ML_NCBUTTS	2
+
+#define TV_ML_NLISTS	4
+
+#define CSWIDE (BUTTW3 * 5 + 5 * 6)
+#define CSHIGH 450
+
+typedef struct csinfo_t {
+    TVINFO *tv;
+    RBUTT *rbt[TV_ML_NRBUTTS];
+    CBUTT cbt[TV_ML_NCBUTTS];
+    LIST ls[TV_ML_NLISTS];
+    BUTT bt[TV_ML_NBUTTS];
+    int up;
+    Window win;
+    struct coding_spec tcs;	/* temporary coding_spec */
+} CSINFO;
+CSINFO csinfo[MAXTVWIN];
+static char **regs;
+static int nregs;
+
+static int  csCheckEvent           PARM((CSINFO *, XEvent *));
+static void csReflect              PARM((CSINFO *));
+static void csRedraw               PARM((CSINFO *));
+static void csListRedraw           PARM((LIST *));
+static void csLsRedraw             PARM((int, SCRL *));
+static void create_registry_list   PARM((void));
+
+static char *(*cvtrtab[])PARM((char *, int, int *)) = {
+    NULL,
+    sjis_to_jis,
+};
+
+static void createCsWins(geom)
+    char *geom;
+{
+    XSetWindowAttributes xswa;
+    char **t;
+    int i, j;
+    
+    create_registry_list();
+    
+    xswa.backing_store = WhenMapped;
+    for (i = 0; i < MAXTVWIN; i++) {
+	char nam[8];
+	TVINFO *tv = &tinfo[i];
+	CSINFO *cs = &csinfo[i];
+	tv->cs = cs;
+	cs->tv = tv;
+	sprintf(nam, "XVcs%d", i);
+	cs->win = CreateWindow("xv codeset", nam, geom,
+			       CSWIDE, CSHIGH, infofg, infobg, 0);
+	if (!cs->win) FatalError("couldn't create 'charset' window!");
+#ifdef BACKING_STORE
+	XChangeWindowAttributes(theDisp, cs->win, CWBackingStore, &xswa);
+#endif
+	XSelectInput(theDisp, cs->win, ExposureMask | ButtonPressMask);
+	
+	DrawString(cs->win, 5, 5 + ASCENT, "Initial States");
+	for (i = 0; i < TV_ML_NLISTS; i++) {
+	    int x, y;
+	    char buf[80];
+	    
+	    if (i / 2 == 0)
+		x = 15;
+	    else
+		x = 280;
+	    if (i % 2 == 0)
+		y = 5 + LINEHIGH * 1;
+	    else
+		y = 5 + LINEHIGH * 7 + SPACING * 3;
+	    
+	    sprintf(buf, "Designation for G%d:", i + 1);
+	    DrawString(cs->win, x, y + ASCENT, buf);
+	    
+	    LSCreate(&cs->ls[i], cs->win, x + 15, y + LINEHIGH,
+			200, LINEHIGH * 5, 5,
+			regs, nregs + 2,
+			infofg, infobg, hicol, locol, csLsRedraw, 0, 0);
+	    cs->ls[i].selected = 0;
+	}
+	
+	for (i = 0; i < 2; i++) {
+	    char *p;
+	    int n;
+	    int x, y;
+	    int j;
+	    
+	    if ((p = (char *) malloc(3 * 4)) == NULL)
+		FatalError("out of memory in createCsWins().");
+	    strcpy(p, "G1 G2 G3 G4");
+	    p[2] = p[5] = p[8] = '\0';
+	    n = (i == 0 ? TV_ML_GL : TV_ML_GR);
+	    x = (i == 0 ? 15 : 280);
+	    y = 235;
+	    DrawString(cs->win, x, y + ASCENT, "Assignment for GL:");
+	    x += 15;
+	    y += LINEHIGH;
+	    cs->rbt[n] = RBCreate(NULL, cs->win,
+				  x, y, p, infofg, infobg, hicol, locol);
+	    for (j = 1; j < 4; j++) {
+		p += 3;
+		x += 50;
+		RBCreate(cs->rbt[n], cs->win,
+			 x, y, p, infofg, infobg, hicol, locol);
+	    }
+	}
+	
+	DrawString(cs->win, 5, 280 + ASCENT, "Ret Code:");
+	cs->rbt[TV_ML_RETCODE] =
+	    RBCreate(NULL, cs->win, 20, 300, "LF", infofg,infobg, hicol,locol);
+	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 20, 300 + 20, "CR+LF",
+		 infofg, infobg, hicol, locol);
+	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 90, 300, "CR",
+		 infofg, infobg, hicol, locol);
+	RBCreate(cs->rbt[TV_ML_RETCODE], cs->win, 90, 300 + 20, "Any",
+		 infofg, infobg, hicol, locol);
+	
+	DrawString(cs->win, 350, 280 + ASCENT, "Converter:");
+	cs->rbt[TV_ML_CVTR] =
+	    RBCreate(NULL, cs->win, 365, 300, "Nothing",
+		     infofg, infobg, hicol, locol);
+	RBCreate(cs->rbt[TV_ML_CVTR], cs->win, 365, 300 + 20, "Shift JIS",
+		 infofg, infobg, hicol, locol);
+
+	CBCreate(&cs->cbt[TV_ML_SHORT], cs->win, 200, 300, "Short Form",
+		 infofg, infobg, hicol, locol);
+	CBCreate(&cs->cbt[TV_ML_LOCK], cs->win, 200, 320, "Locking Shift",
+		 infofg, infobg, hicol, locol);
+	
+	for (j = 0; j < TV_NCSS; j++) {
+	    BTCreate(&cs->bt[j], cs->win,
+		     5 + (BUTTW3 + 5) * (j % 5),
+		     350 + 5 + (BUTTH + 5) * (j / 5),
+		     BUTTW3, BUTTH, codeSetNames[j],
+		     infofg, infobg, hicol, locol);
+	}
+	BTCreate(&cs->bt[TV_ML_ACCEPT], cs->win,
+		 CSWIDE - 10 - BUTTW3 * 2, CSHIGH - 5 - BUTTH, BUTTW3, BUTTH,
+		 "Accept", infofg, infobg, hicol, locol);
+	BTCreate(&cs->bt[TV_ML_CLOSE], cs->win,
+		 CSWIDE - 5 - BUTTW3, CSHIGH - 5 - BUTTH, BUTTW3, BUTTH,
+		 "Close", infofg, infobg, hicol, locol);
+	
+	XMapSubwindows(theDisp, cs->win);
+	cs->up = 0;
+    }
+}
+
+static void openCsWin(tv)
+    TVINFO *tv;
+{
+    CSINFO *cs = tv->cs;
+    if (cs->up)
+	return;
+    
+    XMapRaised(theDisp, cs->win);
+    cs->up = 1;
+    cs->tcs = cs->tv->ccs;
+    csReflect(cs);
+}
+
+static void closeCsWin(tv)
+    TVINFO *tv;
+{
+    CSINFO *cs = tv->cs;
+    if (!cs->up)
+	return;
+    cs->up = 0;
+    XUnmapWindow(theDisp, cs->win);
+}
+
+int CharsetCheckEvent(xev)
+    XEvent *xev;
+{
+    int i;
+    CSINFO *cs;
+    
+    for (cs = csinfo, i = 0; i < MAXTVWIN; cs++, i++) {
+	if (!cs->up)
+	    continue;
+	if (csCheckEvent(cs, xev))
+	    break;
+    }
+    if (i < MAXTVWIN)
+	return 1;
+    return 0;
+}
+
+static int csCheckEvent(cs, xev)
+    CSINFO *cs;
+    XEvent *xev;
+{
+    TVINFO *tv = cs->tv;
+    RBUTT **rbp;
+    CBUTT *cbp;
+    LIST *ls;
+    BUTT *bp;
+    int i, j;
+    int n;
+    
+    if (xev->type == Expose) {
+	int x, y, w, h;
+	XExposeEvent *e = (XExposeEvent *) xev;
+	x = e->x; y = e->y; w = e->width; h = e->height;
+	
+	if (cs->win == e->window){
+	    csRedraw(cs);
+	    return 1;
+	} else {
+	    for (i = 0; i < TV_ML_NLISTS; i++) {
+		if (cs->ls[i].win == e->window) {
+		    LSRedraw(&cs->ls[i], 0);
+		    return 1;
+		}
+	    }
+	   for (i = 0; i < TV_ML_NLISTS; i++) {
+		if (cs->ls[i].scrl.win == e->window) {
+		    SCRedraw(&cs->ls[i].scrl);
+		    return 1;
+		}
+	   }
+	}
+    } else if (xev->type == ButtonPress) {
+	int x, y;
+	XButtonEvent *e = (XButtonEvent *) xev;
+	x = e->x; y = e->y;
+	if (cs->win == e->window) {
+	    for (bp = cs->bt, i = 0; i < TV_ML_NBUTTS; bp++, i++) {
+		if (PTINRECT(x, y, bp->x, bp->y, bp->w, bp->h))
+		    break;
+	    }
+	    if (i < TV_ML_NBUTTS) {
+		if (BTTrack(bp)) {
+		    if (i < TV_NCSS) {
+			cs->tcs = coding_spec[i];
+			csReflect(cs);
+		    } else {
+			switch (i) {
+			case TV_ML_ACCEPT:
+			    setCodingSpec(cs->tv, &cs->tcs);
+			    break;
+			case TV_ML_CLOSE:
+			    closeCsWin(cs->tv);
+			    break;
+			}
+		    }
+		}
+		return 1;
+	    }
+	    for (cbp = cs->cbt, i = 0; i < TV_ML_NCBUTTS; cbp++, i++) {
+		if (CBClick(cbp, x, y) && CBTrack(cbp))
+		    break;
+	    }
+	    if (i < TV_ML_NCBUTTS) {
+		switch (i) {
+		case TV_ML_SHORT:
+		    cs->tcs.coding_system.short_form = cbp->val;
+		    break;
+		case TV_ML_LOCK:
+		    cs->tcs.coding_system.lock_shift = cbp->val;
+		    break;
+		}
+		return 1;
+	    }
+	    for (rbp = cs->rbt, i = 0; i < TV_ML_NRBUTTS; rbp++, i++) {
+		if ((n = RBClick(*rbp, x, y)) >= 0 && RBTrack(*rbp, n)) {
+		    break;
+		}
+	    }
+	    if (i < TV_ML_NRBUTTS) {
+		switch (i) {
+		case TV_ML_RETCODE:
+		    cs->tcs.coding_system.eol = n;
+		    break;
+		case TV_ML_GL:
+		    cs->tcs.coding_system.gl = n;
+		    break;
+		case TV_ML_GR:
+		    cs->tcs.coding_system.gr = n;
+		    break;
+		case TV_ML_CVTR:
+		    cs->tcs.converter = cvtrtab[n];
+		    break;
+		}
+		return 1;
+	    }
+	} else {
+	    for (ls = cs->ls, i = 0; i < TV_ML_NLISTS; ls++, i++) {
+		if (ls->win == e->window) {
+		    LSClick(ls, e);
+		    n = ls->selected;
+		    if (n < nregs) {
+			char r[32], *p = r;
+			int b7;
+			strcpy(r, regs[n]);
+			if ((p = strrchr(r, '/')) != NULL) {
+			    *p = '\0';
+			    b7 = (*(p + 1) == 'R' ? 1 : 0);
+			} else
+			    b7 = 0;	/* shouldn't occur */
+			cs->tcs.coding_system.design[i] = lookup_design(r, b7);
+		    } else if (n == nregs)    /* initially none is designed. */
+			cs->tcs.coding_system.design[i].bpc = 0;
+		    else
+			cs->tcs.coding_system.design[i].bpc = -1;
+		    return 1;
+		}
+	    }
+	    for (ls = cs->ls, i = 0; i < TV_ML_NLISTS; ls++, i++) {
+		if (ls->scrl.win == e->window) {
+		    SCTrack(&ls->scrl, x, y);
+		    return 1;
+		}
+	    }
+	}
+    }
+    return 0;
+}
+
+static void csReflect(cs)
+    CSINFO *cs;
+{
+    int i;
+    
+    RBSelect(cs->rbt[TV_ML_RETCODE], cs->tcs.coding_system.eol);
+    RBSelect(cs->rbt[TV_ML_GL], cs->tcs.coding_system.gl);
+    RBSelect(cs->rbt[TV_ML_GR], cs->tcs.coding_system.gr);
+    for (i = 0; i < sizeof cvtrtab / sizeof cvtrtab[0]; i++) {
+	if (cs->tcs.converter == cvtrtab[i])
+	    break;
+    }
+    if (i >= sizeof cvtrtab / sizeof cvtrtab[0])
+	FatalError("program error in csReflect().");
+    RBSelect(cs->rbt[TV_ML_CVTR], i);
+    
+    cs->cbt[TV_ML_SHORT].val = cs->tcs.coding_system.short_form;
+    cs->cbt[TV_ML_LOCK].val = cs->tcs.coding_system.lock_shift;
+    for (i = 0; i < TV_ML_NLISTS; i++) {
+	struct design design = cs->tcs.coding_system.design[i];
+	char *reg, r[32];
+	int b7;
+	int n = 0;
+	switch (design.bpc) {
+	case -1:
+	    n = nregs + 1;
+	    break;
+	case 0:
+	    n = nregs;
+	    break;
+	case 1:
+	case 2:
+	    if ((reg = lookup_registry(design, &b7)) == NULL)
+		FatalError("internal error in csReflect.");
+	    sprintf(r, "%s/%s", reg, b7 ? "Right" : "Left");
+	    for (n = 0; n < nregs; n++) {
+		if (strcmp(regs[n], r) == 0)
+		    break;
+	    }
+	}
+	cs->ls[i].selected = n;
+	ScrollToCurrent(&cs->ls[i]);
+    }
+    csRedraw(cs);
+    for (i = 0; i < TV_ML_NLISTS; i++)
+	csListRedraw(&cs->ls[i]);
+}
 
+static void csRedraw(cs)
+    CSINFO *cs;
+{
+    int i;
+    
+    XSetForeground(theDisp, theGC, infofg);
+    DrawString(cs->win,  5,5 + ASCENT, "Initial States");
+    for (i = 0; i < TV_ML_NLISTS; i++) {
+	int x, y;
+	char buf[80];
+	
+	if (i / 2 == 0)
+	    x = 15;
+	else
+	    x = 280;
+	if (i % 2 == 0)
+	    y = 5 + LINEHIGH * 1;
+	else
+	    y = 5 + LINEHIGH * 7 + SPACING * 3;
+	
+	sprintf(buf, "Designation for G%d:", i);
+	DrawString(cs->win, x, y + ASCENT, buf);
+    }
+    
+    DrawString(cs->win,  15, 235 + ASCENT, "Invocation for GL:");
+    DrawString(cs->win, 280, 235 + ASCENT, "Invocation for GR:");
+    DrawString(cs->win,   5, 280 + ASCENT, "Ret Code:");
+    DrawString(cs->win, 350, 280 + ASCENT, "Converter:");
+    
+    for (i = 0; i < TV_ML_NBUTTS; i++)
+	BTRedraw(&cs->bt[i]);
+    for (i = 0; i < TV_ML_NCBUTTS; i++)
+	CBRedraw(&cs->cbt[i]);
+    for (i = 0; i < TV_ML_NRBUTTS; i++)
+	RBRedraw(cs->rbt[i], -1);
+}
+
+static void csListRedraw(ls)
+    LIST *ls;
+{
+    int i;
+    for (i = 0; i < TV_ML_NLISTS; i++) {
+	LSRedraw(ls, 0);
+	SCRedraw(&ls->scrl);
+    }
+}
+
+static void csLsRedraw(delta, sptr)
+    int delta;
+    SCRL *sptr;
+{
+    int i, j;
+    for (i = 0; i < MAXTVWIN; i++) {
+	for (j = 0; j < TV_ML_NLISTS; j++) {
+	    if (sptr == &csinfo[i].ls[j].scrl) {
+		LSRedraw(&csinfo[i].ls[j], delta);
+		return;
+	    }
+	}
+    }
+}
+
+int CharsetDelWin(win)
+    Window win;
+{
+    CSINFO *cs;
+    int i;
+
+    for (cs = csinfo, i = 0; i < TV_NCSS; cs++, i++) {
+	if (cs->win == win) {
+	    if (cs->up) {
+		XUnmapWindow(theDisp, cs->win);
+		cs->up = 0;
+	    }
+	    return 1;
+	}
+    }
+    return 0;
+}
+
+static int reg_comp PARM((const void *, const void *));
+static void create_registry_list()
+{
+    struct design d;
+    char *names, *p;
+    int i;
+    
+    if ((p = names = (char *) malloc(32 * 0x80 * 2 * 2)) == NULL)
+	FatalError("out of memory in create_name_list#1.");
+    nregs = 0;
+    for (d.bpc = 1; d.bpc <=2; d.bpc++) {
+	for (d.noc = 94; d.noc <= 96; d.noc += 2) {
+	    for (d.des = ' '; (unsigned char) d.des < 0x80; d.des++) {
+		int b7;
+		char *r;
+		if ((r = lookup_registry(d, &b7)) != NULL) {
+		    sprintf(p, "%s/%s", r, b7 ? "Right" : "Left");
+		    p += strlen(p) + 1;
+		    nregs++;
+		}
+	    }
+	}
+    }
+    if ((names = (char *) realloc(names, (size_t) (p - names))) == NULL)
+	FatalError("out of memory in create_name_list#2.");
+    if ((regs = (char **) malloc(sizeof(char *) * (nregs + 3))) == NULL)
+	FatalError("out of memory in create_name_list#3.");
+    p = names;
+    for (i = 0; i < nregs; i++) {
+	regs[i] = p;
+	p += strlen(p) + 1;
+    }
+    qsort(regs, (size_t) nregs, sizeof(char *), reg_comp);
+    regs[i++] = "nothing";
+    regs[i++] = "unused";
+    regs[i++] = NULL;
+}
+static int reg_comp(dst, src)
+    const void *dst, *src;
+{
+    return strcmp(*(char **) dst, *(char **) src);
+}
+
+
+#endif
 
 
 
diff -Naur xv-3.10a.old/xvtiff.c xv-3.10a/xvtiff.c
--- xv-3.10a.old/xvtiff.c	Sat Jan 14 04:53:34 1995
+++ xv-3.10a/xvtiff.c	Tue Apr 24 09:37:06 2001
@@ -1,7 +1,7 @@
 /*
  * xvtiff.c - load routine for 'TIFF' format pictures
  *
- * LoadTIFF(fname, numcols)  -  load a TIFF file
+ * LoadTIFF(fname, numcols, quick)  -  load a TIFF file
  */
 
 #ifndef va_start
@@ -15,6 +15,35 @@
 #include "tiffio.h"     /* has to be after xv.h, as it needs varargs/stdarg */
 
 
+/* Portions fall under the following copyright:
+ *
+ * Copyright (c) 1992, 1993, 1994 Sam Leffler
+ * Copyright (c) 1992, 1993, 1994 Silicon Graphics, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and 
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that (i) the above copyright notices and this permission notice appear in
+ * all copies of the software and related documentation, and (ii) the names of
+ * Sam Leffler and Silicon Graphics may not be used in any advertising or
+ * publicity relating to the software without the specific, prior written
+ * permission of Sam Leffler and Silicon Graphics.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+ * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+ * 
+ * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+ * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+ * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+ * OF THIS SOFTWARE.
+ */
+
+
+static int   copyTiff    PARM((TIFF *, char *));
+static int   cpStrips    PARM((TIFF *, TIFF *));
+static int   cpTiles     PARM((TIFF *, TIFF *));
 static byte *loadPalette PARM((TIFF *, uint32, uint32, int, int, PICINFO *));
 static byte *loadColor   PARM((TIFF *, uint32, uint32, int, int, PICINFO *));
 static int   loadImage   PARM((TIFF *, uint32, uint32, byte *, int));
@@ -28,19 +57,23 @@
 static int   error_occurred;
 
 /*******************************************/
-int LoadTIFF(fname, pinfo)
-     char *fname;
+int LoadTIFF(fname, pinfo, quick)
+     char    *fname;
      PICINFO *pinfo;
+     int      quick;
 /*******************************************/
 {
   /* returns '1' on success, '0' on failure */
 
   TIFF  *tif;
   uint32 w, h;
+  float  xres, yres;
   short	 bps, spp, photo, orient;
   FILE  *fp;
   byte  *pic8;
   char  *desc, oldpath[MAXPATHLEN+1], tmppath[MAXPATHLEN+1], *sp;
+  char   tmp[256], tmpname[256];
+  int    i, nump;
 
   error_occurred = 0;
 
@@ -60,6 +93,8 @@
   filesize = ftell(fp);
   fclose(fp);
 
+
+
   rmap = pinfo->r;  gmap = pinfo->g;  bmap = pinfo->b;
 
   /* a kludge:  temporarily cd to the directory that the file is in (if
@@ -81,9 +116,57 @@
     }
   }
       
+
+  nump = 1;
+
+  if (!quick) {
+    /* see if there's more than 1 image in tiff file, to determine if we 
+       should do multi-page thing... */
+    
+    tif = TIFFOpen(filename,"r");
+    if (!tif) return 0;
+    while (TIFFReadDirectory(tif)) nump++;
+    TIFFClose(tif);
+    if (DEBUG) 
+      fprintf(stderr,"LoadTIFF: %d page%s found\n", nump, nump==1 ? "" : "s");
+    
     
+    /* if there are multiple images, copy them out to multiple tmp files,
+       and load the first one... */
 
-  tif=TIFFOpen(filename,"r");
+    xv_mktemp(tmpname, "xvpgXXXXXX");
+
+    if (tmpname[0] == '\0') {   /* mktemp() blew up */
+      sprintf(str,"LoadTIFF: Unable to create temporary filename???");
+      ErrPopUp(str, "\nHow unlikely!");
+      return 0;
+    }
+    
+    if (nump>1) {
+      TIFF *in, *out;
+      
+      in = TIFFOpen(filename, "r");
+      if (!in) return 0;
+      for (i=1; i<=nump; i++) {
+	sprintf(tmp, "%s%d", tmpname, i);
+	if (!copyTiff(in, tmp)) {
+	  SetISTR(ISTR_WARNING, "LoadTIFF:  Error writing page files!");
+	  break;
+	}
+	
+	if (!TIFFReadDirectory(in)) break;
+      }
+      if (DEBUG)
+	fprintf(stderr,"LoadTIFF: %d page%s written\n", 
+		i-1, (i-1)==1 ? "" : "s");
+      
+      sprintf(tmp, "%s%d", tmpname, 1);           /* open page #1 */
+      filename = tmp;
+    }
+  }  /* if (!quick) ... */
+
+
+  tif = TIFFOpen(filename,"r");
   if (!tif) return 0;
 
   /* flip orientation so that image comes in X order */
@@ -107,6 +190,11 @@
   TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);
   TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);
   TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);
+  if ((TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) == 1) &&
+      (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) == 1)) {
+    normaspect = yres / xres;
+    if (DEBUG) fprintf(stderr,"TIFF aspect = %f\n", normaspect);
+  }
 
   if (spp == 1) {
       pic8 = loadPalette(tif, w, h, photo, bps, pinfo);
@@ -139,6 +227,8 @@
     if (pic8) free(pic8);
     if (pinfo->comment) free(pinfo->comment);
     pinfo->comment = (char *) NULL;
+    if (!quick && nump>1) KillPageFiles(tmpname, nump);
+    SetCursors(-1);
     return 0;
   }
 
@@ -148,17 +238,167 @@
   pinfo->normw = pinfo->w;   pinfo->normh = pinfo->h;
   pinfo->frmType = F_TIFF;
 
+  if (nump>1) strcpy(pinfo->pagebname, tmpname);
+  pinfo->numpages = nump;
 
   if (pinfo->pic) return 1;
 
+
   /* failed.  if we malloc'd a comment, free it */
   if (pinfo->comment) free(pinfo->comment);
   pinfo->comment = (char *) NULL;
 
+  if (!quick && nump>1) KillPageFiles(tmpname, nump);
+  SetCursors(-1);
+
   return 0;
 }  
 
 
+
+
+/*******************************************/
+
+#define CopyField(tag, v) \
+  if (TIFFGetField(in, tag, &v))            TIFFSetField(out, tag, v)
+#define CopyField2(tag, v1, v2) \
+  if (TIFFGetField(in, tag, &v1, &v2))      TIFFSetField(out, tag, v1, v2)
+#define CopyField3(tag, v1, v2, v3) \
+  if (TIFFGetField(in, tag, &v1, &v2, &v3)) TIFFSetField(out, tag, v1, v2, v3)
+
+
+/*******************************************/
+static int copyTiff(in, fname)
+     TIFF *in;
+     char *fname;
+{
+  /* copies tiff image to given filename.  Returns 0 on error */
+
+  TIFF   *out;
+  short   bitspersample, samplesperpixel, shortv, *shortav;
+  uint32  w, l;
+  float   floatv;
+  char   *stringv;
+  uint32  longv;
+  uint16 *red, *green, *blue, shortv2;
+  int     rv;
+  
+  out = TIFFOpen(fname, "w");
+  if (!out) return 0;
+  
+  CopyField (TIFFTAG_SUBFILETYPE,     longv);
+  CopyField (TIFFTAG_TILEWIDTH,       w);
+  CopyField (TIFFTAG_TILELENGTH,      l);
+  CopyField (TIFFTAG_IMAGEWIDTH,      w);
+  CopyField (TIFFTAG_IMAGELENGTH,     l);
+  CopyField (TIFFTAG_BITSPERSAMPLE,   bitspersample);
+  CopyField (TIFFTAG_COMPRESSION,     shortv);
+  CopyField (TIFFTAG_PREDICTOR,       shortv);
+  CopyField (TIFFTAG_PHOTOMETRIC,     shortv);
+  CopyField (TIFFTAG_THRESHHOLDING,   shortv);
+  CopyField (TIFFTAG_FILLORDER,       shortv);
+  CopyField (TIFFTAG_ORIENTATION,     shortv);
+  CopyField (TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
+  CopyField (TIFFTAG_MINSAMPLEVALUE,  shortv);
+  CopyField (TIFFTAG_MAXSAMPLEVALUE,  shortv);
+  CopyField (TIFFTAG_XRESOLUTION,     floatv);
+  CopyField (TIFFTAG_YRESOLUTION,     floatv);
+  CopyField (TIFFTAG_GROUP3OPTIONS,   longv);
+  CopyField (TIFFTAG_GROUP4OPTIONS,   longv);
+  CopyField (TIFFTAG_RESOLUTIONUNIT,  shortv);
+  CopyField (TIFFTAG_PLANARCONFIG,    shortv);
+  CopyField (TIFFTAG_ROWSPERSTRIP,    longv);
+  CopyField (TIFFTAG_XPOSITION,       floatv);
+  CopyField (TIFFTAG_YPOSITION,       floatv);
+  CopyField (TIFFTAG_IMAGEDEPTH,      longv);
+  CopyField (TIFFTAG_TILEDEPTH,       longv);
+  CopyField2(TIFFTAG_EXTRASAMPLES,    shortv, shortav);
+  CopyField3(TIFFTAG_COLORMAP,        red, green, blue);
+  CopyField2(TIFFTAG_PAGENUMBER,      shortv, shortv2);
+  CopyField (TIFFTAG_ARTIST,          stringv);
+  CopyField (TIFFTAG_IMAGEDESCRIPTION,stringv);
+  CopyField (TIFFTAG_MAKE,            stringv);
+  CopyField (TIFFTAG_MODEL,           stringv);
+  CopyField (TIFFTAG_SOFTWARE,        stringv);
+  CopyField (TIFFTAG_DATETIME,        stringv);
+  CopyField (TIFFTAG_HOSTCOMPUTER,    stringv);
+  CopyField (TIFFTAG_PAGENAME,        stringv);
+  CopyField (TIFFTAG_DOCUMENTNAME,    stringv);
+
+  if (TIFFIsTiled(in)) rv = cpTiles (in, out);
+                  else rv = cpStrips(in, out);
+
+  TIFFClose(out);
+  return rv;
+}
+
+
+/*******************************************/
+static int cpStrips(in, out)
+     TIFF *in, *out;
+{
+  tsize_t bufsize;
+  byte *buf;
+
+  bufsize = TIFFStripSize(in);  
+  buf = (byte *) malloc((size_t) bufsize);
+  if (buf) {
+    tstrip_t s, ns = TIFFNumberOfStrips(in);
+    uint32 *bytecounts;
+    
+    TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);
+    for (s = 0; s < ns; s++) {
+      if (bytecounts[s] > bufsize) {
+	buf = (unsigned char *) realloc(buf, (size_t) bytecounts[s]);
+	if (!buf) return (0);
+	bufsize = bytecounts[s];
+      }
+      if (TIFFReadRawStrip (in,  s, buf, (tsize_t) bytecounts[s]) < 0 ||
+	  TIFFWriteRawStrip(out, s, buf, (tsize_t) bytecounts[s]) < 0) {
+	free(buf);
+	return 0;
+      }
+    }
+    free(buf);
+    return 1;
+  }
+  return 0;
+}
+
+
+/*******************************/
+static int cpTiles(in, out)
+     TIFF *in, *out;
+{
+  tsize_t bufsize;
+  byte   *buf;
+
+  bufsize = TIFFTileSize(in);  
+  buf = (unsigned char *) malloc((size_t) bufsize);
+  if (buf) {
+    ttile_t t, nt = TIFFNumberOfTiles(in);
+    uint32 *bytecounts;
+    
+    TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
+    for (t = 0; t < nt; t++) {
+      if (bytecounts[t] > bufsize) {
+	buf = (unsigned char *)realloc(buf, (size_t) bytecounts[t]);
+	if (!buf) return (0);
+	bufsize = bytecounts[t];
+      }
+      if (TIFFReadRawTile (in,  t, buf, (tsize_t) bytecounts[t]) < 0 ||
+	  TIFFWriteRawTile(out, t, buf, (tsize_t) bytecounts[t]) < 0) {
+	free(buf);
+	return 0;
+      }
+    }
+    free(buf);
+    return 1;
+  }
+  return 0;
+}
+
+
 /*******************************************/
 static byte *loadPalette(tif, w, h, photo, bps, pinfo)
      TIFF *tif;
@@ -186,7 +426,7 @@
     break;
   }
 
-  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",w,h);
+  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",(u_int) w, (u_int) h);
 
   pic8 = (byte *) malloc((size_t) w*h);
   if (!pic8) FatalError("loadPalette() - couldn't malloc 'pic8'");
@@ -214,7 +454,7 @@
 	   "???"),
 	  filesize);
 
-  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",w,h);
+  sprintf(pinfo->shrtInfo, "%ux%u TIFF.",(u_int) w, (u_int) h);
 
   /* allocate 24-bit image */
   pic24 = (byte *) malloc((size_t) w*h*3);
@@ -301,6 +541,10 @@
 static	byte **BWmap;
 static	byte **PALmap;
 
+/* XXXX Work around some collisions with the new library. */
+#define tileContigRoutine _tileContigRoutine
+#define tileSeparateRoutine _tileSeparateRoutine
+
 typedef void (*tileContigRoutine)   PARM((byte*, u_char*, RGBvalue*, 
 					  uint32, uint32, int, int));
 
@@ -340,7 +584,7 @@
 					     uint32, uint32, int, int));
 static void   put4bitbwtile            PARM((byte *, u_char *, RGBvalue *,
 					     uint32, uint32, int, int));
-static void   put16bitbwtile           PARM((byte *, u_char *, RGBvalue *,
+static void   put16bitbwtile           PARM((byte *, u_short *, RGBvalue *,
 					     uint32, uint32, int, int));
 
 static void   putRGBcontig8bittile     PARM((byte *, u_char *, RGBvalue *,
@@ -1014,7 +1258,7 @@
 #define	CASE4(x,op)	switch (x) { case 3: op; case 2: op; case 1: op; }
 
 #define	UNROLL8(w, op1, op2) {		\
-	uint32 x;		        \
+	uint32 x;	                \
 	for (x = w; x >= 8; x -= 8) {	\
 		op1;			\
 		REPEAT8(op2);		\
@@ -1026,7 +1270,7 @@
 }
 
 #define	UNROLL4(w, op1, op2) {		\
-	register uint32 x;		\
+	uint32 x;		        \
 	for (x = w; x >= 4; x -= 4) {	\
 		op1;			\
 		REPEAT4(op2);		\
@@ -1038,7 +1282,7 @@
 }
 
 #define	UNROLL2(w, op1, op2) {		\
-	register uint32 x;		\
+	uint32 x;		        \
 	for (x = w; x >= 2; x -= 2) {	\
 		op1;			\
 		REPEAT2(op2);		\
@@ -1218,7 +1462,7 @@
  */
 static void put16bitbwtile(cp, pp, Map, w, h, fromskew, toskew)
      byte  *cp;
-     u_char *pp;
+     u_short *pp;
      RGBvalue *Map;
      uint32 w, h;
      int fromskew, toskew;
@@ -1227,8 +1471,7 @@
   
   while (h-- > 0) {
     for (x=w; x>0; x--) {
-      *cp++ = Map[(pp[0] << 8) + pp[1]];
-      pp += 2;
+      *cp++ = Map[*pp++];
     }
     cp += toskew;
     pp += fromskew;
@@ -1381,7 +1624,7 @@
   }
 }
 
-#define Code2V(c, RB, RW, CR)  ((((c)-(int)RB)*(float)CR)/(float)(RW-RB))
+#define Code2V(c, RB, RW, CR)  ((((int)(c)-(int)RB)*(float)CR)/(float)(RW-RB))
 
 #define	CLAMP(f,min,max) \
     (int)((f)+.5 < (min) ? (min) : (f)+.5 > (max) ? (max) : (f)+.5)
@@ -1514,7 +1757,7 @@
   case PHOTOMETRIC_MINISWHITE:
   case PHOTOMETRIC_MINISBLACK:
     switch (bitspersample) {
-    case 16: put = put16bitbwtile; break;
+    case 16: put = (tileContigRoutine) put16bitbwtile; break;
     case 8:  put = putgreytile;    break;
     case 4:  put = put4bitbwtile;  break;
     case 2:  put = put2bitbwtile;  break;
diff -Naur xv-3.10a.old/xvtiffwr.c xv-3.10a/xvtiffwr.c
--- xv-3.10a.old/xvtiffwr.c	Wed Jan  4 06:28:13 1995
+++ xv-3.10a/xvtiffwr.c	Tue Apr 24 09:37:06 2001
@@ -84,8 +84,8 @@
   TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, h);
 
   TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, (int)2);
-  TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)1200.0);
-  TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)1200.0);
+  TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float) 72.0);
+  TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float) 72.0);
 
 
   /* write the image data */
diff -Naur xv-3.10a.old/xvvd.c xv-3.10a/xvvd.c
--- xv-3.10a.old/xvvd.c	Thu Jan  1 09:00:00 1970
+++ xv-3.10a/xvvd.c	Tue Apr 24 09:37:06 2001
@@ -0,0 +1,1093 @@
+
+/*
+ * xvvd.c - extract archived file automatically and regard it as a
+ *          directory.
+ */
+
+#define NEEDSDIR
+
+#include "xv.h"
+
+#ifdef AUTO_EXPAND
+
+static void  vd_Dirtovd    		PARM((char *));
+static void  vd_Vdtodir    		PARM((char *));
+static int   vd_Mkvdir    		PARM((char *));
+static int   vd_Rmvdir     		PARM((char *));
+static int   vd_Movevdir  		PARM((char *, char *));
+static void  vd_addvdtable		PARM((char *));
+static void  vd_packvdtable		PARM((void));
+static int   vd_recursive_mkdir		PARM((char *));
+static int   vd_recursive_rmdir		PARM((char *));
+static void  vd_optimize_path		PARM((char *));
+static int   vd_ftype			PARM((char *));
+static int   vd_compp			PARM((char *, char *));
+static int   vd_UncompressFile		PARM((char *, char *, int));
+static int   vd_tarc			PARM((char *));
+static u_int vd_tar_sumchk		PARM((char *));
+
+#define VD_VDTABLESIZE	100
+
+#define VD_ERR -2
+#define VD_UKN -1
+
+static char *ext_command[] = {
+/* KEEP 0 */
+    NULL,
+#define VD_ARC 1
+    "arc xo %s",
+#define VD_ARJ 2
+    "unarj x %s",
+#define VD_LZH 3
+    "lha -xf %s",
+#define VD_TAR 4
+    "tar xvf %s",
+#define VD_ZIP 5
+    "unzip -xo %s",
+#define VD_ZOO 6
+    "zoo xOS %s",
+};
+int vdcount = 0;
+
+static char vdroot[MAXPATHLEN+1];
+static char *vdtable[VD_VDTABLESIZE];
+
+/*
+ * These functions initialize and settle virtual directory system.
+ * Vdinit:
+ *	creates root of virtual directory.
+ * Vdsettle:
+ *	sweeps virtual directories.
+ */
+void Vdinit()
+{
+#ifndef VMS
+    char tmp[MAXPATHLEN+1];
+
+    xv_getwd(tmp, MAXPATHLEN+1);
+    if (chdir(tmpdir)) {
+	fprintf(stderr, "Warning: cannot chdir to tmpdir = '%s'.\n", tmpdir);
+	fprintf(stderr,
+		"         I use current directory '%s' instead of tmpdir.\n",
+		tmp);
+    }
+    xv_getwd(vdroot, MAXPATHLEN+1);
+    strcat(vdroot, "/.xvvdXXXXXX");
+    chdir(tmp);
+#else
+    sprintf(vdroot, "Sys$Scratch:xvvdXXXXXX");
+#endif /* VMS */
+    mktemp(vdroot);
+}
+
+void Vdsettle()
+{
+    int i;
+
+    for (i = 0; i < vdcount; i++)
+	free(vdtable[i]);
+
+    vdcount = 0;
+
+    vd_recursive_rmdir(vdroot);
+}
+
+/*
+ * This function chdir to virtual directory, if specified path is in
+ * virtual directlry.
+ */
+int Chvdir(dir)
+char *dir;
+{
+    char buf[MAXPATHLEN+1];
+
+    if (Mkvdir(dir) == VD_ERR)
+	return -1;
+
+    strcpy(buf, dir);
+    Dirtovd(buf);
+
+    return (chdir(buf));
+}
+
+/*
+ * These functions convert directory <-> virtual directory.
+ * Dirtovd:
+ *	front interface of vd_Dirtovd.
+ * vd_Dirtovd:
+ *	converts directory to virtual directry.
+ * Vdtodir:
+ *	front interface of vd_Vdtodir.
+ * vd_Vdtodir:
+ *	converts virtual directry to normal directory.
+ * Dirtosubst:
+ *	converts directry to substance of archive.
+ */
+void Dirtovd(dir)
+char *dir;
+{
+    int i;
+
+    vd_optimize_path(dir);
+
+    vd_Dirtovd(dir);
+}
+
+static void vd_Dirtovd(dir)
+char *dir;
+{
+    int i;
+
+    for (i = 0; i < vdcount; i++)
+	if (!strncmp(dir, vdtable[i], strlen(vdtable[i]))) {
+	    char tmp[MAXPATHLEN+1];
+
+	    sprintf(tmp, "%s%s", vdroot, dir);
+	    strcpy(dir, tmp);
+	    Dirtovd(dir);
+	}
+}
+
+void Vdtodir(dir)
+char *dir;
+{
+    int i;
+
+    vd_optimize_path(dir);
+
+    vd_Vdtodir(dir);
+}
+
+static void vd_Vdtodir(vd)
+char *vd;
+{
+    int i;
+    char tmp[MAXPATHLEN+1];
+
+    for (i = vdcount-1; i >= 0; i--) {
+	sprintf(tmp, "%s%s", vdroot, vdtable[i]);
+	if(!strncmp(vd, tmp, strlen(tmp))) {
+	    strcpy(tmp, vd+strlen(vdroot));
+	    strcpy(vd, tmp);
+	    Vdtodir(vd);
+	}
+    }
+} 
+
+void Dirtosubst(dir)
+char *dir;
+{
+    char tmp[MAXPATHLEN+1];
+
+    Dirtovd(dir);
+
+    strcpy(tmp, dir+strlen(vdroot));
+
+    if (Isarchive(tmp))
+	strcpy(dir, tmp);
+}
+    
+/*
+ * These functions make virtual directory and extracts archive, if
+ * specified path is archive.
+ * Mkvdir:
+ *	front interface of vd_Mkvdir.
+ * vd_Mkvdir:
+ *	does real work.
+ * Mkvdir_force: (used by makeThumbDir(in xvbrowse.c) only)
+ *	make virtual directory by force.
+ */
+int Mkvdir(dir)
+char *dir;
+{
+    char dir1[MAXPATHLEN+1], dir2[MAXPATHLEN+1];
+    char *d1, *d2;
+    int rv;
+
+#if defined(SYSV) || defined(SVR4)
+    sighold(SIGHUP);
+    sighold(SIGCHLD);
+#else
+    int mask;
+    mask = sigblock(sigmask(SIGHUP)|sigmask(SIGCHLD));
+#endif
+
+    strcpy(dir1, dir);
+    vd_optimize_path(dir1);
+
+    if ((rv = vd_Mkvdir(dir1)) != VD_ERR)
+	goto MKVDIR_END;
+
+    strcpy(dir2, dir1);
+    d2 = dir2 + strlen(dir2);
+    while (rv == VD_ERR) {
+	d2--;
+	while (*d2 != '/')
+	    d2--;
+	*d2 = '\0';
+	rv = vd_Mkvdir(dir2);
+    }
+    d1 = dir1 + strlen(dir2);
+    while ((rv != VD_ERR) && (*d1 != '\0')) {
+	*d2++ = *d1++;
+	while ((*d1 != '/') && (*d1 != '\0'))
+	    *d2++ = *d1++;
+	*d2 = '\0';
+	rv = vd_Mkvdir(dir2);
+    }
+
+MKVDIR_END:
+#if defined(SYSV) || defined(SVR4)
+    sigrelse(SIGHUP);
+    sigrelse(SIGCHLD);
+#else
+    sigsetmask(mask);
+#endif
+
+    return rv;
+}
+
+static int vd_Mkvdir(dir)
+char *dir;
+{
+    char dir1[MAXPATHLEN+1], dir2[MAXPATHLEN+1], tmp[MAXPATHLEN+1];
+    int ftype, i;
+    struct stat st;
+    FILE *pfp;
+
+    strcpy(dir1, dir);
+    Dirtovd(dir1);
+    strcpy(dir2, dir1);
+
+    WaitCursor();
+
+    if ((ftype = vd_ftype(dir1)) < 0) {
+	SetCursors(-1);
+	return ftype;
+    }
+    if (ftype == RFT_COMPRESS) {
+	if (!(ftype = vd_compp(dir1, tmp))) {
+	    SetCursors(-1);
+	    return ftype;
+	}
+	strcpy(dir1, tmp);
+    }
+    if (ftype == RFT_BZIP2) {
+	if (!(ftype = vd_compp(dir1, tmp))) {
+	    SetCursors(-1);
+	    return ftype;
+	}
+	strcpy(dir1, tmp);
+    }
+
+    if (!stat(dir1, &st)) {
+	for(i = 0; i < vdcount; i++)
+	    if (!strcmp(vdtable[i], dir2)) {
+		SetCursors(-1);
+		return 0;
+	    }
+
+	if (!S_ISDIR(st.st_mode)) {
+	    char origdir[MAXPATHLEN+1], buf[MAXPATHLEN+10], buf1[100];
+
+	    if (vdcount >= VD_VDTABLESIZE) {
+		ErrPopUp("Sory, you can't make virtual directory any more.",
+			 "\nBummer!");
+		goto VD_MKVDIR_ERR;
+	    }
+
+	    WaitCursor();
+
+	    xv_getwd(origdir, MAXPATHLEN+1);
+
+	    sprintf(tmp, "%s%s", vdroot, dir2);
+	    if (vd_recursive_mkdir(tmp) || chdir(tmp)) {
+		SetISTR(ISTR_INFO, "fail to make virtual directory.");
+		Warning();
+		goto VD_MKVDIR_ERR;
+	    }
+	    sprintf(buf, ext_command[ftype], dir1);
+
+	    WaitCursor();
+
+	    if((pfp = popen(buf, "r")) == NULL) {
+		SetISTR(ISTR_INFO, "fail to extract archive '%s'.",
+			BaseName(dir2));
+		Warning();
+		goto VD_MKVDIR_ERR;
+	    }
+	    while (1) {
+		if (fread(buf1, 1, sizeof(buf1), pfp) < sizeof(buf1))
+		    break;
+		WaitCursor();
+	    }
+	    if (!feof(pfp)) {
+		SetISTR(ISTR_INFO, "Pipe was broken.");
+		Warning();
+		pclose(pfp);
+		goto VD_MKVDIR_ERR;
+	    }
+	    pclose(pfp);
+
+	    if (strcmp(dir1, dir2))
+		unlink(dir1);
+
+	    vd_addvdtable(dir2);
+	    Dirtovd(origdir);
+	    chdir(origdir);
+	    SetCursors(-1);
+	    return 0;
+
+VD_MKVDIR_ERR:
+	    if (strcmp(dir1, dir2))
+		unlink(dir1);
+	    SetCursors(-1);
+	    return VD_ERR;
+	}
+    }
+    SetCursors(-1);
+    return VD_ERR;
+}
+
+#ifdef VIRTUAL_TD
+void Mkvdir_force(dir)
+char *dir;
+{
+    char tmp[MAXPATHLEN+1];
+
+    if (vdcount >= VD_VDTABLESIZE) {
+      ErrPopUp("Sory, you can't make virtual directory any more.",
+	       "\nBummer!");
+      return;
+    }
+
+    sprintf(tmp, "%s%s", vdroot, dir);
+    if (vd_recursive_mkdir(tmp)) {
+      SetISTR(ISTR_INFO, "fail to make virtual directory.");
+      Warning();
+      return;
+    }
+
+    vd_addvdtable(dir);
+}
+#endif /* VIRTUAL_TD */
+
+/*
+ * These functions remove virtual directory, if exists.
+ * Rmvdir:
+ *	front interface of vd_Rmvdir.
+ * vd_Rmvdir:
+ *	remove virtual directory function.
+ */
+int Rmvdir(dir)
+char *dir;
+{
+    int rv;
+    char buf[MAXPATHLEN+1];
+  
+    strcpy(buf, dir);
+    vd_optimize_path(buf);
+
+    rv = vd_Rmvdir(buf);
+    vd_packvdtable();
+    return rv;
+}
+
+static int vd_Rmvdir(dir)
+char *dir;
+{
+    int i;
+    char tmp[MAXPATHLEN+1];
+
+    for(i = 0; i < vdcount; i++)
+	if (!strncmp(dir, vdtable[i], strlen(dir))) {
+	    sprintf(tmp, "%s%s", vdroot, vdtable[i]);
+	    if (vd_Rmvdir(tmp))
+		return 1;
+	    if (vd_recursive_rmdir(tmp))
+		return 1;
+	    vdtable[i][0] = '\0';
+	}
+    return 0;
+}
+
+/*
+ * These functions move virtual directory, if exists.
+ * Movevdir:
+ *	front interface of move virtual directory function.
+ * vd_Movevdir:
+ *	does real works.
+ */
+int Movevdir(src, dst)
+char *src, *dst;
+{
+/*
+    char sbuf[MAXPATHLEN+1], dbuf[MAXPATHLEN+1];
+
+    strcpy(sbuf, src);
+    vd_optimize_path(sbuf);
+
+    strcpy(dbuf, dst);
+    vd_optimize_path(dbuf);
+
+    return (vd_Movevdir(sbuf, dbuf));
+*/
+    return (vd_Movevdir(src, dst));
+}
+
+static int vd_Movevdir(src, dst)
+char *src, *dst;
+{
+    int i;
+    char *p, *pp;
+    char tmp[MAXPATHLEN+1], tmps[MAXPATHLEN+1], tmpd[MAXPATHLEN+1];
+
+    for (i = 0; i < vdcount; i++)
+	if (!strncmp(src, vdtable[i], strlen(src))) {
+	    sprintf(tmps, "%s%s", vdroot, vdtable[i]);
+	    sprintf(tmp, "%s%s", dst, vdtable[i]+strlen(src));
+	    sprintf(tmpd, "%s%s", vdroot, tmp);
+
+	    if (vd_Movevdir(tmps, tmpd))
+		return 1;
+
+	    pp = vdtable[i];
+	    p = (char *) malloc(strlen(tmp)+1);
+	    strcpy(p, tmp);
+	    vdtable[i] = p;
+
+	    strcpy(tmp, tmpd);
+	    for (p = tmp+strlen(tmp); *p != '/'; p--)
+		;
+	    *p = '\0';
+
+	    if (vd_recursive_mkdir(tmp))
+		goto VD_MOVEVDIR_ERR;
+
+	    if (rename(tmps, tmpd) < 0)
+		goto VD_MOVEVDIR_ERR;
+
+	    free(pp);
+	}
+    return 0;
+
+VD_MOVEVDIR_ERR:
+    free(vdtable[i]);
+    vdtable[i] = pp;
+    return 1;
+}
+
+/*
+ * These functions handle table of virual directories.
+ * vd_addvdtable:
+ *	add virtual directory to table.
+ * vd_packvdtable:
+ *	remove disused virtual directories from table.
+ */
+static void vd_addvdtable(vd)
+char *vd;
+{
+    char *p;
+    p = (char *) malloc(strlen(vd)+1);
+    strcpy(p, vd);
+    vdtable[vdcount] = p;
+    vdcount++;
+}
+
+static void vd_packvdtable()
+{
+    int i, j;
+
+    for (i = j = 0; i < vdcount; i++)
+	if (vdtable[i][0] != '\0')
+	    vdtable[j++] = vdtable[i];
+	else
+	    free(vdtable[i]);
+
+    vdcount = j;
+}
+
+/*
+ * These are utility functions.
+ * vd_recursive_mkdir:
+ *	make directories recursively.
+ * vd_recursive_rmdir
+ *	remove directories recursively.
+ */
+static int vd_recursive_mkdir(dir)
+char *dir;
+{
+    char buf[MAXPATHLEN+1], *p;
+    struct stat st;
+
+    strcpy(buf, dir);
+
+    if (buf[strlen(buf) - 1] == '/')
+	buf[strlen(buf) - 1] = '\0';
+
+    p = rindex(buf, '/');
+    *p = '\0';
+
+    if (stat(buf, &st) < 0)
+	if (vd_recursive_mkdir(buf) < 0)
+	    return (-1);
+
+    *p = '/';
+    if (mkdir(buf, 0700) < 0)
+	return (-1);
+
+    return (0);
+}
+
+static int vd_recursive_rmdir(dir)
+char *dir;
+{
+    char buf[MAXPATHLEN+1], buf2[MAXPATHLEN+1];
+    DIR *dp;
+    struct dirent *di;
+
+    strcpy(buf, dir);
+
+    if (buf[strlen(buf) - 1] == '/')
+	buf[strlen(buf) - 1] = '\0';
+
+    if ((dp = opendir(buf)) == NULL)
+	return (-1);
+
+    while ((di = readdir(dp)) != NULL) {
+	struct stat st;
+
+	if (!strcmp(di->d_name, ".") || !strcmp(di->d_name, ".."))
+	    continue;
+
+	sprintf(buf2, "%s/%s", dir, di->d_name);
+
+	stat(buf2, &st);
+	if (S_ISDIR(st.st_mode)) {
+	    if (vd_recursive_rmdir(buf2) < 0)
+		goto VD_RECURSIVE_RMDIR_ERR;
+	} else
+	    unlink(buf2);
+    }
+    if (rmdir(buf) < 0)
+	goto VD_RECURSIVE_RMDIR_ERR;
+
+    closedir(dp);
+    return (0);
+
+VD_RECURSIVE_RMDIR_ERR:
+    closedir(dp);
+    return (-1);
+}
+
+/*
+ * These functions tests specified path.
+ * Isarchive:
+ *	tests, is it archive?
+ * Isvdir:
+ *	tests, is it in the virtual directory?
+ */
+int Isarchive(path)
+char *path;
+{
+    int ftype;
+
+    if ((ftype = vd_ftype(path)) < 0)
+	return 0;
+
+    if (ftype == RFT_COMPRESS)
+	if (!(ftype = vd_compp(path, NULL)))
+	    return 0;
+
+    if (ftype == RFT_BZIP2)
+	if (!(ftype = vd_compp(path, NULL)))
+	    return 0;
+
+    return ftype;
+}
+
+int Isvdir(path)
+char *path;
+{
+    int rv = 0;
+    char tmp1[MAXPATHLEN+1], tmp2[MAXPATHLEN+1];
+    int archive1, archive2;
+
+    strcpy(tmp1, path);
+    strcpy(tmp2, path);
+
+    vd_optimize_path(tmp1);
+    Dirtovd(tmp2);
+
+    archive1 = Isarchive(tmp1);
+    archive2 = Isarchive(tmp2);
+
+    if (strcmp(tmp1, tmp2)) {
+	char tmp3[MAXPATHLEN+1], tmp4[MAXPATHLEN+1];
+	int archive3, archive4;
+
+	sprintf(tmp3, "%s%s", vdroot, tmp1);
+	strcpy(tmp4, tmp2+strlen(vdroot));
+
+	archive3 = Isarchive(tmp3);
+	archive4 = Isarchive(tmp4);
+
+	if (archive4 && !strcmp(tmp1, tmp4)) {
+	    rv |= 06;
+	    return rv;
+	}
+	rv |= 01;
+	if (archive2)
+	    rv |= 02;
+	else if (archive4)
+	    rv |= 06;
+	return rv;
+    }
+    if (archive1)
+	rv |= 02;
+
+    return rv;
+}
+
+/*
+ * This function optimizes given path.
+ * Expand '~' to home directory and removes '.', and treat '..'.
+ */
+static void vd_optimize_path(path)
+char *path;
+{
+    char *tmp, *reserve;
+
+    if (!strcmp(path, STDINSTR))
+	return;
+
+    if (*path == '\0') {
+	xv_getwd(path, MAXPATHLEN+1);
+	return;
+    }
+    if (*path == '~')
+	Globify(path);
+    if (*path != '/') {
+	char tmp[MAXPATHLEN+1];
+
+	strcpy(tmp, path);
+	xv_getwd(path, MAXPATHLEN+1);
+	strcat(path, "/");
+	strcat(path, tmp);
+    }
+
+    reserve = tmp = path;
+    while(*path != '\0') {
+	if (*path == '/') {
+	    *tmp++ = *path;
+	    while (*++path == '/')
+		;
+	    continue;
+	}
+	if ((*path == '.') && (*(path-1) == '/')) {
+	    if (*(path+1) == '/') {
+		tmp--;
+		path++;
+		continue;
+	    } else if (*(path+1) == '\0') {
+		tmp--;
+		break;
+	    } else if (*(path+1) == '.')
+		if (*(path+2) == '/') {
+		    if ((tmp - reserve) > 1)
+			for (tmp-=2; (*tmp != '/'); tmp--)
+			    ;
+		    else
+			tmp = reserve;
+		    path+=2;
+		    continue;
+		} else if (*(path+2) == '\0') {
+		    if ((tmp - reserve) > 1)
+			for (tmp-=2; (*tmp != '/'); tmp--)
+			    ;
+		    else
+			tmp = reserve+1;
+		    break;
+		}
+	}
+	*tmp++ = *path++;
+    }
+    if (((tmp - reserve) > 1) && *(tmp-1) == '/')
+	tmp--;
+    if (tmp == reserve)
+	*tmp++ = '/';
+
+    *tmp = '\0';
+}
+
+/*
+ * These functions dicide file type.
+ */
+static int vd_ftype(fname)
+char *fname;
+{
+    /* check archive type */
+
+    FILE *fp;
+    byte  magicno[30];    /* first 30 bytes of file */
+    int   rv, n;
+    struct stat st;
+
+    if (!fname) return VD_ERR;   /* shouldn't happen */
+
+    if ((!stat(fname, &st)) && (st.st_mode & S_IFMT) == S_IFDIR) 
+	return VD_UKN;
+    fp = xv_fopen(fname, "r");
+    if (!fp) return VD_ERR;
+
+    n = fread(magicno, (size_t) 1, (size_t) 30, fp);  
+    fclose(fp);
+
+    if (n<30) return VD_UKN;    /* files less than 30 bytes long... */
+
+    rv = VD_UKN;
+
+    if (magicno[0] == 0x60 && magicno[1]==0xea) rv = VD_ARJ;
+
+    else if (magicno[2] == '-' && magicno[3] == 'l' &&
+	     magicno[4] == 'h') rv = VD_LZH;
+
+    else if (strncmp((char *) magicno,"PK", (size_t) 2)==0) rv = VD_ZIP;
+
+    else if (magicno[20]==0xdc && magicno[21]==0xa7 &&
+	     magicno[22]==0xc4 && magicno[23]==0xfd) rv = VD_ZOO;
+
+    else if (vd_tarc(fname)) rv = VD_TAR;
+
+    else if (magicno[0]==0x1f && magicno[1]==0x9d) rv = RFT_COMPRESS;
+
+    else if (!strncmp((char *) &magicno[11], "MAJYO", (size_t) 5))
+	     rv = VD_UKN; /* XXX */
+
+    else if (magicno[0] == 26) rv = VD_ARC;
+
+#ifdef GUNZIP
+    else if (magicno[0]==0x1f && magicno[1]==0x8b) rv = RFT_COMPRESS;/* gzip */
+    else if (magicno[0]==0x1f && magicno[1]==0x9e) rv = RFT_COMPRESS;/*  old */
+    else if (magicno[0]==0x1f && magicno[1]==0x1e) rv = RFT_COMPRESS;/* pack */
+#endif
+#ifdef BUNZIP2
+    else if (magicno[0]==0x42 && magicno[1]==0x5a) rv = RFT_BZIP2;
+#endif
+
+
+    return rv;
+}
+
+static int vd_compp(path, newpath)
+char *path, *newpath;
+{
+    /*
+     * uncompress and check archive type.
+     *
+     * If newpath is NULL, uncompress only 512 byte of 'path' and 
+     * check archive type, so it is for SPEED-UP strategy.
+     * In this case, caller this function does not have to unlink
+     * tempoary file.
+     * Unfortunately it does not work in VMS system.
+     */
+
+    int file_type, r;
+    char uncompname[128], basename[128];
+
+    if (newpath) *newpath = '\0';
+    strcpy(basename, path);
+#if (defined(VMS) && !defined(GUNZIP))
+    /* VMS decompress doesn't like the file to have a trailing .Z in fname
+    however, GUnZip is OK with it, which we are calling UnCompress */
+    *rindex (basename, '.') = '\0';
+#endif
+#ifdef VMS
+    if (UncompressFile(basename, uncompname)) {
+#else
+    if (newpath == NULL) {
+	file_type = ReadFileType(path);
+	r = vd_UncompressFile(basename, uncompname, file_type);
+    }
+    else {
+	file_type = ReadFileType(path);
+	r = UncompressFile(basename, uncompname, file_type);
+    }
+    if (r) {
+#endif
+	if ((file_type = vd_ftype(uncompname)) < 0) {
+	    unlink(uncompname);
+	    return 0;
+	}
+	if (newpath) strcpy(newpath, uncompname);
+	else unlink(uncompname);
+    } else {
+	return 0;
+    }
+    return file_type;
+}
+
+#define HEADERSIZE 512
+
+static void  vd_Dirtovd    		PARM((char *));
+static int   stderr_on			PARM((void));
+static int   stderr_off			PARM((void));
+static FILE  *popen_nul			PARM((char *, char *));
+
+static int vd_UncompressFile(name, uncompname, file_type)
+char *name, *uncompname;
+int file_type;
+{
+    /* Yap, I`m nearly same as original `UncompnameFile' function, but,
+       1) I extract `name' file ONLY first 512 byte.
+       2) I'm called only from UNIX and UNIX like OS, *NOT* VMS */
+    /* returns '1' on success, with name of uncompressed file in uncompname
+       returns '0' on failure */
+
+    char namez[128], *fname, buf[512], tmp[HEADERSIZE];
+    int n;
+    FILE *pfp, *tfp;
+  
+    fname = name;
+    namez[0] = '\0';
+
+
+#ifndef GUNZIP
+    /* see if compressed file name ends with '.Z'.  If it *doesn't* we need
+       temporarly rename it so it *does*, uncompress it, and rename *back*
+       to what it was.  necessary because uncompress doesn't handle files
+       that don't end with '.Z' */
+
+    if (strlen(name) >= (size_t) 2            && 
+	strcmp(name + strlen(name)-2,".Z")!=0 &&
+	strcmp(name + strlen(name)-2,".z")!=0) {
+	strcpy(namez, name);
+	strcat(namez,".Z");
+
+	if (rename(name, namez) < 0) {
+	    sprintf(buf, "Error renaming '%s' to '%s':  %s",
+		    name, namez, ERRSTR(errno));
+	    ErrPopUp(buf, "\nBummer!");
+	    return 0;
+	}
+
+	fname = namez;
+    }
+#endif   /* not GUNZIP */
+  
+    sprintf(uncompname, "%s/xvuXXXXXX", tmpdir);
+    mktemp(uncompname);
+    if (file_type == RFT_COMPRESS)
+      sprintf(buf,"%s -c %s", UNCOMPRESS, fname);
+#ifdef BUNZIP2
+    if (file_type == RFT_BZIP2)
+      sprintf(buf,"%s -c %s", BUNZIP2, fname);
+#endif
+
+    SetISTR(ISTR_INFO, "Uncompressing Header '%s'...", BaseName(fname));
+    if ((pfp = popen_nul(buf, "r")) == NULL) {
+	SetISTR(ISTR_INFO, "Cannot extract for archive '%s'.",
+		BaseName(fname));
+	Warning();
+	return 0;
+    }
+    if ((tfp = fopen(uncompname, "w")) == NULL) {
+	SetISTR(ISTR_INFO, "Unable to create temporarly file.",
+		BaseName(uncompname));
+	Warning();
+	pclose(pfp);
+	return 0;
+    }
+    if ((n = fread(tmp, 1, sizeof(tmp), pfp)) != HEADERSIZE) {
+	SetISTR(ISTR_INFO, "Unable to read '%s'.",
+		BaseName(fname));
+	Warning();
+	pclose(pfp);
+	fclose(tfp);
+	return 0;
+    }
+    fwrite(tmp, 1, n, tfp);
+    fclose(tfp);
+    pclose(pfp);
+    
+    /* if we renamed the file to end with a .Z for the sake of 'uncompress', 
+       rename it back to what it once was... */
+
+    if (strlen(namez)) {
+	if (rename(namez, name) < 0) {
+	    sprintf(buf, "Error renaming '%s' to '%s':  %s",
+		    namez, name, ERRSTR(errno));
+	    ErrPopUp(buf, "\nBummer!");
+	}
+    }
+  
+    return 1;
+}
+
+#define TARBLOCK 512
+#define CKSTART 148 /* XXX */
+#define CKSIZE 8
+
+/*
+ * Tar file: 1, other: 0
+ */
+static int vd_tarc(fname)
+char *fname;
+{
+    FILE *fp;
+    unsigned int sum;
+    char *ckp, buf[TARBLOCK];
+
+    if ((fp = fopen(fname, "r")) == NULL)
+	return 0;
+
+    fread(buf, TARBLOCK, 1, fp);
+    fclose(fp);
+
+    for (sum = 0, ckp = buf + CKSTART;
+	 (ckp < buf + CKSTART + CKSIZE) && *ckp != '\0';
+	 ckp++) {
+	sum *= 8;
+	if (*ckp == ' ')
+	    continue;
+	if (*ckp < '0' || '7' < *ckp)
+	    return 0;
+	sum += *ckp - '0';
+    }
+    if (sum != vd_tar_sumchk(buf))
+	return 0;
+
+    return 1;
+}
+
+static unsigned int vd_tar_sumchk(buf)
+char *buf;
+{
+    int i;
+    unsigned int sum = 0;
+
+    for (i = 0; i < CKSTART; i++) {
+	sum += *(buf + i);
+    }
+    sum += ' ' * 8;
+    for (i += 8; i < TARBLOCK; i++) {
+	sum += *(buf + i);
+    }
+    return sum;
+}
+
+
+static stde = -1;        /*  fd of stderr    */
+static nul = -1;         /*  fd of /dev/null */
+
+/*
+ * switch off the output to stderr(bypass to /dev/null).
+ */
+static int stderr_off()
+{
+    if (nul < 0)
+      nul = open("/dev/null", O_RDONLY);
+    if (nul < 0) {
+	fprintf(stderr, "/dev/null open failure\n");
+	return -1;
+    }
+    if (stde < 0)
+	stde = dup(2);
+    if (stde < 0) {
+	fprintf(stderr, "duplicate stderr failure\n");
+	return -1;
+    }
+    close(2);
+    dup(nul);
+    return 0;
+}
+
+/*
+ * turn on stderr output.
+ */
+static int stderr_on()
+{
+    if ((stde < 0) || (nul < 0)) {
+	fprintf(stderr, "stderr_on should call after stderr_off\n");
+	return -1;
+    }
+    close(2);
+    dup(stde);
+    return 0;
+}
+
+/*
+ * popen with no output to stderr.
+ */
+static FILE *popen_nul(prog, mode)
+char *prog, *mode;
+{
+    FILE *fp;
+
+    stderr_off();
+    fp = popen(prog, mode);
+    stderr_on();
+    return fp;
+}
+
+/*
+ * These functions are for SIGNAL.
+ * If XV end by C-c, there are dust of directory which name is .xvvd???,
+ * made by xvvd. Then, I handle SIGINT, and add good finish.
+ */
+void vd_HUPhandler()
+{
+#if defined(SYSV) || defined(SVR4)
+    sighold(SIGHUP);
+#else
+    int mask;
+    mask = sigblock(sigmask(SIGHUP));
+#endif
+
+  Vdsettle();
+
+#if defined(SYSV) || defined(SVR4)
+    sigrelse(SIGHUP);
+    signal(SIGHUP, (void (*)PARM((int))) vd_HUPhandler);
+#else
+    sigsetmask(mask);
+#endif
+}
+
+void vd_handler(sig)
+int sig;
+{
+#if defined(SYSV) || defined(SVR4)
+    sighold(sig);
+#else
+    sigblock(sigmask(sig));
+#endif
+
+    Quit(1); /*exit(1);*/
+}
+
+int vd_Xhandler(disp,event)
+Display *disp;
+XErrorEvent *event;
+{
+    Quit(1); /*exit(1);*/
+}
+
+int vd_XIOhandler(disp)
+Display *disp;
+{
+    fprintf(stderr, "XIO  fatal IO error ? (?) on X server\n");
+    fprintf(stderr, "You must normal exit in xv usage.\n");
+    Quit(1); /*exit(1);*/
+}
+
+void vd_handler_setup()
+{
+    signal(SIGHUP, (void (*)PARM((int))) vd_HUPhandler);
+    signal(SIGINT, (void (*)PARM((int))) vd_handler);
+    signal(SIGTERM,(void (*)PARM((int))) vd_handler);
+
+    XSetErrorHandler(vd_Xhandler);
+    XSetIOErrorHandler(vd_XIOhandler);
+}
+#endif /* AUTO_EXPAND */
diff -Naur xv-3.10a.old/xvxwd.c xv-3.10a/xvxwd.c
--- xv-3.10a.old/xvxwd.c	Fri Dec 23 07:34:40 1994
+++ xv-3.10a/xvxwd.c	Tue Apr 24 09:37:05 2001
@@ -396,11 +396,30 @@
     h11P->pixmap_width;
   
   bits_per_item  = h11P->bitmap_unit;
-  bits_used      = bits_per_item;
   bits_per_pixel = h11P->bits_per_pixel;
   byte_order     = h11P->byte_order;
   bit_order      = h11P->bitmap_bit_order;
   
+ 
+  /* add sanity-code for freako 'exceed' server, where bitmapunit = 8
+     and bitsperpix = 32 (and depth=24)... */
+ 
+  if (bits_per_item < bits_per_pixel) {
+    bits_per_item = bits_per_pixel;
+   
+    /* round bits_per_item up to next legal value, if necc */
+    if      (bits_per_item <  8) bits_per_item = 8;
+    else if (bits_per_item < 16) bits_per_item = 16;
+    else                         bits_per_item = 32;
+  }
+ 
+ 
+  /* which raises the question:  how (can?) you ever have a 24 bits per pix,
+     (ie, 3 bytes, no alpha/padding) */
+ 
+ 
+  bits_used      = bits_per_item;
+
   if (bits_per_pixel == sizeof(pixel_mask) * 8)  pixel_mask = (CARD32) -1;
   else pixel_mask = (1 << bits_per_pixel) - 1;
   
